// Decompiled: godminer_aba271e64f7cf41c

int _init(EVP_PKEY_CTX *ctx)

{
    int iVar1;

    iVar1 = FUN_0001d520();
    return iVar1;
}

void _start(undefined4 param_1)

{
    undefined4 in_stack_00000000;

    __libc_start_main(main, in_stack_00000000, &stack0x00000004, 0xccfb9,
                      0xccff5, param_1);
    /* WARNING: Subroutine does not return */
    abort();
}

/* WARNING: Removing unreachable block (ram,0x0001d534) */

void FUN_0001d520(void)

{
    __gmon_start__();
    return;
}

/* WARNING: Removing unreachable block (ram,0x0001d558) */
/* WARNING: Removing unreachable block (ram,0x0001d562) */

void FUN_0001d544(void)

{
    return;
}

/* WARNING: Removing unreachable block (ram,0x0001d584) */
/* WARNING: Removing unreachable block (ram,0x0001d58e) */

void FUN_0001d568(void)

{
    return;
}

void _FINI_0(void)

{
    if (DAT_0015127c == '\0') {
        FUN_0001d544();
        DAT_0015127c = '\x01';
    }
    return;
}

void FUN_0001d5b0(int param_1)

{
    bool bVar1;
    int iVar2;
    int *piVar3;

    if ((param_1 != 0) && (*(int *)(param_1 + 4) != -1)) {
        piVar3 = (int *)(param_1 + 4);
        DataMemoryBarrier(0xb);
        do {
            iVar2 = *piVar3;
            bVar1 = (bool)hasExclusiveAccess(piVar3);
        } while (!bVar1);
        *piVar3 = iVar2 + -1;
        if (iVar2 + -1 == 0) {
            json_delete(param_1);
        }
    }
    return;
}

void FUN_0001d618(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_0001d7a4(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/util.h",
                 0x90, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

uint FUN_0001d934(uint param_1)

{
    return param_1 << 0x18 | (param_1 >> 8 & 0xff) << 0x10 |
           (param_1 >> 0x10 & 0xff) << 8 | param_1 >> 0x18;
}

void FUN_0001d95c(int param_1, int param_2, int param_3)

{
    undefined4 uVar1;
    int iVar2;
    int local_c;

    if ((param_1 != 0) && (param_2 != 0)) {
        for (local_c = 0; local_c < *(int *)(param_2 + 8);
             local_c = local_c + 1) {
            if (param_3 == *(int *)(*(int *)(param_2 + 0x10) + local_c * 4)) {
                uVar1 = json_string(
                    *(undefined4 *)(*(int *)(param_2 + 0xc) + local_c * 4));
                json_object_set_new(param_1, "status", uVar1);
                iVar2 = *(int *)(*(int *)(param_2 + 0x10) + local_c * 4);
                uVar1 = json_integer(iVar2, iVar2 >> 0x1f);
                json_object_set_new(param_1, &DAT_000cd21c, uVar1);
                uVar1 = json_string(
                    *(undefined4 *)(*(int *)(param_2 + 0x14) + local_c * 4));
                json_object_set_new(param_1, &DAT_000cd224, uVar1);
                return;
            }
        }
    }
    return;
}

void FUN_0001daac(int param_1, undefined4 param_2)

{
    undefined1 auStack_24[5];
    char local_1f;
    undefined4 local_10;
    undefined4 local_c;

    local_10 = param_2;
    get_miner_working_status(auStack_24);
    if (param_1 != 0) {
        if (local_1f == '\0') {
            local_c = 0;
        } else {
            local_c = 0xffffffff;
        }
        FUN_0001d95c(param_1, local_10, local_c);
    }
    return;
}

void FUN_0001db28(int param_1, undefined4 param_2)

{
    undefined1 auStack_24[6];
    char local_1e;
    undefined4 local_10;
    undefined4 local_c;

    local_10 = param_2;
    get_miner_working_status(auStack_24);
    if (param_1 != 0) {
        if (local_1e == '\0') {
            local_c = 0;
        } else {
            local_c = 0xffffffff;
        }
        FUN_0001d95c(param_1, local_10, local_c);
    }
    return;
}

void FUN_0001dba4(int param_1, undefined4 param_2)

{
    undefined1 auStack_24[4];
    char local_20;
    undefined4 local_10;
    undefined4 local_c;

    local_10 = param_2;
    get_miner_working_status(auStack_24);
    local_c = 0;
    if (param_1 != 0) {
        if (local_20 != '\0') {
            local_c = 0xffffffff;
        }
        FUN_0001d95c(param_1, local_10, local_c);
    }
    return;
}

void FUN_0001dc14(int param_1, undefined4 param_2)

{
    char local_24[2];
    char local_22;
    undefined4 local_10;
    undefined4 local_c;

    local_10 = param_2;
    get_miner_working_status(local_24);
    local_c = 0;
    if (param_1 != 0) {
        if (local_24[0] != '\0') {
            local_c = 0xffffffff;
        }
        if (local_22 != '\0') {
            local_c = 0xfffffffe;
        }
        FUN_0001d95c(param_1, local_10, local_c);
    }
    return;
}

void FUN_0001dc98(int param_1, undefined4 param_2)

{
    undefined1 auStack_24[9];
    char local_1b;
    undefined4 local_10;
    undefined4 local_c;

    local_10 = param_2;
    get_miner_working_status(auStack_24);
    local_c = 0;
    if (param_1 != 0) {
        if (local_1b != '\0') {
            local_c = 0xfffffffe;
        }
        FUN_0001d95c(param_1, local_10, local_c);
    }
    return;
}

void FUN_0001dd08(int param_1)

{
    undefined4 uVar1;
    undefined4 uVar2;
    int local_c;

    if (param_1 != 0) {
        for (local_c = 0; *(int *)(&DAT_0014d384 + local_c * 0x18) != 0;
             local_c = local_c + 1) {
            uVar1 = json_object();
            uVar2 =
                json_string(*(undefined4 *)(&DAT_0014d384 + local_c * 0x18));
            json_object_set_new(uVar1, &DAT_000cd368, uVar2);
            (**(code **)(&DAT_0014d388 + local_c * 0x18))(
                uVar1, &DAT_0014d384 + local_c * 0x18);
            json_array_append_new(param_1, uVar1);
        }
    }
    return;
}

void FUN_0001de14(int param_1, undefined4 *param_2)

{
    undefined4 uVar1;
    char local_2c[16];
    undefined8 local_1c;
    undefined8 uStack_14;
    undefined4 local_c;

    local_1c = 0;
    uStack_14 = 0;
    local_2c[0] = '\0';
    local_2c[1] = '\0';
    local_2c[2] = '\0';
    local_2c[3] = '\0';
    local_2c[4] = '\0';
    local_2c[5] = '\0';
    local_2c[6] = '\0';
    local_2c[7] = '\0';
    local_2c[8] = '\0';
    local_2c[9] = '\0';
    local_2c[10] = '\0';
    local_2c[0xb] = '\0';
    local_2c[0xc] = '\0';
    local_2c[0xd] = '\0';
    local_2c[0xe] = '\0';
    local_2c[0xf] = '\0';
    if ((param_1 != 0) && (param_2 != (undefined4 *)0x0)) {
        local_c = json_object();
        uVar1 = json_string(&DAT_000cd370);
        json_object_set_new(local_c, "STATUS", uVar1);
        uVar1 = json_integer(DAT_00151284, DAT_00151284 >> 0x1f);
        json_object_set_new(local_c, &DAT_000cd37c, uVar1);
        snprintf((char *)&local_1c, 0x10, "%s", *param_2);
        uVar1 = json_string(&local_1c);
        json_object_set_new(local_c, &DAT_000cd388, uVar1);
        snprintf(local_2c, 0x10, "%s", param_2[1]);
        uVar1 = json_string(local_2c);
        json_object_set_new(local_c, "api_version", uVar1);
        json_object_set_new(param_1, "STATUS", local_c);
    }
    return;
}

void FUN_0001df60(int param_1)

{
    undefined4 uVar1;
    char local_cc[64];
    undefined8 local_8c;
    undefined8 uStack_84;
    undefined8 local_7c;
    undefined8 local_74;
    undefined8 local_6c;
    undefined8 local_64;
    undefined8 local_5c;
    undefined8 local_54;
    char local_4c[64];
    undefined4 local_c;

    local_4c[0] = '\0';
    local_4c[1] = '\0';
    local_4c[2] = '\0';
    local_4c[3] = '\0';
    local_4c[4] = '\0';
    local_4c[5] = '\0';
    local_4c[6] = '\0';
    local_4c[7] = '\0';
    local_4c[8] = '\0';
    local_4c[9] = '\0';
    local_4c[10] = '\0';
    local_4c[0xb] = '\0';
    local_4c[0xc] = '\0';
    local_4c[0xd] = '\0';
    local_4c[0xe] = '\0';
    local_4c[0xf] = '\0';
    local_4c[0x10] = '\0';
    local_4c[0x11] = '\0';
    local_4c[0x12] = '\0';
    local_4c[0x13] = '\0';
    local_4c[0x14] = '\0';
    local_4c[0x15] = '\0';
    local_4c[0x16] = '\0';
    local_4c[0x17] = '\0';
    local_4c[0x18] = '\0';
    local_4c[0x19] = '\0';
    local_4c[0x1a] = '\0';
    local_4c[0x1b] = '\0';
    local_4c[0x1c] = '\0';
    local_4c[0x1d] = '\0';
    local_4c[0x1e] = '\0';
    local_4c[0x1f] = '\0';
    local_4c[0x20] = '\0';
    local_4c[0x21] = '\0';
    local_4c[0x22] = '\0';
    local_4c[0x23] = '\0';
    local_4c[0x24] = '\0';
    local_4c[0x25] = '\0';
    local_4c[0x26] = '\0';
    local_4c[0x27] = '\0';
    local_4c[0x28] = '\0';
    local_4c[0x29] = '\0';
    local_4c[0x2a] = '\0';
    local_4c[0x2b] = '\0';
    local_4c[0x2c] = '\0';
    local_4c[0x2d] = '\0';
    local_4c[0x2e] = '\0';
    local_4c[0x2f] = '\0';
    local_4c[0x30] = '\0';
    local_4c[0x31] = '\0';
    local_4c[0x32] = '\0';
    local_4c[0x33] = '\0';
    local_4c[0x34] = '\0';
    local_4c[0x35] = '\0';
    local_4c[0x36] = '\0';
    local_4c[0x37] = '\0';
    local_4c[0x38] = '\0';
    local_4c[0x39] = '\0';
    local_4c[0x3a] = '\0';
    local_4c[0x3b] = '\0';
    local_4c[0x3c] = '\0';
    local_4c[0x3d] = '\0';
    local_4c[0x3e] = '\0';
    local_4c[0x3f] = '\0';
    local_8c = 0;
    uStack_84 = 0;
    local_7c = 0;
    local_74 = 0;
    local_6c = 0;
    local_64 = 0;
    local_5c = 0;
    local_54 = 0;
    local_cc[0] = '\0';
    local_cc[1] = '\0';
    local_cc[2] = '\0';
    local_cc[3] = '\0';
    local_cc[4] = '\0';
    local_cc[5] = '\0';
    local_cc[6] = '\0';
    local_cc[7] = '\0';
    local_cc[8] = '\0';
    local_cc[9] = '\0';
    local_cc[10] = '\0';
    local_cc[0xb] = '\0';
    local_cc[0xc] = '\0';
    local_cc[0xd] = '\0';
    local_cc[0xe] = '\0';
    local_cc[0xf] = '\0';
    local_cc[0x10] = '\0';
    local_cc[0x11] = '\0';
    local_cc[0x12] = '\0';
    local_cc[0x13] = '\0';
    local_cc[0x14] = '\0';
    local_cc[0x15] = '\0';
    local_cc[0x16] = '\0';
    local_cc[0x17] = '\0';
    local_cc[0x18] = '\0';
    local_cc[0x19] = '\0';
    local_cc[0x1a] = '\0';
    local_cc[0x1b] = '\0';
    local_cc[0x1c] = '\0';
    local_cc[0x1d] = '\0';
    local_cc[0x1e] = '\0';
    local_cc[0x1f] = '\0';
    local_cc[0x20] = '\0';
    local_cc[0x21] = '\0';
    local_cc[0x22] = '\0';
    local_cc[0x23] = '\0';
    local_cc[0x24] = '\0';
    local_cc[0x25] = '\0';
    local_cc[0x26] = '\0';
    local_cc[0x27] = '\0';
    local_cc[0x28] = '\0';
    local_cc[0x29] = '\0';
    local_cc[0x2a] = '\0';
    local_cc[0x2b] = '\0';
    local_cc[0x2c] = '\0';
    local_cc[0x2d] = '\0';
    local_cc[0x2e] = '\0';
    local_cc[0x2f] = '\0';
    local_cc[0x30] = '\0';
    local_cc[0x31] = '\0';
    local_cc[0x32] = '\0';
    local_cc[0x33] = '\0';
    local_cc[0x34] = '\0';
    local_cc[0x35] = '\0';
    local_cc[0x36] = '\0';
    local_cc[0x37] = '\0';
    local_cc[0x38] = '\0';
    local_cc[0x39] = '\0';
    local_cc[0x3a] = '\0';
    local_cc[0x3b] = '\0';
    local_cc[0x3c] = '\0';
    local_cc[0x3d] = '\0';
    local_cc[0x3e] = '\0';
    local_cc[0x3f] = '\0';
    if (param_1 != 0) {
        local_c = json_object();
        snprintf(local_4c, 0x40, "%s", g_miner_version);
        uVar1 = json_string(local_4c);
        json_object_set_new(local_c, "miner_version", uVar1);
        snprintf((char *)&local_8c, 0x40, "%s", g_miner_compiletime);
        uVar1 = json_string(&local_8c);
        json_object_set_new(local_c, "CompileTime", uVar1);
        snprintf(local_cc, 0x40, "%s", g_miner_type);
        uVar1 = json_string(local_cc);
        json_object_set_new(local_c, &DAT_000cd368, uVar1);
        json_object_set_new(param_1, &DAT_000cd3b4, local_c);
    }
    return;
}

void set_elapsed_time_validity(undefined1 param_1)

{
    DAT_00151280 = param_1;
    return;
}

undefined4 get_miner_elapsed_time(void)

{
    int iVar1;
    int *piVar2;
    char *pcVar3;
    undefined1 auStack_1058[4096];
    sysinfo local_58;
    undefined4 local_18;

    iVar1 = sysinfo(&local_58);
    if (iVar1 == 0) {
        DAT_0015129c = local_58.uptime;
    } else {
        V_LOCK();
        piVar2 = __errno_location();
        iVar1 = *piVar2;
        piVar2 = __errno_location();
        pcVar3 = strerror(*piVar2);
        logfmt_raw(auStack_1058, 0x1000, 0,
                   "Failed to get sysinfo, errno:%u, reason:%s", iVar1, pcVar3);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_miner_elapsed_time", 0x16, 0x152, 0x28, auStack_1058);
        DAT_0015129c = time((time_t *)0x0);
    }
    if (DAT_00151280 == '\0') {
        local_18 = 0;
    } else {
        local_18 = SUB84(
            (double)(longlong)DAT_0015129c - (double)(longlong)DAT_00151298, 0);
    }
    return local_18;
}

void set_miner_start_time(void)

{
    int iVar1;
    int *piVar2;
    char *pcVar3;
    undefined1 auStack_1150[4096];
    sysinfo local_150;
    char acStack_110[260];

    iVar1 = sysinfo(&local_150);
    if (iVar1 == 0) {
        DAT_00151298 = local_150.uptime;
        DAT_0015129c = local_150.uptime + 1;
        sprintf(acStack_110, "%s total_tv_start_sys=%ld total_tv_end_sys=%ld",
                "set_miner_start_time", local_150.uptime, DAT_0015129c);
        V_LOCK();
        logfmt_raw(auStack_1150, 0x1000, 0, &DAT_000cd384, acStack_110);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "set_miner_start_time", 0x14, 0x175, 0x3c, auStack_1150);
    } else {
        piVar2 = __errno_location();
        iVar1 = *piVar2;
        piVar2 = __errno_location();
        pcVar3 = strerror(*piVar2);
        sprintf(acStack_110, "Failed to get sysinfo, errno:%u, reason:%s",
                iVar1, pcVar3);
        DAT_00151298 = time((time_t *)0x0);
        DAT_0015129c = DAT_00151298 + 1;
    }
    return;
}

/* WARNING: Globals starting with '_' overlap smaller symbols at the same
 * address */

void api_flush(void)

{
    local_work = 0;
    new_blocks = 0;
    DAT_001512a0 = 0;
    last_getwork = 0;
    total_getworks = 0;
    total_stale = 0;
    total_discarded = 0;
    total_go = 0;
    total_ro = 0;
    total_accepted = 0;
    total_rejected = 0;
    total_diff1 = 0;
    total_diff_accepted._0_4_ = 0;
    total_diff_accepted._4_4_ = 0;
    total_diff_rejected._0_4_ = 0;
    total_diff_rejected._4_4_ = 0;
    total_diff_stale._0_4_ = 0;
    total_diff_stale._4_4_ = 0;
    DAT_001512a8._0_4_ = 0;
    DAT_001512a8._4_4_ = 0;
    DAT_001512b0 = 0;
    DAT_001512b4 = 0;
    _DAT_001512b8 = 0;
    return;
}

undefined4 update_rate_ideal(int param_1)

{
    int iVar1;

    iVar1 = strcmp((char *)(param_1 + 0x130), "D7");
    if (iVar1 != 0) {
        strcmp((char *)(param_1 + 0x130), "D7e");
    }
    return 0;
}

float get_total_nonce_rate(void)

{
    int iVar1;
    float local_1c;
    int local_18;
    undefined4 local_14;
    int local_10;
    float local_c;

    local_18 = 0;
    local_c = 0.0;
    local_14 = get_all_created_runtime(&local_18);
    iVar1 = is_eeprom_loaded();
    if (iVar1 != 0) {
        for (local_10 = 0; local_10 < local_18; local_10 = local_10 + 1) {
            local_1c = 0.0;
            iVar1 = api_get_eeprom_nonce_response_rate(local_10, &local_1c);
            if (iVar1 == 0) {
                local_c = local_c + local_1c;
            }
        }
        if (local_c <= 0.0) {
            local_c = 0.0;
        } else {
            local_c = local_c / (float)(longlong)local_18;
        }
        local_c = local_c / 100.0;
    }
    return local_c;
}

float get_total_accept_rate(void)

{
    int iVar1;
    float fVar2;
    undefined4 local_14;
    undefined4 local_10;
    undefined4 local_c;

    local_c = 0;
    local_10 = 0;
    for (local_14 = 0; local_14 < total_pools; local_14 = local_14 + 1) {
        iVar1 = *(int *)(pools + local_14 * 4);
        if (iVar1 != 0) {
            local_c = (int)(longlong)((double)(longlong)local_c +
                                      *(double *)(iVar1 + 0x7a8));
            local_10 = (int)(longlong)((double)(longlong)local_10 +
                                       *(double *)(iVar1 + 0x7b0));
        }
    }
    if (local_c + local_10 == 0) {
        fVar2 = 0.0;
    } else {
        fVar2 =
            (float)(longlong)local_10 / (float)(longlong)(local_c + local_10);
    }
    return 1.0 - fVar2;
}

/* WARNING: Globals starting with '_' overlap smaller symbols at the same
 * address */

undefined4 FUN_0001e9f4(undefined4 param_1, int param_2)

{
    void *__dest;
    undefined4 uVar1;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;
    double dVar2;
    undefined8 uVar3;
    undefined1 auStack_11b0[224];
    int local_10d0;
    undefined4 local_10cc;
    undefined1 auStack_10c8[4096];
    double dStack_c8;
    undefined1 auStack_c0[12];
    float fStack_b4;
    float fStack_b0;
    float fStack_ac;
    float fStack_a8;
    undefined4 uStack_a0;
    undefined4 local_90;
    undefined4 uStack_8c;
    int local_84;
    undefined8 local_80;
    undefined4 uStack_78;
    undefined4 uStack_74;
    undefined4 local_70;
    undefined4 uStack_6c;
    undefined4 local_68;
    undefined4 uStack_64;
    double dStack_60;
    double dStack_58;
    double dStack_50;
    double local_48;
    double dStack_40;
    int local_38;
    int local_34;
    int local_30;
    undefined4 local_2c;
    undefined4 local_28;
    undefined4 local_24;
    undefined4 local_20;
    int local_1c;
    void *local_18;
    void *local_14;

    local_20 = 0;
    local_1c = 0;
    local_24 = 0;
    local_28 = 0;
    local_2c = 0;
    local_80 = 0;
    local_84 = 0;
    local_10d0 = param_2;
    local_10cc = param_1;
    local_30 = frontend_runtime_instance();
    local_34 = get_all_created_runtime(&local_84);
    local_18 = (void *)0x0;
    local_14 = (void *)0x0;
    local_38 = local_10d0;
    if ((local_10d0 == 0) || (local_10d0 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_10c8, 0x1000, 0, "%s: input bad api param",
                   "get_summary");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_summary", 0xb, 0x20d, 100, auStack_10c8);
        local_20 = 0x80000002;
        dVar2 = (double)CONCAT44(g_hash_rate_5s._4_4_, g_hash_rate_5s._0_4_);
    } else {
        FUN_0001de14(local_10cc, local_10d0);
        FUN_0001df60(local_10cc);
        local_2c = json_array();
        local_24 = json_object();
        read_system_status_from_monitor(auStack_c0);
        uVar1 = format_hashrate_double(
            uStack_a0, *(undefined4 *)(*(int *)(local_30 + 0x48) + 0x10),
            &dStack_c8, &local_80);
        dStack_40 = (double)CONCAT44(extraout_s1, uVar1);
        local_48 = dStack_40 * (double)fStack_b4;
        dStack_50 = dStack_40 * (double)fStack_b0;
        dStack_58 = dStack_40 * (double)fStack_ac;
        dStack_60 = dStack_40 * (double)fStack_a8;
        local_68 = local_90;
        uStack_64 = uStack_8c;
        g_hash_rate_5s = local_48;
        if (0 < local_84) {
            local_18 = malloc(local_84 * 0xe0);
            local_14 = malloc(local_84 << 2);
            for (local_1c = 0; local_1c < local_84; local_1c = local_1c + 1) {
                __dest = (void *)((int)local_18 + local_1c * 0xe0);
                read_status_from_monitor(
                    auStack_11b0, *(undefined4 *)(local_34 + local_1c * 4));
                memcpy(__dest, auStack_11b0, 0xe0);
                *(undefined4 *)((int)local_14 + local_1c * 4) =
                    *(undefined4 *)(*(int *)(local_34 + local_1c * 4) + 0xfc);
            }
        }
        local_70 = get_miner_elapsed_time();
        uStack_6c = extraout_s1_00;
        uStack_74 = get_total_nonce_rate();
        uStack_78 = get_total_accept_rate();
        uVar3 = FUN_000cce38(local_70, uStack_6c);
        uVar1 = json_integer((int)uVar3, (int)((ulonglong)uVar3 >> 0x20));
        json_object_set_new(local_24, "elapsed", uVar1);
        uVar3 = FUN_000cce38(SUB84(local_48 * 100.0, 0),
                             (int)((ulonglong)(local_48 * 100.0) >> 0x20));
        dVar2 =
            (double)FUN_000ccae4((int)uVar3, (int)((ulonglong)uVar3 >> 0x20));
        uVar1 = json_real(SUB84(dVar2 / 100.0, 0));
        json_object_set_new(local_24, "rate_5s", uVar1);
        uVar3 = FUN_000cce38(SUB84(dStack_60 * 100.0, 0),
                             (int)((ulonglong)(dStack_60 * 100.0) >> 0x20));
        dVar2 =
            (double)FUN_000ccae4((int)uVar3, (int)((ulonglong)uVar3 >> 0x20));
        uVar1 = json_real(SUB84(dVar2 / 100.0, 0));
        json_object_set_new(local_24, "rate_avg", uVar1);
        uVar3 = FUN_000cce38(SUB84(dStack_58 * 100.0, 0),
                             (int)((ulonglong)(dStack_58 * 100.0) >> 0x20));
        dVar2 =
            (double)FUN_000ccae4((int)uVar3, (int)((ulonglong)uVar3 >> 0x20));
        uVar1 = json_real(SUB84(dVar2 / 100.0, 0));
        json_object_set_new(local_24, "rate_30m", uVar1);
        uVar3 = FUN_000cce38(SUB84(dStack_c8 * 100.0, 0),
                             (int)((ulonglong)(dStack_c8 * 100.0) >> 0x20));
        dVar2 =
            (double)FUN_000ccae4((int)uVar3, (int)((ulonglong)uVar3 >> 0x20));
        uVar1 = json_real(SUB84(dVar2 / 100.0, 0));
        json_object_set_new(local_24, "rate_ideal", uVar1);
        uVar1 = json_string(&local_80);
        json_object_set_new(local_24, "rate_unit", uVar1);
        uVar1 = json_integer(local_68, uStack_64);
        json_object_set_new(local_24, "hw_all", uVar1);
        uVar1 = json_integer(_DAT_001512b8, DAT_001512bc);
        json_object_set_new(local_24, "bestshare", uVar1);
        local_28 = json_array();
        FUN_0001dd08(local_28);
        json_object_set_new(local_24, "status", local_28);
        json_array_append_new(local_2c, local_24);
        json_object_set_new(local_10cc, "SUMMARY", local_2c);
        dVar2 = g_hash_rate_5s;
        if (0 < local_84) {
            free(local_14);
            free(local_18);
            dVar2 = g_hash_rate_5s;
        }
    }
    g_hash_rate_5s._4_4_ = (undefined4)((ulonglong)dVar2 >> 0x20);
    g_hash_rate_5s._0_4_ = SUB84(dVar2, 0);
    return local_20;
}

undefined4 FUN_0001ef90(int param_1, int param_2)

{
    undefined4 uVar1;
    time_t tVar2;
    undefined8 uVar3;
    undefined1 auStack_115c[4096];
    undefined8 local_15c;
    undefined8 uStack_154;
    undefined8 local_14c;
    char local_144[16];
    undefined4 local_134;
    undefined1 uStack_130;
    undefined1 uStack_12f;
    undefined2 uStack_12e;
    undefined4 uStack_12c;
    char acStack_128[128];
    char acStack_a8[128];
    int local_28;
    undefined4 uStack_24;
    uint local_20;
    undefined4 local_1c;
    undefined4 local_18;
    int local_14;
    undefined4 local_10;
    int local_c;

    local_10 = 0;
    local_18 = 0;
    local_1c = 0;
    local_c = 0;
    local_14 = param_2;
    memset(acStack_a8, 0, 0x80);
    memset(acStack_128, 0, 0x80);
    local_134._0_1_ = '\0';
    local_134._1_1_ = '\0';
    local_134._2_1_ = '\0';
    local_134._3_1_ = '\0';
    uStack_130 = 0;
    uStack_12f = 0;
    uStack_12e = 0;
    uStack_12c = 0;
    local_144[0] = '\0';
    local_144[1] = '\0';
    local_144[2] = '\0';
    local_144[3] = '\0';
    local_144[4] = '\0';
    local_144[5] = '\0';
    local_144[6] = '\0';
    local_144[7] = '\0';
    local_144[8] = '\0';
    local_144[9] = '\0';
    local_144[10] = '\0';
    local_144[0xb] = '\0';
    local_144[0xc] = '\0';
    local_144[0xd] = '\0';
    local_144[0xe] = '\0';
    local_144[0xf] = '\0';
    local_15c = 0;
    uStack_154 = 0;
    local_14c = 0;
    local_20 = 0;
    if ((local_14 == 0) || (param_1 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_115c, 0x1000, 0, "%s: input bad api param",
                   "get_pools");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_pools", 9, 0x25a, 100, auStack_115c);
        local_10 = 0x80000002;
    } else {
        FUN_0001de14(param_1, local_14);
        FUN_0001df60(param_1);
        local_18 = json_array();
        uStack_24 = get_total_nonce_rate();
        for (local_c = 0; local_c < total_pools; local_c = local_c + 1) {
            local_28 = *(int *)(pools + local_c * 4);
            if (local_28 != 0) {
                local_1c = json_object();
                uVar1 = json_integer(local_c, local_c >> 0x1f);
                json_object_set_new(local_1c, "index", uVar1);
                memset(acStack_a8, 0, 0x80);
                snprintf(acStack_a8, 0x80, "%s",
                         *(undefined4 *)(local_28 + 0xc));
                uVar1 = json_string(acStack_a8);
                json_object_set_new(local_1c, &DAT_000cd530, uVar1);
                memset(acStack_128, 0, 0x80);
                snprintf(acStack_128, 0x80, "%s",
                         *(undefined4 *)(local_28 + 0x10));
                uVar1 = json_string(acStack_128);
                json_object_set_new(local_1c, &DAT_000cd534, uVar1);
                memset(&local_134, 0, 0xc);
                if (*(char *)(local_28 + 0x770) == '\0') {
                    local_134._0_1_ = 'A';
                    local_134._1_1_ = 'l';
                    local_134._2_1_ = 'i';
                    local_134._3_1_ = 'v';
                    uStack_130 = 0x65;
                    uStack_12f = 0;
                } else {
                    local_134._0_1_ = 'D';
                    local_134._1_1_ = 'e';
                    local_134._2_1_ = 'a';
                    local_134._3_1_ = 'd';
                    uStack_130 = 0;
                }
                uVar1 = json_string(&local_134);
                json_object_set_new(local_1c, "status", uVar1);
                uVar1 = json_integer(*(int *)(local_28 + 4),
                                     *(int *)(local_28 + 4) >> 0x1f);
                json_object_set_new(local_1c, "priority", uVar1);
                uVar1 = json_integer(*(undefined4 *)(local_28 + 0x660), 0);
                json_object_set_new(local_1c, "getworks", uVar1);
                uVar1 = json_integer(*(undefined4 *)(local_28 + 0x788),
                                     *(undefined4 *)(local_28 + 0x78c));
                json_object_set_new(local_1c, "accepted", uVar1);
                uVar1 = json_integer(*(undefined4 *)(local_28 + 0x790),
                                     *(undefined4 *)(local_28 + 0x794));
                json_object_set_new(local_1c, "rejected", uVar1);
                uVar1 = json_integer(*(undefined4 *)(local_28 + 0x798), 0);
                json_object_set_new(local_1c, "discarded", uVar1);
                uVar1 = json_integer(*(undefined4 *)(local_28 + 0x668), 0);
                json_object_set_new(local_1c, "stale", uVar1);
                memset(local_144, 0, 0x10);
                snprintf(local_144, 0x10, "%s", local_28 + 0x7b8);
                uVar1 = json_string(local_144);
                json_object_set_new(local_1c, &DAT_000cd590, uVar1);
                uVar1 = json_integer(*(undefined4 *)(local_28 + 0x7c8),
                                     *(undefined4 *)(local_28 + 0x7cc));
                json_object_set_new(local_1c, "diff1", uVar1);
                uVar1 = json_real(*(undefined4 *)(local_28 + 0x7a8));
                json_object_set_new(local_1c, "diffa", uVar1);
                uVar3 = FUN_000cce38(*(undefined4 *)(local_28 + 0x7b0),
                                     *(undefined4 *)(local_28 + 0x7b4));
                uVar1 =
                    json_integer((int)uVar3, (int)((ulonglong)uVar3 >> 0x20));
                json_object_set_new(local_1c, "diffr", uVar1);
                uVar3 = FUN_000cce38(*(undefined4 *)(local_28 + 0x718),
                                     *(undefined4 *)(local_28 + 0x71c));
                uVar1 =
                    json_integer((int)uVar3, (int)((ulonglong)uVar3 >> 0x20));
                json_object_set_new(local_1c, "diffs", uVar1);
                uVar3 = FUN_000cce38(*(undefined4 *)(local_28 + 0x658),
                                     *(undefined4 *)(local_28 + 0x65c));
                uVar1 =
                    json_integer((int)uVar3, (int)((ulonglong)uVar3 >> 0x20));
                json_object_set_new(local_1c, "lsdiff", uVar1);
                memset(&local_15c, 0, 0x18);
                if (*(int *)(local_28 + 0x650) < 1) {
                    local_15c = CONCAT62(local_15c._2_6_, 0x30);
                } else {
                    tVar2 = time((time_t *)0x0);
                    local_20 = tVar2 - *(int *)(local_28 + 0x650);
                    snprintf((char *)&local_15c, 0x18, "%d:%d:%d",
                             local_20 / 0xe10, (local_20 % 0xe10) / 0x3c,
                             (local_20 % 0xe10) % 0x3c);
                }
                uVar1 = json_string(&local_15c);
                json_object_set_new(local_1c, "lstime", uVar1);
                json_array_append_new(local_18, local_1c);
            }
        }
        json_object_set_new(param_1, "POOLS", local_18);
    }
    return local_10;
}

undefined4 FUN_0001f6e4(int param_1, int param_2)

{
    size_t sVar1;
    int iVar2;
    void *__dest;
    undefined4 uVar3;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;
    double dVar4;
    undefined8 uVar5;
    undefined1 auStack_15d0[224];
    int local_14f0;
    int local_14ec;
    undefined1 auStack_14e4[4096];
    int local_4e4;
    double dStack_4e0;
    undefined1 auStack_4d8[4];
    int local_4d4;
    int local_4d0;
    float local_4cc;
    float local_4c8;
    float local_4c4;
    float local_4c0;
    undefined4 local_4b8;
    uint local_4a8;
    int iStack_4a4;
    char acStack_4a0[1024];
    undefined8 local_a0;
    double dStack_98;
    undefined8 local_90;
    undefined4 uStack_88;
    undefined4 uStack_84;
    uint local_80;
    int iStack_7c;
    double dStack_78;
    double dStack_70;
    double dStack_68;
    double dStack_60;
    double dStack_58;
    int local_4c;
    int local_48;
    undefined4 local_44;
    undefined4 local_40;
    undefined4 local_3c;
    undefined4 local_38;
    undefined4 local_34;
    int local_30;
    undefined4 local_2c;
    void *local_28;
    void *local_24;
    int local_20;
    uint local_1c;

    local_2c = 0;
    local_20 = 0;
    local_1c = 0;
    local_34 = 0;
    local_38 = 0;
    local_3c = 0;
    local_40 = 0;
    local_44 = 0;
    local_a0 = 0;
    local_4e4 = 0;
    local_24 = (void *)0x0;
    local_28 = (void *)0x0;
    local_14f0 = param_2;
    local_14ec = param_1;
    local_30 = param_2;
    local_48 = get_all_created_runtime(&local_4e4);
    local_4c = frontend_runtime_instance();
    if ((local_30 == 0) || (local_14ec == 0)) {
        V_LOCK();
        logfmt_raw(auStack_14e4, 0x1000, 0, "%s: input bad api param",
                   "get_stats");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_stats", 9, 0x2e1, 100, auStack_14e4);
        local_2c = 0x80000002;
    } else {
        FUN_0001de14(local_14ec, local_30);
        FUN_0001df60(local_14ec);
        local_34 = json_array();
        read_system_status_from_monitor(auStack_4d8);
        uVar3 = format_hashrate_double(
            local_4b8, *(undefined4 *)(*(int *)(local_4c + 0x48) + 0x10),
            &dStack_4e0, &local_a0);
        dStack_58 = (double)CONCAT44(extraout_s1, uVar3);
        dStack_60 = dStack_58 * (double)local_4cc;
        dStack_68 = dStack_58 * (double)local_4c8;
        dStack_70 = dStack_58 * (double)local_4c4;
        dStack_78 = dStack_58 * (double)local_4c0;
        local_80 = local_4a8;
        iStack_7c = iStack_4a4;
        if (0 < local_4e4) {
            local_24 = malloc(local_4e4 * 0xe0);
            local_28 = malloc(local_4e4 << 2);
            for (local_20 = 0; local_20 < local_4e4; local_20 = local_20 + 1) {
                __dest = (void *)((int)local_24 + local_20 * 0xe0);
                read_status_from_monitor(
                    auStack_15d0, *(undefined4 *)(local_48 + local_20 * 4));
                memcpy(__dest, auStack_15d0, 0xe0);
                *(undefined4 *)((int)local_28 + local_20 * 4) =
                    *(undefined4 *)(*(int *)(local_48 + local_20 * 4) + 0xfc);
            }
        }
        local_38 = json_object();
        uStack_84 = get_total_nonce_rate();
        uStack_88 = get_total_accept_rate();
        uVar3 = get_miner_elapsed_time();
        local_90 = CONCAT44(extraout_s1_00, uVar3);
        uVar5 = FUN_000cce38(uVar3, extraout_s1_00);
        uVar3 = json_integer((int)uVar5, (int)((ulonglong)uVar5 >> 0x20));
        json_object_set_new(local_38, "elapsed", uVar3);
        uVar5 = FUN_000cce38(SUB84(dStack_60 * 100.0, 0),
                             (int)((ulonglong)(dStack_60 * 100.0) >> 0x20));
        dVar4 =
            (double)FUN_000ccae4((int)uVar5, (int)((ulonglong)uVar5 >> 0x20));
        uVar3 = json_real(SUB84(dVar4 / 100.0, 0));
        json_object_set_new(local_38, "rate_5s", uVar3);
        uVar5 = FUN_000cce38(SUB84(dStack_78 * 100.0, 0),
                             (int)((ulonglong)(dStack_78 * 100.0) >> 0x20));
        dVar4 =
            (double)FUN_000ccae4((int)uVar5, (int)((ulonglong)uVar5 >> 0x20));
        uVar3 = json_real(SUB84(dVar4 / 100.0, 0));
        json_object_set_new(local_38, "rate_avg", uVar3);
        uVar5 = FUN_000cce38(SUB84(dStack_70 * 100.0, 0),
                             (int)((ulonglong)(dStack_70 * 100.0) >> 0x20));
        dVar4 =
            (double)FUN_000ccae4((int)uVar5, (int)((ulonglong)uVar5 >> 0x20));
        uVar3 = json_real(SUB84(dVar4 / 100.0, 0));
        json_object_set_new(local_38, "rate_30m", uVar3);
        dVar4 = dStack_4e0 * 0.972 * 10.0;
        uVar5 = FUN_000cce38(SUB84(dVar4, 0), (int)((ulonglong)dVar4 >> 0x20));
        dVar4 =
            (double)FUN_000ccae4((int)uVar5, (int)((ulonglong)uVar5 >> 0x20));
        uVar3 = json_real(SUB84(dVar4 / 10.0, 0));
        json_object_set_new(local_38, "rate_ideal", uVar3);
        uVar3 = json_string(&local_a0);
        json_object_set_new(local_38, "rate_unit", uVar3);
        uVar3 = json_integer(local_4e4, local_4e4 >> 0x1f);
        json_object_set_new(local_38, "chain_num", uVar3);
        uVar3 = json_integer(local_4d4, local_4d4 >> 0x1f);
        json_object_set_new(local_38, "fan_num", uVar3);
        local_3c = json_array();
        for (local_20 = 0; local_20 < local_4d4; local_20 = local_20 + 1) {
            iVar2 = *(int *)(local_4d0 + local_20 * 4);
            uVar3 = json_integer(iVar2, iVar2 >> 0x1f);
            json_array_append_new(local_3c, uVar3);
        }
        json_object_set_new(local_38, &DAT_000cd5f0, local_3c);
        if (local_80 + (uint)total_diff1 == 0 &&
            iStack_7c + total_diff1._4_4_ +
                    (uint)CARRY4(local_80, (uint)total_diff1) ==
                0) {
            dStack_98 = 0.0;
        } else {
            dVar4 = (double)FUN_000ccad4(local_80, iStack_7c);
            dStack_98 = (double)FUN_000ccad4(
                local_80 + (uint)total_diff1,
                iStack_7c + total_diff1._4_4_ +
                    (uint)CARRY4(local_80, (uint)total_diff1));
            dStack_98 = dVar4 / dStack_98;
        }
        dVar4 = dStack_98 * 100.0 * 10000.0;
        uVar5 = FUN_000cce38(SUB84(dVar4, 0), (int)((ulonglong)dVar4 >> 0x20));
        dVar4 =
            (double)FUN_000ccae4((int)uVar5, (int)((ulonglong)uVar5 >> 0x20));
        uVar3 = json_real(SUB84(dVar4 / 10000.0, 0));
        json_object_set_new(local_38, "hwp_total", uVar3);
        local_40 = json_array();
        for (local_20 = 0; local_20 < local_4e4; local_20 = local_20 + 1) {
            local_44 = json_object();
            iVar2 = *(int *)((int)local_28 + local_20 * 4);
            uVar3 = json_integer(iVar2, iVar2 >> 0x1f);
            json_object_set_new(local_44, "index", uVar3);
            iVar2 = *(int *)((int)local_24 + local_20 * 0xe0 + 0x50);
            uVar3 = json_integer(iVar2, iVar2 >> 0x1f);
            json_object_set_new(local_44, "freq_avg", uVar3);
            dStack_70 = dStack_58 * (double)*(float *)((int)local_24 +
                                                       local_20 * 0xe0 + 0x2c);
            dStack_4e0 =
                *(double *)((int)local_24 + local_20 * 0xe0 + 0x38) * dStack_58;
            uVar5 =
                FUN_000cce38(SUB84(dStack_4e0 * 100.0, 0),
                             (int)((ulonglong)(dStack_4e0 * 100.0) >> 0x20));
            dVar4 = (double)FUN_000ccae4((int)uVar5,
                                         (int)((ulonglong)uVar5 >> 0x20));
            uVar3 = json_real(SUB84(dVar4 / 100.0, 0));
            json_object_set_new(local_44, "rate_ideal", uVar3);
            uVar5 = FUN_000cce38(SUB84(dStack_70 * 100.0, 0),
                                 (int)((ulonglong)(dStack_70 * 100.0) >> 0x20));
            dVar4 = (double)FUN_000ccae4((int)uVar5,
                                         (int)((ulonglong)uVar5 >> 0x20));
            uVar3 = json_real(SUB84(dVar4 / 100.0, 0));
            json_object_set_new(local_44, "rate_real", uVar3);
            iVar2 = *(int *)((int)local_24 + local_20 * 0xe0 + 0x48);
            uVar3 = json_integer(iVar2, iVar2 >> 0x1f);
            json_object_set_new(local_44, "asic_num", uVar3);
            if (*(int *)((int)local_24 + local_20 * 0xe0 + 0x4c) != 0) {
                strcpy(acStack_4a0,
                       *(char **)((int)local_24 + local_20 * 0xe0 + 0x4c));
                local_1c = 0;
                while (sVar1 = strlen(acStack_4a0), local_1c < sVar1) {
                    if ((acStack_4a0[local_1c] != 'o') &&
                        (acStack_4a0[local_1c] != ' ')) {
                        acStack_4a0[local_1c] = 'x';
                    }
                    local_1c = local_1c + 1;
                }
                uVar3 = json_string(acStack_4a0);
                json_object_set_new(local_44, &DAT_000cd624, uVar3);
            }
            local_3c = json_array();
            for (local_1c = 0; (int)local_1c <
                               *(int *)((int)local_24 + local_20 * 0xe0 + 0x1c);
                 local_1c = local_1c + 1) {
                uVar3 = json_integer(0, 0);
                json_array_append_new(local_3c, uVar3);
            }
            for (local_1c = 0; (int)local_1c <
                               *(int *)((int)local_24 + local_20 * 0xe0 + 0x20);
                 local_1c = local_1c + 1) {
                uVar3 = json_integer(0, 0);
                json_array_append_new(local_3c, uVar3);
            }
            json_object_set_new(local_44, "temp_pic", local_3c);
            local_3c = json_array();
            for (local_1c = 0; (int)local_1c <
                               *(int *)((int)local_24 + local_20 * 0xe0 + 0x1c);
                 local_1c = local_1c + 1) {
                iVar2 = *(int *)(*(int *)((int)local_24 + local_20 * 0xe0 + 4) +
                                 local_1c * 4);
                uVar3 = json_integer(iVar2, iVar2 >> 0x1f);
                json_array_append_new(local_3c, uVar3);
            }
            for (local_1c = 0; (int)local_1c <
                               *(int *)((int)local_24 + local_20 * 0xe0 + 0x20);
                 local_1c = local_1c + 1) {
                iVar2 =
                    *(int *)(*(int *)((int)local_24 + local_20 * 0xe0 + 0xc) +
                             local_1c * 4);
                uVar3 = json_integer(iVar2, iVar2 >> 0x1f);
                json_array_append_new(local_3c, uVar3);
            }
            json_object_set_new(local_44, "temp_pcb", local_3c);
            local_3c = json_array();
            for (local_1c = 0; (int)local_1c <
                               *(int *)((int)local_24 + local_20 * 0xe0 + 0x1c);
                 local_1c = local_1c + 1) {
                iVar2 = *(int *)(*(int *)((int)local_24 + local_20 * 0xe0 + 8) +
                                 local_1c * 4);
                uVar3 = json_integer(iVar2, iVar2 >> 0x1f);
                json_array_append_new(local_3c, uVar3);
            }
            for (local_1c = 0; (int)local_1c <
                               *(int *)((int)local_24 + local_20 * 0xe0 + 0x20);
                 local_1c = local_1c + 1) {
                iVar2 =
                    *(int *)(*(int *)((int)local_24 + local_20 * 0xe0 + 0x10) +
                             local_1c * 4);
                uVar3 = json_integer(iVar2, iVar2 >> 0x1f);
                json_array_append_new(local_3c, uVar3);
            }
            json_object_set_new(local_44, "temp_chip", local_3c);
            uVar3 = json_integer(
                *(undefined4 *)((int)local_24 + local_20 * 0xe0 + 0x58),
                *(undefined4 *)((int)local_24 + local_20 * 0xe0 + 0x5c));
            json_object_set_new(local_44, &DAT_000cd650, uVar3);
            iVar2 = is_eeprom_loaded();
            if (iVar2 == 0) {
                iVar2 = is_eeprom_loaded();
                if (iVar2 == 0) {
                    uVar3 = json_false();
                } else {
                    uVar3 = json_true();
                }
                json_object_set_new(local_44, "eeprom_loaded", uVar3);
            } else {
                iVar2 = is_eeprom_loaded();
                if (iVar2 == 0) {
                    uVar3 = json_false();
                } else {
                    uVar3 = json_true();
                }
                json_object_set_new(local_44, "eeprom_loaded", uVar3);
                iVar2 = api_get_eeprom_chip_sn(local_20);
                if (iVar2 != 0) {
                    uVar3 = api_get_eeprom_chip_sn(local_20);
                    uVar3 = json_string(uVar3);
                    json_object_set_new(local_44, &DAT_000cd664, uVar3);
                }
            }
            json_array_append_new(local_40, local_44);
        }
        json_object_set_new(local_38, "chain", local_40);
        json_array_append_new(local_34, local_38);
        json_object_set_new(local_14ec, "STATS", local_34);
        if (0 < local_4e4) {
            free(local_28);
            free(local_24);
        }
    }
    return local_2c;
}

undefined4 FUN_00020588(undefined4 param_1, int param_2)

{
    undefined4 uVar1;
    void *__dest;
    undefined4 uVar2;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;
    double dVar3;
    undefined8 uVar4;
    undefined1 auStack_1168[224];
    int local_1088;
    undefined4 local_1084;
    undefined1 auStack_107c[4096];
    int local_7c;
    undefined8 local_78;
    undefined8 local_70;
    char local_68[8];
    undefined4 local_60;
    undefined4 local_5c;
    undefined4 local_58;
    undefined4 local_54;
    undefined4 local_50;
    int local_4c;
    int local_48;
    int local_44;
    undefined4 local_40;
    undefined4 local_3c;
    undefined4 local_38;
    undefined4 local_34;
    void *local_30;
    void *local_2c;
    double local_28;
    int local_1c;
    int local_18;
    uint local_14;

    local_34 = 0;
    local_1c = 0;
    local_18 = 0;
    local_14 = 0;
    local_38 = 0;
    local_3c = 0;
    local_40 = 0;
    local_68[0] = '\0';
    local_68[1] = '\0';
    local_68[2] = '\0';
    local_68[3] = '\0';
    local_68[4] = '\0';
    local_68[5] = '\0';
    local_68[6] = '\0';
    local_68[7] = '\0';
    local_70 = 0;
    local_28 = 1.0;
    local_7c = 0;
    local_2c = (void *)0x0;
    local_30 = (void *)0x0;
    local_1088 = param_2;
    local_1084 = param_1;
    local_44 = param_2;
    local_48 = get_all_created_runtime(&local_7c);
    local_4c = frontend_runtime_instance();
    local_50 = 0;
    local_54 = 0;
    local_58 = 0;
    local_5c = 0;
    local_60 = 0;
    if ((local_1088 == 0) || (local_44 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_107c, 0x1000, 0, "%s: input bad api param",
                   "get_rate");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_rate", 8, 0x39d, 100, auStack_107c);
        local_34 = 0x80000002;
    } else {
        FUN_0001de14(local_1084, local_44);
        FUN_0001df60(local_1084);
        if (0 < local_7c) {
            local_2c = malloc(local_7c * 0xe0);
            local_30 = malloc(local_7c << 2);
            for (local_1c = 0; local_1c < local_7c; local_1c = local_1c + 1) {
                __dest = (void *)((int)local_2c + local_1c * 0xe0);
                read_status_from_monitor(
                    auStack_1168, *(undefined4 *)(local_48 + local_1c * 4));
                memcpy(__dest, auStack_1168, 0xe0);
                *(undefined4 *)((int)local_30 + local_1c * 4) =
                    *(undefined4 *)(*(int *)(local_48 + local_1c * 4) + 0xfc);
            }
            local_14 = *(uint *)((int)local_2c + 0xd8);
            if (*(int *)((int)local_2c + 0xdc) != 0 || 0x18 < local_14) {
                local_14 = 0x18;
            }
            local_38 = *(undefined4 *)((int)local_2c + 0xd0);
            uVar2 = format_hashrate_double(
                (int)*(undefined8 *)((int)local_2c + 0x38),
                *(undefined4 *)(*(int *)(local_4c + 0x48) + 0x10), &local_78,
                &local_70);
            local_28 = (double)CONCAT44(extraout_s1, uVar2);
        }
        local_50 = json_array();
        local_5c = json_object();
        if (local_7c == 0) {
            uVar2 = format_hashrate_double(
                0, *(undefined4 *)(*(int *)(local_4c + 0x48) + 0x10), &local_78,
                &local_70);
            local_28 = (double)CONCAT44(extraout_s1_00, uVar2);
        }
        uVar2 = json_string(&local_70);
        json_object_set_new(local_5c, &DAT_000cd678, uVar2);
        local_54 = json_array();
        for (local_1c = 0; local_1c < (int)local_14; local_1c = local_1c + 1) {
            memset(local_68, 0, 8);
            snprintf(local_68, 8, "%dmin", (local_1c + 1) * 0xf);
            uVar2 = json_string(local_68);
            json_array_append_new(local_54, uVar2);
        }
        json_object_set_new(local_5c, "xAxis", local_54);
        local_54 = json_array();
        for (local_1c = 0; local_1c < local_7c; local_1c = local_1c + 1) {
            local_58 = json_object();
            memset(local_68, 0, 8);
            snprintf(local_68, 8, "chain%d",
                     *(undefined4 *)((int)local_30 + local_1c * 4));
            uVar2 = json_string(local_68);
            json_object_set_new(local_58, &DAT_000cd698, uVar2);
            local_60 = json_array();
            for (local_18 = 0; local_18 < (int)local_14;
                 local_18 = local_18 + 1) {
                dVar3 =
                    (double)*(float *)((int)local_2c + (local_18 + 0x1c) * 4 +
                                       local_1c * 0xe0) *
                    local_28;
                local_78._0_4_ = SUB84(dVar3, 0);
                local_78._4_4_ = (undefined4)((ulonglong)dVar3 >> 0x20);
                uVar2 = local_78._4_4_;
                uVar1 = (undefined4)local_78;
                local_78 = dVar3;
                uVar4 = FUN_000cce38(uVar1, uVar2);
                uVar2 =
                    json_integer((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
                json_array_append_new(local_60, uVar2);
            }
            json_object_set_new(local_58, &DAT_000cd6a0, local_60);
            json_array_append_new(local_54, local_58);
        }
        json_object_set_new(local_5c, "series", local_54);
        json_array_append_new(local_50, local_5c);
        json_object_set_new(local_1084, &DAT_000cd6b0, local_50);
        if (0 < local_7c) {
            free(local_30);
            free(local_2c);
        }
    }
    return local_34;
}

void FUN_00020b4c(void)

{
    int iVar1;
    undefined1 auStack_1010[4096];
    undefined4 local_10;
    uint local_c;

    local_10 = 0;
    local_c = 0;
    V_LOCK();
    logfmt_raw(auStack_1010, 0x1000, 0, "START %s",
               "load_default_config_without_restart");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "load_default_config_without_restart", 0x23, 1000, 0x14,
         auStack_1010);
    if ((default_config != (char *)0x0) &&
        (iVar1 = access(default_config, 4), iVar1 == 0)) {
        local_c = judge_load_config(default_config);
    }
    if ((local_c & 1) != 0) {
        reload_pool();
    }
    return;
}

undefined4 FUN_00020c5c(undefined4 param_1, int param_2)

{
    undefined1 auStack_1034[4096];
    undefined4 local_34;
    undefined8 local_30;
    undefined4 local_28;
    int local_24;
    undefined4 local_20;
    undefined4 local_1c;
    undefined4 local_18;
    undefined4 local_14;
    undefined4 local_10;
    undefined4 local_c;

    local_10 = 0;
    local_c = 0;
    local_30 = 0;
    local_34 = 0;
    local_14 = frontend_runtime_instance();
    local_18 = get_all_created_runtime(&local_34);
    local_1c = 0;
    local_20 = 0;
    local_24 = param_2;
    if ((param_2 == 0) || (param_2 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_1034, 0x1000, 0, "%s: input bad api param",
                   "get_warnings");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_warnings", 0xc, 0x406, 100, auStack_1034);
        local_10 = 0x80000002;
    } else {
        FUN_0001de14(param_1, param_2);
        FUN_0001df60(param_1);
        local_28 = 0;
        local_28 = json_array();
        sweep_get_error_code(local_28);
        json_object_set_new(param_1, "WARNING", local_28);
    }
    return local_10;
}

undefined4 FUN_00020df0(undefined4 param_1, undefined4 param_2)

{
    int iVar1;
    undefined1 auStack_100c[4096];
    undefined4 local_c;

    local_c = 0;
    V_LOCK();
    logfmt_raw(auStack_100c, 0x1000, 0,
               "<<<<<<<<<<<<<<<<<<<<exec %s start>>>>>>>>>>>>>>>>",
               "reload_config");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "reload_config", 0xd, 0x418, 0x14, auStack_100c, param_2,
         param_1);
    iVar1 = strcmp(&DAT_00151288, DAT_0014d378);
    if (iVar1 == 0) {
        FUN_00020b4c();
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0,
                   "<<<<<<<<<<<<<<<<<<<<exec %s end>>>>>>>>>>>>>>>>>>",
                   "reload_config");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "reload_config", 0xd, 0x41f, 0x14, auStack_100c);
    } else {
        local_c = 0x80000005;
    }
    return local_c;
}

void FUN_00020f64(int param_1, char param_2, int param_3, char *param_4)

{
    uint uVar1;
    undefined4 uVar2;
    char local_44[48];
    undefined2 local_14[2];
    undefined4 local_10;
    undefined4 local_c;

    local_c = 0;
    local_10 = 0;
    local_14[0] = 0;
    local_44[0] = '\0';
    local_44[1] = '\0';
    local_44[2] = '\0';
    local_44[3] = '\0';
    local_44[4] = '\0';
    local_44[5] = '\0';
    local_44[6] = '\0';
    local_44[7] = '\0';
    local_44[8] = '\0';
    local_44[9] = '\0';
    local_44[10] = '\0';
    local_44[0xb] = '\0';
    local_44[0xc] = '\0';
    local_44[0xd] = '\0';
    local_44[0xe] = '\0';
    local_44[0xf] = '\0';
    local_44[0x10] = '\0';
    local_44[0x11] = '\0';
    local_44[0x12] = '\0';
    local_44[0x13] = '\0';
    local_44[0x14] = '\0';
    local_44[0x15] = '\0';
    local_44[0x16] = '\0';
    local_44[0x17] = '\0';
    local_44[0x18] = '\0';
    local_44[0x19] = '\0';
    local_44[0x1a] = '\0';
    local_44[0x1b] = '\0';
    local_44[0x1c] = '\0';
    local_44[0x1d] = '\0';
    local_44[0x1e] = '\0';
    local_44[0x1f] = '\0';
    local_44[0x20] = '\0';
    local_44[0x21] = '\0';
    local_44[0x22] = '\0';
    local_44[0x23] = '\0';
    local_44[0x24] = '\0';
    local_44[0x25] = '\0';
    local_44[0x26] = '\0';
    local_44[0x27] = '\0';
    local_44[0x28] = '\0';
    local_44[0x29] = '\0';
    local_44[0x2a] = '\0';
    local_44[0x2b] = '\0';
    local_44[0x2c] = '\0';
    local_44[0x2d] = '\0';
    local_44[0x2e] = '\0';
    local_44[0x2f] = '\0';
    if ((param_1 != 0) && (param_4 != (char *)0x0)) {
        local_c = json_array();
        local_10 = json_object();
        if (param_2 == '\0') {
            uVar1 = 0xd734;
        } else {
            uVar1 = 0xd370;
        }
        snprintf((char *)local_14, 2, "%s", uVar1 | 0xc0000);
        uVar2 = json_string(local_14);
        json_object_set_new(local_10, "STATUS", uVar2);
        uVar2 = json_integer(DAT_00151284, DAT_00151284 >> 0x1f);
        json_object_set_new(local_10, &DAT_000cd738, uVar2);
        uVar2 = json_integer(param_3, param_3 >> 0x1f);
        json_object_set_new(local_10, &DAT_000cd740, uVar2);
        if (param_3 == 7) {
            snprintf(local_44, 0x30, param_4, total_pools);
        } else {
            snprintf(local_44, 0x30, "%s", param_4);
        }
        uVar2 = json_string(local_44);
        json_object_set_new(local_10, &DAT_000cd388, uVar2);
        uVar2 = json_string(opt_api_description);
        json_object_set_new(local_10, "Description", uVar2);
        json_array_append_new(local_c, local_10);
        json_object_set_new(param_1, "STATUS", local_c);
        if (param_2 != '\x01') {
            uVar2 = json_integer(1, 0);
            json_object_set_new(param_1, &DAT_000cd754, uVar2);
        }
    }
    return;
}

/* WARNING: Globals starting with '_' overlap smaller symbols at the same
 * address */

undefined4 FUN_000211a8(int param_1, int param_2)

{
    undefined4 uVar1;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;
    double dVar2;
    double dVar3;
    undefined8 uVar4;
    undefined1 auStack_1194[4096];
    undefined4 local_194;
    undefined1 auStack_190[12];
    undefined1 auStack_184[32];
    undefined1 auStack_164[32];
    undefined1 auStack_144[32];
    undefined1 auStack_124[32];
    undefined1 auStack_104[32];
    undefined1 auStack_e4[12];
    undefined1 auStack_d8[12];
    float fStack_cc;
    float fStack_c8;
    float fStack_c4;
    float fStack_c0;
    undefined4 uStack_b8;
    uint local_a8;
    int iStack_a4;
    double dStack_a0;
    double dStack_98;
    double dStack_90;
    double dStack_88;
    undefined4 uStack_80;
    undefined4 uStack_7c;
    double dStack_78;
    double dStack_70;
    undefined8 local_68;
    uint local_60;
    int iStack_5c;
    double dStack_58;
    double dStack_50;
    double dStack_48;
    double dStack_40;
    double dStack_38;
    int local_30;
    undefined4 local_2c;
    int local_28;
    undefined4 local_24;
    undefined4 local_20;
    undefined4 local_1c;

    local_1c = 0;
    local_20 = 0;
    local_24 = 0;
    local_194 = 0;
    local_28 = param_2;
    local_2c = get_all_created_runtime(&local_194);
    local_30 = frontend_runtime_instance();
    if ((local_28 == 0) || (param_1 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_1194, 0x1000, 0, "%s: input bad api param",
                   "get_summary_old");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_summary_old", 0xf, 0x463, 100, auStack_1194);
        local_1c = 0x80000002;
    } else {
        FUN_00020f64(param_1, 1, 0xb, *(undefined4 *)(local_28 + 8));
        local_20 = json_array();
        local_24 = json_object();
        read_system_status_from_monitor(auStack_d8);
        format_hashrate_string(
            SUB84((double)fStack_cc, 0),
            *(undefined4 *)(*(int *)(local_30 + 0x48) + 0x10), auStack_104);
        format_hashrate_string(
            SUB84((double)fStack_c8, 0),
            *(undefined4 *)(*(int *)(local_30 + 0x48) + 0x10), auStack_124);
        format_hashrate_string(
            SUB84((double)fStack_c4, 0),
            *(undefined4 *)(*(int *)(local_30 + 0x48) + 0x10), auStack_144);
        format_hashrate_string(
            SUB84((double)fStack_c0, 0),
            *(undefined4 *)(*(int *)(local_30 + 0x48) + 0x10), auStack_164);
        format_hashrate_string(
            uStack_b8, *(undefined4 *)(*(int *)(local_30 + 0x48) + 0x10),
            auStack_184);
        uVar1 = format_hashrate_double(
            uStack_b8, *(undefined4 *)(*(int *)(local_30 + 0x48) + 0x10),
            auStack_190, auStack_e4);
        dStack_38 = (double)CONCAT44(extraout_s1, uVar1);
        dStack_40 = dStack_38 * (double)fStack_cc;
        dStack_48 = dStack_38 * (double)fStack_c8;
        dStack_50 = dStack_38 * (double)fStack_c4;
        dStack_58 = dStack_38 * (double)fStack_c0;
        local_60 = local_a8;
        iStack_5c = iStack_a4;
        uVar1 = get_miner_elapsed_time();
        local_68 = (double)CONCAT44(extraout_s1_00, uVar1);
        dVar2 = (double)FUN_000ccae4((undefined4)total_accepted,
                                     total_accepted._4_4_);
        dVar3 = local_68;
        if (local_68 == 0.0) {
            dVar3 = 1.0;
        }
        dStack_70 = (dVar2 / dVar3) * 60.0;
        dVar3 = local_68;
        if (local_68 == 0.0) {
            dVar3 = 1.0;
        }
        dStack_78 =
            ((total_diff_accepted + total_diff_rejected + total_diff_stale) /
             dVar3) *
            60.0;
        uStack_7c = get_total_nonce_rate();
        uStack_80 = get_total_accept_rate();
        uVar4 = FUN_000cce38((undefined4)local_68, local_68._4_4_);
        uVar1 = json_integer((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
        json_object_set_new(local_24, "Elapsed", uVar1);
        uVar4 = FUN_000cce38(SUB84(dStack_40 * 100.0, 0),
                             (int)((ulonglong)(dStack_40 * 100.0) >> 0x20));
        dVar3 =
            (double)FUN_000ccae4((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
        uVar1 = json_real(SUB84(dVar3 / 100.0, 0));
        json_object_set_new(local_24, "GHS 5s", uVar1);
        uVar4 = FUN_000cce38(SUB84(dStack_58 * 100.0, 0),
                             (int)((ulonglong)(dStack_58 * 100.0) >> 0x20));
        dVar3 =
            (double)FUN_000ccae4((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
        uVar1 = json_real(SUB84(dVar3 / 100.0, 0));
        json_object_set_new(local_24, "GHS av", uVar1);
        uVar4 = FUN_000cce38(SUB84(dStack_50 * 100.0, 0),
                             (int)((ulonglong)(dStack_50 * 100.0) >> 0x20));
        dVar3 =
            (double)FUN_000ccae4((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
        uVar1 = json_real(SUB84(dVar3 / 100.0, 0));
        json_object_set_new(local_24, "GHS 30m", uVar1);
        uVar1 = json_integer(DAT_001512a0, 0);
        json_object_set_new(local_24, "Found Blocks", uVar1);
        uVar1 = json_integer((undefined4)total_getworks, total_getworks._4_4_);
        json_object_set_new(local_24, "Getwork", uVar1);
        uVar1 = json_integer((undefined4)total_accepted, total_accepted._4_4_);
        json_object_set_new(local_24, "Accepted", uVar1);
        uVar1 = json_integer((undefined4)total_rejected, total_rejected._4_4_);
        json_object_set_new(local_24, "Rejected", uVar1);
        uVar1 = json_integer(local_60, iStack_5c);
        json_object_set_new(local_24, "Hardware Errors", uVar1);
        uVar4 = FUN_000cce38(SUB84(dStack_70 * 100.0, 0),
                             (int)((ulonglong)(dStack_70 * 100.0) >> 0x20));
        dVar3 =
            (double)FUN_000ccae4((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
        uVar1 = json_real(SUB84(dVar3 / 100.0, 0));
        json_object_set_new(local_24, "Utility", uVar1);
        uVar1 =
            json_integer((undefined4)total_discarded, total_discarded._4_4_);
        json_object_set_new(local_24, "Discarded", uVar1);
        uVar1 = json_integer((undefined4)total_stale, total_stale._4_4_);
        json_object_set_new(local_24, "Stale", uVar1);
        uVar1 = json_integer(total_go, 0);
        json_object_set_new(local_24, "Get Failures", uVar1);
        uVar1 = json_integer(local_work, 0);
        json_object_set_new(local_24, "Local Work", uVar1);
        uVar1 = json_integer(total_ro, 0);
        json_object_set_new(local_24, "Remote Failures", uVar1);
        uVar1 = json_integer(new_blocks, 0);
        json_object_set_new(local_24, "Network Blocks", uVar1);
        uVar4 = FUN_000cce38(SUB84(DAT_001512a8 * 100.0, 0),
                             (int)((ulonglong)(DAT_001512a8 * 100.0) >> 0x20));
        dVar3 =
            (double)FUN_000ccae4((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
        uVar1 = json_real(SUB84(dVar3 / 100.0, 0));
        json_object_set_new(local_24, "Total MH", uVar1);
        uVar1 = json_real(SUB84(dStack_78, 0));
        json_object_set_new(local_24, "Work Utility", uVar1);
        uVar4 = FUN_000cce38(
            SUB84(total_diff_accepted * 100.0, 0),
            (int)((ulonglong)(total_diff_accepted * 100.0) >> 0x20));
        dVar3 =
            (double)FUN_000ccae4((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
        uVar1 = json_real(SUB84(dVar3 / 100.0, 0));
        json_object_set_new(local_24, "Difficulty Accepted", uVar1);
        uVar4 = FUN_000cce38(
            SUB84(total_diff_rejected * 100.0, 0),
            (int)((ulonglong)(total_diff_rejected * 100.0) >> 0x20));
        dVar3 =
            (double)FUN_000ccae4((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
        uVar1 = json_real(SUB84(dVar3 / 100.0, 0));
        json_object_set_new(local_24, "Difficulty Rejected", uVar1);
        uVar4 =
            FUN_000cce38(SUB84(total_diff_stale * 100.0, 0),
                         (int)((ulonglong)(total_diff_stale * 100.0) >> 0x20));
        dVar3 =
            (double)FUN_000ccae4((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
        uVar1 = json_real(SUB84(dVar3 / 100.0, 0));
        json_object_set_new(local_24, "Difficulty Stale", uVar1);
        uVar1 = json_integer(_DAT_001512b8, DAT_001512bc);
        json_object_set_new(local_24, "Best Share", uVar1);
        if (local_60 + (uint)total_diff1 == 0 &&
            iStack_5c + total_diff1._4_4_ +
                    (uint)CARRY4(local_60, (uint)total_diff1) ==
                0) {
            dStack_88 = 0.0;
        } else {
            dVar3 = (double)FUN_000ccad4(local_60, iStack_5c);
            dStack_88 = (double)FUN_000ccad4(
                local_60 + (uint)total_diff1,
                iStack_5c + total_diff1._4_4_ +
                    (uint)CARRY4(local_60, (uint)total_diff1));
            dStack_88 = dVar3 / dStack_88;
        }
        uVar4 = FUN_000cce38(SUB84(dStack_88 * 100.0, 0),
                             (int)((ulonglong)(dStack_88 * 100.0) >> 0x20));
        dVar3 =
            (double)FUN_000ccae4((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
        uVar1 = json_real(SUB84(dVar3 / 100.0, 0));
        json_object_set_new(local_24, "Device Hardware%", uVar1);
        dStack_90 = total_diff_rejected;
        if ((uint)total_diff1 == 0 && total_diff1._4_4_ == 0) {
            dStack_90 = 0.0;
        } else {
            dVar3 = (double)FUN_000ccae4((uint)total_diff1, total_diff1._4_4_);
            dStack_90 = dStack_90 / dVar3;
        }
        uVar4 = FUN_000cce38(SUB84(dStack_90 * 100.0, 0),
                             (int)((ulonglong)(dStack_90 * 100.0) >> 0x20));
        dVar3 =
            (double)FUN_000ccae4((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
        uVar1 = json_real(SUB84(dVar3 / 100.0, 0));
        json_object_set_new(local_24, "Device Rejected%", uVar1);
        if (total_diff_accepted + total_diff_rejected + total_diff_stale ==
            0.0) {
            dStack_98 = 0.0;
        } else {
            dStack_98 =
                total_diff_rejected /
                (total_diff_accepted + total_diff_rejected + total_diff_stale);
        }
        uVar4 = FUN_000cce38(SUB84(dStack_98 * 100.0, 0),
                             (int)((ulonglong)(dStack_98 * 100.0) >> 0x20));
        dVar3 =
            (double)FUN_000ccae4((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
        uVar1 = json_real(SUB84(dVar3 / 100.0, 0));
        json_object_set_new(local_24, "Pool Rejected%", uVar1);
        if (total_diff_accepted + total_diff_rejected + total_diff_stale ==
            0.0) {
            dStack_a0 = 0.0;
        } else {
            dStack_a0 =
                total_diff_stale /
                (total_diff_accepted + total_diff_rejected + total_diff_stale);
        }
        uVar4 = FUN_000cce38(SUB84(dStack_a0 * 100.0, 0),
                             (int)((ulonglong)(dStack_a0 * 100.0) >> 0x20));
        dVar3 =
            (double)FUN_000ccae4((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
        uVar1 = json_real(SUB84(dVar3 / 100.0, 0));
        json_object_set_new(local_24, "Pool Stale%", uVar1);
        uVar1 = json_integer(last_getwork, last_getwork >> 0x1f);
        json_object_set_new(local_24, "Last getwork", uVar1);
        uVar1 = json_string(auStack_104);
        json_object_set_new(local_24, "RT HASHRATE", uVar1);
        uVar1 = json_string(auStack_164);
        json_object_set_new(local_24, "AV HASHRATE", uVar1);
        uVar1 = json_string(auStack_184);
        json_object_set_new(local_24, "THEORY HASHRATE", uVar1);
        json_array_append_new(local_20, local_24);
        json_object_set_new(param_1, "SUMMARY", local_20);
        uVar1 = json_integer(1, 0);
        json_object_set_new(param_1, &DAT_000cd754, uVar1);
    }
    return local_1c;
}

undefined4 FUN_00021eb0(int param_1, int param_2)

{
    time_t tVar1;
    undefined4 uVar2;
    double dVar3;
    undefined8 uVar4;
    undefined1 auStack_1164[4096];
    undefined8 local_164;
    undefined8 uStack_15c;
    undefined8 local_154;
    char local_14c[140];
    char acStack_c0[128];
    double dStack_40;
    int local_38;
    int local_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    double local_28;
    uint local_1c;
    undefined4 local_18;
    undefined4 local_14;
    undefined4 local_10;
    int local_c;

    local_10 = 0;
    local_14 = 0;
    local_18 = 0;
    local_c = 0;
    memset(acStack_c0, 0, 0x80);
    memset(local_14c + 0xc, 0, 0x80);
    local_14c[0] = '\0';
    local_14c[1] = '\0';
    local_14c[2] = '\0';
    local_14c[3] = '\0';
    local_14c[4] = 0;
    local_14c[5] = 0;
    local_14c[6] = '\0';
    local_14c[7] = '\0';
    local_14c[8] = '\0';
    local_14c[9] = '\0';
    local_14c[10] = '\0';
    local_14c[0xb] = '\0';
    local_164 = 0;
    uStack_15c = 0;
    local_154 = 0;
    local_1c = 0;
    local_28 = 0.0;
    local_30 = 0;
    uStack_2c = 0;
    local_34 = param_2;
    if ((param_2 == 0) || (param_1 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_1164, 0x1000, 0, "%s: input bad api param",
                   "get_pools_old");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_pools_old", 0xd, 0x4c0, 100, auStack_1164);
        local_10 = 0x80000002;
    } else if (total_pools == 0) {
        FUN_00020f64(param_1, 0, 8, "No pools");
    } else {
        FUN_00020f64(param_1, 1, 7, *(undefined4 *)(param_2 + 8));
        local_14 = json_array();
        for (local_c = 0; local_c < total_pools; local_c = local_c + 1) {
            local_38 = *(int *)(pools + local_c * 4);
            local_18 = json_object();
            uVar2 = json_integer(local_c, local_c >> 0x1f);
            json_object_set_new(local_18, &DAT_000cd8fc, uVar2);
            memset(acStack_c0, 0, 0x80);
            snprintf(acStack_c0, 0x80, "%s", *(undefined4 *)(local_38 + 0xc));
            uVar2 = json_string(acStack_c0);
            json_object_set_new(local_18, &DAT_000cd904, uVar2);
            memset(local_14c, 0, 0xc);
            if (*(char *)(local_38 + 0x770) == '\0') {
                builtin_strncpy(local_14c, "Alive", 6);
            } else {
                builtin_strncpy(local_14c, "Deed", 4);
                local_14c[4] = 0;
            }
            uVar2 = json_string(local_14c);
            json_object_set_new(local_18, "Status", uVar2);
            uVar2 = json_integer(*(int *)(local_38 + 4),
                                 *(int *)(local_38 + 4) >> 0x1f);
            json_object_set_new(local_18, "Priority", uVar2);
            uVar2 = json_integer(*(int *)(local_38 + 0x664),
                                 *(int *)(local_38 + 0x664) >> 0x1f);
            json_object_set_new(local_18, "Quota", uVar2);
            uVar2 = json_string(&DAT_000cd92c);
            json_object_set_new(local_18, "Long Poll", uVar2);
            uVar2 = json_integer(*(undefined4 *)(local_38 + 0x660), 0);
            json_object_set_new(local_18, "Getworks", uVar2);
            uVar2 = json_integer(*(undefined4 *)(local_38 + 0x788),
                                 *(undefined4 *)(local_38 + 0x78c));
            json_object_set_new(local_18, "Accepted", uVar2);
            uVar2 = json_integer(*(undefined4 *)(local_38 + 0x790),
                                 *(undefined4 *)(local_38 + 0x794));
            json_object_set_new(local_18, "Rejected", uVar2);
            uVar2 = json_integer(*(undefined4 *)(local_38 + 0x798), 0);
            json_object_set_new(local_18, "Discarded", uVar2);
            uVar2 = json_integer(*(undefined4 *)(local_38 + 0x668), 0);
            json_object_set_new(local_18, "Stale", uVar2);
            uVar2 = json_integer(*(undefined4 *)(local_38 + 0x79c), 0);
            json_object_set_new(local_18, "Get Failures", uVar2);
            uVar2 = json_integer(*(undefined4 *)(local_38 + 0x7a0), 0);
            json_object_set_new(local_18, "Remote Failures", uVar2);
            memset(local_14c + 0xc, 0, 0x80);
            snprintf(local_14c + 0xc, 0x80, "%s",
                     *(undefined4 *)(local_38 + 0x10));
            uVar2 = json_string(local_14c + 0xc);
            json_object_set_new(local_18, &DAT_000cd948, uVar2);
            memset(&local_164, 0, 0x18);
            if (*(int *)(local_38 + 0x650) < 1) {
                local_164 = CONCAT62(local_164._2_6_, 0x30);
            } else {
                tVar1 = time((time_t *)0x0);
                local_1c = tVar1 - *(int *)(local_38 + 0x650);
                snprintf((char *)&local_164, 0x18, "%d:%d:%d", local_1c / 0xe10,
                         (local_1c % 0xe10) / 0x3c, (local_1c % 0xe10) % 0x3c);
            }
            uVar2 = json_string(&local_164);
            json_object_set_new(local_18, "Last Share Time", uVar2);
            sprintf((char *)(local_38 + 0x7b8), "%8.4f",
                    *(undefined4 *)(local_38 + 0x710),
                    *(undefined4 *)(local_38 + 0x714));
            uVar2 = json_string(local_38 + 0x7b8);
            json_object_set_new(local_18, &DAT_000cd968, uVar2);
            uVar2 = json_integer(*(undefined4 *)(local_38 + 0x7c8),
                                 *(undefined4 *)(local_38 + 0x7cc));
            json_object_set_new(local_18, "Diff1 Shares", uVar2);
            uVar2 = json_string(&DAT_000cd240);
            json_object_set_new(local_18, "Proxy Type", uVar2);
            uVar2 = json_string(&DAT_000cd240);
            json_object_set_new(local_18, "Proxy", uVar2);
            dVar3 = *(double *)(local_38 + 0x7a8) * 100.0;
            uVar4 =
                FUN_000cce38(SUB84(dVar3, 0), (int)((ulonglong)dVar3 >> 0x20));
            dVar3 = (double)FUN_000ccae4((int)uVar4,
                                         (int)((ulonglong)uVar4 >> 0x20));
            uVar2 = json_real(SUB84(dVar3 / 100.0, 0));
            json_object_set_new(local_18, "Difficulty Accepted", uVar2);
            dVar3 = *(double *)(local_38 + 0x7b0) * 100.0;
            uVar4 =
                FUN_000cce38(SUB84(dVar3, 0), (int)((ulonglong)dVar3 >> 0x20));
            dVar3 = (double)FUN_000ccae4((int)uVar4,
                                         (int)((ulonglong)uVar4 >> 0x20));
            uVar2 = json_real(SUB84(dVar3 / 100.0, 0));
            json_object_set_new(local_18, "Difficulty Rejected", uVar2);
            dVar3 = *(double *)(local_38 + 0x718) * 100.0;
            uVar4 =
                FUN_000cce38(SUB84(dVar3, 0), (int)((ulonglong)dVar3 >> 0x20));
            dVar3 = (double)FUN_000ccae4((int)uVar4,
                                         (int)((ulonglong)uVar4 >> 0x20));
            uVar2 = json_real(SUB84(dVar3 / 100.0, 0));
            json_object_set_new(local_18, "Difficulty Stale", uVar2);
            dVar3 = *(double *)(local_38 + 0x658) * 100.0;
            uVar4 =
                FUN_000cce38(SUB84(dVar3, 0), (int)((ulonglong)dVar3 >> 0x20));
            dVar3 = (double)FUN_000ccae4((int)uVar4,
                                         (int)((ulonglong)uVar4 >> 0x20));
            uVar2 = json_real(SUB84(dVar3 / 100.0, 0));
            json_object_set_new(local_18, "Last Share Difficulty", uVar2);
            if (*(char *)(local_38 + 0x1c) == '\0') {
                uVar2 = json_false();
            } else {
                uVar2 = json_true();
            }
            json_object_set_new(local_18, "Has Stratum", uVar2);
            uVar2 = json_true();
            json_object_set_new(local_18, "Stratum Active", uVar2);
            uVar2 = json_string(&DAT_000cd240);
            json_object_set_new(local_18, "Stratum URL", uVar2);
            uVar2 = json_false();
            json_object_set_new(local_18, "Has GBT", uVar2);
            uVar2 = json_real(0);
            json_object_set_new(local_18, "Best Share", uVar2);
            if (*(double *)(local_38 + 0x7a8) + *(double *)(local_38 + 0x7b0) +
                    *(double *)(local_38 + 0x718) ==
                0.0) {
                local_28 = 0.0;
            } else {
                local_28 = *(double *)(local_38 + 0x7b0) /
                           (*(double *)(local_38 + 0x7a8) +
                            *(double *)(local_38 + 0x7b0) +
                            *(double *)(local_38 + 0x718));
            }
            uVar4 = FUN_000cce38(SUB84(local_28 * 100.0, 0),
                                 (int)((ulonglong)(local_28 * 100.0) >> 0x20));
            dVar3 = (double)FUN_000ccae4((int)uVar4,
                                         (int)((ulonglong)uVar4 >> 0x20));
            uVar2 = json_real(SUB84(dVar3 / 100.0, 0));
            json_object_set_new(local_18, "Pool Rejected%", uVar2);
            if (*(double *)(local_38 + 0x7a8) + *(double *)(local_38 + 0x7b0) +
                    *(double *)(local_38 + 0x718) ==
                0.0) {
                dStack_40 = 0.0;
            } else {
                dStack_40 = *(double *)(local_38 + 0x718) /
                            (*(double *)(local_38 + 0x7a8) +
                             *(double *)(local_38 + 0x7b0) +
                             *(double *)(local_38 + 0x718));
            }
            uVar4 = FUN_000cce38(SUB84(dStack_40 * 100.0, 0),
                                 (int)((ulonglong)(dStack_40 * 100.0) >> 0x20));
            dVar3 = (double)FUN_000ccae4((int)uVar4,
                                         (int)((ulonglong)uVar4 >> 0x20));
            uVar2 = json_real(SUB84(dVar3 / 100.0, 0));
            json_object_set_new(local_18, "Pool Stale%%", uVar2);
            json_array_append_new(local_14, local_18);
        }
        json_object_set_new(param_1, "POOLS", local_14);
        uVar2 = json_integer(1, 0);
        json_object_set_new(param_1, &DAT_000cd754, uVar2);
    }
    return local_10;
}

void FUN_00022a40(int param_1, int param_2, char *param_3)

{
    int local_10;
    size_t local_c;

    local_c = 0;
    for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
        sprintf(param_3 + local_c, "%d-",
                *(undefined4 *)(param_1 + local_10 * 4));
        local_c = strlen(param_3);
    }
    param_3[local_c - 1] = '-';
    param_3[local_c - 1] = '\0';
    return;
}

/* WARNING: Type propagation algorithm not settling */

undefined4 FUN_00022b04(int param_1, int param_2, undefined4 param_3)

{
    undefined4 uVar1;
    int iVar2;
    void *__dest;
    bool bVar3;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;
    uint uVar4;
    double dVar5;
    double dVar6;
    undefined8 uVar7;
    undefined1 auStack_13c0[228];
    undefined4 local_12dc;
    int local_12d8;
    int local_12d4;
    undefined1 auStack_12cc[4096];
    char acStack_2cc[12];
    int local_2c0[4];
    double dStack_2b0;
    undefined1 auStack_2a8[32];
    undefined1 auStack_288[32];
    undefined1 auStack_268[32];
    undefined1 auStack_248[32];
    undefined1 auStack_228[12];
    int local_21c;
    undefined1 auStack_218[4];
    int local_214;
    int local_210;
    float fStack_20c;
    float fStack_208;
    float fStack_204;
    float fStack_200;
    undefined4 uStack_1f8;
    char acStack_1e0[256];
    char local_e0[32];
    undefined8 local_c0;
    undefined8 uStack_b8;
    double dStack_b0;
    undefined4 uStack_a8;
    undefined4 uStack_a4;
    double dStack_a0;
    double dStack_98;
    undefined8 local_90;
    double dStack_88;
    double dStack_80;
    double dStack_78;
    double dStack_70;
    double dStack_68;
    int local_5c;
    int local_58;
    int local_54;
    undefined8 uStack_50;
    int local_48;
    undefined4 local_44;
    undefined4 local_40;
    undefined4 local_3c;
    undefined4 local_38;
    undefined4 local_34;
    uint local_30;
    int iStack_2c;
    int local_28;
    int local_24;
    char local_1d;
    void *local_1c;
    void *local_18;
    int local_14;

    local_34 = 0;
    local_38 = 0;
    local_3c = 0;
    local_14 = 0;
    local_40 = 0;
    local_44 = 0;
    local_c0 = 0;
    uStack_b8 = 0;
    local_e0[0] = '\0';
    local_e0[1] = '\0';
    local_e0[2] = '\0';
    local_e0[3] = '\0';
    local_e0[4] = '\0';
    local_e0[5] = '\0';
    local_e0[6] = '\0';
    local_e0[7] = '\0';
    local_e0[8] = '\0';
    local_e0[9] = '\0';
    local_e0[10] = '\0';
    local_e0[0xb] = '\0';
    local_e0[0xc] = '\0';
    local_e0[0xd] = '\0';
    local_e0[0xe] = '\0';
    local_e0[0xf] = '\0';
    local_e0[0x10] = '\0';
    local_e0[0x11] = '\0';
    local_e0[0x12] = '\0';
    local_e0[0x13] = '\0';
    local_e0[0x14] = '\0';
    local_e0[0x15] = '\0';
    local_e0[0x16] = '\0';
    local_e0[0x17] = '\0';
    local_e0[0x18] = '\0';
    local_e0[0x19] = '\0';
    local_e0[0x1a] = '\0';
    local_e0[0x1b] = '\0';
    local_e0[0x1c] = '\0';
    local_e0[0x1d] = '\0';
    local_e0[0x1e] = '\0';
    local_e0[0x1f] = '\0';
    local_12dc = param_3;
    local_12d8 = param_2;
    local_12d4 = param_1;
    memset(acStack_1e0, 0, 0x100);
    local_48 = 0;
    local_21c = 0;
    local_18 = (void *)0x0;
    local_1c = (void *)0x0;
    local_1d = '\0';
    local_24 = -100;
    local_28 = 0x7fffffff;
    local_30 = 0;
    iStack_2c = 0;
    uStack_50 = 0;
    local_54 = local_12d8;
    if ((local_12d8 == 0) || (local_12d4 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_12cc, 0x1000, 0, "%s: input bad api param",
                   "get_stats_old");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_stats_old", 0xd, 0x556, 100, auStack_12cc);
        local_3c = 0x80000002;
    } else {
        FUN_00020f64(local_12d4, 1, 0x46, *(undefined4 *)(local_12d8 + 8));
        local_34 = json_array();
        local_38 = json_object();
        uVar1 = json_string(&DAT_000cd9f0);
        json_object_set_new(local_38, "BMMiner", uVar1);
        uVar1 = json_string(g_miner_version);
        json_object_set_new(local_38, "Miner", uVar1);
        uVar1 = json_string(g_miner_compiletime);
        json_object_set_new(local_38, "CompileTime", uVar1);
        uVar1 = json_string(g_miner_type);
        json_object_set_new(local_38, &DAT_000cda08, uVar1);
        json_array_append_new(local_34, local_38);
        read_system_status_from_monitor(auStack_218);
        local_58 = get_all_created_runtime(&local_21c);
        local_5c = frontend_runtime_instance();
        if (0 < local_21c) {
            local_18 = malloc(local_21c * 0xe0);
            local_1c = malloc(local_21c << 2);
            for (local_14 = 0; local_14 < local_21c; local_14 = local_14 + 1) {
                __dest = (void *)((int)local_18 + local_14 * 0xe0);
                read_status_from_monitor(
                    auStack_13c0, *(undefined4 *)(local_58 + local_14 * 4));
                memcpy(__dest, auStack_13c0, 0xe0);
                *(int *)((int)local_1c + local_14 * 4) =
                    *(int *)(*(int *)(local_58 + local_14 * 4) + 0xfc) + 1;
            }
        }
        local_38 = json_object();
        uVar1 = json_integer(local_14, local_14 >> 0x1f);
        json_object_set_new(local_38, "STATS", uVar1);
        snprintf((char *)&local_c0, 0x10, "BTM_SOC%d", local_14);
        uVar1 = json_string(&local_c0);
        json_object_set_new(local_38, &DAT_000cda1c, uVar1);
        format_hashrate_string(
            SUB84((double)fStack_20c, 0),
            *(undefined4 *)(*(int *)(local_5c + 0x48) + 0x10), auStack_248);
        format_hashrate_string(
            SUB84((double)fStack_204, 0),
            *(undefined4 *)(*(int *)(local_5c + 0x48) + 0x10), auStack_268);
        format_hashrate_string(
            SUB84((double)fStack_200, 0),
            *(undefined4 *)(*(int *)(local_5c + 0x48) + 0x10), auStack_288);
        format_hashrate_string(
            uStack_1f8, *(undefined4 *)(*(int *)(local_5c + 0x48) + 0x10),
            auStack_2a8);
        uVar1 = format_hashrate_double(
            uStack_1f8, *(undefined4 *)(*(int *)(local_5c + 0x48) + 0x10),
            &dStack_2b0, auStack_228);
        dStack_68 = (double)CONCAT44(extraout_s1, uVar1);
        dStack_70 = dStack_68 * (double)fStack_20c;
        dStack_78 = dStack_68 * (double)fStack_208;
        dStack_80 = dStack_68 * (double)fStack_204;
        dStack_88 = dStack_68 * (double)fStack_200;
        uVar1 = get_miner_elapsed_time();
        local_90 = (double)CONCAT44(extraout_s1_00, uVar1);
        dVar5 = (double)FUN_000ccae4((undefined4)total_accepted,
                                     total_accepted._4_4_);
        dVar6 = local_90;
        if (local_90 == 0.0) {
            dVar6 = 1.0;
        }
        dStack_98 = (dVar5 / dVar6) * 60.0;
        dVar6 = local_90;
        if (local_90 == 0.0) {
            dVar6 = 1.0;
        }
        dStack_a0 =
            ((total_diff_accepted + total_diff_rejected + total_diff_stale) /
             dVar6) *
            60.0;
        uStack_a4 = get_total_nonce_rate();
        uStack_a8 = get_total_accept_rate();
        uVar7 = FUN_000cce38((undefined4)local_90, local_90._4_4_);
        uVar1 = json_integer((int)uVar7, (int)((ulonglong)uVar7 >> 0x20));
        json_object_set_new(local_38, "Elapsed", uVar1);
        uVar7 = FUN_000cce38(SUB84(dStack_70 * 100.0, 0),
                             (int)((ulonglong)(dStack_70 * 100.0) >> 0x20));
        dVar6 =
            (double)FUN_000ccae4((int)uVar7, (int)((ulonglong)uVar7 >> 0x20));
        uVar1 = json_real(SUB84(dVar6 / 100.0, 0));
        json_object_set_new(local_38, "GHS 5s", uVar1);
        uVar7 = FUN_000cce38(SUB84(dStack_88 * 100.0, 0),
                             (int)((ulonglong)(dStack_88 * 100.0) >> 0x20));
        dVar6 =
            (double)FUN_000ccae4((int)uVar7, (int)((ulonglong)uVar7 >> 0x20));
        uVar1 = json_real(SUB84(dVar6 / 100.0, 0));
        json_object_set_new(local_38, "GHS av", uVar1);
        uVar7 = FUN_000cce38(SUB84(dStack_80 * 100.0, 0),
                             (int)((ulonglong)(dStack_80 * 100.0) >> 0x20));
        dVar6 =
            (double)FUN_000ccae4((int)uVar7, (int)((ulonglong)uVar7 >> 0x20));
        uVar1 = json_real(SUB84(dVar6 / 100.0, 0));
        json_object_set_new(local_38, "rate_30m", uVar1);
        uVar7 = FUN_000cce38(SUB84(dStack_2b0 * 100.0, 0),
                             (int)((ulonglong)(dStack_2b0 * 100.0) >> 0x20));
        dVar6 =
            (double)FUN_000ccae4((int)uVar7, (int)((ulonglong)uVar7 >> 0x20));
        uVar1 = json_real(SUB84(dVar6 / 100.0, 0));
        json_object_set_new(local_38, "total_rateideal", uVar1);
        uVar1 =
            json_integer(opt_bitmain_work_mode, opt_bitmain_work_mode >> 0x1f);
        json_object_set_new(local_38, &DAT_000cda30, uVar1);
        uVar1 = json_integer(local_21c, local_21c >> 0x1f);
        json_object_set_new(local_38, "miner_count", uVar1);
        for (local_14 = 0; local_14 < local_21c; local_14 = local_14 + 1) {
            iVar2 = *(int *)((int)local_18 + local_14 * 0xe0 + 0x50);
            if (iVar2 <= local_28) {
                local_28 = iVar2;
            }
        }
        uVar1 = json_integer(local_28, local_28 >> 0x1f);
        json_object_set_new(local_38, "frequency", uVar1);
        uVar1 = json_integer(local_214, local_214 >> 0x1f);
        json_object_set_new(local_38, "fan_num", uVar1);
        for (local_14 = 0; local_14 < local_214; local_14 = local_14 + 1) {
            memset(local_e0, 0, 0x20);
            snprintf(local_e0, 0x20, "fan%d", local_14 + 1);
            iVar2 = *(int *)(local_210 + local_14 * 4);
            uVar1 = json_integer(iVar2, iVar2 >> 0x1f);
            json_object_set_new(local_38, local_e0, uVar1);
        }
        for (local_14 = 0; local_14 < local_21c; local_14 = local_14 + 1) {
            local_1d =
                (char)*(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0x1c) +
                (char)*(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0x20) +
                local_1d;
            iVar2 = *(int *)((int)local_18 + local_14 * 0xe0 + 0x14);
            if (local_24 < iVar2) {
                local_24 = iVar2;
            }
        }
        uVar1 = json_integer(local_1d, 0);
        json_object_set_new(local_38, "temp_num", uVar1);
        for (local_14 = 0; local_14 < local_21c; local_14 = local_14 + 1) {
            local_2c0[3] = 0;
            local_2c0[2] = 0;
            local_2c0[1] = 0;
            local_2c0[0] = 0;
            local_48 = 0xffffff01;
            find_min_and_max_int(
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 4),
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0x1c),
                local_2c0 + 3, local_2c0 + 2);
            find_min_and_max_int(
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0xc),
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0x20),
                local_2c0 + 1, local_2c0);
            local_48 = local_2c0[0];
            if (local_2c0[0] < local_2c0[2]) {
                local_48 = local_2c0[2];
            }
            sprintf(local_e0, "temp%d",
                    *(undefined4 *)((int)local_1c + local_14 * 4));
            uVar1 = json_integer(local_48, local_48 >> 0x1f);
            json_object_set_new(local_38, local_e0, uVar1);
            local_48 = 0xffffff01;
            local_2c0[0] = 0;
            local_2c0[1] = 0;
            local_2c0[2] = 0;
            local_2c0[3] = 0;
            find_min_and_max_int(
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 8),
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0x1c),
                local_2c0 + 3, local_2c0 + 2);
            find_min_and_max_int(
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0x10),
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0x20),
                local_2c0 + 1, local_2c0);
            local_48 = local_2c0[0];
            if (local_2c0[0] < local_2c0[2]) {
                local_48 = local_2c0[2];
            }
            sprintf(local_e0, "temp2_%d",
                    *(undefined4 *)((int)local_1c + local_14 * 4));
            uVar1 = json_integer(local_48, local_48 >> 0x1f);
            json_object_set_new(local_38, local_e0, uVar1);
        }
        for (local_14 = 0; local_14 < local_21c; local_14 = local_14 + 1) {
            memset(local_e0, 0, 0x20);
            memset(acStack_1e0, 0, 0x100);
            snprintf(local_e0, 0x20, "temp_in_pcb_%d",
                     *(undefined4 *)((int)local_1c + local_14 * 4));
            FUN_00022a40(
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 4),
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0x1c),
                acStack_1e0);
            uVar1 = json_string(acStack_1e0);
            json_object_set_new(local_38, local_e0, uVar1);
        }
        for (local_14 = 0; local_14 < local_21c; local_14 = local_14 + 1) {
            memset(local_e0, 0, 0x20);
            memset(acStack_1e0, 0, 0x100);
            snprintf(local_e0, 0x20, "temp_out_pcb_%d",
                     *(undefined4 *)((int)local_1c + local_14 * 4));
            FUN_00022a40(
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0xc),
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0x20),
                acStack_1e0);
            uVar1 = json_string(acStack_1e0);
            json_object_set_new(local_38, local_e0, uVar1);
        }
        for (local_14 = 0; local_14 < local_21c; local_14 = local_14 + 1) {
            memset(local_e0, 0, 0x20);
            memset(acStack_1e0, 0, 0x100);
            snprintf(local_e0, 0x20, "temp_in_chip_%d",
                     *(undefined4 *)((int)local_1c + local_14 * 4));
            FUN_00022a40(
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 8),
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0x1c),
                acStack_1e0);
            uVar1 = json_string(acStack_1e0);
            json_object_set_new(local_38, local_e0, uVar1);
        }
        for (local_14 = 0; local_14 < local_21c; local_14 = local_14 + 1) {
            memset(local_e0, 0, 0x20);
            memset(acStack_1e0, 0, 0x100);
            snprintf(local_e0, 0x20, "temp_out_chip_%d",
                     *(undefined4 *)((int)local_1c + local_14 * 4));
            FUN_00022a40(
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0xc),
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0x20),
                acStack_1e0);
            uVar1 = json_string(acStack_1e0);
            json_object_set_new(local_38, local_e0, uVar1);
        }
        uVar1 = json_integer(local_24, local_24 >> 0x1f);
        json_object_set_new(local_38, "temp_max", uVar1);
        for (local_14 = 0; local_14 < local_21c; local_14 = local_14 + 1) {
            memset(local_e0, 0, 0x20);
            snprintf(local_e0, 0x20, "chain_acn%d",
                     *(undefined4 *)((int)local_1c + local_14 * 4));
            iVar2 = *(int *)((int)local_18 + local_14 * 0xe0 + 0x48);
            uVar1 = json_integer(iVar2, iVar2 >> 0x1f);
            json_object_set_new(local_38, local_e0, uVar1);
        }
        for (local_14 = 0; local_14 < local_21c; local_14 = local_14 + 1) {
            sprintf(acStack_2cc, "chain_acs%d",
                    *(undefined4 *)((int)local_1c + local_14 * 4));
            memset(local_e0, 0, 0x20);
            memset(acStack_1e0, 0, 0x100);
            snprintf(local_e0, 0x20, "chain_acs%d",
                     *(undefined4 *)((int)local_1c + local_14 * 4));
            snprintf(acStack_1e0, 0x100, "%s",
                     *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0x4c));
            uVar1 = json_string(acStack_1e0);
            json_object_set_new(local_38, local_e0, uVar1);
        }
        for (local_14 = 0; local_14 < local_21c; local_14 = local_14 + 1) {
            memset(local_e0, 0, 0x20);
            snprintf(local_e0, 0x20, "chain_hw%d",
                     *(undefined4 *)((int)local_1c + local_14 * 4));
            uVar1 = json_integer(
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0x58),
                *(undefined4 *)((int)local_18 + local_14 * 0xe0 + 0x5c));
            json_object_set_new(local_38, local_e0, uVar1);
            uVar7 = *(undefined8 *)((int)local_18 + local_14 * 0xe0 + 0x58);
            uVar4 = (uint)uVar7;
            bVar3 = CARRY4(uVar4, local_30);
            local_30 = uVar4 + local_30;
            iStack_2c =
                (int)((ulonglong)uVar7 >> 0x20) + iStack_2c + (uint)bVar3;
        }
        uVar1 = json_integer(local_30, iStack_2c);
        json_object_set_new(local_38, "no_matching_work", uVar1);
        for (local_14 = 0; local_14 < local_21c; local_14 = local_14 + 1) {
            memset(local_e0, 0, 0x20);
            snprintf(local_e0, 0x20, "chain_rate%d",
                     *(undefined4 *)((int)local_1c + local_14 * 4));
            dStack_b0 =
                (((double)*(float *)((int)local_18 + local_14 * 0xe0 + 0x30) /
                  1000.0) /
                 1000.0) /
                1000.0;
            uVar1 = json_real(SUB84(dStack_b0, 0));
            json_object_set_new(local_38, local_e0, uVar1);
        }
        for (local_14 = 0; local_14 < local_21c; local_14 = local_14 + 1) {
            format_hashrate_string(
                SUB84(
                    (double)*(float *)((int)local_18 + local_14 * 0xe0 + 0x30),
                    0),
                *(undefined4 *)(*(int *)(local_5c + 0x48) + 0x10),
                auStack_12cc);
            snprintf(local_e0, 0x20, "CHAIN AVG HASHRATE%d",
                     *(undefined4 *)((int)local_1c + local_14 * 4));
            uVar1 = json_string(auStack_12cc);
            json_object_set_new(local_38, local_e0, uVar1);
        }
        for (local_14 = 0; local_14 < local_21c; local_14 = local_14 + 1) {
            memset(local_e0, 0, 0x20);
            snprintf(local_e0, 0x20, "freq%d",
                     *(undefined4 *)((int)local_1c + local_14 * 4));
            iVar2 = *(int *)((int)local_18 + local_14 * 0xe0 + 0x50);
            uVar1 = json_integer(iVar2, iVar2 >> 0x1f);
            json_object_set_new(local_38, local_e0, uVar1);
        }
        uVar1 = json_string(g_miner_version);
        json_object_set_new(local_38, "miner_version", uVar1);
        uVar1 = json_string(0);
        json_object_set_new(local_38, "miner_id", uVar1);
        json_array_append_new(local_34, local_38);
        json_object_set_new(local_12d4, "STATS", local_34);
        uVar1 = json_integer(1, 0);
        json_object_set_new(local_12d4, &DAT_000cd754, uVar1);
        if (0 < local_21c) {
            free(local_1c);
            free(local_18);
        }
    }
    return local_3c;
}

undefined4 FUN_00023ff8(int param_1, int param_2)

{
    undefined4 uVar1;
    undefined1 auStack_1018[4096];
    int local_18;
    undefined4 local_14;
    undefined4 local_10;
    undefined4 local_c;

    local_14 = 0;
    local_10 = 0;
    local_c = 0;
    local_18 = param_2;
    if ((param_2 == 0) || (param_1 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, "%s: input bad api param",
                   "get_version_old");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_version_old", 0xf, 0x659, 100, auStack_1018);
        local_14 = 0x80000002;
    } else {
        FUN_00020f64(param_1, 1, 0x16, *(undefined4 *)(param_2 + 8));
        local_10 = json_array();
        local_c = json_object();
        uVar1 = json_string(&DAT_000cd9f0);
        json_object_set_new(local_c, "BMMiner", uVar1);
        uVar1 = json_string(&DAT_000cdb3c);
        json_object_set_new(local_c, &DAT_000cdb40, uVar1);
        uVar1 = json_string(g_miner_version);
        json_object_set_new(local_c, "Miner", uVar1);
        uVar1 = json_string(g_miner_compiletime);
        json_object_set_new(local_c, "CompileTime", uVar1);
        uVar1 = json_string(g_miner_type);
        json_object_set_new(local_c, &DAT_000cda08, uVar1);
        json_array_append_new(local_10, local_c);
        json_object_set_new(param_1, "VERSION", local_10);
        uVar1 = json_integer(1, 0);
        json_object_set_new(param_1, &DAT_000cd754, uVar1);
    }
    return local_14;
}

undefined4 FUN_00024244(int param_1, int param_2)

{
    undefined4 uVar1;
    undefined1 auStack_102c[4096];
    undefined1 auStack_2c[8];
    int local_24;
    undefined1 *local_20;
    int local_1c;
    undefined4 local_18;
    undefined4 local_14;
    int local_10;
    undefined4 local_c;

    local_c = 0;
    local_14 = 0;
    local_18 = 0;
    local_20 = reject_reason_map;
    local_10 = 0;
    local_1c = param_2;
    map_iter_(auStack_2c);
    if ((local_1c == 0) || (param_1 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_102c, 0x1000, 0, "%s: input bad api param",
                   "get_reject_summary_old");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_reject_summary_old", 0x16, 0x679, 100, auStack_102c);
        local_c = 0x80000002;
    } else {
        FUN_00020f64(param_1, 1, 0x47, *(undefined4 *)(local_1c + 8));
        local_14 = json_array();
        local_18 = json_object();
        while (true) {
            local_24 = map_next_(local_20, auStack_2c);
            if (local_24 == 0)
                break;
            local_10 = local_10 + 1;
            uVar1 = map_get_(local_20, local_24);
            *(undefined4 *)(local_20 + 0xc) = uVar1;
            uVar1 = json_integer(**(int **)(local_20 + 0xc),
                                 **(int **)(local_20 + 0xc) >> 0x1f);
            json_object_set_new(local_18, local_24, uVar1);
        }
        uVar1 = json_integer(local_10, local_10 >> 0x1f);
        json_object_set_new(local_18, "total_reason", uVar1);
        json_array_append_new(local_14, local_18);
        json_object_set_new(param_1, "REJECT_REASON", local_14);
        uVar1 = json_integer(1, 0);
        json_object_set_new(param_1, &DAT_000cd754, uVar1);
    }
    return local_c;
}

undefined4 FUN_000244b0(int param_1, int param_2)

{
    undefined4 uVar1;
    undefined1 auStack_103c[4096];
    undefined1 auStack_3c[7];
    char local_35;
    undefined1 local_34;
    int local_1c;
    undefined4 local_18;
    undefined4 local_14;
    int local_10;
    undefined4 local_c;

    local_c = 0;
    local_14 = 0;
    local_18 = 0;
    local_1c = param_2;
    if ((param_2 == 0) || (param_1 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_103c, 0x1000, 0, "%s: input bad api param",
                   "get_timeout_summary_old");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_timeout_summary_old", 0x17, 0x696, 100, auStack_103c);
        local_c = 0x80000002;
    } else {
        FUN_00020f64(param_1, 1, 0x48, *(undefined4 *)(param_2 + 8));
        local_14 = json_array();
        local_18 = json_object();
        memcpy(auStack_3c, "timeout", 7);
        local_34 = 0;
        for (local_10 = 0; local_10 < 10; local_10 = local_10 + 1) {
            local_35 = (char)local_10 + '0';
            uVar1 = json_integer(
                *(undefined4 *)(max_timeout_value + local_10 * 8),
                *(undefined4 *)(max_timeout_value + local_10 * 8 + 4));
            json_object_set_new(local_18, auStack_3c, uVar1);
        }
        json_array_append_new(local_14, local_18);
        json_object_set_new(param_1, "TIMEOUT_REASON", local_14);
        uVar1 = json_integer(1, 0);
        json_object_set_new(param_1, &DAT_000cd754, uVar1);
    }
    return local_c;
}

undefined4 FUN_000246d8(int param_1, int param_2)

{
    int *piVar1;
    undefined4 uVar2;
    int iVar3;
    undefined4 uVar4;
    undefined4 *puVar5;
    undefined4 uVar6;
    undefined4 uVar7;
    undefined1 auStack_2060[4096];
    char acStack_1060[32];
    char acStack_1040[4096];
    int local_40;
    int local_3c;
    int local_38;
    int local_34;
    int local_30;
    undefined4 local_2c;
    undefined4 local_28;
    undefined4 local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;

    local_24 = 0;
    local_28 = 0;
    local_2c = 0;
    local_40 = 0;
    local_30 = param_2;
    local_34 = get_all_created_runtime(&local_40);
    local_20 = 0;
    if ((local_30 == 0) || (param_1 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_2060, 0x1000, 0, "%s: input bad api param",
                   "get_noncenum_old");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_noncenum_old", 0x10, 0x6b8, 100, auStack_2060);
        local_24 = 0x80000002;
    } else {
        FUN_00020f64(param_1, 1, 0x49, *(undefined4 *)(local_30 + 8));
        local_28 = json_array();
        local_2c = json_object();
        piVar1 = (int *)get_current_pool();
        uVar2 = json_integer(*piVar1, *piVar1 >> 0x1f);
        json_object_set_new(local_2c, "current_pool", uVar2);
        local_1c = 0;
        while (true) {
            if (local_40 <= local_1c)
                break;
            iVar3 = *(int *)(local_34 + local_1c * 4);
            uVar2 = *(undefined4 *)(iVar3 + 0x1b8);
            uVar4 = *(undefined4 *)(iVar3 + 0x1bc);
            iVar3 = *(int *)(local_34 + local_1c * 4);
            uVar6 = *(undefined4 *)(iVar3 + 0x1c0);
            uVar7 = *(undefined4 *)(iVar3 + 0x1c4);
            local_20 = snprintf(
                acStack_1040, 0x1000, "device %d wc %llu nc %llu detail:",
                *(undefined4 *)(*(int *)(local_34 + local_1c * 4) + 0xf8),
                uVar2, uVar4, uVar6, uVar7);
            local_38 = *(int *)(*(int *)(local_34 + local_1c * 4) + 0x150);
            local_18 = 0;
            while (true) {
                if (local_38 <= local_18)
                    break;
                local_3c = *(int *)(*(int *)(local_34 + local_1c * 4) + 0x1c8) +
                           local_18 * 0x30;
                iVar3 =
                    snprintf(acStack_1040 + local_20, 0x1000 - local_20,
                             "%d:", local_18 + 1, uVar2, uVar4, uVar6, uVar7);
                local_20 = local_20 + iVar3;
                for (local_14 = 0; local_14 < 6; local_14 = local_14 + 1) {
                    puVar5 = (undefined4 *)(local_3c + local_14 * 8);
                    uVar2 = *puVar5;
                    uVar4 = puVar5[1];
                    iVar3 =
                        snprintf(acStack_1040 + local_20, 0x1000 - local_20,
                                 " %llu", uVar4, uVar2, uVar4, uVar6, uVar7);
                    local_20 = local_20 + iVar3;
                }
                iVar3 =
                    snprintf(acStack_1040 + local_20, 0x1000U - local_20, " /",
                             0x1000U - local_20, uVar2, uVar4, uVar6, uVar7);
                local_20 = local_20 + iVar3;
                local_18 = local_18 + 1;
            }
            iVar3 = dev_ctrl();
            uVar2 = (**(code **)(iVar3 + 0x30))(
                *(undefined4 *)(*(int *)(local_34 + local_1c * 4) + 0xf8));
            sprintf(acStack_1060, "chain%d", uVar2);
            uVar2 = json_string(acStack_1040);
            json_object_set_new(local_2c, acStack_1060, uVar2);
            local_1c = local_1c + 1;
        }
        json_array_append_new(local_28, local_2c);
        json_object_set_new(param_1, "NONCENUM_REASON", local_28);
        uVar2 = json_integer(1, 0);
        json_object_set_new(param_1, &DAT_000cd754, uVar2);
    }
    return local_24;
}

undefined4 FUN_00024b50(int param_1, int param_2, char *param_3)

{
    long lVar1;
    undefined4 uVar2;
    undefined1 auStack_1064[4128];
    ulong local_44[2];
    undefined1 local_3c;
    char local_3b;
    undefined2 local_3a;
    int local_34;
    char *local_30;
    char local_29;
    ulong local_28;
    undefined2 local_24;
    char local_22;
    byte local_21;
    int local_20;
    undefined4 local_1c;
    int local_18;
    char *local_14;

    local_1c = 0;
    local_34 = 0;
    local_18 = param_2;
    local_14 = param_3;
    local_20 = get_all_created_runtime(&local_34);
    if (local_34 < 1) {
        FUN_00020f64(param_1, 0, 10, "No ASCs");
        uVar2 = 0x80000001;
    } else if ((local_18 == 0) || (param_1 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_1064, 0x1000, 0, "%s: input bad api param",
                   "set_chipreg_old");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "set_chipreg_old", 0xf, 0x6f6, 100, auStack_1064);
        uVar2 = 0x80000002;
    } else {
        FUN_00020f64(param_1, 1, 0x4e, *(undefined4 *)(local_18 + 8));
        if ((local_14 == (char *)0x0) || (*local_14 == '\0')) {
            uVar2 = 0x80000002;
        } else {
            local_30 = local_14;
            lVar1 = strtol(local_14, &local_30, 10);
            local_21 = (byte)lVar1;
            local_30 = local_30 + 1;
            lVar1 = strtol(local_30, &local_30, 10);
            local_22 = (char)lVar1;
            local_30 = local_30 + 1;
            lVar1 = strtol(local_30, &local_30, 0x10);
            local_24 = (undefined2)lVar1;
            local_30 = local_30 + 1;
            local_28 = strtoul(local_30, &local_30, 0x10);
            local_29 =
                local_22 *
                (char)*(undefined4 *)(*(int *)(local_20 + (uint)local_21 * 4) +
                                      0x164);
            V_LOCK();
            logfmt_raw(
                auStack_1064, 0x1000, 0,
                "%s: set chain_offset %d chain %d chip %d chipaddr %x reg %x "
                "to %08x",
                "set_chipreg_old", local_21,
                *(undefined4 *)(*(int *)(local_20 + (uint)local_21 * 4) + 0xfc),
                local_22, local_29, local_24, local_28);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/api_new.c",
                 0x93, "set_chipreg_old", 0xf, 0x705, 0x28, auStack_1064);
            memset(local_44, 0, 0x10);
            local_3c = 0;
            local_3b = local_29;
            local_3a = local_24;
            local_44[0] = local_28;
            uVar2 =
                (**(code **)(*(int *)(local_20 + (uint)local_21 * 4) + 0x10c))(
                    *(undefined4 *)(local_20 + (uint)local_21 * 4), local_44);
        }
    }
    return uVar2;
}

undefined4 FUN_00024ef4(int param_1, int param_2, char *param_3)

{
    long lVar1;
    int iVar2;
    undefined1 auStack_1060[4144];
    int local_30;
    char *local_2c;
    undefined8 local_28;
    byte local_19;
    int local_18;
    undefined4 local_14;
    int local_10;
    char *local_c;

    local_14 = 0;
    local_30 = 0;
    local_10 = param_2;
    local_c = param_3;
    local_18 = get_all_created_runtime(&local_30);
    if (local_30 < 1) {
        FUN_00020f64(param_1, 0, 10, "No ASCs");
        local_14 = 0x80000001;
    } else if ((local_10 == 0) || (param_1 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_1060, 0x1000, 0, "%s: input bad api param",
                   "set_uart_print_time");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "set_uart_print_time", 0x13, 0x727, 100, auStack_1060);
        local_14 = 0x80000002;
    } else {
        FUN_00020f64(param_1, 1, 0x50, *(undefined4 *)(local_10 + 8));
        if ((local_c == (char *)0x0) || (*local_c == '\0')) {
            local_14 = 0x80000002;
        } else {
            local_2c = local_c;
            lVar1 = strtol(local_c, &local_2c, 10);
            local_19 = (byte)lVar1;
            local_2c = local_2c + 1;
            local_28 = strtoll(local_2c, &local_2c, 10);
            V_LOCK();
            logfmt_raw(auStack_1060, 0x1000, 0,
                       "%s: set chain_offset %d uart print time %lld ms",
                       "set_uart_print_time", local_19, (undefined4)local_28,
                       local_28._4_4_);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/api_new.c",
                 0x93, "set_uart_print_time", 0x13, 0x732, 0x28, auStack_1060);
            iVar2 = *(int *)(local_18 + (uint)local_19 * 4) + 0x478;
            set_remain_debug_print_time(iVar2, iVar2, (undefined4)local_28,
                                        local_28._4_4_);
            iVar2 = *(int *)(local_18 + (uint)local_19 * 4) + 0x4c0;
            set_remain_debug_print_time(iVar2, iVar2, (undefined4)local_28,
                                        local_28._4_4_);
        }
    }
    return local_14;
}

undefined4 FUN_000251c4(int param_1, int param_2, char *param_3)

{
    long lVar1;
    int iVar2;
    undefined1 auStack_1060[4144];
    int local_30;
    char *local_2c;
    undefined8 local_28;
    byte local_19;
    int local_18;
    undefined4 local_14;
    int local_10;
    char *local_c;

    local_14 = 0;
    local_30 = 0;
    local_10 = param_2;
    local_c = param_3;
    local_18 = get_all_created_runtime(&local_30);
    if (local_30 < 1) {
        FUN_00020f64(param_1, 0, 10, "No ASCs");
        local_14 = 0x80000001;
    } else if ((local_10 == 0) || (param_1 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_1060, 0x1000, 0, "%s: input bad api param",
                   "set_uart_print_lines");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "set_uart_print_lines", 0x14, 0x752, 100, auStack_1060);
        local_14 = 0x80000002;
    } else {
        FUN_00020f64(param_1, 1, 0x51, *(undefined4 *)(local_10 + 8));
        if ((local_c == (char *)0x0) || (*local_c == '\0')) {
            local_14 = 0x80000002;
        } else {
            local_2c = local_c;
            lVar1 = strtol(local_c, &local_2c, 10);
            local_19 = (byte)lVar1;
            local_2c = local_2c + 1;
            local_28 = strtoll(local_2c, &local_2c, 10);
            V_LOCK();
            logfmt_raw(auStack_1060, 0x1000, 0,
                       "%s: set chain_offset %d uart print lines %lld",
                       "set_uart_print_lines", local_19, (undefined4)local_28,
                       local_28._4_4_);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/api_new.c",
                 0x93, "set_uart_print_lines", 0x14, 0x75d, 0x28, auStack_1060);
            iVar2 = *(int *)(local_18 + (uint)local_19 * 4) + 0x478;
            set_remain_debug_print_lines(iVar2, iVar2, (undefined4)local_28,
                                         local_28._4_4_);
            iVar2 = *(int *)(local_18 + (uint)local_19 * 4) + 0x4c0;
            set_remain_debug_print_lines(iVar2, iVar2, (undefined4)local_28,
                                         local_28._4_4_);
        }
    }
    return local_14;
}

undefined4 FUN_00025494(int param_1, int param_2, char *param_3)

{
    byte bVar1;
    ushort uVar2;
    size_t __maxlen;
    long lVar3;
    ulong uVar4;
    undefined4 uVar5;
    int iVar6;
    undefined1 auStack_1088[4096];
    char acStack_88[32];
    undefined4 local_68;
    undefined1 auStack_64[8];
    undefined1 local_5c;
    ushort local_5a;
    int local_54;
    char *local_50;
    char local_4a;
    byte local_49;
    int local_48;
    char *local_44;
    void *local_40;
    size_t local_3c;
    int local_38;
    byte local_32;
    byte local_31;
    int local_30;
    int local_2c;
    undefined4 local_28;
    undefined4 local_24;
    int local_20;
    char *local_1c;

    local_28 = 0;
    local_24 = 0;
    local_20 = param_2;
    local_1c = param_3;
    local_30 = get_all_created_runtime(&local_54);
    if (local_54 < 1) {
        FUN_00020f64(param_1, 0, 10, "No ASCs");
        local_28 = 0x80000001;
    } else if ((local_20 == 0) || (param_1 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_1088, 0x1000, 0, "%s: input bad api param",
                   "get_target_chipreg_old");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_target_chipreg_old", 0x16, 0x780, 100, auStack_1088);
        local_28 = 0x80000002;
    } else {
        FUN_00020f64(param_1, 1, 0x4a, *(undefined4 *)(local_20 + 8));
        if ((local_1c == (char *)0x0) || (*local_1c == '\0')) {
            local_28 = 0x80000002;
        } else {
            local_50 = local_1c;
            lVar3 = strtol(local_1c, &local_50, 10);
            local_31 = (byte)lVar3;
            local_50 = local_50 + 1;
            uVar4 = strtoul(local_50, &local_50, 0x10);
            local_32 = (byte)uVar4;
            memset(auStack_64, 0, 0x10);
            local_5a = (ushort)local_32;
            local_5c = 1;
            local_24 = json_array();
            local_38 =
                *(int *)(*(int *)(local_30 + (uint)local_31 * 4) + 0x150);
            local_3c = 0x40;
            local_40 = malloc(local_38 * 0xc);
            local_44 = (char *)malloc(local_3c);
            (**(code **)(*(int *)(local_30 + (uint)local_31 * 4) + 0x120))(
                *(undefined4 *)(local_30 + (uint)local_31 * 4), auStack_64,
                local_38, local_40, &local_68);
            local_48 = snprintf(
                local_44, local_3c, "chain %d detect %d chips",
                *(undefined4 *)(*(int *)(local_30 + (uint)local_31 * 4) + 0xfc),
                local_68);
            uVar5 = json_string(local_44);
            json_array_append_new(local_24, uVar5);
            local_50 = local_50 + 1;
            for (local_2c = strtol(local_50, &local_50, 10); local_2c != 0;
                 local_2c = local_2c + -1) {
                local_50 = local_50 + 1;
                lVar3 = strtol(local_50, &local_50, 10);
                local_49 = (byte)lVar3;
                local_4a = local_49 *
                           (char)*(undefined4 *)(*(int *)(local_30 +
                                                          (uint)local_31 * 4) +
                                                 0x164);
                V_LOCK();
                logfmt_raw(
                    auStack_1088, 0x1000, 0,
                    "%s: set chain_id %d chain %d chip_id %d chip_addr %x "
                    "reg_addr %x",
                    "get_target_chipreg_old", local_31,
                    *(undefined4 *)(*(int *)(local_30 + (uint)local_31 * 4) +
                                    0xfc),
                    local_49, local_4a, local_32);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/api_new.c",
                     0x93, "get_target_chipreg_old", 0x16, 0x79f, 0x28,
                     auStack_1088);
                __maxlen = local_3c;
                bVar1 = *(byte *)((int)local_40 + (uint)local_49 * 0xc + 4);
                uVar2 = *(ushort *)((int)local_40 + (uint)local_49 * 0xc + 6);
                uVar5 = FUN_0001d934(
                    *(undefined4 *)((int)local_40 + (uint)local_49 * 0xc));
                local_48 =
                    snprintf(local_44, __maxlen, "chip %02x reg %02x data %08x",
                             (uint)bVar1, (uint)uVar2, uVar5);
                uVar5 = json_string(local_44);
                json_array_append_new(local_24, uVar5);
            }
            iVar6 = dev_ctrl();
            uVar5 = (**(code **)(iVar6 + 0x30))(*(
                undefined4 *)(*(int *)(local_30 + (uint)local_31 * 4) + 0xf8));
            sprintf(acStack_88, "chain%d", uVar5);
            json_object_set_new(param_1, acStack_88, local_24);
            free(local_44);
            free(local_40);
        }
    }
    return local_28;
}

undefined4 FUN_00025a08(int param_1, int param_2, char *param_3)

{
    byte bVar1;
    ushort uVar2;
    char cVar3;
    size_t sVar4;
    undefined4 uVar5;
    int iVar6;
    undefined1 auStack_1084[4099];
    byte local_81;
    char acStack_80[32];
    int local_60;
    undefined1 auStack_5c[8];
    undefined1 local_54;
    ushort local_52;
    int local_4c;
    char *local_48;
    void *local_44;
    size_t local_40;
    int local_3c;
    int local_38;
    char *local_34;
    int local_30;
    int local_2c;
    undefined4 local_28;
    undefined4 local_24;
    int local_20;
    int local_1c;

    local_24 = 0;
    local_28 = 0;
    local_2c = 0;
    local_4c = 0;
    local_34 = param_3;
    local_30 = param_2;
    local_38 = get_all_created_runtime(&local_4c);
    if (local_4c < 1) {
        FUN_00020f64(param_1, 0, 10, "No ASCs");
        local_24 = 0x80000001;
    } else if ((local_30 == 0) || (param_1 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_1084, 0x1000, 0, "%s: input bad api param",
                   "get_chipreg_old");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_chipreg_old", 0xf, 0x7c3, 100, auStack_1084);
        local_24 = 0x80000002;
    } else {
        FUN_00020f64(param_1, 1, 0x4b, *(undefined4 *)(local_30 + 8));
        if ((((local_34 == (char *)0x0) || (*local_34 == '\0')) ||
             (sVar4 = strlen(local_34), sVar4 != 2)) ||
            (cVar3 = hex2bin(&local_81, local_34, 1), cVar3 != '\x01')) {
            local_24 = 0x80000002;
        } else {
            memset(auStack_5c, 0, 0x10);
            local_54 = 1;
            local_52 = (ushort)local_81;
            for (local_20 = 0; local_20 < local_4c; local_20 = local_20 + 1) {
                local_28 = json_array();
                local_3c = *(int *)(*(int *)(local_38 + local_20 * 4) + 0x150);
                local_40 = 0x40;
                local_44 = malloc(local_3c * 0xc);
                local_48 = (char *)malloc(local_40);
                (**(code **)(*(int *)(local_38 + local_20 * 4) + 0x120))(
                    *(undefined4 *)(local_38 + local_20 * 4), auStack_5c,
                    local_3c, local_44, &local_60);
                local_2c = snprintf(
                    local_48, local_40,
                    "=========================================chain %d detect "
                    "%d chips",
                    *(undefined4 *)(*(int *)(local_38 + local_20 * 4) + 0xfc),
                    local_60);
                uVar5 = json_string(local_48);
                json_array_append_new(local_28, uVar5);
                for (local_1c = 0; sVar4 = local_40, local_1c < local_60;
                     local_1c = local_1c + 1) {
                    bVar1 = *(byte *)((int)local_44 + local_1c * 0xc + 4);
                    uVar2 = *(ushort *)((int)local_44 + local_1c * 0xc + 6);
                    uVar5 = FUN_0001d934(
                        *(undefined4 *)((int)local_44 + local_1c * 0xc));
                    local_2c = snprintf(local_48, sVar4,
                                        "chip %02x reg %02x data %08x",
                                        (uint)bVar1, (uint)uVar2, uVar5);
                    uVar5 = json_string(local_48);
                    json_array_append_new(local_28, uVar5);
                }
                iVar6 = dev_ctrl();
                uVar5 = (**(code **)(iVar6 + 0x30))(
                    *(undefined4 *)(*(int *)(local_38 + local_20 * 4) + 0xf8));
                sprintf(acStack_80, "chain%d", uVar5);
                json_object_set_new(param_1, acStack_80, local_28);
                free(local_48);
                free(local_44);
            }
        }
    }
    return local_24;
}

undefined4 FUN_00025e80(int param_1, int param_2, char *param_3)

{
    byte bVar1;
    size_t __maxlen;
    long lVar2;
    ulong uVar3;
    int iVar4;
    undefined4 uVar5;
    undefined1 auStack_1080[4100];
    char acStack_7c[32];
    int local_5c;
    undefined1 auStack_58[8];
    undefined1 local_50;
    char local_4f;
    undefined2 local_4e;
    undefined1 local_4c;
    int local_48;
    char *local_44;
    char *local_40;
    void *local_3c;
    size_t local_38;
    int local_34;
    char local_2e;
    byte local_2d;
    int local_2c;
    char *local_28;
    int local_24;
    int local_20;
    undefined4 local_1c;
    undefined4 local_18;
    int local_14;

    local_1c = 0;
    local_18 = 0;
    local_14 = 0;
    local_48 = 0;
    local_28 = param_3;
    local_24 = param_2;
    local_2c = get_all_created_runtime(&local_48);
    if (local_48 < 1) {
        FUN_00020f64(param_1, 0, 10, "No ASCs");
        local_1c = 0x80000001;
    } else if ((local_24 == 0) || (param_1 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_1080, 0x1000, 0, "%s: input bad api param",
                   "get_target_corereg_old");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_target_corereg_old", 0x16, 0x805, 100, auStack_1080);
        local_1c = 0x80000002;
    } else {
        FUN_00020f64(param_1, 1, 0x4c, *(undefined4 *)(local_24 + 8));
        if ((local_28 == (char *)0x0) || (*local_28 == '\0')) {
            local_1c = 0x80000002;
        } else {
            local_44 = local_28;
            lVar2 = strtol(local_28, &local_44, 10);
            local_2d = (byte)lVar2;
            local_44 = local_44 + 1;
            lVar2 = strtol(local_44, &local_44, 10);
            local_2e = (char)lVar2;
            memset(auStack_58, 0, 0x10);
            local_4f =
                local_2e *
                (char)*(undefined4 *)(*(int *)(local_2c + (uint)local_2d * 4) +
                                      0x164);
            local_50 = 0;
            local_44 = local_44 + 1;
            uVar3 = strtoul(local_44, &local_44, 0x10);
            local_4e = (undefined2)uVar3;
            local_4c = 0xff;
            local_18 = json_array();
            local_34 =
                *(int *)(*(int *)(local_2c + (uint)local_2d * 4) + 0x154) *
                *(int *)(*(int *)(local_2c + (uint)local_2d * 4) + 0x150);
            local_38 = 0x40;
            local_3c = malloc(local_34 * 0xc);
            local_40 = (char *)malloc(local_38);
            V_LOCK();
            logfmt_raw(auStack_1080, 0x1000, 0,
                       "chip_offset: %d, chip_id: %d, chip_addr: %x, reg_addr: "
                       "%x, core_no: %d",
                       local_2d, local_2e, local_4f, local_4e, local_34);
            V_UNLOCK();
            uVar5 = 0x81d;
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/api_new.c",
                 0x93, "get_target_corereg_old", 0x16, 0x81d, 0x28,
                 auStack_1080);
            (**(code **)(*(int *)(local_2c + (uint)local_2d * 4) + 300))(
                *(undefined4 *)(local_2c + (uint)local_2d * 4), auStack_58,
                local_34, local_3c, &local_5c, uVar5, 2000, 0);
            local_14 = snprintf(
                local_40, local_38,
                "=========================================chain %d detect %d "
                "cores",
                *(undefined4 *)(*(int *)(local_2c + (uint)local_2d * 4) + 0xfc),
                local_5c);
            uVar5 = json_string(local_40);
            json_array_append_new(local_18, uVar5);
            local_20 = 0;
            while (true) {
                __maxlen = local_38;
                if (local_5c <= local_20)
                    break;
                bVar1 = *(byte *)((int)local_3c + local_20 * 0xc + 8);
                uVar5 = FUN_0001d934(
                    *(undefined4 *)((int)local_3c + local_20 * 0xc));
                local_14 = snprintf(local_40, __maxlen, "core %02x data %08x",
                                    (uint)bVar1, uVar5);
                uVar5 = json_string(local_40);
                json_array_append_new(local_18, uVar5);
                local_20 = local_20 + 1;
            }
            iVar4 = dev_ctrl();
            uVar5 = (**(code **)(iVar4 + 0x30))(*(
                undefined4 *)(*(int *)(local_2c + (uint)local_2d * 4) + 0xf8));
            sprintf(acStack_7c, "chain%d", uVar5);
            json_object_set_new(param_1, acStack_7c, local_18);
            free(local_40);
            free(local_3c);
        }
    }
    return local_1c;
}

undefined4 FUN_000263d4(int param_1, int param_2, char *param_3)

{
    byte bVar1;
    byte bVar2;
    ushort uVar3;
    size_t __maxlen;
    char cVar4;
    undefined4 uVar5;
    int iVar6;
    undefined1 auStack_1088[4096];
    byte local_88;
    undefined1 local_87;
    char acStack_84[32];
    int local_64;
    undefined1 auStack_60[8];
    undefined1 local_58;
    undefined1 local_57;
    ushort local_56;
    undefined1 local_54;
    int local_50;
    char *local_4c;
    void *local_48;
    size_t local_44;
    int local_40;
    size_t local_3c;
    int local_38;
    char *local_34;
    int local_30;
    int local_2c;
    undefined4 local_28;
    undefined4 local_24;
    int local_20;
    int local_1c;

    local_24 = 0;
    local_28 = 0;
    local_2c = 0;
    local_50 = 0;
    local_34 = param_3;
    local_30 = param_2;
    local_38 = get_all_created_runtime(&local_50);
    if (local_50 < 1) {
        FUN_00020f64(param_1, 0, 10, "No ASCs");
        local_24 = 0x80000001;
    } else if ((local_30 == 0) || (param_1 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_1088, 0x1000, 0, "%s: input bad api param",
                   "get_corereg_old");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "get_corereg_old", 0xf, 0x846, 100, auStack_1088);
        local_24 = 0x80000002;
    } else {
        FUN_00020f64(param_1, 1, 0x4d, *(undefined4 *)(local_30 + 8));
        local_3c = strlen(local_34);
        if ((((local_34 == (char *)0x0) || (*local_34 == '\0')) ||
             ((local_3c != 2 && (local_3c != 4)))) ||
            (cVar4 = hex2bin(&local_88, local_34, (int)local_3c / 2),
             cVar4 != '\x01')) {
            local_24 = 0x80000002;
        } else {
            memset(auStack_60, 0, 0x10);
            local_57 = 0;
            local_58 = 1;
            local_56 = (ushort)local_88;
            local_54 = 0xff;
            if (local_3c == 4) {
                local_56 = CONCAT11(local_88, local_87);
            }
            for (local_20 = 0; local_20 < local_50; local_20 = local_20 + 1) {
                local_28 = json_array();
                local_40 = *(int *)(*(int *)(local_38 + local_20 * 4) + 0x154) *
                           *(int *)(*(int *)(local_38 + local_20 * 4) + 0x150);
                local_44 = 0x40;
                local_48 = malloc(local_40 * 0xc);
                local_4c = (char *)malloc(local_44);
                (**(code **)(*(int *)(local_38 + local_20 * 4) + 300))(
                    *(undefined4 *)(local_38 + local_20 * 4), auStack_60,
                    local_40, local_48, &local_64);
                local_2c = snprintf(
                    local_4c, local_44,
                    "=========================================chain %d detect "
                    "%d cores",
                    *(undefined4 *)(*(int *)(local_38 + local_20 * 4) + 0xfc),
                    local_64);
                uVar5 = json_string(local_4c);
                json_array_append_new(local_28, uVar5);
                for (local_1c = 0; __maxlen = local_44, local_1c < local_64;
                     local_1c = local_1c + 1) {
                    bVar1 = *(byte *)((int)local_48 + local_1c * 0xc + 4);
                    bVar2 = *(byte *)((int)local_48 + local_1c * 0xc + 8);
                    uVar3 = *(ushort *)((int)local_48 + local_1c * 0xc + 6);
                    uVar5 = FUN_0001d934(
                        *(undefined4 *)((int)local_48 + local_1c * 0xc));
                    local_2c =
                        snprintf(local_4c, __maxlen,
                                 "chip %02x core %02x reg %04x data %08x",
                                 (uint)bVar1, (uint)bVar2, (uint)uVar3, uVar5);
                    uVar5 = json_string(local_4c);
                    json_array_append_new(local_28, uVar5);
                }
                iVar6 = dev_ctrl();
                uVar5 = (**(code **)(iVar6 + 0x30))(
                    *(undefined4 *)(*(int *)(local_38 + local_20 * 4) + 0xf8));
                sprintf(acStack_84, "chain%d", uVar5);
                json_object_set_new(param_1, acStack_84, local_28);
                free(local_4c);
                free(local_48);
            }
        }
    }
    return local_24;
}

undefined4 FUN_000268ec(int param_1, int param_2, char *param_3)

{
    int iVar1;
    undefined4 uVar2;
    undefined1 auStack_101c[4096];
    int local_1c;
    undefined4 local_18;
    undefined4 local_14;
    undefined4 local_10;
    int local_c;

    local_18 = 0;
    local_14 = 0;
    local_10 = 0;
    local_c = param_2;
    if ((param_2 == 0) || (param_1 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_101c, 0x1000, 0, "%s: input bad api param",
                   "reset_fpga_baud_old");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "reset_fpga_baud_old", 0x13, 0x87b, 100, auStack_101c);
        local_18 = 0x80000002;
    } else {
        FUN_00020f64(param_1, 1, 0x4f, *(undefined4 *)(param_2 + 8));
        local_14 = json_array();
        local_1c = atoi(param_3);
        V_LOCK();
        logfmt_raw(auStack_101c, 0x1000, 0, "parameter = \"%s\", config = %d.",
                   param_3, local_1c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "reset_fpga_baud_old", 0x13, 0x882, 100, auStack_101c);
        iVar1 = dev_ctrl();
        (**(code **)(iVar1 + 0x10))(local_1c);
        json_object_set_new(param_1, "FPGA_BAUD", local_14);
        uVar2 = json_integer(1, 0);
        json_object_set_new(param_1, &DAT_000cd754, uVar2);
    }
    return local_18;
}

void print_summary(void)

{
    undefined4 uVar1;
    uint *puVar2;
    int iVar3;
    undefined4 uVar4;
    undefined8 *puVar5;
    undefined4 uVar6;
    undefined4 uVar7;
    undefined4 uVar8;
    undefined4 extraout_s1;
    ulonglong uVar9;
    undefined8 uVar10;
    undefined8 uVar11;
    double dVar12;
    double dVar13;
    undefined4 uVar14;
    undefined1 auStack_20ac[4096];
    char acStack_10ac[4096];
    int local_ac;
    undefined1 auStack_a8[24];
    float fStack_90;
    int local_6c;
    int local_68;
    int local_64;
    int local_60;
    int local_5c;
    int local_58;
    int local_54;
    double local_50;
    double dStack_48;
    int local_40;
    int local_3c;
    undefined8 local_38;
    int local_2c;
    undefined8 local_28;
    int local_20;
    int local_1c;

    read_system_status_from_monitor(auStack_a8);
    local_50 = ((double)fStack_90 / 1000.0) / 1000.0;
    uVar8 = get_miner_elapsed_time();
    dStack_48 = (double)CONCAT44(extraout_s1, uVar8);
    local_40 = (int)(longlong)dStack_48 / 0xe10;
    local_3c = ((int)(longlong)dStack_48 % 0xe10) / 0x3c;
    local_2c = (int)(longlong)dStack_48 % 0x3c;
    dVar13 = (double)FUN_000ccae4((uint)total_accepted, total_accepted._4_4_);
    local_38 = (dVar13 / dStack_48) * 60.0;
    local_28 = (((double)CONCAT44(total_diff_accepted._4_4_,
                                  (undefined4)total_diff_accepted) +
                 (double)CONCAT44(total_diff_rejected._4_4_,
                                  (undefined4)total_diff_rejected) +
                 total_diff_stale) /
                dStack_48) *
               60.0;
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0, "Summary of runtime statistics:");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x89e, 0x50, auStack_20ac);
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0, "Runtime: %d hrs : %d mins : %d secs",
               local_40, local_3c, local_2c);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x89f, 0x50, auStack_20ac);
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0, "Average hashrate: %.1f Mhash/s",
               SUB84(local_50, 0));
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8a0, 0x50, auStack_20ac);
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0, "Total got job from pools: %lld");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8a1, 0x50, auStack_20ac);
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0, "Total generated local work  %d");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8a2, 0x50, auStack_20ac);
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0, "Solved blocks: %d", DAT_001512a0);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8a3, 0x50, auStack_20ac);
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0, "Share submissions: %lld",
               (uint)total_rejected + (uint)total_accepted,
               total_rejected._4_4_ + total_accepted._4_4_ +
                   (uint)CARRY4((uint)total_rejected, (uint)total_accepted));
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8a4, 0x50, auStack_20ac);
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0, "Accepted shares: %lld",
               (uint)total_accepted, total_accepted._4_4_);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8a5, 0x50, auStack_20ac);
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0, "Rejected shares: %lld");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8a6, 0x50, auStack_20ac);
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0, "Accepted difficulty shares: %1.f");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8a7, 0x50, auStack_20ac);
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0, "Rejected difficulty shares: %1.f");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8a8, 0x50, auStack_20ac);
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0, "Total Hardware errors %llu");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8a9, 0x50, auStack_20ac);
    if ((uint)total_accepted == 0 && total_accepted._4_4_ == 0) {
        if ((uint)total_rejected == 0 && total_rejected._4_4_ == 0)
            goto LAB_000273f8;
    }
    V_LOCK();
    uVar9 = VectorAdd(CONCAT44(total_rejected._4_4_, (uint)total_rejected),
                      CONCAT44(total_rejected._4_4_, (uint)total_rejected), 8);
    uVar10 = VectorAdd((uVar9 & 0xffffffff00000000) + (uVar9 & 0xffffffff),
                       CONCAT44(total_rejected._4_4_, (uint)total_rejected), 8);
    uVar11 = VectorShiftLeft(uVar10, 5, 0x40, 0);
    uVar10 = VectorAdd(uVar10, uVar11, 8);
    dVar13 = (double)FUN_000ccae4(
        (uint)uVar10 + (uint)total_rejected,
        (int)((ulonglong)uVar10 >> 0x20) + total_rejected._4_4_ +
            (uint)CARRY4((uint)uVar10, (uint)total_rejected));
    dVar12 = (double)FUN_000ccae4(
        (uint)total_rejected + (uint)total_accepted,
        total_rejected._4_4_ + total_accepted._4_4_ +
            (uint)CARRY4((uint)total_rejected, (uint)total_accepted));
    logfmt_raw(auStack_20ac, 0x1000, 0, "Reject ratio: %.1f%%",
               dVar13 / dVar12);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8ac, 0x50, auStack_20ac);
LAB_000273f8:
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0,
               "Utility (accepted shares / min): %.2f/min", SUB84(local_38, 0),
               local_38._4_4_);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8ae, 0x50, auStack_20ac);
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0,
               "Work Utility (diff1 shares solved / min): %.2f/min",
               SUB84(local_28, 0), local_28._4_4_);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8af, 0x50, auStack_20ac);
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0,
               "Stale submissions discarded due to new blocks: %lld",
               (undefined4)total_stale, total_stale._4_4_);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8b0, 0x50, auStack_20ac);
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0,
               "Unable to get work from server occasions: %d");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8b1, 0x50, auStack_20ac);
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0,
               "Submitting work remotely delay occasions: %d");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8b2, 0x50, auStack_20ac);
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0, "New blocks detected on network: %d");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8b3, 0x50, auStack_20ac);
    if (0 < total_pools) {
        V_LOCK();
        logfmt_raw(auStack_20ac, 0x1000, 0, "Summary of pool statistics:");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "print_summary", 0xd, 0x8b7, 0x50, auStack_20ac);
        for (local_20 = 0; local_20 < total_pools; local_20 = local_20 + 1) {
            local_1c = *(int *)(pools + local_20 * 4);
            V_LOCK();
            logfmt_raw(auStack_20ac, 0x1000, 0, "Pool: %s",
                       *(undefined4 *)(local_1c + 0xc));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/api_new.c",
                 0x93, "print_summary", 0xd, 0x8bc, 0x50, auStack_20ac);
            V_LOCK();
            logfmt_raw(auStack_20ac, 0x1000, 0, "User: %s",
                       *(undefined4 *)(local_1c + 0x10));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/api_new.c",
                 0x93, "print_summary", 0xd, 0x8bd, 0x50, auStack_20ac);
            V_LOCK();
            logfmt_raw(auStack_20ac, 0x1000, 0, "Share submissions: %lld",
                       *(int *)(local_1c + 0x790) + *(int *)(local_1c + 0x788));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/api_new.c",
                 0x93, "print_summary", 0xd, 0x8be, 0x50, auStack_20ac);
            V_LOCK();
            logfmt_raw(auStack_20ac, 0x1000, 0, "Accepted shares: %lld",
                       *(undefined4 *)(local_1c + 0x788));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/api_new.c",
                 0x93, "print_summary", 0xd, 0x8bf, 0x50, auStack_20ac);
            V_LOCK();
            logfmt_raw(auStack_20ac, 0x1000, 0, "Rejected shares: %lld",
                       *(undefined4 *)(local_1c + 0x790));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/api_new.c",
                 0x93, "print_summary", 0xd, 0x8c0, 0x50, auStack_20ac);
            V_LOCK();
            logfmt_raw(auStack_20ac, 0x1000, 0,
                       "Accepted difficulty shares: %1.f",
                       *(undefined4 *)(local_1c + 0x7a8));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/api_new.c",
                 0x93, "print_summary", 0xd, 0x8c1, 0x50, auStack_20ac);
            V_LOCK();
            logfmt_raw(auStack_20ac, 0x1000, 0,
                       "Rejected difficulty shares: %1.f",
                       *(undefined4 *)(local_1c + 0x7b0));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/api_new.c",
                 0x93, "print_summary", 0xd, 0x8c2, 0x50, auStack_20ac);
            if (*(int *)(local_1c + 0x788) == 0 &&
                *(int *)(local_1c + 0x78c) == 0) {
                if (*(int *)(local_1c + 0x790) != 0 ||
                    *(int *)(local_1c + 0x794) != 0)
                    goto LAB_00027b84;
            } else {
            LAB_00027b84:
                V_LOCK();
                puVar2 = (uint *)(local_1c + 0x790);
                uVar9 =
                    VectorAdd(*(undefined8 *)puVar2, *(undefined8 *)puVar2, 8);
                uVar10 = VectorAdd((uVar9 & 0xffffffff00000000) +
                                       (uVar9 & 0xffffffff),
                                   *(undefined8 *)puVar2, 8);
                uVar11 = VectorShiftLeft(uVar10, 5, 0x40, 0);
                uVar10 = VectorAdd(uVar10, uVar11, 8);
                dVar13 = (double)FUN_000ccae4(
                    (uint)uVar10 + *puVar2,
                    (int)((ulonglong)uVar10 >> 0x20) +
                        *(int *)(local_1c + 0x794) +
                        (uint)CARRY4((uint)uVar10, *puVar2));
                dVar12 = (double)FUN_000ccae4(
                    *(uint *)(local_1c + 0x790) + *(uint *)(local_1c + 0x788),
                    *(int *)(local_1c + 0x794) + *(int *)(local_1c + 0x78c) +
                        (uint)CARRY4(*(uint *)(local_1c + 0x790),
                                     *(uint *)(local_1c + 0x788)));
                logfmt_raw(auStack_20ac, 0x1000, 0, "Reject ratio: %.1f%%",
                           dVar13 / dVar12);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/api_new.c",
                     0x93, "print_summary", 0xd, 0x8c5, 0x50, auStack_20ac);
            }
        }
    }
    V_LOCK();
    logfmt_raw(auStack_20ac, 0x1000, 0, "Summary of per device statistics:");
    V_UNLOCK();
    uVar10 = 0x8ca0000000d;
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/api_new.c",
         0x93, "print_summary", 0xd, 0x8ca, 0x50, auStack_20ac);
    local_ac = 0;
    local_64 = get_all_created_runtime(&local_ac);
    local_60 = 0;
    for (local_5c = 0; local_5c < local_ac; local_5c = local_5c + 1) {
        uVar8 = *(undefined4 *)(*(int *)(local_64 + local_5c * 4) + 0xf8);
        iVar3 = *(int *)(local_64 + local_5c * 4);
        uVar1 = *(undefined4 *)(iVar3 + 0x1b8);
        uVar4 = *(undefined4 *)(iVar3 + 0x1bc);
        iVar3 = *(int *)(local_64 + local_5c * 4);
        uVar6 = *(undefined4 *)(iVar3 + 0x1c0);
        uVar7 = *(undefined4 *)(iVar3 + 0x1c4);
        uVar14 = (undefined4)((ulonglong)uVar10 >> 0x20);
        uVar10 = CONCAT44(uVar14, uVar8);
        local_60 = snprintf(
            acStack_10ac, 0x1000, "chain %d device %d wc %llu nc %llu detail: ",
            *(undefined4 *)(*(int *)(local_64 + local_5c * 4) + 0xfc), uVar8,
            uVar14, uVar1, uVar4, uVar6, uVar7);
        local_68 = *(int *)(*(int *)(local_64 + local_5c * 4) + 0x150);
        local_58 = 0;
        while (true) {
            if (local_68 <= local_58)
                break;
            local_6c = *(int *)(*(int *)(local_64 + local_5c * 4) + 0x1c8) +
                       local_58 * 0x30;
            iVar3 = snprintf(acStack_10ac + local_60, 0x1000 - local_60,
                             "%d:", local_58 + 1, uVar10, uVar1, uVar4, uVar6,
                             uVar7);
            local_60 = local_60 + iVar3;
            for (local_54 = 0; local_54 < 6; local_54 = local_54 + 1) {
                puVar5 = (undefined8 *)(local_6c + local_54 * 8);
                uVar10 = *puVar5;
                iVar3 = snprintf(acStack_10ac + local_60, 0x1000 - local_60,
                                 " %llu", *(undefined4 *)((int)puVar5 + 4),
                                 *(undefined4 *)puVar5,
                                 *(undefined4 *)((int)puVar5 + 4), uVar1, uVar4,
                                 uVar6, uVar7);
                local_60 = local_60 + iVar3;
            }
            iVar3 = snprintf(acStack_10ac + local_60, 0x1000 - local_60, " /");
            local_60 = local_60 + iVar3;
            local_58 = local_58 + 1;
        }
        V_LOCK();
        logfmt_raw(auStack_20ac, 0x1000, 0, &DAT_000cd384, acStack_10ac);
        V_UNLOCK();
        uVar10 = 0x8de0000000d;
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "print_summary", 0xd, 0x8de, 0x50, auStack_20ac);
    }
    return;
}

int FUN_00027ff4(char *param_1, size_t param_2, int param_3)

{
    int iVar1;
    char local_20[20];
    int local_c;

    local_20[0x10] = '\0';
    local_20[0x11] = '\0';
    local_20[0x12] = '\0';
    local_20[0x13] = '\0';
    local_c = 0;
    local_20[0] = '\0';
    local_20[1] = '\0';
    local_20[2] = '\0';
    local_20[3] = '\0';
    local_20[4] = '\0';
    local_20[5] = '\0';
    local_20[6] = '\0';
    local_20[7] = '\0';
    local_20[8] = '\0';
    local_20[9] = '\0';
    local_20[10] = '\0';
    local_20[0xb] = '\0';
    local_20[0xc] = '\0';
    local_20[0xd] = '\0';
    local_20[0xe] = '\0';
    local_20[0xf] = '\0';
    if (((param_1 == (char *)0x0) || ((int)param_2 < 1)) ||
        (0x10 < (int)param_2)) {
        iVar1 = -0x7ffffffe;
    } else {
        strncpy(local_20, param_1, param_2);
        if (param_3 == 0) {
            for (local_c = 0; *(int *)(new_cmds + local_c * 0xc) != 0;
                 local_c = local_c + 1) {
                iVar1 = strcmp(local_20, *(char **)(new_cmds + local_c * 0xc));
                if (iVar1 == 0) {
                    return local_c;
                }
            }
        } else if ((param_3 == 1) || (param_3 == 2)) {
            for (local_c = 0; *(int *)(old_cmds + local_c * 0x10) != 0;
                 local_c = local_c + 1) {
                iVar1 = strcmp(local_20, *(char **)(old_cmds + local_c * 0x10));
                if (iVar1 == 0) {
                    return local_c;
                }
            }
        }
        iVar1 = -0x7ffffffd;
    }
    return iVar1;
}

int FUN_00028180(void)

{
    int iVar1;
    time_t tVar2;
    int *piVar3;
    char *pcVar4;
    undefined1 auStack_1058[4096];
    undefined4 local_58;
    addrinfo *local_54;
    addrinfo local_50;
    char acStack_30[12];
    int local_24;
    undefined4 local_20;
    char *local_1c;
    short local_16;
    int local_14;
    int local_10;
    addrinfo *local_c;

    local_16 = 0xfbc;
    local_10 = 0;
    local_14 = 0;
    sprintf(acStack_30, "%d", 0xfbc);
    memset(&local_50, 0, 0x20);
    local_50.ai_flags = 1;
    local_50.ai_family = 0;
    iVar1 = getaddrinfo("0.0.0.0", acStack_30, &local_50, &local_54);
    if (iVar1 == 0) {
        local_c = local_54;
        while ((local_c != (addrinfo *)0x0 &&
                (local_10 = socket(local_54->ai_family, 1, 0), local_10 < 1))) {
            local_c = local_c->ai_next;
        }
        if (local_10 == -1) {
            V_LOCK();
            logfmt_raw(auStack_1058, 0x1000, 0, "%s: exec socket() failed",
                       "api_init_socket");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/api_new.c",
                 0x93, "api_init_socket", 0xf, 0x93f, 100, auStack_1058);
            local_10 = -0x7ffffffa;
        } else {
            local_58 = 1;
            local_20 = 4;
            setsockopt(local_10, 1, 2, &local_58, 4);
            local_24 = time((time_t *)0x0);
            while (local_14 == 0) {
                iVar1 = bind(local_10, local_c->ai_addr, local_c->ai_addrlen);
                if (iVar1 < 0) {
                    piVar3 = __errno_location();
                    local_1c = strerror(*piVar3);
                    tVar2 = time((time_t *)0x0);
                    if (0x3d < tVar2 - local_24)
                        break;
                    V_LOCK();
                    logfmt_raw(
                        auStack_1058, 0x1000, 0,
                        "%s: api bind to port %d failed, trying again in 30sec",
                        "api_init_socket", (int)local_16);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "api_new.c",
                         0x93, "api_init_socket", 0xf, 0x951, 0x50,
                         auStack_1058);
                    sleep(0x1e);
                } else {
                    local_14 = 1;
                }
            }
            freeaddrinfo(local_54);
            if (local_14 == 0) {
                V_LOCK();
                logfmt_raw(auStack_1058, 0x1000, 0,
                           "api bind to port %d, failed (%s)", (int)local_16,
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/api_new.c",
                     0x93, "api_init_socket", 0xf, 0x95b, 100, auStack_1058);
                local_10 = -0x7ffffffa;
            } else {
                iVar1 = listen(local_10, 100);
                if (iVar1 < 0) {
                    V_LOCK();
                    piVar3 = __errno_location();
                    pcVar4 = strerror(*piVar3);
                    logfmt_raw(auStack_1058, 0x1000, 0,
                               "%s: exec listen() failed (%s)",
                               "api_init_socket", pcVar4);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "api_new.c",
                         0x93, "api_init_socket", 0xf, 0x961, 100,
                         auStack_1058);
                    close(local_10);
                    local_10 = -0x7ffffffa;
                }
            }
        }
    } else {
        V_LOCK();
        logfmt_raw(auStack_1058, 0x1000, 0, "%s: exec getaddrinfo() failed",
                   "api_init_socket");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, "api_init_socket", 0xf, 0x930, 100, auStack_1058);
        local_10 = -0x7ffffffa;
    }
    return local_10;
}

undefined4 FUN_0002863c(undefined4 param_1, undefined4 param_2, char *param_3,
                        char *param_4, undefined4 *param_5)

{
    undefined4 uVar1;
    undefined1 auStack_1110[4096];
    undefined1 auStack_110[252];
    int *local_14;
    int *local_10;
    undefined4 local_c;

    local_c = 0;
    local_10 = (int *)0x0;
    local_14 = (int *)0x0;
    local_10 = (int *)json_loads(param_1, 0, auStack_110);
    if ((local_10 == (int *)0x0) || (*local_10 != 0)) {
        *param_5 = 2;
        snprintf(param_3, 0x10, "%s", param_1);
    } else {
        local_14 = (int *)json_object_get(local_10, "command");
        if ((local_14 == (int *)0x0) || (*local_14 != 2)) {
            V_LOCK();
            logfmt_raw(auStack_1110, 0x1000, 0,
                       "%s error: format error about command",
                       "parse_recv_buf");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/api_new.c",
                 0x93, "parse_recv_buf", 0xe, 0x987, 100, auStack_1110);
            local_c = 0x80000007;
        } else {
            uVar1 = json_string_value(local_14);
            snprintf(param_3, 0x10, "%s", uVar1);
            local_14 = (int *)json_object_get(local_10, "new_api");
            if ((local_14 == (int *)0x0) || (*local_14 != 5)) {
                local_14 = (int *)json_object_get(local_10, "parameter");
                if ((local_14 != (int *)0x0) && (*local_14 == 2)) {
                    uVar1 = json_string_value(local_14);
                    snprintf(param_4, 0x20, "%s", uVar1);
                }
                *param_5 = 1;
            } else {
                *param_5 = 0;
            }
        }
        FUN_0001d5b0(local_10);
    }
    return local_c;
}

void FUN_000288b8(uint *param_1, char *param_2)

{
    int *piVar1;
    char *pcVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    int iVar6;
    fd_set fStack_10bc;
    undefined1 auStack_103c[4096];
    timeval local_3c;
    fd_set *local_34;
    ssize_t local_30;
    int local_2c;
    int local_28;
    char *local_24;
    uint local_20;
    size_t local_1c;
    size_t local_18;
    char local_11;

    local_1c = 0;
    local_18 = 0;
    local_11 = '\0';
    local_2c = 0;
    local_30 = 0;
    local_28 = 0;
    local_24 = (char *)0x0;
    if ((param_1 != (uint *)0x0) && (param_2 != (char *)0x0)) {
        local_1c = strlen(param_2);
        local_1c = local_1c + 1;
        local_24 = param_2;
        local_18 = local_1c;
        while (local_11 != '\x01') {
            local_3c.tv_sec = 0;
            local_3c.tv_usec = 50000;
            local_34 = &fStack_10bc;
            for (local_20 = 0; local_20 < 0x20; local_20 = local_20 + 1) {
                local_34->fds_bits[local_20] = 0;
            }
            uVar4 = *param_1;
            uVar3 = uVar4 + 0x1f;
            if (-1 < (int)uVar4) {
                uVar3 = uVar4;
            }
            uVar5 = *param_1;
            uVar4 = uVar5 & 0x1f;
            if ((int)uVar5 < 1) {
                uVar4 = -(-uVar5 & 0x1f);
            }
            fStack_10bc.fds_bits[(int)uVar3 >> 5] =
                fStack_10bc.fds_bits[(int)uVar3 >> 5] | 1 << (uVar4 & 0xff);
            local_2c = select(*param_1 + 1, (fd_set *)0x0, &fStack_10bc,
                              (fd_set *)0x0, &local_3c);
            if (local_2c < 1) {
                V_LOCK();
                logfmt_raw(auStack_103c, 0x1000, 0,
                           "%s: send select failed, ret = %d",
                           "send_api_result", local_2c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/api_new.c",
                     0x93, "send_api_result", 0xf, 0x9b9, 100, auStack_103c);
                return;
            }
            local_30 = send(*param_1, local_24, local_18, 0);
            if (local_30 < 0) {
                local_28 = local_28 + 1;
                piVar1 = __errno_location();
                if ((*piVar1 != 0xb) &&
                    (piVar1 = __errno_location(), *piVar1 != 0xb)) {
                    V_LOCK();
                    iVar6 = local_1c - local_18;
                    piVar1 = __errno_location();
                    pcVar2 = strerror(*piVar1);
                    logfmt_raw(auStack_103c, 0x1000, 0,
                               "%s: send (%d:%d) failed %s", "send_api_result",
                               local_1c, iVar6, pcVar2);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "api_new.c",
                         0x93, "send_api_result", 0xf, 0x9c7, 100,
                         auStack_103c);
                    return;
                }
                V_LOCK();
                logfmt_raw(auStack_103c, 0x1000, 0, "%s: send EAGAIN ",
                           "send_api_result");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/api_new.c",
                     0x93, "send_api_result", 0xf, 0x9c3, 0x14, auStack_103c);
                if (((int)local_18 < 1) || (2 < local_28)) {
                    local_11 = '\x01';
                } else {
                    local_11 = '\0';
                }
            } else {
                local_18 = local_18 - local_30;
                local_24 = local_24 + local_30;
                if (local_30 == 0) {
                    local_28 = local_28 + 1;
                }
                if (((int)local_18 < 1) || (2 < local_28)) {
                    local_11 = '\x01';
                } else {
                    local_11 = '\0';
                }
            }
        }
    }
    return;
}

int FUN_00028d88(int param_1, char *param_2, int param_3, int param_4)

{
    size_t sVar1;
    undefined4 uVar2;
    int extraout_r3;
    int extraout_r3_00;
    int extraout_r3_01;
    int extraout_r3_02;
    int extraout_r3_03;
    char local_7c[8];
    undefined2 local_74;
    int local_18;
    int local_14;

    local_14 = 0x80000001;
    local_18 = 0;
    memset(local_7c, 0, 100);
    if ((((param_2 == (char *)0x0) || (param_1 == 0)) || (param_4 < 0)) ||
        (2 < param_4)) {
        param_4 = -0x7ffffffe;
    } else {
        sVar1 = strlen(param_2);
        local_14 = FUN_00027ff4(param_2, sVar1, param_4);
        if (local_14 < 0) {
            if (param_4 == 0) {
                if (local_14 == -0x7ffffffd) {
                    snprintf(local_7c, 100, "not support (%s)", param_2);
                } else {
                    builtin_strncpy(local_7c, "bad para", 8);
                    local_74 = 0x6d;
                }
                uVar2 = json_string(local_7c);
                json_object_set_new(param_1, "error_message", uVar2);
                param_4 = extraout_r3;
            } else {
                param_4 = local_14;
                if (local_14 == -0x7ffffffd) {
                    FUN_00020f64(param_1, 0, 0xe, "Invalid command");
                    param_4 = extraout_r3_00;
                }
            }
        } else {
            local_18 = local_14;
            if (param_4 == 0) {
                param_4 = (**(code **)(new_cmds + local_14 * 0xc + 8))(
                    param_1, new_cmds + local_14 * 0xc);
                if (param_4 < 0) {
                    if (param_4 == -0x7ffffffe) {
                        builtin_strncpy(local_7c, "bad para", 8);
                        local_74 = 0x6d;
                    }
                    local_14 = param_4;
                    uVar2 = json_string(local_7c);
                    json_object_set_new(param_1, "error_message", uVar2);
                    param_4 = extraout_r3_01;
                }
            } else if ((param_4 == 1) || (param_4 == 2)) {
                if (param_3 == 0) {
                    (**(code **)(old_cmds + local_14 * 0x10 + 0xc))(
                        param_1, old_cmds + local_14 * 0x10, 0);
                    param_4 = extraout_r3_03;
                } else {
                    (**(code **)(old_cmds + local_14 * 0x10 + 0xc))(
                        param_1, old_cmds + local_14 * 0x10, param_3);
                    param_4 = extraout_r3_02;
                }
            }
        }
    }
    return param_4;
}

void FUN_00029034(int *param_1)

{
    DAT_00151282 = 1;
    if (*param_1 != -1) {
        shutdown(*param_1, 2);
        close(*param_1);
        *param_1 = -1;
    }
    return;
}

void FUN_000290a8(char *param_1, int *param_2)

{
    undefined4 uVar1;
    undefined4 extraout_s1;
    undefined8 uVar2;
    char local_108[4];
    ushort local_104;

    memset(local_108, 0, 0x100);
    if ((param_1 != (char *)0x0) && (param_2 != (int *)0x0)) {
        if ((param_2 == (int *)0x0) || (*param_2 != 6)) {
            if ((param_2 == (int *)0x0) || (*param_2 != 5)) {
                if ((param_2 == (int *)0x0) || (*param_2 != 3)) {
                    if ((param_2 == (int *)0x0) || (*param_2 != 4)) {
                        if ((param_2 != (int *)0x0) && (*param_2 == 2)) {
                            uVar1 = json_string_value(param_2);
                            snprintf(local_108, 0x100, "%s", uVar1);
                        }
                    } else {
                        uVar1 = json_real_value(param_2);
                        snprintf(local_108, 0x100, "%.2lf", local_108,
                                 CONCAT44(extraout_s1, uVar1));
                    }
                } else {
                    uVar2 = json_integer_value(param_2);
                    uVar1 = (undefined4)((ulonglong)uVar2 >> 0x20);
                    snprintf(local_108, 0x100, "%lld", uVar1, (int)uVar2,
                             uVar1);
                }
            } else {
                builtin_strncpy(local_108, "true", 4);
                local_104 = local_104 & 0xff00;
            }
        } else {
            builtin_strncpy(local_108, "fals", 4);
            local_104 = 0x65;
        }
        strcat(param_1, local_108);
    }
    return;
}

void FUN_0002924c(char *param_1, undefined4 param_2)

{
    undefined4 uVar1;
    size_t sVar2;
    char *apcStack_13c[4];
    char *local_12c;
    char acStack_128[256];
    int local_28;
    int local_24;
    int local_20;
    int *local_1c;
    char *local_18;
    int local_14;
    int local_10;
    int *local_c;

    local_c = (int *)0x0;
    local_1c = (int *)0x0;
    local_20 = 0;
    memset(acStack_128, 0, 0x100);
    local_14 = 0;
    apcStack_13c[0] = "SUMMARY";
    apcStack_13c[1] = "POOLS";
    apcStack_13c[2] = "STATS";
    apcStack_13c[3] = "DEVS";
    local_12c = "VERSION";
    local_18 = (char *)0x0;
    local_28 = 0;
    local_24 = 5;
    for (local_10 = 0; local_10 < local_24; local_10 = local_10 + 1) {
        local_c = (int *)json_object_get(param_2, apcStack_13c[local_10]);
        if ((local_c != (int *)0x0) && (*local_c == 1))
            break;
    }
    if (local_10 < local_24) {
        if ((local_10 == 0) || (local_10 == 4)) {
            snprintf(acStack_128, 0x100, "%s,", apcStack_13c[local_10]);
            strcat(param_1, acStack_128);
        }
        local_28 = json_array_size(local_c);
        for (local_14 = 0; local_14 < local_28; local_14 = local_14 + 1) {
            local_1c = (int *)json_array_get(local_c, local_14);
            if ((local_1c != (int *)0x0) && (*local_1c == 0)) {
                uVar1 = json_object_iter(local_1c);
                local_18 = (char *)json_object_iter_key(uVar1);
                while (local_18 != (char *)0x0) {
                    uVar1 = json_object_key_to_iter(local_18);
                    local_20 = json_object_iter_value(uVar1);
                    if (local_20 == 0)
                        break;
                    strcat(param_1, local_18);
                    sVar2 = strlen(param_1);
                    (param_1 + sVar2)[0] = '=';
                    (param_1 + sVar2)[1] = '\0';
                    FUN_000290a8(param_1, local_20);
                    sVar2 = strlen(param_1);
                    (param_1 + sVar2)[0] = ',';
                    (param_1 + sVar2)[1] = '\0';
                    uVar1 = json_object_key_to_iter(local_18);
                    uVar1 = json_object_iter_next(local_1c, uVar1);
                    local_18 = (char *)json_object_iter_key(uVar1);
                }
                sVar2 = strlen(param_1);
                param_1[sVar2 - 1] = '|';
                if (local_14 != local_28 + -1) {
                    sVar2 = strlen(param_1);
                    param_1[sVar2] = ',';
                }
            }
        }
    }
    return;
}

undefined4 FUN_00029550(int param_1, char *param_2)

{
    int *piVar1;
    undefined4 uVar2;
    int iVar3;
    size_t sVar4;
    undefined4 local_10;
    char *local_c;

    local_10 = 0;
    if ((param_1 == 0) || (param_2 == (char *)0x0)) {
        local_10 = 0x80000007;
    } else {
        piVar1 = (int *)json_object_get(param_1, "STATUS");
        if ((piVar1 == (int *)0x0) || (*piVar1 != 1)) {
            local_10 = 0x80000002;
        } else {
            piVar1 = (int *)json_array_get(piVar1, 0);
            if ((piVar1 == (int *)0x0) || (*piVar1 != 0)) {
                local_10 = 0x80000002;
            } else {
                uVar2 = json_object_iter(piVar1);
                local_c = (char *)json_object_iter_key(uVar2);
                while (local_c != (char *)0x0) {
                    uVar2 = json_object_key_to_iter(local_c);
                    iVar3 = json_object_iter_value(uVar2);
                    if (iVar3 == 0)
                        break;
                    strcat(param_2, local_c);
                    sVar4 = strlen(param_2);
                    (param_2 + sVar4)[0] = '=';
                    (param_2 + sVar4)[1] = '\0';
                    FUN_000290a8(param_2, iVar3);
                    sVar4 = strlen(param_2);
                    (param_2 + sVar4)[0] = ',';
                    (param_2 + sVar4)[1] = '\0';
                    uVar2 = json_object_key_to_iter(local_c);
                    uVar2 = json_object_iter_next(piVar1, uVar2);
                    local_c = (char *)json_object_iter_key(uVar2);
                }
                sVar4 = strlen(param_2);
                param_2[sVar4 - 1] = '|';
                FUN_0002924c(param_2, param_1);
            }
        }
    }
    return local_10;
}

undefined4 FUN_00029740(undefined4 param_1, undefined4 param_2)

{
    undefined4 uVar1;
    int iVar2;
    uint uVar3;
    char local_140[268];
    void *local_34;
    undefined4 local_30;
    undefined4 local_2c;
    int *local_28;
    int *local_24;
    int *local_20;
    int *local_1c;
    undefined4 local_18;
    int local_14;
    int local_10;
    uint local_c;

    local_18 = 0;
    local_c = 0;
    local_1c = (int *)0x0;
    local_20 = (int *)0x0;
    local_24 = (int *)0x0;
    local_28 = (int *)0x0;
    local_2c = 0;
    local_30 = 0;
    local_140[0] = '\0';
    local_140[1] = '\0';
    local_140[2] = '\0';
    local_140[3] = '\0';
    local_140[4] = '\0';
    local_140[5] = '\0';
    local_140[6] = '\0';
    local_140[7] = '\0';
    local_140[8] = '\0';
    local_140[9] = '\0';
    local_140[10] = '\0';
    local_140[0xb] = '\0';
    local_140[0xc] = '\0';
    local_140[0xd] = '\0';
    local_140[0xe] = '\0';
    local_140[0xf] = '\0';
    local_14 = 0;
    local_34 = (void *)0x0;
    local_1c = (int *)json_loads(param_2, 0, local_140 + 0x10);
    if ((local_1c == (int *)0x0) || (*local_1c != 0)) {
        local_18 = 0x80000003;
    } else {
        local_20 = (int *)json_object_get(local_1c, "command");
        if ((local_20 == (int *)0x0) || (*local_20 != 1)) {
            FUN_0001d5b0(local_1c);
            local_18 = 0x80000003;
        } else {
            local_24 = (int *)json_object_get(local_1c, "new_api");
            if ((local_24 == (int *)0x0) || (*local_24 != 5)) {
                local_10 = 1;
            } else {
                local_10 = 0;
            }
            local_2c = json_object();
            local_c = 0;
            while (((uVar3 = json_array_size(local_20),
                     local_c < uVar3 &&
                         (local_28 = (int *)json_array_get(local_20, local_c),
                          local_28 != (int *)0x0)) &&
                    ((int)local_c < 0xb))) {
                if ((local_28 != (int *)0x0) && (*local_28 == 2)) {
                    memset(local_140, 0, 0x10);
                    uVar1 = json_string_value(local_28);
                    snprintf(local_140, 0x10, "%s", uVar1);
                    iVar2 = strcmp(local_140, "reload");
                    if ((iVar2 == 0) && (local_10 == 0)) {
                        local_14 = 1;
                    } else {
                        local_30 = json_object();
                        FUN_00028d88(local_30, local_140, 0, local_10);
                        json_object_set_new(local_2c, local_140, local_30);
                    }
                }
                local_c = local_c + 1;
            }
            local_34 = (void *)json_dumps(local_2c, 0x6000);
            FUN_000288b8(param_1, local_34);
            free(local_34);
            if (local_14 == 1) {
                FUN_00028d88(local_2c, "reload", 0, 0);
            }
            FUN_0001d5b0(local_2c);
            FUN_0001d5b0(local_1c);
        }
    }
    return local_18;
}

void FUN_00029a00(undefined1 param_1)

{
    DAT_00151281 = param_1;
    return;
}

undefined1 FUN_00029a34(void)

{
    return DAT_00151281;
}

void api(void)

{
    int iVar1;
    int *piVar2;
    char *pcVar3;
    size_t sVar4;
    __pthread_unwind_buf_t a_Stack_b210[6];
    undefined1 auStack_b0f8[4096];
    undefined1 auStack_a0f8[4096];
    undefined1 auStack_90f8[4096];
    undefined1 auStack_80f8[4096];
    undefined1 auStack_70f8[4096];
    undefined1 auStack_60f8[4096];
    undefined1 auStack_50f8[4096];
    undefined1 auStack_40f8[4096];
    undefined4 local_30f8;
    undefined4 local_30f4;
    undefined4 local_30f0;
    undefined4 local_30ec;
    undefined4 local_30e8;
    int local_30e4;
    undefined8 local_30e0;
    undefined8 uStack_30d8;
    undefined8 local_30d0;
    undefined8 local_30c8;
    undefined8 local_30c0;
    undefined8 uStack_30b8;
    undefined1 auStack_30b0[4096];
    char local_20b0[8192];
    socklen_t local_b0;
    sockaddr asStack_ac[8];
    int local_2c;
    int local_28;
    int local_24;
    ssize_t local_20;
    undefined4 local_1c;
    void *local_18;
    int *local_14;
    code *local_10;
    int local_c;

    local_24 = 0;
    local_28 = -1;
    local_2c = -1;
    local_20 = 0;
    memset(local_20b0, 0, 0x2000);
    memset(auStack_30b0, 0, 0x1000);
    local_30c0 = 0;
    uStack_30b8 = 0;
    local_30e0 = 0;
    uStack_30d8 = 0;
    local_30d0 = 0;
    local_30c8 = 0;
    local_30e4 = 2;
    local_1c = 0;
    local_18 = (void *)0x0;
    iVar1 = FUN_00029a34();
    if (iVar1 == 0) {
        V_LOCK();
        logfmt_raw(auStack_b0f8, 0x1000, 0, "Start api function");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/api_new.c",
             0x93, &DAT_000ce894, 3, 0xaf0, 0x3c, auStack_b0f8);
        local_10 = FUN_00029034;
        local_14 = &local_28;
        local_c = __sigsetjmp(a_Stack_b210, 0);
        if (local_c != 0) {
            (*local_10)(local_14);
            __pthread_unwind_next(a_Stack_b210);
        }
        __pthread_register_cancel(a_Stack_b210);
        local_24 = FUN_00028180();
        if (local_24 < 0) {
            V_LOCK();
            logfmt_raw(auStack_a0f8, 0x1000, 0, "%s: init socket failed",
                       &DAT_000ce894);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/api_new.c",
                 0x93, &DAT_000ce894, 3, 0xaf7, 100, auStack_a0f8);
        } else {
            local_28 = local_24;
            FUN_00029a00(1);
            while (DAT_00151282 != '\x01') {
                local_b0 = 0x80;
                local_2c = accept(local_28, asStack_ac, &local_b0);
                if (local_2c < 0) {
                    V_LOCK();
                    piVar2 = __errno_location();
                    pcVar3 = strerror(*piVar2);
                    logfmt_raw(auStack_90f8, 0x1000, 0,
                               "%s: exec accept failed (%s)", &DAT_000ce894,
                               pcVar3);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "api_new.c",
                         0x93, &DAT_000ce894, 3, 0xb04, 100, auStack_90f8);
                    break;
                }
                local_30e8 = 1;
                local_30ec = 5;
                local_30f0 = 2;
                setsockopt(local_2c, 1, 9, &local_30e8, 4);
                setsockopt(local_2c, 6, 1, &local_30e8, 4);
                setsockopt(local_2c, 6, 6, &local_30e8, 4);
                setsockopt(local_2c, 6, 4, &local_30ec, 4);
                setsockopt(local_2c, 6, 5, &local_30f0, 4);
                local_30f8 = 10;
                local_30f4 = 0;
                local_24 = setsockopt(local_2c, 1, 0x15, &local_30f8, 8);
                if (local_24 != 0) {
                    V_LOCK();
                    logfmt_raw(auStack_80f8, 0x1000, 0,
                               "%s:setsocket SO_SNDTIMEO failed\n",
                               &DAT_000ce894);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "api_new.c",
                         0x93, &DAT_000ce894, 3, 0xb17, 100, auStack_80f8);
                    close(local_2c);
                }
                local_24 = setsockopt(local_2c, 1, 0x14, &local_30f8, 8);
                if (local_24 != 0) {
                    V_LOCK();
                    logfmt_raw(auStack_70f8, 0x1000, 0,
                               "%s:setsocket SO_RCVTIMEO failed\n",
                               &DAT_000ce894);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "api_new.c",
                         0x93, &DAT_000ce894, 3, 0xb1d, 100, auStack_70f8);
                    close(local_2c);
                }
                local_20 = recv(local_2c, local_20b0, 0xfff, 0);
                if (local_20 < 0) {
                    local_20b0[0] = '\0';
                LAB_0002a3e8:
                    close(local_2c);
                } else {
                    local_20b0[local_20] = '\0';
                    memset(&local_30c0, 0, 0x10);
                    memset(&local_30e0, 0, 0x20);
                    memset(&DAT_00151288, 0, 0x10);
                    DAT_00151284 = time((time_t *)0x0);
                    getnameinfo(asStack_ac, 0x80, &DAT_00151288, 0x10,
                                (char *)0x0, 0, 1);
                    V_LOCK();
                    logfmt_raw(auStack_60f8, 0x1000, 0, "connect_addr: %s",
                               &DAT_00151288);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "api_new.c",
                         0x93, &DAT_000ce894, 3, 0xb2e, 0x14, auStack_60f8);
                    sVar4 = strlen(local_20b0);
                    local_24 = FUN_00029740(&local_2c, local_20b0, sVar4 + 1);
                    if (local_24 != 0) {
                        local_1c = json_object();
                        sVar4 = strlen(local_20b0);
                        local_24 =
                            FUN_0002863c(local_20b0, sVar4 + 1, &local_30c0,
                                         &local_30e0, &local_30e4);
                        if (local_24 < 0) {
                            V_LOCK();
                            logfmt_raw(auStack_50f8, 0x1000, 0,
                                       "%s: input invaild param format",
                                       &DAT_000ce894);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/api_new.c",
                                 0x93, &DAT_000ce894, 3, 0xb3d, 100,
                                 auStack_50f8);
                            FUN_00020f64(local_1c, 0, 0x18,
                                         "Missing JSON \'command\'");
                        } else {
                            FUN_00028d88(local_1c, &local_30c0, &local_30e0,
                                         local_30e4);
                        }
                        if (local_30e4 == 2) {
                            memset(auStack_30b0, 0, 0x1000);
                            FUN_00029550(local_1c, auStack_30b0);
                            FUN_000288b8(&local_2c, auStack_30b0);
                            FUN_0001d5b0(local_1c);
                        } else {
                            local_18 = (void *)json_dumps(local_1c, 0x6000);
                            FUN_000288b8(&local_2c, local_18);
                            FUN_0001d5b0(local_1c);
                            free(local_18);
                        }
                        goto LAB_0002a3e8;
                    }
                    close(local_2c);
                }
            }
            __pthread_unregister_cancel(a_Stack_b210);
            (*local_10)(local_14);
            FUN_00029a00(0);
            V_LOCK();
            logfmt_raw(auStack_40f8, 0x1000, 0, "End api function !!!");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/api_new.c",
                 0x93, &DAT_000ce894, 3, 0xb5c, 0x3c, auStack_40f8);
            close(local_28);
        }
    }
    return;
}

void FUN_0002a4d0(int param_1)

{
    bool bVar1;
    int iVar2;
    int *piVar3;

    if ((param_1 != 0) && (*(int *)(param_1 + 4) != -1)) {
        piVar3 = (int *)(param_1 + 4);
        DataMemoryBarrier(0xb);
        do {
            iVar2 = *piVar3;
            bVar1 = (bool)hasExclusiveAccess(piVar3);
        } while (!bVar1);
        *piVar3 = iVar2 + -1;
        if (iVar2 + -1 == 0) {
            json_delete(param_1);
        }
    }
    return;
}

undefined4 FUN_0002a538(undefined4 param_1, undefined4 param_2)

{
    V_STR(param_1, "error", param_2);
    return param_1;
}

undefined4 FUN_0002a570(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "chain", param_3, param_4);
    return param_1;
}

undefined4 FUN_0002a5a4(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "poolno", param_3, param_4);
    return param_1;
}

int FUN_0002a5d8(void *param_1, __start_routine *param_2)

{
    int iVar1;

    pthread_attr_init((pthread_attr_t *)((int)param_1 + 8));
    iVar1 =
        pthread_create((pthread_t *)((int)param_1 + 4),
                       (pthread_attr_t *)((int)param_1 + 8), param_2, param_1);
    pthread_attr_destroy((pthread_attr_t *)((int)param_1 + 8));
    return iVar1;
}

void FUN_0002a644(int param_1)

{
    if (*(int *)(param_1 + 0x464) != 0) {
        free(*(void **)(param_1 + 0x464));
        *(undefined4 *)(param_1 + 0x464) = 0;
    }
    return;
}

void FUN_0002a68c(void *param_1, void *param_2)

{
    char *pcVar1;

    memcpy(param_1, param_2, 0x470);
    if (*(int *)((int)param_2 + 0x464) != 0) {
        pcVar1 = strdup(*(char **)((int)param_2 + 0x464));
        *(char **)((int)param_1 + 0x464) = pcVar1;
    }
    return;
}

void FUN_0002a6ec(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_0002a878(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/util.h",
                 0x90, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

void FUN_0002a99c(char *param_1)

{
    char *local_c;

    local_c = param_1;
    if (*param_1 != '\0') {
        *param_1 = 'x';
        local_c = param_1 + 1;
    }
    while (*local_c != '\0') {
        *local_c = '\0';
        local_c = local_c + 1;
    }
    return;
}

void get_currentalgo(char *param_1, size_t param_2)

{
    snprintf(param_1, param_2, "%s", (&PTR_s_ckb_2040_0014d568)[opt_algo]);
    return;
}

char workio_submit_work(undefined4 param_1, int *param_2)

{
    int iVar1;
    uint uVar2;
    uint uVar3;
    undefined1 auStack_1c60[4096];
    undefined1 auStack_c60[3072];
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    char local_19;
    int local_18;
    int local_14;

    local_14 = 0;
    local_18 = frontend_runtime_instance();
    iVar1 = pool_tget(param_2, param_2 + 0x1dc);
    if (iVar1 == 0) {
        update_pool_diff1_of_all_runtimes(param_2);
        (**(code **)(local_18 + 0x20))(param_1, param_2, auStack_c60);
        do {
            local_19 = (**(code **)(local_18 + 0xc))(param_2, auStack_c60);
            if (local_19 != '\x01') {
                total_ro = total_ro + 1;
                param_2[0x1e8] = param_2[0x1e8] + 1;
                uVar2 = DAT_00151854 + 1;
                iVar1 = DAT_00151854 * -0x2e48e8a7;
                uVar3 = DAT_00151854 % 10000;
                DAT_00151854 = uVar2;
                if (uVar3 == 0) {
                    V_LOCK(iVar1);
                    FUN_0002a5a4(&local_40, &local_40, *param_2,
                                 *param_2 >> 0x1f);
                    logfmt_raw(auStack_1c60, 0x1000, 0, uStack_24, local_40,
                               uStack_3c, uStack_38, uStack_34, local_30,
                               uStack_2c, uStack_28, uStack_24,
                               "submit_upstream_work stratum_send_line failed "
                               "%d count %d",
                               local_19, local_14);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "god-miner.c",
                         0x95, "workio_submit_work", 0x12, 0xa2, 100,
                         auStack_1c60);
                }
            }
            local_14 = local_14 + 1;
        } while ((local_14 < 4) && (local_19 != '\x01'));
    } else {
        V_LOCK();
        FUN_0002a5a4(&local_60, &local_60, *param_2, *param_2 >> 0x1f);
        logfmt_raw(auStack_1c60, 0x1000, 0, uStack_44, local_60, uStack_5c,
                   uStack_58, uStack_54, local_50, uStack_4c, uStack_48,
                   uStack_44, "submit idle pool\'s nonce.");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "workio_submit_work", 0x12, 0x94, 0x14, auStack_1c60);
        local_19 = '\0';
    }
    return local_19;
}

void update_recorded_timeout_value(uint param_1, uint param_2)

{
    uint uVar1;
    bool bVar2;
    int local_18;
    int local_14;
    undefined8 local_10;

    local_10 = SIMDExpandImmediate(0, 0xe, 0xff);
    local_14 = 0;
    for (local_18 = 0; local_18 < 10; local_18 = local_18 + 1) {
        uVar1 = *(uint *)(max_timeout_value + local_18 * 8 + 4);
        bVar2 = uVar1 <= local_10._4_4_;
        if (local_10._4_4_ == uVar1) {
            bVar2 =
                *(uint *)(max_timeout_value + local_18 * 8) <= (uint)local_10;
        }
        if (bVar2 &&
            (local_10._4_4_ != uVar1 ||
             (uint)local_10 != *(uint *)(max_timeout_value + local_18 * 8))) {
            local_10 = *(undefined8 *)(max_timeout_value + local_18 * 8);
            local_14 = local_18;
        }
    }
    bVar2 = local_10._4_4_ <= param_2;
    if (param_2 == local_10._4_4_) {
        bVar2 = (uint)local_10 <= param_1;
    }
    if (bVar2 && (param_2 != local_10._4_4_ || param_1 != (uint)local_10)) {
        *(uint *)(max_timeout_value + local_14 * 8) = param_1;
        *(uint *)(max_timeout_value + local_14 * 8 + 4) = param_2;
    }
    return;
}

void work_generator_thread(undefined4 *param_1)

{
    longlong lVar1;
    long lVar2;
    int iVar3;
    uint uVar4;
    undefined4 uVar5;
    uint uVar6;
    bool bVar7;
    undefined8 uVar8;
    undefined1 auStack_14ec[4096];
    timespec local_4ec;
    int local_4e4[2];
    int local_4dc;
    undefined1 auStack_4d8[1096];
    undefined4 local_90;
    int local_74;
    int *local_64;
    undefined1 *local_60;
    int *local_5c;
    int *local_58;
    int local_54;
    int *local_50;
    int local_4c;
    undefined1 *local_48;
    int local_44;
    undefined4 local_40;
    undefined4 *local_3c;
    int local_38;
    int local_34;
    int local_30;
    char local_29;
    undefined8 local_28;
    undefined4 local_20;
    char *local_1c;
    undefined4 *local_18;
    undefined4 local_14;

    local_40 = *param_1;
    local_4dc = 0;
    local_3c = param_1;
    local_34 = frontend_runtime_instance();
    local_38 = get_all_created_runtime(&local_4dc);
    local_20 = 0;
    local_28 = SIMDExpandImmediate(0, 0xe, 0xff);
    local_29 = '\0';
    memset(auStack_4d8, 0, 0x470);
    for (local_30 = 0; local_30 < local_4dc; local_30 = local_30 + 1) {
        iVar3 = *(int *)(local_38 + local_30 * 4);
        uVar4 = *(uint *)(iVar3 + 0x460);
        uVar6 = *(uint *)(iVar3 + 0x464);
        bVar7 = uVar6 <= local_28._4_4_;
        if (local_28._4_4_ == uVar6) {
            bVar7 = uVar4 <= (uint)local_28;
        }
        if (bVar7 && (local_28._4_4_ != uVar6 || (uint)local_28 != uVar4)) {
            local_28 =
                *(undefined8 *)(*(int *)(local_38 + local_30 * 4) + 0x460);
        }
    }
    local_1c = (char *)calloc(1, 0x40);
    snprintf(local_1c, 0x40, "%.10s_%d", "work_generator_thread", 0);
    V_LOCK();
    lVar2 = syscall(0xe0);
    logfmt_raw(auStack_14ec, 0x1000, 0, "%s on pid %ld", local_1c, lVar2);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/god-miner.c",
         0x95, "work_generator_thread", 0x15, 0xd0, 0x28, auStack_14ec);
    prctl(0xf, local_1c);
    local_48 = send_job_timer;
    clock_gettime(1, (timespec *)send_job_timer);
    do {
        do {
            while (true) {
                while (true) {
                    while (true) {
                        while (true) {
                            local_14 = 0;
                            local_18 = (undefined4 *)get_current_pool();
                            if (local_18 != (undefined4 *)0x0)
                                break;
                            V_LOCK();
                            logfmt_raw(auStack_14ec, 0x1000, 0,
                                       "work generator: current pool is NULL");
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/god-miner.c",
                                 0x95, "work_generator_thread", 0x15, 0xe3,
                                 0x14, auStack_14ec);
                        }
                        iVar3 = pool_tget(local_18, local_18 + 0x1dc);
                        if (iVar3 == 0)
                            break;
                        sleep(0);
                    }
                    local_4c = (uint)local_28;
                    local_50 = local_4e4;
                    clock_gettime(1, &local_4ec);
                    local_54 = local_4ec.tv_nsec + (local_4c % 1000000) * 1000;
                    *local_50 = local_4ec.tv_sec + local_54 / 1000000000 +
                                local_4c / 1000000;
                    local_50[1] = local_54 % 1000000000;
                    local_44 = pool_twait_to_be_expected_and_set(
                        local_18, local_18 + 0x1df, 1, 0, local_4e4);
                    if (local_44 != 1)
                        break;
                    V_LOCK();
                    logfmt_raw(auStack_14ec, 0x1000, 0,
                               "pool has been changed");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "god-miner.c",
                         0x95, "work_generator_thread", 0x15, 0xef, 0x14,
                         auStack_14ec);
                    sleep(0);
                }
                if (local_44 == 0x6e) {
                    V_LOCK();
                    logfmt_raw(auStack_14ec, 0x1000, 0,
                               "Wait for new job timeout");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "god-miner.c",
                         0x95, "work_generator_thread", 0x15, 0xf3, 0x14,
                         auStack_14ec);
                } else {
                    V_LOCK();
                    logfmt_raw(auStack_14ec, 0x1000, 0, "New job has come");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "god-miner.c",
                         0x95, "work_generator_thread", 0x15, 0xf5, 0x14,
                         auStack_14ec);
                }
                pthread_mutex_lock((pthread_mutex_t *)(local_18 + 0x18e));
                iVar3 = pool_tget(local_18, local_18 + 0x18c);
                if (iVar3 == 0)
                    break;
                pthread_mutex_unlock((pthread_mutex_t *)(local_18 + 0x18e));
                V_LOCK();
                logfmt_raw(auStack_14ec, 0x1000, 0,
                           "work generator: jobid %p cancel %d",
                           local_18[0x18b], *(undefined1 *)(local_18 + 0x18c));
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "god-miner.c",
                     0x95, "work_generator_thread", 0x15, 0xfb, 0x14,
                     auStack_14ec);
                sleep(0);
            }
            iVar3 = (**(code **)(local_34 + 0x24))(auStack_4d8, local_18);
            if (iVar3 == 2) {
                V_LOCK();
                logfmt_raw(auStack_14ec, 0x1000, 0,
                           "poolno=%d work generator switched to new job %s",
                           *local_18, local_18[0x18b]);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "god-miner.c",
                     0x95, "work_generator_thread", 0x15, 0x102, 0x14,
                     auStack_14ec);
                bVar7 = 0xfffffffe < (uint)total_getworks;
                total_getworks._0_4_ = (uint)total_getworks + 1;
                total_getworks._4_4_ = total_getworks._4_4_ + (uint)bVar7;
                local_18[0x198] = local_18[0x198] + 1;
                FUN_0002a644(auStack_4d8);
                FUN_0002a68c(auStack_4d8, local_18 + 0x72);
                local_29 = '\x01';
            }
            pthread_mutex_unlock((pthread_mutex_t *)(local_18 + 0x18e));
        } while (local_74 == 0);
        local_90 = local_18[0x14];
        for (local_30 = 0; local_30 < local_4dc; local_30 = local_30 + 1) {
            pthread_mutex_lock((pthread_mutex_t *)(local_18 + 0x18e));
            iVar3 = (**(code **)(local_34 + 0x24))(auStack_4d8, local_18);
            if (iVar3 == 2) {
                pthread_mutex_unlock((pthread_mutex_t *)(local_18 + 0x18e));
                break;
            }
            if ((local_29 == '\0') || (local_30 != 0)) {
                uVar5 = 0;
            } else {
                uVar5 = 1;
            }
            (*(code *)**(undefined4 **)(local_34 + 0x48))(auStack_4d8, local_18,
                                                          uVar5);
            pthread_mutex_unlock((pthread_mutex_t *)(local_18 + 0x18e));
            local_work = local_work + 1;
            last_getwork = time((time_t *)0x0);
            (**(code **)(*(int *)(local_34 + 0x48) + 4))(
                *(undefined4 *)(local_38 + local_30 * 4), auStack_4d8);
        }
        if (local_29 == '\0') {
            V_LOCK();
            local_5c = (int *)send_job_timer;
            clock_gettime(1, (timespec *)(send_job_timer + 8));
            iVar3 = local_5c[2] - *local_5c;
            uVar8 = VectorShiftLeft((longlong)iVar3, 5, 0x40, 0);
            uVar8 = VectorSub(uVar8, (longlong)iVar3, 8);
            uVar8 = VectorAdd(uVar8, uVar8, 8);
            uVar4 = (uint)uVar8;
            uVar8 = VectorAdd(CONCAT44((int)((ulonglong)uVar8 >> 0x20) * 2 +
                                           (uint)CARRY4(uVar4, uVar4),
                                       uVar4 * 2),
                              (longlong)iVar3, 8);
            uVar8 = VectorShiftLeft(uVar8, 3, 0x40, 0);
            uVar4 = (local_5c[3] - local_5c[1]) / 1000000;
            logfmt_raw(auStack_14ec, 0x1000, 0,
                       "Updated job pushed after %lld ms", uVar4 + (uint)uVar8,
                       ((int)uVar4 >> 0x1f) + (int)((ulonglong)uVar8 >> 0x20) +
                           (uint)CARRY4(uVar4, (uint)uVar8));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/god-miner.c",
                 0x95, "work_generator_thread", 0x15, 0x123, 0x14,
                 auStack_14ec);
        } else {
            local_29 = '\0';
            V_LOCK();
            local_58 = (int *)send_job_timer;
            clock_gettime(1, (timespec *)(send_job_timer + 8));
            iVar3 = local_58[2] - *local_58;
            uVar8 = VectorShiftLeft((longlong)iVar3, 5, 0x40, 0);
            uVar8 = VectorSub(uVar8, (longlong)iVar3, 8);
            uVar8 = VectorAdd(uVar8, uVar8, 8);
            uVar4 = (uint)uVar8;
            uVar8 = VectorAdd(CONCAT44((int)((ulonglong)uVar8 >> 0x20) * 2 +
                                           (uint)CARRY4(uVar4, uVar4),
                                       uVar4 * 2),
                              (longlong)iVar3, 8);
            uVar8 = VectorShiftLeft(uVar8, 3, 0x40, 0);
            uVar4 = (local_58[3] - local_58[1]) / 1000000;
            logfmt_raw(auStack_14ec, 0x1000, 0, "New job pushed after %lld ms",
                       uVar4 + (uint)uVar8,
                       ((int)uVar4 >> 0x1f) + (int)((ulonglong)uVar8 >> 0x20) +
                           (uint)CARRY4(uVar4, (uint)uVar8));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/god-miner.c",
                 0x95, "work_generator_thread", 0x15, 0x121, 0x14,
                 auStack_14ec);
        }
        local_64 = (int *)send_job_timer;
        clock_gettime(1, (timespec *)(send_job_timer + 8));
        lVar1 = (ulonglong)(uint)(local_64[2] - *local_64) * 1000000;
        uVar6 = (uint)lVar1;
        uVar4 = (local_64[3] - local_64[1]) / 1000;
        update_recorded_timeout_value(
            uVar6 + uVar4, (local_64[2] - *local_64 >> 0x1f) * 1000000 +
                               (int)((ulonglong)lVar1 >> 0x20) +
                               ((int)uVar4 >> 0x1f) +
                               (uint)CARRY4(uVar6, uVar4));
        local_60 = send_job_timer;
        clock_gettime(1, (timespec *)send_job_timer);
    } while (true);
}

void nonce_submit_thread(undefined4 param_1)

{
    long lVar1;
    pthread_t __th;
    bool bVar2;
    undefined1 auStack_2068[4096];
    uint local_1068;
    uint uStack_1064;
    undefined1 auStack_4b0[1136];
    undefined1 auStack_40[4];
    uint *local_3c;
    int local_38;
    char *local_34;
    int *local_30;
    int local_2c;
    undefined8 uStack_28;
    int local_1c;
    undefined4 local_18;
    int local_14;

    uStack_28 = 0;
    local_1c = 0;
    local_18 = param_1;
    local_14 = frontend_runtime_instance();
    local_30 = (int *)get_all_created_runtime(auStack_40);
    local_34 = (char *)calloc(1, 0x40);
    snprintf(local_34, 0x40, "%.10s_%d", "nonce_submit_thread", 0);
    V_LOCK();
    lVar1 = syscall(0xe0);
    logfmt_raw(auStack_2068, 0x1000, 0, "%s on pid %ld", local_34, lVar1);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/god-miner.c",
         0x95, "nonce_submit_thread", 0x13, 0x13d, 0x28, auStack_2068);
    prctl(0xf, local_34);
    __th = pthread_self();
    pthread_detach(__th);
    local_38 = *local_30;
    do {
        (**(code **)(local_38 + 0x2c))(local_38, &local_1068);
        local_3c = &local_1068;
        bVar2 = (uint)((int)total_pools >> 0x1f) <= uStack_1064;
        if (uStack_1064 == (int)total_pools >> 0x1f) {
            bVar2 = total_pools <= local_1068;
        }
        if (bVar2) {
            local_2c = 0;
        } else {
            local_2c = *(int *)(pools + local_1068 * 4);
        }
        if (local_2c == 0) {
            V_LOCK();
            logfmt_raw(auStack_2068, 0x1000, 0, "the pool is NULL");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/god-miner.c",
                 0x95, "nonce_submit_thread", 0x13, 0x14c, 0x50, auStack_2068);
        } else {
            pthread_mutex_lock((pthread_mutex_t *)(local_2c + 0x638));
            FUN_0002a644(auStack_4b0);
            FUN_0002a68c(auStack_4b0, local_2c + 0x1c8);
            local_1c = (**(code **)(*(int *)(local_14 + 0x48) + 8))(
                auStack_4b0, local_2c, &local_1068);
            pthread_mutex_unlock((pthread_mutex_t *)(local_2c + 0x638));
            if (local_1c == 1) {
                bVar2 = 0xfffffffe < (uint)total_stale;
                total_stale._0_4_ = (uint)total_stale + 1;
                total_stale._4_4_ = total_stale._4_4_ + (uint)bVar2;
                *(int *)(local_2c + 0x668) = *(int *)(local_2c + 0x668) + 1;
                *(double *)(local_2c + 0x718) = *(double *)(local_2c + 0x718) +
                                                *(double *)(local_2c + 0x710);
                total_diff_stale =
                    *(double *)(local_2c + 0x710) + total_diff_stale;
            } else {
                workio_submit_work(auStack_4b0, local_2c);
            }
        }
    } while (true);
}

void parse_arg(int param_1, char *param_2)

{
    char *pcVar1;
    int iVar2;
    int local_1114[23];
    undefined1 auStack_10b8[160];
    undefined1 auStack_1018[4096];
    int *local_18;
    int local_14;
    size_t local_10;
    int local_c;

    pcVar1 = param_2;
    if (param_1 != 0x76) {
        pcVar1 = opt_version_path;
        if (param_1 < 0x77) {
            if (param_1 == 99) {
                local_18 = (int *)json_load_file(param_2, 0, local_1114);
                if ((local_18 == (int *)0x0) || (*local_18 != 0)) {
                    if (local_1114[0] < 0) {
                        V_LOCK();
                        logfmt_raw(auStack_1018, 0x1000, 0, &DAT_000d7154,
                                   auStack_10b8);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/god-miner.c",
                             0x95, "parse_arg", 9, 399, 100, auStack_1018);
                    } else {
                        V_LOCK();
                        logfmt_raw(auStack_1018, 0x1000, 0, "%s:%d: %s",
                                   param_2, local_1114[0], auStack_10b8);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/god-miner.c",
                             0x95, "parse_arg", 9, 0x191, 100, auStack_1018);
                    }
                } else {
                    parse_config(local_18, param_2);
                    FUN_0002a4d0(local_18);
                }
                if (default_config != (char *)0x0) {
                    free(default_config);
                    default_config = (char *)0x0;
                }
                default_config = strdup(param_2);
                pcVar1 = opt_version_path;
            } else if (param_1 < 100) {
                if (param_1 == 0x50) {
                    opt_protocol = 1;
                } else if (param_1 == 0x61) {
                    for (local_14 = 0; local_14 < 0xe;
                         local_14 = local_14 + 1) {
                        local_10 = strlen((&PTR_s_ckb_2040_0014d568)[local_14]);
                        if (((local_10 != 0) &&
                             (iVar2 = strncasecmp(
                                  param_2, (&PTR_s_ckb_2040_0014d568)[local_14],
                                  local_10),
                              iVar2 == 0)) &&
                            (param_2[local_10] == '\0')) {
                            opt_algo = local_14;
                            break;
                        }
                    }
                    pcVar1 = opt_version_path;
                    if (local_14 == 0xe) {
                        V_LOCK();
                        logfmt_raw(auStack_1018, 0x1000, 0,
                                   "Unknown algo parameter \'%s\'", param_2);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/god-miner.c",
                             0x95, "parse_arg", 9, 0x17e, 100, auStack_1018);
                        pcVar1 = opt_version_path;
                    }
                } else {
                    if (param_1 != 0x46)
                        goto LAB_0002c8f0;
                    fan_pwm_fixed = 1;
                }
            } else if (param_1 == 0x6f) {
                local_c = set_url(param_2);
                pcVar1 = opt_version_path;
                if (local_c != 0) {
                    V_LOCK();
                    logfmt_raw(auStack_1018, 0x1000, 0, &DAT_000d7154, local_c);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "god-miner.c",
                         0x95, "parse_arg", 9, 0x1b7, 100, auStack_1018);
                    pcVar1 = opt_version_path;
                }
            } else {
                if (param_1 < 0x70) {
                    if (param_1 == 0x68) {
                        V_LOCK();
                        logfmt_raw(
                            auStack_1018, 0x1000, 0,
                            "Usage: GODMINER [OPTIONS]\nOptions:\n  -a, "
                            "--algo=ALGO       specify the algorithm to use\n  "
                            "                        eth_1798         ethash\n "
                            "                         ckb_2040         "
                            "eaglesong\n                          ckb_2042     "
                            "    eaglesong\n                          kda_2110 "
                            "        blake2s\n                          "
                            "dcr_1727         blaker14\n                       "
                            "   hns_2130         blake2s\n                     "
                            "     dash_1766        x11\n                       "
                            "   xmr_2042         xmr\n  -o, --url=URL         "
                            "URL of mining server\n  -u, --user=USERNAME   "
                            "username for mining server\n  -p, --pass=PASSWORD "
                            "  password for mining server\n  -P, --protocol    "
                            "    verbose dump of protocol-level activities\n   "
                            "   --api-remote      Allow remote control\n  -c, "
                            "--config=FILE     load a JSON-format "
                            "configuration file\n  -v, --version         "
                            "display version information and exit\n  -F, "
                            "--bitmain-fan-ctrl  set if fixed fan\'s pwm\n     "
                            " --bitmain-fan-pwm=N set pwm value when fan pwm "
                            "fixed\n      --bitmain-freq=N  set working freq\n "
                            "     --bitmain-voltage=N  set working power "
                            "voltage\n  -z, --zlog=FILE       load a zlog "
                            "configuration file\n  -h, --help            "
                            "display this help text and exit\n");
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/god-miner.c",
                             0x95, "parse_arg", 9, 0x1ed, 0x28, auStack_1018);
                        /* WARNING: Subroutine does not return */
                        exit(0);
                    }
                LAB_0002c8f0:
                    V_LOCK();
                    logfmt_raw(auStack_1018, 0x1000, 0,
                               "unknow config parameter!");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "god-miner.c",
                         0x95, "parse_arg", 9, 0x206, 100, auStack_1018);
                    /* WARNING: Subroutine does not return */
                    exit(1);
                }
                if (param_1 == 0x70) {
                    local_c = set_pass(param_2);
                    if (local_c == 0) {
                        FUN_0002a99c(param_2);
                        pcVar1 = opt_version_path;
                    } else {
                        V_LOCK();
                        logfmt_raw(auStack_1018, 0x1000, 0, &DAT_000d7154,
                                   local_c);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/god-miner.c",
                             0x95, "parse_arg", 9, 0x1a2, 100, auStack_1018);
                        pcVar1 = opt_version_path;
                    }
                } else {
                    if (param_1 != 0x75)
                        goto LAB_0002c8f0;
                    local_c = set_user(param_2);
                    pcVar1 = opt_version_path;
                    if (local_c != 0) {
                        V_LOCK();
                        logfmt_raw(auStack_1018, 0x1000, 0, &DAT_000d7154,
                                   local_c);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/god-miner.c",
                             0x95, "parse_arg", 9, 0x1af, 100, auStack_1018);
                        pcVar1 = opt_version_path;
                    }
                }
            }
        } else if (param_1 != 0x409) {
            if (param_1 < 0x40a) {
                if (param_1 == 0x406) {
                    opt_api_remote = 1;
                } else if (param_1 != 0x408) {
                    if (param_1 != 0x7a)
                        goto LAB_0002c8f0;
                    if (opt_zlog_conf_file != (char *)0x0) {
                        free(opt_zlog_conf_file);
                    }
                    opt_zlog_conf_file = strdup(param_2);
                    pcVar1 = opt_version_path;
                }
            } else if (param_1 == 0x40b) {
                local_10 = atoi(param_2);
                V_LOCK();
                logfmt_raw(auStack_1018, 0x1000, 0, "1035 v: %d!", local_10);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "god-miner.c",
                     0x95, "parse_arg", 9, 0x1e3, 0x28, auStack_1018);
                if ((local_10 == 0) || (local_10 == 1)) {
                    opt_custom_power_mode = (undefined1)local_10;
                    pcVar1 = opt_version_path;
                } else {
                    V_LOCK();
                    logfmt_raw(auStack_1018, 0x1000, 0,
                               "power mode value error!");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "god-miner.c",
                         0x95, "parse_arg", 9, 0x1e5, 100, auStack_1018);
                    pcVar1 = opt_version_path;
                }
            } else if (param_1 < 0x40b) {
                local_10 = atoi(param_2);
                if (((int)local_10 < 0) || (100 < (int)local_10)) {
                    V_LOCK();
                    logfmt_raw(auStack_1018, 0x1000, 0, "fan_pwm value error!");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "god-miner.c",
                         0x95, "parse_arg", 9, 0x1da, 100, auStack_1018);
                    /* WARNING: Subroutine does not return */
                    exit(1);
                }
                if ((int)local_10 < 0x1e) {
                    V_LOCK();
                    logfmt_raw(
                        auStack_1018, 0x1000, 0,
                        "fan-pwm shouldn\'t be set to %d, reset it to %d!",
                        local_10, 0x1e);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "god-miner.c",
                         0x95, "parse_arg", 9, 0x1de, 0x50, auStack_1018);
                }
                fan_pwm = 0x1e;
                pcVar1 = opt_version_path;
                if (0x1e < (int)local_10) {
                    fan_pwm = local_10;
                }
            } else if (param_1 != 0x40c) {
                if (param_1 != 0x7ee)
                    goto LAB_0002c8f0;
                iVar2 = strcmp(param_2, "app");
                if (iVar2 == 0) {
                    chip_update_param = 1;
                } else {
                    iVar2 = strcmp(param_2, "fir");
                    if (iVar2 != 0) {
                        V_LOCK();
                        logfmt_raw(auStack_1018, 0x1000, 0, "invalid input!\n");
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/god-miner.c",
                             0x95, "parse_arg", 9, 0x200, 100, auStack_1018);
                        /* WARNING: Subroutine does not return */
                        exit(1);
                    }
                    chip_update_param = 0;
                }
                opt_chip_update = 1;
                pcVar1 = opt_version_path;
            }
        }
    }
    opt_version_path = pcVar1;
    return;
}

void parse_config(undefined4 param_1)

{
    char *__s;
    undefined4 uVar1;
    uint uVar2;
    undefined8 uVar3;
    undefined1 auStack_103c[4096];
    char acStack_3c[16];
    char acStack_2c[16];
    int *local_1c;
    char *local_18;
    int *local_14;
    uint local_10;
    int local_c;

    for (local_c = 0;
         (local_c < 0x13 && (*(int *)(&DAT_000d7024 + local_c * 0x10) != 0));
         local_c = local_c + 1) {
        local_14 = (int *)json_object_get(
            param_1, *(undefined4 *)(&DAT_000d7024 + local_c * 0x10));
        if (local_14 != (int *)0x0) {
            if (((*(int *)(&DAT_000d7028 + local_c * 0x10) == 0) ||
                 (local_14 == (int *)0x0)) ||
                (*local_14 != 2)) {
                if (((*(int *)(&DAT_000d7028 + local_c * 0x10) == 0) ||
                     (local_14 == (int *)0x0)) ||
                    (*local_14 != 3)) {
                    if (((*(int *)(&DAT_000d7028 + local_c * 0x10) == 0) ||
                         (local_14 == (int *)0x0)) ||
                        (*local_14 != 4)) {
                        if (((*(int *)(&DAT_000d7028 + local_c * 0x10) == 0) ||
                             (local_14 == (int *)0x0)) ||
                            (*local_14 != 1)) {
                            if (*(int *)(&DAT_000d7028 + local_c * 0x10) == 0) {
                                if ((local_14 != (int *)0x0) &&
                                    (*local_14 == 5)) {
                                    parse_arg(*(undefined4 *)(&DAT_000d7030 +
                                                              local_c * 0x10),
                                              &DAT_000d746c);
                                }
                            } else {
                                V_LOCK();
                                logfmt_raw(auStack_103c, 0x1000, 0,
                                           "JSON option %s invalid",
                                           *(undefined4 *)(&DAT_000d7024 +
                                                           local_c * 0x10));
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/"
                                     "god-miner.c",
                                     0x95, "parse_config", 0xc, 0x234, 100,
                                     auStack_103c);
                            }
                        } else {
                            local_10 = 0;
                            while ((uVar2 = json_array_size(local_14),
                                    local_10 < uVar2 &&
                                        (local_1c = (int *)json_array_get(
                                             local_14, local_10),
                                         local_1c != (int *)0x0))) {
                                if ((local_1c == (int *)0x0) ||
                                    (*local_1c != 0)) {
                                    V_LOCK();
                                    logfmt_raw(auStack_103c, 0x1000, 0,
                                               "JSON %s array value invalid",
                                               *(undefined4 *)(&DAT_000d7024 +
                                                               local_c * 0x10));
                                    V_UNLOCK();
                                    zlog(g_zc,
                                         "/workspace/jenkins/jenkins/workspace/"
                                         "Antminer_L9_CVCtrl_release/build/"
                                         "rootfs/buildroot/tmp/release/build/"
                                         "godminer-origin_godminer-branch1/"
                                         "god-miner.c",
                                         0x95, "parse_config", 0xc, 0x22c, 100,
                                         auStack_103c);
                                } else {
                                    parse_config(local_1c, 0);
                                }
                                local_10 = local_10 + 1;
                            }
                        }
                    } else {
                        uVar3 = json_real_value(local_14);
                        sprintf(acStack_3c, "%f", (int)uVar3,
                                (int)((ulonglong)uVar3 >> 0x20));
                        parse_arg(
                            *(undefined4 *)(&DAT_000d7030 + local_c * 0x10),
                            acStack_3c);
                    }
                } else {
                    uVar1 = json_integer_value(local_14);
                    sprintf(acStack_2c, "%d", uVar1);
                    parse_arg(*(undefined4 *)(&DAT_000d7030 + local_c * 0x10),
                              acStack_2c);
                }
            } else {
                __s = (char *)json_string_value(local_14);
                local_18 = strdup(__s);
                if (local_18 == (char *)0x0) {
                    return;
                }
                parse_arg(*(undefined4 *)(&DAT_000d7030 + local_c * 0x10),
                          local_18);
                free(local_18);
            }
        }
    }
    return;
}

void FUN_0002ce3c(int param_1, undefined4 *param_2)

{
    undefined1 auStack_100c[4096];
    int local_c;

    while (true) {
        local_c =
            getopt_long(param_1, param_2, "a:c:hp:Po:u:v:F", &DAT_000d7024, 0);
        if (local_c < 0)
            break;
        parse_arg(local_c, optarg);
    }
    if (optind < param_1) {
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0,
                   "%s: unsupported non-option argument -- \'%s\'", *param_2,
                   param_2[optind]);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "parse_cmdline", 0xd, 0x244, 100, auStack_100c);
        /* WARNING: Subroutine does not return */
        exit(1);
    }
    return;
}

void FUN_0002cfb4(undefined4 param_1)

{
    undefined1 auStack_1008[4096];

    switch (param_1) {
    case 2:
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, "SIGINT received, exiting");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "signal_handler", 0xe, 0x24e, 0x50, auStack_1008);
        print_summary();
        /* WARNING: Subroutine does not return */
        exit(0);
    case 3:
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, "SIGQUIT received, exiting");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "signal_handler", 0xe, 0x253, 0x50, auStack_1008);
        print_summary();
        /* WARNING: Subroutine does not return */
        exit(0);
    default:
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0,
                   "catch signal %d, it should not be here");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "signal_handler", 0xe, 0x266, 0x50, auStack_1008);
        break;
    case 10:
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, "SIGUSR1 received, reload log");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "signal_handler", 0xe, 0x262, 0x50, auStack_1008);
        log_reload();
        break;
    case 0xb:
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, "SIGSEGV received, exiting");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "signal_handler", 0xe, 0x25d, 0x50, auStack_1008);
        print_summary();
        /* WARNING: Subroutine does not return */
        exit(0);
    case 0xf:
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, "SIGTERM received, exiting");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "signal_handler", 0xe, 600, 0x50, auStack_1008);
        print_summary();
        /* WARNING: Subroutine does not return */
        exit(0);
    }
    return;
}

void FUN_0002d2f4(void)

{
    undefined1 auStack_1014[4096];
    uint local_14;
    uint local_10;
    uint local_c;

    local_10 = 0x10302456;
    local_10 = get_hardware_version();
    local_c = (int)local_10 >> 0x10 & 0xff;
    local_14 = local_10 & 0xff;
    V_LOCK();
    logfmt_raw(auStack_1014, 0x1000, 0, "godminer Version = 0x%04X %s",
               local_10 & 0xffff,
               "2.0.0_release_clean_master_"
               "62efe336adce4a2cd0126a04d0c912151939985c_Aug 21 2024 19:33:46");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/god-miner.c",
         0x95, "init_miner_version", 0x12, 0x291, 0x28, auStack_1014);
    sprintf(g_miner_version, "%d.%d-%s", local_14, local_c, "2.0.0");
    return;
}

void make_fake_version(void)

{
    char acStack_48[64];

    sprintf(acStack_48, "%s %s", "Aug 21 2024", "19:33:46");
    strcpy(g_miner_compiletime, acStack_48);
    g_miner_type[0] = 'A';
    g_miner_type[1] = 'n';
    g_miner_type[2] = 't';
    g_miner_type[3] = 'm';
    g_miner_type[4] = 'i';
    g_miner_type[5] = 'n';
    g_miner_type[6] = 'e';
    g_miner_type[7] = 'r';
    g_miner_type[8] = ' ';
    g_miner_type[9] = 'u';
    g_miner_type[10] = 'n';
    g_miner_type[0xb] = 'k';
    g_miner_type[0xc] = 'n';
    g_miner_type[0xd] = 'o';
    g_miner_type[0xe] = 'w';
    g_miner_type[0xf] = '\0';
    return;
}

void read_version_file(void)

{
    size_t sVar1;
    undefined1 auStack_1114[4096];
    char acStack_114[256];
    FILE *local_14;
    size_t local_10;
    char *local_c;

    local_14 = fopen(opt_version_path, "rb");
    memset(acStack_114, 0, 0x100);
    local_10 = 0;
    local_c = (char *)0x0;
    if (local_14 == (FILE *)0x0) {
        V_LOCK();
        logfmt_raw(auStack_1114, 0x1000, 0, "Open miner version file %s error",
                   opt_version_path);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "read_version_file", 0x11, 0x2a5, 100, auStack_1114);
    } else {
        local_10 = fread(acStack_114, 1, 0x100, local_14);
        if ((int)local_10 < 1) {
            V_LOCK();
            logfmt_raw(auStack_1114, 0x1000, 0,
                       "Read miner version file %s error %d", opt_version_path,
                       local_10);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/god-miner.c",
                 0x95, "read_version_file", 0x11, 0x2aa, 100, auStack_1114);
        } else {
            local_c = strchr(acStack_114, 10);
            if (local_c == (char *)0x0) {
                strcpy(g_miner_compiletime, acStack_114);
            } else {
                memcpy(g_miner_compiletime, acStack_114,
                       (int)local_c - (int)acStack_114);
                strcpy(acStack_114, local_c + 1);
                local_c = strchr(acStack_114, 10);
                if (local_c == (char *)0x0) {
                    strcpy(g_miner_type, acStack_114);
                } else {
                    memcpy(g_miner_type, acStack_114,
                           (int)local_c - (int)acStack_114);
                }
            }
            sVar1 = strlen(g_miner_compiletime);
            if (g_miner_version[sVar1 + 0x3f] == '\n') {
                sVar1 = strlen(g_miner_compiletime);
                g_miner_version[sVar1 + 0x3f] = 0;
            }
            sVar1 = strlen(g_miner_compiletime);
            if (g_miner_version[sVar1 + 0x3f] == '\r') {
                sVar1 = strlen(g_miner_compiletime);
                g_miner_version[sVar1 + 0x3f] = 0;
            }
            sVar1 = strlen(g_miner_type);
            if (g_miner_compiletime[sVar1 + 0x3f] == '\n') {
                sVar1 = strlen(g_miner_type);
                g_miner_compiletime[sVar1 + 0x3f] = 0;
            }
            sVar1 = strlen(g_miner_type);
            if (g_miner_compiletime[sVar1 + 0x3f] == '\r') {
                sVar1 = strlen(g_miner_type);
                g_miner_compiletime[sVar1 + 0x3f] = 0;
            }
        }
    }
    V_LOCK();
    logfmt_raw(auStack_1114, 0x1000, 0, "Miner compile time: %s type: %s",
               g_miner_compiletime, g_miner_type);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/god-miner.c",
         0x95, "read_version_file", 0x11, 0x2cd, 0x3c, auStack_1114);
    return;
}

/* WARNING: Restarted to delay deadcode elimination for space: stack */

uint godminer_chip_status_monitor(int param_1)

{
    char cVar1;
    uint uVar2;
    undefined8 uVar3;
    undefined4 uVar4;
    undefined8 in_d17;
    undefined1 auStack_1060[4096];
    undefined1 local_60[44];
    undefined4 local_34;
    uint *local_30;
    undefined4 local_2c;
    int local_28;
    undefined4 local_24;
    uint *local_20;
    int local_1c;
    int local_18;
    int local_14;

    local_14 = get_flag_from_monitor(param_1);
    local_18 = get_current_pool();
    local_1c = get_miner_working_status_p();
    local_20 = (uint *)(local_14 + 0x30);
    local_24 = 1;
    /* WARNING: Ignoring partial resolution of indirect */
    uVar4 = 1;
    uVar3 = VectorShiftLeft(1, in_d17, 8, 1);
    if (((uint)uVar3 & *(uint *)(local_14 + 0x30)) != 0 ||
        ((uint)((ulonglong)uVar3 >> 0x20) & *(uint *)(local_14 + 0x34)) != 0) {
        cVar1 = pool_tget(local_18, local_18 + 0x770);
        if (cVar1 != '\x01') {
            set_miner_6060info_runtime_bad_asic_err(
                *(undefined4 *)(param_1 + 0xfc), 1);
            *(undefined1 *)(local_1c + 0x10) = 1;
        }
        local_28 = local_14 + 0x30;
        local_2c = 1;
        /* WARNING: Ignoring partial resolution of indirect */
        uVar4 = 1;
        uVar3 = VectorShiftLeft(1, in_d17, 8, 1);
        *(uint *)(local_14 + 0x38) = (uint)uVar3 | *(uint *)(local_14 + 0x38);
        *(uint *)(local_14 + 0x3c) =
            (uint)((ulonglong)uVar3 >> 0x20) | *(uint *)(local_14 + 0x3c);
    }
    local_30 = (uint *)(local_14 + 0x30);
    local_34 = 2;
    /* WARNING: Ignoring partial resolution of indirect */
    uVar4 = 2;
    uVar3 = VectorShiftLeft(1, in_d17, 8, 1);
    uVar2 = (uint)(((uint)uVar3 & *local_30) != 0 ||
                   ((uint)((ulonglong)uVar3 >> 0x20) &
                    *(uint *)(local_14 + 0x34)) != 0);
    if (uVar2 != 0) {
        cVar1 = pool_tget(local_18, local_18 + 0x770);
        if (cVar1 != '\x01') {
            V_LOCK();
            FUN_0002a570(local_60, local_60, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(auStack_1060, 0x1000, 0);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/god-miner.c",
                 0x95, "godminer_chip_status_monitor");
            set_miner_6060info_runtime_bad_asic_err(
                *(undefined4 *)(param_1 + 0xfc), 1);
            *(undefined1 *)(local_1c + 0x11) = 1;
        }
        /* WARNING: Ignoring partial resolution of indirect */
        uVar4 = 2;
        uVar3 = VectorShiftLeft(1, in_d17, 8, 1);
        uVar2 = (uint)((ulonglong)uVar3 >> 0x20) | *(uint *)(local_14 + 0x3c);
        *(uint *)(local_14 + 0x38) = (uint)uVar3 | *(uint *)(local_14 + 0x38);
        *(uint *)(local_14 + 0x3c) = uVar2;
    }
    return uVar2;
}

/* WARNING: Restarted to delay deadcode elimination for space: stack */

uint godminer_fan_monitor(int param_1)

{
    uint uVar1;
    undefined8 uVar2;
    undefined4 uVar3;
    undefined8 in_d17;
    undefined1 auStack_1078[4096];
    undefined1 local_78[32];
    undefined1 local_58[40];
    undefined4 local_30;
    uint *local_2c;
    undefined4 local_28;
    int local_24;
    undefined4 local_20;
    uint *local_1c;
    uint local_18;
    int local_14;

    *(int *)(&DAT_00151858 + *(int *)(param_1 + 0xf8) * 4) =
        *(int *)(&DAT_00151858 + *(int *)(param_1 + 0xf8) * 4) + 1;
    local_18 = get_miner_working_status_p();
    local_14 = get_flag_from_monitor(param_1);
    local_1c = (uint *)(local_14 + 0x20);
    local_20 = 1;
    /* WARNING: Ignoring partial resolution of indirect */
    uVar3 = 1;
    uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
    if (((uint)uVar2 & *(uint *)(local_14 + 0x20)) != 0 ||
        ((uint)((ulonglong)uVar2 >> 0x20) & *(uint *)(local_14 + 0x24)) != 0) {
        V_LOCK();
        FUN_0002a538(local_78, "fan lost");
        logfmt_raw(auStack_1078, 0x1000, 0);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "godminer_fan_monitor");
        V_LOCK();
        logfmt_raw(auStack_1078, 0x1000, 0, "Sweep error string = %s.");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "godminer_fan_monitor");
        local_24 = local_14 + 0x20;
        local_28 = 1;
        /* WARNING: Ignoring partial resolution of indirect */
        uVar3 = 1;
        uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
        *(uint *)(local_14 + 0x28) = (uint)uVar2 | *(uint *)(local_14 + 0x28);
        *(uint *)(local_14 + 0x2c) =
            (uint)((ulonglong)uVar2 >> 0x20) | *(uint *)(local_14 + 0x2c);
        *(undefined1 *)(local_18 + 0x12) = 1;
    }
    local_2c = (uint *)(local_14 + 0x20);
    local_30 = 0;
    /* WARNING: Ignoring partial resolution of indirect */
    uVar3 = 0;
    uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
    uVar1 = (uint)(((uint)uVar2 & *local_2c) != 0 ||
                   ((uint)((ulonglong)uVar2 >> 0x20) &
                    *(uint *)(local_14 + 0x24)) != 0);
    if (uVar1 != 0) {
        V_LOCK();
        FUN_0002a538(local_58, "fan slow");
        logfmt_raw(auStack_1078, 0x1000, 0);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "godminer_fan_monitor");
        /* WARNING: Ignoring partial resolution of indirect */
        uVar3 = 0;
        uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
        *(uint *)(local_14 + 0x28) = (uint)uVar2 | *(uint *)(local_14 + 0x28);
        *(uint *)(local_14 + 0x2c) =
            (uint)((ulonglong)uVar2 >> 0x20) | *(uint *)(local_14 + 0x2c);
        *(undefined1 *)(local_18 + 0x13) = 1;
        uVar1 = local_18;
    }
    return uVar1;
}

void godminer_register_status_monitor(void)

{
    add_chip_status_observer(godminer_chip_status_monitor);
    add_fanspeed_observer(godminer_fan_monitor);
    return;
}

int FUN_0002df70(undefined4 param_1)

{
    char *pcVar1;
    ushort **ppuVar2;
    size_t sVar3;
    char local_180[352];
    int local_20;
    size_t local_1c;
    FILE *local_18;
    uint local_14;
    uint local_10;
    int local_c;

    memset(local_180 + 0x60, 0, 0x100);
    local_c = 0;
    local_180[0x20] = '\0';
    local_180[0x21] = '\0';
    local_180[0x22] = '\0';
    local_180[0x23] = '\0';
    local_180[0x24] = '\0';
    local_180[0x25] = '\0';
    local_180[0x26] = '\0';
    local_180[0x27] = '\0';
    local_180[0x28] = '\0';
    local_180[0x29] = '\0';
    local_180[0x2a] = '\0';
    local_180[0x2b] = '\0';
    local_180[0x2c] = '\0';
    local_180[0x2d] = '\0';
    local_180[0x2e] = '\0';
    local_180[0x2f] = '\0';
    local_180[0x30] = '\0';
    local_180[0x31] = '\0';
    local_180[0x32] = '\0';
    local_180[0x33] = '\0';
    local_180[0x34] = '\0';
    local_180[0x35] = '\0';
    local_180[0x36] = '\0';
    local_180[0x37] = '\0';
    local_180[0x38] = '\0';
    local_180[0x39] = '\0';
    local_180[0x3a] = '\0';
    local_180[0x3b] = '\0';
    local_180[0x3c] = '\0';
    local_180[0x3d] = '\0';
    local_180[0x3e] = '\0';
    local_180[0x3f] = '\0';
    local_180[0x40] = '\0';
    local_180[0x41] = '\0';
    local_180[0x42] = '\0';
    local_180[0x43] = '\0';
    local_180[0x44] = '\0';
    local_180[0x45] = '\0';
    local_180[0x46] = '\0';
    local_180[0x47] = '\0';
    local_180[0x48] = '\0';
    local_180[0x49] = '\0';
    local_180[0x4a] = '\0';
    local_180[0x4b] = '\0';
    local_180[0x4c] = '\0';
    local_180[0x4d] = '\0';
    local_180[0x4e] = '\0';
    local_180[0x4f] = '\0';
    local_180[0x50] = '\0';
    local_180[0x51] = '\0';
    local_180[0x52] = '\0';
    local_180[0x53] = '\0';
    local_180[0x54] = '\0';
    local_180[0x55] = '\0';
    local_180[0x56] = '\0';
    local_180[0x57] = '\0';
    local_180[0x58] = '\0';
    local_180[0x59] = '\0';
    local_180[0x5a] = '\0';
    local_180[0x5b] = '\0';
    local_180[0x5c] = '\0';
    local_180[0x5d] = '\0';
    local_180[0x5e] = '\0';
    local_180[0x5f] = '\0';
    snprintf(local_180 + 0x20, 0x40, "pidof %s", param_1);
    local_18 = popen(local_180 + 0x20, "r");
    if (local_18 != (FILE *)0x0) {
        do {
            pcVar1 = fgets(local_180 + 0x60, 0x100, local_18);
        } while (pcVar1 != (char *)0x0);
        pclose(local_18);
        local_18 = (FILE *)0x0;
        local_10 = 0;
        local_14 = 1;
        while (sVar3 = strlen(local_180 + 0x60), local_14 <= sVar3) {
            local_180[0] = '\0';
            local_180[1] = '\0';
            local_180[2] = '\0';
            local_180[3] = '\0';
            local_180[4] = '\0';
            local_180[5] = '\0';
            local_180[6] = '\0';
            local_180[7] = '\0';
            local_180[8] = '\0';
            local_180[9] = '\0';
            local_180[10] = '\0';
            local_180[0xb] = '\0';
            local_180[0xc] = '\0';
            local_180[0xd] = '\0';
            local_180[0xe] = '\0';
            local_180[0xf] = '\0';
            local_180[0x10] = '\0';
            local_180[0x11] = '\0';
            local_180[0x12] = '\0';
            local_180[0x13] = '\0';
            local_180[0x14] = '\0';
            local_180[0x15] = '\0';
            local_180[0x16] = '\0';
            local_180[0x17] = '\0';
            local_180[0x18] = '\0';
            local_180[0x19] = '\0';
            local_180[0x1a] = '\0';
            local_180[0x1b] = '\0';
            local_180[0x1c] = '\0';
            local_180[0x1d] = '\0';
            local_180[0x1e] = '\0';
            local_180[0x1f] = '\0';
            ppuVar2 = __ctype_b_loc();
            if (((*ppuVar2)[(byte)local_180[local_14 + 0x5f]] & 0x2000) != 0) {
                local_1c = (local_14 - local_10) - 1;
                strncpy(local_180, local_180 + local_10 + 0x60, local_1c);
                local_10 = local_14;
                local_20 = atoi(local_180);
                if (0 < local_20) {
                    local_c = local_c + 1;
                }
            }
            local_14 = local_14 + 1;
        }
    }
    if (0 < local_c) {
        printf("%d instance of %s is already Running on this machine!\n",
               local_c, param_1);
    }
    return local_c;
}

bool FUN_0002e168(void)

{
    int iVar1;

    iVar1 = FUN_0002df70("godminer");
    return 1 < iVar1;
}

void FUN_0002e198(void)

{
    int iVar1;
    int local_1c;
    int local_18;
    int local_14;

    local_1c = 0;
    local_18 = get_all_created_runtime(&local_1c);
    iVar1 = is_eeprom_loaded();
    if (iVar1 != 0) {
        for (local_14 = 0; local_14 < local_1c; local_14 = local_14 + 1) {
            (**(code **)(*(int *)(local_18 + local_14 * 4) + 0xa4))(
                *(undefined4 *)(local_18 + local_14 * 4), 1, opt_custom_freq, 1,
                opt_custom_voltage);
        }
    }
    return;
}

void FUN_0002e254(void)

{
    int iVar1;
    int local_14;
    int local_10;
    int local_c;

    local_14 = 0;
    local_10 = get_all_created_runtime(&local_14);
    local_c = 0;
    while (true) {
        if (local_14 <= local_c)
            break;
        iVar1 = dev_ctrl();
        (**(code **)(iVar1 + 0x50))(
            *(undefined4 *)(*(int *)(local_10 + local_c * 4) + 0xf8));
        local_c = local_c + 1;
    }
    return;
}

uint set_working_voltage_and_runtime_freq(void)

{
    char cVar1;
    int iVar2;
    uint uVar3;
    undefined1 auStack_1030[4096];
    int local_30;
    undefined4 local_2c;
    int local_28;
    int local_24;
    int local_20;
    int local_1c;
    char local_16;
    byte local_15;
    uint local_14;
    int local_10;
    int local_c;

    local_20 = get_working_voltage();
    local_1c = get_current_voltage();
    local_30 = 0;
    local_24 = get_all_created_runtime(&local_30);
    cVar1 = is_power_init();
    if (cVar1 == '\x01') {
        uVar3 = opt_algo;
        if (opt_algo == 8) {
            local_16 = '\0';
            local_15 = 0;
            if (local_20 < local_1c) {
                local_28 = -7;
            } else {
                local_28 = 7;
            }
            local_2c = 0x19;
            while ((local_16 != '\x01' || (uVar3 = local_15 ^ 1, uVar3 != 0))) {
                if (local_16 != '\x01') {
                    local_14 = 0;
                    for (local_10 = 0; local_10 < local_30;
                         local_10 = local_10 + 1) {
                        uVar3 = (**(code **)(*(int *)(local_24 + local_10 * 4) +
                                             0xbc))(
                            *(undefined4 *)(local_24 + local_10 * 4), local_2c);
                        local_14 = uVar3 | local_14;
                    }
                    uVar3 = local_14;
                    if (local_14 == 0) {
                        uVar3 = 1;
                    }
                    local_16 = (char)uVar3;
                    if (local_14 != 0) {
                        local_16 = '\0';
                    }
                    if (local_16 != '\x01') {
                        usleep(200000);
                        for (local_c = 0; local_c < local_30;
                             local_c = local_c + 1) {
                            uVar3 =
                                (**(code **)(*(int *)(local_24 + local_c * 4) +
                                             0xbc))(
                                    *(undefined4 *)(local_24 + local_c * 4),
                                    local_2c);
                            local_14 = uVar3 | local_14;
                        }
                        uVar3 = local_14;
                        if (local_14 == 0) {
                            uVar3 = 1;
                        }
                        local_16 = (char)uVar3;
                        if (local_14 != 0) {
                            local_16 = '\0';
                        }
                    }
                }
                uVar3 = local_1c - local_20 >> 0x1f;
                iVar2 = local_28;
                if (local_28 < 0) {
                    iVar2 = -local_28;
                }
                if (iVar2 < (int)((local_1c - local_20 ^ uVar3) - uVar3)) {
                    local_1c = local_1c + local_28;
                    set_voltage(local_1c, 1);
                } else if (local_1c != local_20) {
                    local_1c = local_20;
                    set_voltage(local_20, 1);
                }
                if (local_1c == local_20) {
                    local_15 = 1;
                }
                FUN_0002e254();
            }
        }
    } else {
        V_LOCK();
        logfmt_raw(auStack_1030, 0x1000, 0, "%s, power has not init!",
                   "set_working_voltage_and_runtime_freq");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "set_working_voltage_and_runtime_freq", 0x24, 0x5d5, 100,
             auStack_1030);
        V_LOCK();
        logfmt_raw(auStack_1030, 0x1000, 0, "Sweep error string = %s.",
                   &DAT_000d777c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "set_working_voltage_and_runtime_freq", 0x24, 0x5d6, 100,
             auStack_1030);
        uVar3 = 0xffffffff;
    }
    return uVar3;
}

void setsystime_basestampfile(void)

{
    int *piVar1;
    char *pcVar2;
    int iVar3;
    undefined1 auStack_1070[72];
    time_t local_1028[4];
    undefined1 auStack_1018[4096];
    time_t local_18;
    FILE *local_14;

    local_14 = (FILE *)0x0;
    local_14 = fopen("/nvdata/timestamp.data", "r+");
    if (local_14 == (FILE *)0x0) {
        local_14 = fopen("/nvdata/timestamp.data", "w+");
        if (local_14 == (FILE *)0x0) {
            V_LOCK();
            piVar1 = __errno_location();
            iVar3 = *piVar1;
            piVar1 = __errno_location();
            pcVar2 = strerror(*piVar1);
            logfmt_raw(auStack_1018, 0x1000, 0,
                       "file op errno = %d reason = %s", iVar3, pcVar2);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/god-miner.c",
                 0x95, "setsystime_basestampfile", 0x18, 0x62f, 0x28,
                 auStack_1018);
            return;
        }
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, "sys time ref file time");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "setsystime_basestampfile", 0x18, 0x635, 0x28, auStack_1018);
        iVar3 = FUN_000ccff8("/config/sn", auStack_1070);
        if (((iVar3 == 0) ||
             (iVar3 = FUN_000ccff8("/config/passwd", auStack_1070),
              iVar3 == 0)) ||
            (iVar3 = FUN_000ccff8("/config/shadow", auStack_1070),
             iVar3 == 0)) {
            fprintf(local_14, "%ld", local_1028[0]);
            stime(local_1028);
        } else {
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, "No ref time file");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/god-miner.c",
                 0x95, "setsystime_basestampfile", 0x18, 0x63d, 0x28,
                 auStack_1018);
        }
        fflush(local_14);
    } else {
        local_18 = 0;
        fscanf(local_14, "%ld", &local_18);
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, "timestamp file=%ld", local_18);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "setsystime_basestampfile", 0x18, 0x646, 0x28, auStack_1018);
        if (local_18 != 0) {
            stime(&local_18);
        }
    }
    fclose(local_14);
    return;
}

void update_timestamp_file(void)

{
    int *piVar1;
    char *pcVar2;
    int iVar3;
    undefined1 auStack_1018[4096];
    time_t local_18;
    FILE *local_14;

    local_14 = (FILE *)0x0;
    local_14 = fopen("/nvdata/timestamp.data", "w");
    if (local_14 == (FILE *)0x0) {
        V_LOCK();
        piVar1 = __errno_location();
        iVar3 = *piVar1;
        piVar1 = __errno_location();
        pcVar2 = strerror(*piVar1);
        logfmt_raw(auStack_1018, 0x1000, 0, "file op errno = %d reason = %s",
                   iVar3, pcVar2);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "update_timestamp_file", 0x15, 0x657, 0x28, auStack_1018);
    } else {
        time(&local_18);
        fprintf(local_14, "%ld", local_18);
        fflush(local_14);
        fclose(local_14);
    }
    return;
}

/* WARNING: Removing unreachable block (ram,0x0002eb8c) */

void call_setsystime_from_http(void)

{
    undefined1 auStack_2010[4096];
    char local_1010[4096];
    undefined4 local_10;
    int local_c;

    local_10 = 0;
    builtin_strncpy(local_1010, "/www/pages/cgi-bin/getandsettime.cgi", 0x24);
    local_1010[0x24] = 0;
    local_c = 0x24;
    local_c = my_system(local_1010);
    if (local_c != 0) {
        setsystime_basestampfile();
    }
    V_LOCK();
    logfmt_raw(auStack_2010, 0x1000, 0, "port system time result=%d", local_c);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/god-miner.c",
         0x95, "call_setsystime_from_http", 0x19, 0x678, 0x28, auStack_2010);
    return;
}

void droa_log_init(void)

{
    int iVar1;
    size_t __n;
    undefined1 auStack_101c[4096];
    char *local_1c;
    undefined4 local_18;
    uint local_14;

    local_18 = get_all_created_runtime(&g_chain_number);
    for (local_14 = 0; (int)local_14 < g_chain_number;
         local_14 = local_14 + 1) {
        if (local_14 < 0x10) {
            local_1c = (char *)api_get_eeprom_chip_sn(local_14);
            iVar1 = local_14 * 0x40;
            __n = strlen(local_1c);
            strncpy(g_bsn + iVar1, local_1c, __n);
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0, "droa board_sn:%s",
                       g_bsn + local_14 * 0x40);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/god-miner.c",
                 0x95, "droa_log_init", 0xd, 0x686, 0x3c, auStack_101c);
        }
    }
    return;
}

uint get_miner_status(void)

{
    byte local_20;
    byte local_1f;
    byte local_1e;
    byte local_1d;
    byte local_1c;
    byte local_1b;
    byte local_1a;
    byte local_19;
    byte local_18;
    byte local_10;
    byte local_f;
    byte local_e;
    byte local_d;
    undefined4 local_c;

    local_c = 0;
    get_miner_working_status(&local_20);
    return (uint)local_10 << 0xc | (uint)local_f << 0xb | (uint)local_e << 10 |
           (uint)local_d << 9 | (uint)local_20 << 8 | (uint)local_1f << 7 |
           (uint)local_1e << 6 | (uint)local_1d << 5 | (uint)local_1c << 4 |
           (uint)local_1b << 3 | (uint)local_1a << 2 | (uint)local_19 << 1 |
           (uint)local_18;
}

void update_droa_log(void)

{
    undefined4 uVar1;
    undefined4 uVar2;
    int iVar3;
    char *pcVar4;
    undefined4 uVar5;
    size_t sVar6;
    undefined4 uVar7;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;
    tm local_104c[93];
    __time_t local_4c;
    timeval local_48;
    long local_40;
    char *local_3c;
    FILE *local_38;
    int local_34;

    local_38 = fopen("/tmp/miner/droa.log", "r+");
    if (local_38 == (FILE *)0x0) {
        V_LOCK();
        logfmt_raw(local_104c, 0x1000, 0, "droalog open failed in 3 minute");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "update_droa_log", 0xf, 0x6e3, 0x28, local_104c);
    } else {
        local_34 = 0;
        fseek(local_38, -2, 2);
        while (iVar3 = fgetc(local_38), iVar3 != 10) {
            fseek(local_38, -2, 1);
            local_34 = local_34 + 1;
        }
        local_34 = local_34 + 1;
        fseek(local_38, -local_34, 2);
        local_3c = (char *)malloc(0x200);
        memset(local_3c, 0, 0x200);
        fgets(local_3c, 0x200, local_38);
        pcVar4 = strstr(local_3c, "RTime:");
        if (pcVar4 == (char *)0x0) {
            fflush(local_38);
            fclose(local_38);
            uVar7 = get_miner_elapsed_time();
            uVar2 = g_hash_rate_5s._4_4_;
            uVar1 = (undefined4)g_hash_rate_5s;
            uVar5 = get_miner_status();
            snprintf((char *)local_104c, 0x1000, "RTime:%f,AR:%f,RStat:%d",
                     local_104c, CONCAT44(extraout_s1_00, uVar7), uVar1, uVar2,
                     uVar5);
            log_droa(local_104c, 0);
        } else {
            local_40 = 0;
            local_48.tv_sec = 0;
            local_48.tv_usec = 0;
            gettimeofday(&local_48, (__timezone_ptr_t)0x0);
            local_4c = local_48.tv_sec;
            localtime_r(&local_4c, local_104c);
            fseek(local_38, -local_34, 2);
            local_40 = ftell(local_38);
            memset(local_3c, 0, 0x200);
            uVar7 = get_miner_elapsed_time();
            uVar2 = g_hash_rate_5s._4_4_;
            uVar1 = (undefined4)g_hash_rate_5s;
            uVar5 = get_miner_status();
            sprintf(local_3c,
                    "%d-%02d-%02d %02d:%02d:%02d RTime:%f,AR:%f,RStat:%d\n",
                    local_104c[0].tm_year + 0x76c, local_104c[0].tm_mon + 1,
                    local_104c[0].tm_mday, local_104c[0].tm_hour,
                    local_104c[0].tm_min, local_104c[0].tm_sec,
                    CONCAT44(extraout_s1, uVar7), uVar1, uVar2, uVar5);
            fprintf(local_38, local_3c);
            fflush(local_38);
            fclose(local_38);
            sVar6 = strlen(local_3c);
            truncate("/tmp/miner/droa.log", sVar6 + local_40);
        }
        free(local_3c);
    }
    return;
}

bool check_test_pool(void)

{
    char *pcVar1;
    undefined1 auStack_1018[4096];
    int local_18;
    int local_14;
    undefined1 local_d;
    int local_c;

    local_c = 0;
    local_d = 0;
    for (local_14 = 0; local_14 < total_pools; local_14 = local_14 + 1) {
        local_18 = *(int *)(pools + local_14 * 4);
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, "droa optpools=%d,%s", local_14,
                   *(undefined4 *)(local_18 + 0xc));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, "check_test_pool", 0xf, 0x6ed, 0x28, auStack_1018);
        pcVar1 = strstr(*(char **)(local_18 + 0xc), "TEST");
        if (pcVar1 != (char *)0x0) {
            local_c = local_c + 1;
        }
    }
    V_LOCK();
    logfmt_raw(auStack_1018, 0x1000, 0, "droa TEST count=%d", local_c);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/god-miner.c",
         0x95, "check_test_pool", 0xf, 0x6f4, 0x28, auStack_1018);
    is_test_pool = 2 < local_c;
    return 2 < local_c;
}

undefined1 compare_nvdata_bin(void)

{
    char *pcVar1;
    int iVar2;
    undefined1 auStack_1010[4099];
    undefined1 local_d;
    uint local_c;

    local_d = 0;
    local_c = 0;
    do {
        if (0xb < local_c) {
            return local_d;
        }
        pcVar1 = strstr(*(char **)(efactor + local_c * 0x58 + 4), "str");
        if (pcVar1 == (char *)0x0) {
            if (efactor[local_c * 0x58 + 0x14] !=
                **(char **)(efactor + local_c * 0x58 + 0x10)) {
                V_LOCK();
                logfmt_raw(auStack_1010, 0x1000, 0,
                           "droa,%s intcmp different, readback=%d,cmp=%d",
                           *(undefined4 *)(efactor + local_c * 0x58),
                           efactor[local_c * 0x58 + 0x14],
                           **(undefined1 **)(efactor + local_c * 0x58 + 0x10));
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "god-miner.c",
                     0x95, "compare_nvdata_bin", 0x12, 0x710, 0x28,
                     auStack_1010);
                return 1;
            }
        } else {
            if (**(char **)(efactor + local_c * 0x58 + 0xc) == '\0') {
                pcVar1 = "None";
            } else {
                pcVar1 = *(char **)(efactor + local_c * 0x58 + 0xc);
            }
            iVar2 = strcmp(efactor + local_c * 0x58 + 0x15, pcVar1);
            if (iVar2 != 0) {
                V_LOCK();
                logfmt_raw(auStack_1010, 0x1000, 0,
                           "droa,%s strcmp different, %s,%s",
                           *(undefined4 *)(efactor + local_c * 0x58),
                           local_c * 0x58 + 0x14d67d,
                           *(undefined4 *)(efactor + local_c * 0x58 + 0xc));
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "god-miner.c",
                     0x95, "compare_nvdata_bin", 0x12, 0x707, 0x28,
                     auStack_1010);
                return 1;
            }
        }
        local_c = local_c + 1;
    } while (true);
}

void record_nvdata_droalog(void)

{
    int *piVar1;
    char *pcVar2;
    undefined4 uVar3;
    undefined4 uVar4;
    undefined4 uVar5;
    undefined *puVar6;
    undefined4 uVar7;
    size_t sVar8;
    size_t sVar9;
    undefined *puVar10;
    undefined1 *puVar11;
    undefined1 *puVar12;
    int iVar13;
    undefined1 *puVar14;
    undefined *puVar15;
    char acStack_122c[512];
    char acStack_102c[4096];
    FILE *local_2c;
    uint local_28;
    char *local_24;

    local_2c = (FILE *)0x0;
    droa_log_init();
    local_2c = fopen("/nvdata/mbin.data", "r+");
    if (local_2c == (FILE *)0x0) {
        local_2c = fopen("/nvdata/mbin.data", "w+");
        uVar7 = g_chain_number;
        if (local_2c == (FILE *)0x0) {
            V_LOCK();
            piVar1 = __errno_location();
            iVar13 = *piVar1;
            piVar1 = __errno_location();
            pcVar2 = strerror(*piVar1);
            logfmt_raw(acStack_102c, 0x1000, 0,
                       "file op errno = %d reason = %s", iVar13, pcVar2);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/god-miner.c",
                 0x95, "record_nvdata_droalog", 0x15, 0x727, 0x28,
                 acStack_102c);
        } else {
            if (g_miner_sn[0] == '\0') {
                puVar14 = &DAT_000d778c;
            } else {
                puVar14 = g_miner_sn;
            }
            uVar3 = platform_get_chain_domain_num();
            uVar4 = platform_get_chain_asic_num();
            uVar5 = platform_get_domain_asic_num();
            if (g_bsn[0] == '\0') {
                puVar12 = &DAT_000d778c;
            } else {
                puVar12 = g_bsn;
            }
            if (g_bsn[0x40] == '\0') {
                puVar10 = &DAT_000d778c;
            } else {
                puVar10 = (undefined *)0x151450;
            }
            if (g_bsn[0x80] == '\0') {
                puVar6 = &DAT_000d778c;
            } else {
                puVar6 = (undefined *)0x151490;
            }
            if (g_bsn[0xc0] == '\0') {
                puVar15 = &DAT_000d778c;
            } else {
                puVar15 = (undefined *)0x1514d0;
            }
            if (pwr_sn[0] == '\0') {
                puVar11 = &DAT_000d778c;
            } else {
                puVar11 = pwr_sn;
            }
            snprintf(acStack_102c, 0x1000,
                     "MCT:%s,TYPE:%s,SN:%s,ChN:%d,ChDN:%d,ChAN:%d,DoAN:%d,"
                     "ChSN0:%s,ChSN1:%s,ChSN2:%s,ChSN3:%s,PWR:%s",
                     g_miner_compiletime, g_miner_type, puVar14, uVar7, uVar3,
                     uVar4, uVar5, puVar12, puVar10, puVar6, puVar15, puVar11);
            log_droa(acStack_102c, 0);
            uVar7 = get_miner_status();
            snprintf(acStack_102c, 0x1000, "InitStat:%d", uVar7);
            log_droa(acStack_102c, 0);
            uVar7 = g_chain_number;
            if (g_miner_sn[0] == '\0') {
                puVar14 = &DAT_000d778c;
            } else {
                puVar14 = g_miner_sn;
            }
            uVar3 = platform_get_chain_domain_num();
            uVar4 = platform_get_chain_asic_num();
            uVar5 = platform_get_domain_asic_num();
            if (g_bsn[0] == '\0') {
                puVar12 = &DAT_000d778c;
            } else {
                puVar12 = g_bsn;
            }
            if (g_bsn[0x40] == '\0') {
                puVar10 = &DAT_000d778c;
            } else {
                puVar10 = (undefined *)0x151450;
            }
            if (g_bsn[0x80] == '\0') {
                puVar6 = &DAT_000d778c;
            } else {
                puVar6 = (undefined *)0x151490;
            }
            if (g_bsn[0xc0] == '\0') {
                puVar15 = &DAT_000d778c;
            } else {
                puVar15 = (undefined *)0x1514d0;
            }
            if (pwr_sn[0] == '\0') {
                puVar11 = &DAT_000d778c;
            } else {
                puVar11 = pwr_sn;
            }
            fprintf(local_2c,
                    "MCT:%s,TYPE:%s,SN:%s,ChN:%d,ChDN:%d,ChAN:%d,DoAN:%d,ChSN0:"
                    "%s,ChSN1:%s,ChSN2:%s,ChSN3:%s,PWR:%s",
                    g_miner_compiletime, g_miner_type, puVar14, uVar7, uVar3,
                    uVar4, uVar5, puVar12, puVar10, puVar6, puVar15, puVar11);
            fflush(local_2c);
            fclose(local_2c);
        }
    } else {
        local_24 = (char *)0x0;
        memset(acStack_122c, 0, 0x200);
        fgets(acStack_122c, 0x1ff, local_2c);
        local_24 = strtok(acStack_122c, ",");
        while (local_24 != (char *)0x0) {
            for (local_28 = 0; local_28 < 0xc; local_28 = local_28 + 1) {
                pcVar2 =
                    strstr(local_24, *(char **)(efactor + local_28 * 0x58));
                if (pcVar2 != (char *)0x0) {
                    pcVar2 = strstr(*(char **)(efactor + local_28 * 0x58 + 4),
                                    "str");
                    if (pcVar2 == (char *)0x0) {
                        sVar8 = strlen(*(char **)(efactor + local_28 * 0x58));
                        iVar13 = atoi(local_24 + sVar8);
                        efactor[local_28 * 0x58 + 0x14] = (char)iVar13;
                    } else {
                        iVar13 = local_28 * 0x58;
                        sVar8 = strlen(*(char **)(efactor + local_28 * 0x58));
                        pcVar2 = local_24 + sVar8;
                        sVar8 = strlen(local_24);
                        sVar9 = strlen(*(char **)(efactor + local_28 * 0x58));
                        strncpy(efactor + iVar13 + 0x15, pcVar2, sVar8 - sVar9);
                    }
                }
            }
            local_24 = strtok((char *)0x0, ",");
        }
        iVar13 = compare_nvdata_bin();
        if (iVar13 == 0) {
            uVar7 = get_miner_status();
            snprintf(acStack_102c, 0x1000, "InitStat:%d", uVar7);
            log_droa(acStack_102c, 0);
        } else {
            fclose(local_2c);
            local_2c = (FILE *)0x0;
            V_LOCK();
            logfmt_raw(acStack_102c, 0x1000, 0,
                       "droa bin data changed, need update droa bin data");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/god-miner.c",
                 0x95, "record_nvdata_droalog", 0x15, 0x75e, 0x28,
                 acStack_102c);
            local_2c = fopen("/nvdata/mbin.data", "w");
            if (local_2c == (FILE *)0x0) {
                V_LOCK();
                logfmt_raw(acStack_102c, 0x1000, 0,
                           "droa log miner bin data update failed");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "god-miner.c",
                     0x95, "record_nvdata_droalog", 0x15, 0x776, 0x28,
                     acStack_102c);
            } else {
                V_LOCK();
                logfmt_raw(acStack_102c, 0x1000, 0, "update droa bin data");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "god-miner.c",
                     0x95, "record_nvdata_droalog", 0x15, 0x764, 0x28,
                     acStack_102c);
                uVar7 = g_chain_number;
                if (g_miner_sn[0] == '\0') {
                    puVar14 = &DAT_000d778c;
                } else {
                    puVar14 = g_miner_sn;
                }
                uVar3 = platform_get_chain_domain_num();
                uVar4 = platform_get_chain_asic_num();
                uVar5 = platform_get_domain_asic_num();
                if (g_bsn[0] == '\0') {
                    puVar12 = &DAT_000d778c;
                } else {
                    puVar12 = g_bsn;
                }
                if (g_bsn[0x40] == '\0') {
                    puVar10 = &DAT_000d778c;
                } else {
                    puVar10 = (undefined *)0x151450;
                }
                if (g_bsn[0x80] == '\0') {
                    puVar6 = &DAT_000d778c;
                } else {
                    puVar6 = (undefined *)0x151490;
                }
                if (g_bsn[0xc0] == '\0') {
                    puVar15 = &DAT_000d778c;
                } else {
                    puVar15 = (undefined *)0x1514d0;
                }
                if (pwr_sn[0] == '\0') {
                    puVar11 = &DAT_000d778c;
                } else {
                    puVar11 = pwr_sn;
                }
                snprintf(acStack_102c, 0x1000,
                         "MCT:%s,TYPE:%s,SN:%s,ChN:%d,ChDN:%d,ChAN:%d,DoAN:%d,"
                         "ChSN0:%s,ChSN1:%s,ChSN2:%s,ChSN3:%s,PWR:%s",
                         g_miner_compiletime, g_miner_type, puVar14, uVar7,
                         uVar3, uVar4, uVar5, puVar12, puVar10, puVar6, puVar15,
                         puVar11);
                log_droa(acStack_102c, 0);
                uVar7 = get_miner_status();
                snprintf(acStack_102c, 0x1000, "InitStat:%d", uVar7);
                log_droa(acStack_102c, 0);
                uVar7 = g_chain_number;
                if (g_miner_sn[0] == '\0') {
                    puVar14 = &DAT_000d778c;
                } else {
                    puVar14 = g_miner_sn;
                }
                uVar3 = platform_get_chain_domain_num();
                uVar4 = platform_get_chain_asic_num();
                uVar5 = platform_get_domain_asic_num();
                if (g_bsn[0] == '\0') {
                    puVar12 = &DAT_000d778c;
                } else {
                    puVar12 = g_bsn;
                }
                if (g_bsn[0x40] == '\0') {
                    puVar10 = &DAT_000d778c;
                } else {
                    puVar10 = (undefined *)0x151450;
                }
                if (g_bsn[0x80] == '\0') {
                    puVar6 = &DAT_000d778c;
                } else {
                    puVar6 = (undefined *)0x151490;
                }
                if (g_bsn[0xc0] == '\0') {
                    puVar15 = &DAT_000d778c;
                } else {
                    puVar15 = (undefined *)0x1514d0;
                }
                if (pwr_sn[0] == '\0') {
                    puVar11 = &DAT_000d778c;
                } else {
                    puVar11 = pwr_sn;
                }
                fprintf(local_2c,
                        "MCT:%s,TYPE:%s,SN:%s,ChN:%d,ChDN:%d,ChAN:%d,DoAN:%d,"
                        "ChSN0:%s,ChSN1:%s,ChSN2:%s,ChSN3:%s,PWR:%s",
                        g_miner_compiletime, g_miner_type, puVar14, uVar7,
                        uVar3, uVar4, uVar5, puVar12, puVar10, puVar6, puVar15,
                        puVar11);
                fflush(local_2c);
                fclose(local_2c);
            }
        }
    }
    return;
}

void droa_macro_check(void)

{
    int iVar1;
    int *piVar2;
    char *pcVar3;
    undefined1 auStack_1014[4096];
    FILE *local_14;

    iVar1 = access("/nvdata/droaswitch", 0);
    if (iVar1 != 0) {
        local_14 = (FILE *)0x0;
        local_14 = fopen("/nvdata/droaswitch", "w");
        if (local_14 == (FILE *)0x0) {
            V_LOCK();
            piVar2 = __errno_location();
            iVar1 = *piVar2;
            piVar2 = __errno_location();
            pcVar3 = strerror(*piVar2);
            logfmt_raw(auStack_1014, 0x1000, 0, "cswitch file ret=%d,reason=%s",
                       iVar1, pcVar3);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/god-miner.c",
                 0x95, "droa_macro_check", 0x10, 0x78a, 0x3c, auStack_1014);
        } else {
            fclose(local_14);
        }
    }
    return;
}

int main(undefined4 param_1, undefined4 param_2)

{
    int iVar1;
    undefined1 auStack_1030[4096];
    int local_30;
    undefined1 *local_2c;
    undefined4 local_28;
    undefined4 local_24;
    undefined4 local_20;
    undefined4 local_1c;
    undefined4 local_18;
    int local_14;
    int local_10;
    int local_c;

    local_20 = 0;
    local_24 = 0;
    local_28 = 0;
    local_1c = 0;
    local_10 = 0;
    local_18 = 0;
    iVar1 = FUN_0002e168();
    if (iVar1 == 0) {
        iVar1 = log_init();
        if (iVar1 != 0) {
            puts("log init error!");
        }
        V_LOCK();
        logfmt_raw(auStack_1030, 0x1000, 0, "release version");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, &DAT_000d7f04, 4, 0x7b1, 0x28, auStack_1030);
        V_LOCK();
        logfmt_raw(auStack_1030, 0x1000, 0, "asic mode");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, &DAT_000d7f04, 4, 0x7b6, 0x28, auStack_1030);
        FUN_0002ce3c(param_1, param_2);
        V_LOCK();
        logfmt_raw(auStack_1030, 0x1000, 0, "opt_algo %d, %s", opt_algo,
                   (&PTR_s_ckb_2040_0014d568)[opt_algo]);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/god-miner.c",
             0x95, &DAT_000d7f04, 4, 0x7ba, 0x14, auStack_1030);
        custom_param_check();
        if (opt_chip_update == '\0') {
            if (total_pools == 0) {
                V_LOCK();
                logfmt_raw(auStack_1030, 0x1000, 0,
                           "Need to specify at least one pool server.");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "god-miner.c",
                     0x95, &DAT_000d7f04, 4, 2000, 0x50, auStack_1030);
                V_LOCK();
                logfmt_raw(auStack_1030, 0x1000, 0, "Pool setup failed!");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "god-miner.c",
                     0x95, &DAT_000d7f04, 4, 0x7d1, 100, auStack_1030);
                local_10 = 1;
            } else {
                check_test_pool();
                V_LOCK();
                logfmt_raw(auStack_1030, 0x1000, 0, "Droa is_test_pool=%d",
                           is_test_pool);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "god-miner.c",
                     0x95, &DAT_000d7f04, 4, 0x7d7, 0x28, auStack_1030);
                cal_log_init();
                droa_macro_check();
                if (opt_version_path == 0) {
                    make_fake_version(opt_algo);
                } else {
                    read_version_file();
                }
                if (opt_api_remote != '\0') {
                    pools_active = 1;
                    start_api_thread();
                }
                local_14 = dhash_content_init(opt_algo);
                if (local_14 == 0) {
                    printf("invalid pointer(%s)!\n", "dhash_content");
                    local_10 = 3;
                } else {
                    set_frontend_runtime_type(local_14, opt_algo);
                    check_pool_worker();
                    local_10 = hardware_init(opt_algo);
                    if (local_10 == 0) {
                        local_c =
                            machine_runtime_init(opt_machine_type, opt_algo);
                        if (local_c == 0) {
                            printf("invalid pointer(%s)!\n", "machine_runtime");
                            local_10 = 3;
                        } else {
                            FUN_0002d2f4();
                            check_sn(*(undefined4 *)(local_c + 0x7c));
                            FUN_0002e198();
                            http_test_case_init();
                            start_http_thread();
                            iVar1 = check_pool_connect();
                            if (iVar1 == 0x131) {
                                local_10 = 1;
                            } else {
                                local_10 =
                                    (**(code **)(local_c + 0x30))(local_c);
                                if (local_10 == 0) {
                                    signal(2, FUN_0002cfb4);
                                    signal(3, FUN_0002cfb4);
                                    signal(0xf, FUN_0002cfb4);
                                    signal(0xb, FUN_0002cfb4);
                                    signal(10, FUN_0002cfb4);
                                    signal(0xd, (__sighandler_t)0x1);
                                    V_LOCK();
                                    logfmt_raw(auStack_1030, 0x1000, 0,
                                               "always catch signal!");
                                    V_UNLOCK();
                                    zlog(g_zc,
                                         "/workspace/jenkins/jenkins/workspace/"
                                         "Antminer_L9_CVCtrl_release/build/"
                                         "rootfs/buildroot/tmp/release/build/"
                                         "godminer-origin_godminer-branch1/"
                                         "god-miner.c",
                                         0x95, &DAT_000d7f04, 4, 0x830, 0x28,
                                         auStack_1030);
                                    iVar1 = create_pool_connect();
                                    if (iVar1 == 0x131) {
                                        local_10 = 1;
                                    } else {
                                        local_2c = thr_info;
                                        thr_info._0_4_ = 0;
                                        local_30 = FUN_0002a5d8(
                                            thr_info, work_generator_thread);
                                        if (local_30 == 0) {
                                            local_2c = (undefined1 *)0x161030;
                                            thr_info._48_4_ = 1;
                                            local_30 = FUN_0002a5d8(
                                                0x161030, nonce_submit_thread);
                                            if (local_30 == 0) {
                                                miner_monitor_init();
                                                if (is_test_pool != '\x01') {
                                                    V_LOCK();
                                                    logfmt_raw(
                                                        auStack_1030, 0x1000, 0,
                                                        "record droalogs");
                                                    V_UNLOCK();
                                                    zlog(g_zc,
                                                         "/workspace/jenkins/"
                                                         "jenkins/workspace/"
                                                         "Antminer_L9_CVCtrl_"
                                                         "release/build/rootfs/"
                                                         "buildroot/tmp/"
                                                         "release/build/"
                                                         "godminer-origin_"
                                                         "godminer-branch1/"
                                                         "god-miner.c",
                                                         0x95, &DAT_000d7f04, 4,
                                                         0x84d, 0x28,
                                                         auStack_1030);
                                                    record_nvdata_droalog();
                                                }
                                                godminer_register_status_monitor();
                                                miner_monitor_start();
                                                sleep(5);
                                                set_miner_start_time();
                                                set_elapsed_time_validity(1);
                                                start_watchpool_thread();
                                                sleep(5);
                                                (**(code **)(local_c + 0xc))(
                                                    local_c);
                                                pthread_join(thr_info._4_4_,
                                                             (void **)0x0);
                                                V_LOCK();
                                                logfmt_raw(auStack_1030, 0x1000,
                                                           0,
                                                           "workio threads "
                                                           "dead, exiting.");
                                                V_UNLOCK();
                                                zlog(g_zc,
                                                     "/workspace/jenkins/"
                                                     "jenkins/workspace/"
                                                     "Antminer_L9_CVCtrl_"
                                                     "release/build/rootfs/"
                                                     "buildroot/tmp/release/"
                                                     "build/"
                                                     "godminer-origin_godminer-"
                                                     "branch1/god-miner.c",
                                                     0x95, &DAT_000d7f04, 4,
                                                     0x886, 0x50, auStack_1030);
                                                print_summary();
                                                dhash_content_exit(local_14);
                                                (**(code **)(local_c + 0x14))();
                                                machine_runtime_exit(
                                                    DAT_00151850);
                                                local_10 = 0;
                                            } else {
                                                V_LOCK();
                                                logfmt_raw(
                                                    auStack_1030, 0x1000, 0,
                                                    "simulation submit thread "
                                                    "create failed");
                                                V_UNLOCK();
                                                zlog(g_zc,
                                                     "/workspace/jenkins/"
                                                     "jenkins/workspace/"
                                                     "Antminer_L9_CVCtrl_"
                                                     "release/build/rootfs/"
                                                     "buildroot/tmp/release/"
                                                     "build/"
                                                     "godminer-origin_godminer-"
                                                     "branch1/god-miner.c",
                                                     0x95, &DAT_000d7f04, 4,
                                                     0x843, 100, auStack_1030);
                                                local_10 = 1;
                                            }
                                        } else {
                                            V_LOCK();
                                            logfmt_raw(auStack_1030, 0x1000, 0,
                                                       "work generator thread "
                                                       "%d create failed");
                                            V_UNLOCK();
                                            zlog(g_zc,
                                                 "/workspace/jenkins/jenkins/"
                                                 "workspace/"
                                                 "Antminer_L9_CVCtrl_release/"
                                                 "build/rootfs/buildroot/tmp/"
                                                 "release/build/"
                                                 "godminer-origin_godminer-"
                                                 "branch1/god-miner.c",
                                                 0x95, &DAT_000d7f04, 4, 0x83b,
                                                 100, auStack_1030);
                                            local_10 = 1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            iVar1 = chip_update_xmr_routine(chip_update_param);
            if (iVar1 == 0) {
                local_10 = 0;
            } else {
                local_10 = -1;
            }
        }
    } else {
        printf("godminer is forbidden to start again as it is already started, "
               "will exit immediately.");
        local_10 = 1;
    }
    return local_10;
}

void FUN_00030d14(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_00030ea0(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/util.h",
                 0x90, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

void get_miner_info(int param_1)

{
    int iVar1;
    int local_1c;
    undefined4 local_18;
    undefined4 local_14;
    int local_10;
    int local_c;

    local_10 = 0;
    local_14 = 0xc;
    local_1c = 0;
    local_18 = get_all_created_runtime(&local_1c);
    for (local_c = 0; local_c < local_1c; local_c = local_c + 1) {
        iVar1 = sprintf((char *)(param_1 + local_10), "chain%d_voltage=%d;",
                        local_c + 1, local_14);
        local_10 = local_10 + iVar1;
        iVar1 = sprintf((char *)(param_1 + local_10), "chain%d_voladded=%d;",
                        local_c + 1, 0);
        local_10 = local_10 + iVar1;
        iVar1 = sprintf((char *)(param_1 + local_10), "chain%d_basefreq=%d;",
                        local_c + 1, 0);
        local_10 = local_10 + iVar1;
        iVar1 = sprintf((char *)(param_1 + local_10), "chain%d_badcore=%d;",
                        local_c + 1, 0);
        local_10 = local_10 + iVar1;
    }
    iVar1 = sprintf((char *)(param_1 + local_10), "chainnum=%d;", local_1c);
    local_10 = local_10 + iVar1;
    sprintf((char *)(param_1 + local_10), "version=%s;", g_miner_compiletime);
    return;
}

undefined4 get_freq_scan_status(void)

{
    return freq_scan_status;
}

void FUN_000311f4(int param_1)

{
    if (param_1 == 1) {
        freq_scan_status = 1;
    } else if (param_1 == 2) {
        freq_scan_status = 2;
        search_failed_info._0_4_ = 0x313a52;
    } else if (param_1 == 0) {
        freq_scan_status = 0;
    } else {
        freq_scan_status = 0;
        search_failed_info[0] = 'u';
        search_failed_info[1] = 'n';
        search_failed_info[2] = 'k';
        search_failed_info[3] = 'n';
        search_failed_info[4] = 'o';
        search_failed_info[5] = 'w';
        search_failed_info[6] = 'n';
        search_failed_info[7] = '\0';
    }
    return;
}

undefined4 FUN_000312b8(char *param_1, size_t param_2, undefined4 param_3)

{
    if (freq_scan_status == 1) {
        snprintf(param_1, param_2, "%d", param_3);
    } else if (freq_scan_status == 2) {
        snprintf(param_1, param_2, "%s:%s", "searchfailed", search_failed_info);
    } else if (freq_scan_status == 0) {
        snprintf(param_1, param_2, "searching");
    } else {
        snprintf(param_1, param_2, "searching");
    }
    return 0;
}

undefined4 FUN_0003137c(void)

{
    return 0;
}

undefined4 get_miner_sale_hashrate(void)

{
    uint uVar1;
    undefined4 uVar2;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;
    int local_6c;
    int local_68;
    undefined1 auStack_64[12];
    double dStack_58;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined8 uStack_48;
    int local_40;
    char *local_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    double dStack_30;
    int local_28;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    uint local_14;
    double local_10;

    local_68 = 0;
    local_24 = get_all_created_runtime(&local_68);
    local_28 = 0;
    local_6c = 1;
    local_14 = 0;
    uVar2 = get_miner_elapsed_time();
    dStack_30 = (double)CONCAT44(extraout_s1, uVar2);
    local_38 = 0;
    uStack_34 = 0;
    local_3c = (char *)get_miner_6060info_status();
    local_50 = 0;
    uStack_4c = 0;
    local_10 = 0.0;
    for (local_18 = 0; local_18 < local_68; local_18 = local_18 + 1) {
        uVar1 = (**(code **)(*(int *)(local_24 + local_18 * 4) + 0x8c))(
            *(undefined4 *)(local_24 + local_18 * 4), &dStack_58, &local_6c);
        local_14 = uVar1 | local_14;
        local_10 = local_10 + dStack_58;
    }
    local_38 = 0;
    uStack_34 = 0;
    if (1.0 <= dStack_30 - 0.0) {
        if (local_14 != 0) {
            FUN_000311f4(2);
            search_failed_info._0_4_ = 0x313a52;
        }
        if (*local_3c != '\0') {
            FUN_000311f4(2);
            search_failed_info._0_4_ = 0x313a50;
        }
        for (local_1c = 0; local_1c < 8; local_1c = local_1c + 1) {
            if (local_3c[(local_1c + 3) * 0x10] != '\0') {
                FUN_000311f4(2);
                snprintf(search_failed_info, 0x100, "F%d:1", local_1c);
            }
        }
        for (local_20 = 0; local_20 < 0x10; local_20 = local_20 + 1) {
            if (local_3c[(local_20 + 0x1b) * 0x10] != '\0') {
                FUN_000311f4(2);
                snprintf(search_failed_info, 0x100, "J%d:1", local_20);
            }
        }
        local_40 = frontend_runtime_instance();
        uVar2 = format_hashrate_double(
            SUB84(local_10, 0),
            *(undefined4 *)(*(int *)(local_40 + 0x48) + 0x10), &local_50,
            auStack_64);
        uStack_48 = CONCAT44(extraout_s1_00, uVar2);
        local_28 = (int)(longlong)(double)CONCAT44(uStack_4c, local_50);
        local_28 = FUN_000cc518(local_28 * local_6c, local_6c);
    } else {
        FUN_000311f4(0);
    }
    return local_28;
}

undefined4 get_miner_qualified_hashrate(void)

{
    undefined4 uVar1;

    FUN_000311f4(1);
    uVar1 = get_miner_sale_hashrate();
    return uVar1;
}

undefined4 get_theory_hashrate(void)

{
    uint uVar1;
    undefined4 uVar2;
    undefined4 extraout_s1;
    undefined1 auStack_58[12];
    int local_4c;
    double dStack_48;
    undefined4 local_40;
    undefined4 uStack_3c;
    int local_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    double dStack_28;
    int local_20;
    int local_1c;
    uint local_18;
    undefined4 local_14;
    double local_10;

    local_4c = 0;
    local_20 = get_all_created_runtime(&local_4c);
    local_18 = 0;
    uVar2 = get_miner_elapsed_time();
    dStack_28 = (double)CONCAT44(extraout_s1, uVar2);
    local_30 = 0;
    uStack_2c = 0;
    local_10 = 0.0;
    local_40 = 0;
    uStack_3c = 0;
    for (local_1c = 0; local_1c < local_4c; local_1c = local_1c + 1) {
        uVar1 = (**(code **)(*(int *)(local_20 + local_1c * 4) + 0x88))(
            *(undefined4 *)(local_20 + local_1c * 4), &dStack_48);
        local_18 = uVar1 | local_18;
        local_10 = local_10 + dStack_48;
    }
    local_30 = 0;
    uStack_2c = 0;
    if (1.0 <= dStack_28 - 0.0) {
        local_34 = frontend_runtime_instance();
        format_hashrate_double(
            SUB84(local_10, 0),
            *(undefined4 *)(*(int *)(local_34 + 0x48) + 0x10), &local_40,
            auStack_58);
        if (local_18 == 0) {
            local_14 =
                (undefined4)(longlong)(double)CONCAT44(uStack_3c, local_40);
            FUN_000311f4(1);
        } else {
            FUN_000311f4(2);
        }
    } else {
        FUN_000311f4(0);
        local_14 = (undefined4)(longlong)(double)CONCAT44(uStack_3c, local_40);
    }
    return local_14;
}

/* WARNING: Type propagation algorithm not settling */

undefined4 http_test_bm(int param_1, char *param_2, size_t param_3)

{
    char cVar1;
    char *pcVar2;
    undefined4 uVar3;
    int iVar4;
    size_t sVar5;
    undefined4 uVar6;
    undefined4 uVar7;
    char *pcVar8;
    char *pcVar9;
    undefined1 auStack_1058[4096];
    undefined8 local_58;
    undefined2 uStack_50;
    undefined6 local_4e;
    undefined2 uStack_48;
    int local_44[5];
    FILE *local_30;
    int local_2c;
    int local_28;
    int local_24;
    undefined4 local_20;
    int local_1c;

    local_44[2] = -1;
    local_44[1] = 0xffffffff;
    local_44[0] = 0;
    local_24 = 0;
    local_28 = get_all_created_runtime(local_44);
    pcVar2 = strstr((char *)(param_1 + 4), "/rate");
    if (pcVar2 == (char *)0x0) {
        pcVar2 = strstr((char *)(param_1 + 4), "/test");
        if (pcVar2 == (char *)0x0) {
            pcVar2 = strstr((char *)(param_1 + 4), "/ideal_rate");
            if (pcVar2 == (char *)0x0) {
                pcVar2 = strstr((char *)(param_1 + 4), "/max_rate");
                if (pcVar2 == (char *)0x0) {
                    pcVar2 = strstr((char *)(param_1 + 4), "/miner_status");
                    if (pcVar2 == (char *)0x0) {
                        pcVar2 = strstr((char *)(param_1 + 4), "/productName");
                        if (pcVar2 == (char *)0x0) {
                            iVar4 =
                                strncmp((char *)(param_1 + 4), "/get_sn", 7);
                            if (iVar4 == 0) {
                                local_2c = 0;
                                local_58 = 0;
                                uStack_50 = 0;
                                local_4e = 0;
                                uStack_48 = 0;
                                local_30 = (FILE *)0x0;
                                V_LOCK();
                                logfmt_raw(auStack_1058, 0x1000, 0,
                                           "cmd : get miner sn");
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/"
                                     "http_test.c",
                                     0x95, "http_test_bm", 0xc, 0x164, 0x14,
                                     auStack_1058);
                                local_30 = fopen(g_miner_sn_file_path, "r");
                                if (local_30 == (FILE *)0x0) {
                                    local_2c = -1;
                                } else {
                                    fread(&local_58, 0x11, 1, local_30);
                                    fclose(local_30);
                                }
                                if ((char)local_58 == '\0') {
                                    local_2c = -2;
                                }
                                if (local_2c == 0) {
                                    snprintf(param_2, 0x12, "%s", &local_58);
                                } else {
                                    builtin_strncpy(
                                        param_2, "no miner sn stored on board",
                                        0x1c);
                                }
                            } else {
                                iVar4 = strncmp((char *)(param_1 + 4),
                                                "/set_sn", 7);
                                if (iVar4 == 0) {
                                    V_LOCK();
                                    logfmt_raw(
                                        auStack_1058, 0x1000, 0,
                                        "cmd : set miner sn, doesn\'t spport");
                                    V_UNLOCK();
                                    zlog(g_zc,
                                         "/workspace/jenkins/jenkins/workspace/"
                                         "Antminer_L9_CVCtrl_release/build/"
                                         "rootfs/buildroot/tmp/release/build/"
                                         "godminer-origin_godminer-branch1/"
                                         "http_test.c",
                                         0x95, "http_test_bm", 0xc, 0x1ae, 0x50,
                                         auStack_1058);
                                    pcVar2 = "doesn\'t support sn set in "
                                             "Release mode";
                                    do {
                                        pcVar9 = pcVar2;
                                        pcVar8 = param_2;
                                        uVar3 = *(undefined4 *)(pcVar9 + 4);
                                        uVar6 = *(undefined4 *)(pcVar9 + 8);
                                        uVar7 = *(undefined4 *)(pcVar9 + 0xc);
                                        *(undefined4 *)pcVar8 =
                                            *(undefined4 *)pcVar9;
                                        *(undefined4 *)(pcVar8 + 4) = uVar3;
                                        *(undefined4 *)(pcVar8 + 8) = uVar6;
                                        *(undefined4 *)(pcVar8 + 0xc) = uVar7;
                                        param_2 = pcVar8 + 0x10;
                                        pcVar2 = pcVar9 + 0x10;
                                    } while (pcVar9 + 0x10 != "e mode");
                                    param_2[0] = 'e';
                                    param_2[1] = ' ';
                                    param_2[2] = 'm';
                                    param_2[3] = 'o';
                                    cVar1 = pcVar9[0x16];
                                    *(undefined2 *)(pcVar8 + 0x14) =
                                        *(undefined2 *)(pcVar9 + 0x14);
                                    pcVar8[0x16] = cVar1;
                                } else {
                                    iVar4 = strncmp((char *)(param_1 + 4),
                                                    "/miner_power", 0xc);
                                    if (iVar4 == 0) {
                                        local_20 = bitmain_get_miner_power();
                                        snprintf(param_2, param_3,
                                                 "miner power:%d", local_20);
                                    } else {
                                        iVar4 = strncmp((char *)(param_1 + 4),
                                                        "/miner_temp", 0xb);
                                        if (iVar4 != 0) {
                                            return 0xffffffff;
                                        }
                                        for (local_1c = 0;
                                             local_1c < local_44[0];
                                             local_1c = local_1c + 1) {
                                            if (*(char *)(*(int *)(local_28 +
                                                                   local_1c *
                                                                       4) +
                                                          0x100) != '\0') {
                                                (**(code **)(*(int *)(local_28 +
                                                                      local_1c *
                                                                          4) +
                                                             0xd0))(
                                                    *(undefined4 *)(local_28 +
                                                                    local_1c *
                                                                        4),
                                                    auStack_1058, 4000);
                                                iVar4 = snprintf(
                                                    param_2 + local_24,
                                                    param_3 - local_24,
                                                    "chain_fd %d:\n%s\n",
                                                    *(undefined4
                                                          *)(*(int *)(local_28 +
                                                                      local_1c *
                                                                          4) +
                                                             0xfc),
                                                    auStack_1058);
                                                local_24 = local_24 + iVar4;
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            V_LOCK();
                            sVar5 = strlen(g_miner_type);
                            logfmt_raw(auStack_1058, 0x1000, 0,
                                       "cmd : get miner type[%d] %s", sVar5,
                                       g_miner_type);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/http_test.c",
                                 0x95, "http_test_bm", 0xc, 0x15c, 0x14,
                                 auStack_1058);
                            strcpy(param_2, g_miner_type);
                        }
                    } else {
                        V_LOCK();
                        logfmt_raw(auStack_1058, 0x1000, 0,
                                   "cmd : get miner status");
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/http_test.c",
                             0x95, "http_test_bm", 0xc, 0x157, 0x14,
                             auStack_1058);
                        FUN_0003137c(param_2, param_3);
                    }
                } else {
                    V_LOCK();
                    logfmt_raw(auStack_1058, 0x1000, 0, "cmd : get max rate");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "http_test.c",
                         0x95, "http_test_bm", 0xc, 0x151, 0x14, auStack_1058);
                    iVar4 = get_theory_hashrate();
                    local_44[4] = (iVar4 * 0x66) / 100;
                    FUN_000312b8(param_2, param_3, local_44[4]);
                }
            } else {
                V_LOCK();
                logfmt_raw(auStack_1058, 0x1000, 0, "cmd : get ideal rate");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "http_test.c",
                     0x95, "http_test_bm", 0xc, 0x14b, 0x14, auStack_1058);
                uVar3 = get_miner_sale_hashrate();
                FUN_000312b8(param_2, param_3, uVar3);
            }
        } else {
            __isoc99_sscanf(param_1 + 4, "/test.%d.%d", local_44 + 2,
                            local_44 + 1);
            V_LOCK();
            logfmt_raw(auStack_1058, 0x1000, 0, "cmd : get test = %d",
                       local_44[2]);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/http_test.c",
                 0x95, "http_test_bm", 0xc, 0x13d, 0x14, auStack_1058);
            if (local_44[2] == 0x20b) {
                get_miner_info(param_2);
            } else {
                sprintf(param_2, "OK get test=%d", local_44[2]);
            }
        }
    } else {
        local_44[3] = 0;
        V_LOCK();
        logfmt_raw(auStack_1058, 0x1000, 0, "cmd : get rate");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/http_test.c",
             0x95, "http_test_bm", 0xc, 0x136, 0x14, auStack_1058);
        local_44[3] = get_miner_qualified_hashrate();
        FUN_000312b8(param_2, param_3, local_44[3]);
    }
    return 0;
}

void http_test_case_init(void)

{
    http_test_case = http_test_bm;
    return;
}

void FUN_000321e8(int param_1)

{
    bool bVar1;
    int iVar2;
    int *piVar3;

    if ((param_1 != 0) && (*(int *)(param_1 + 4) != -1)) {
        piVar3 = (int *)(param_1 + 4);
        DataMemoryBarrier(0xb);
        do {
            iVar2 = *piVar3;
            bVar1 = (bool)hasExclusiveAccess(piVar3);
        } while (!bVar1);
        *piVar3 = iVar2 + -1;
        if (iVar2 + -1 == 0) {
            json_delete(param_1);
        }
    }
    return;
}

undefined4 FUN_00032250(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "poolno", param_3, param_4);
    return param_1;
}

int FUN_00032284(void *param_1, __start_routine *param_2)

{
    int iVar1;

    pthread_attr_init((pthread_attr_t *)((int)param_1 + 8));
    iVar1 =
        pthread_create((pthread_t *)((int)param_1 + 4),
                       (pthread_attr_t *)((int)param_1 + 8), param_2, param_1);
    pthread_attr_destroy((pthread_attr_t *)((int)param_1 + 8));
    return iVar1;
}

void FUN_000322f0(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_0003247c(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/util.h",
                 0x90, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

void FUN_0003260c(undefined4 param_1)

{
    undefined4 uVar1;
    undefined1 auStack_1010[4096];
    int *local_10;
    undefined1 *local_c;

    local_c = reject_reason_map;
    if (DAT_00151914 < 0x14) {
        if (DAT_00151914 == 0) {
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0, "reject reason init %d",
                       DAT_00151914);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/pool.c",
                 0x90, "reject_reason_history_update", 0x1c, 0x30, 0x28,
                 auStack_1010);
            memset(reject_reason_map, 0, 0x14);
        }
        uVar1 = map_get_(local_c, param_1);
        *(undefined4 *)(local_c + 0xc) = uVar1;
        local_10 = *(int **)(local_c + 0xc);
        if (local_10 == (int *)0x0) {
            DAT_00151914 = DAT_00151914 + 1;
            *(undefined4 *)(local_c + 0x10) = 1;
            map_set_(local_c, param_1, local_c + 0x10, 4);
        } else {
            *local_10 = *local_10 + 1;
        }
    } else {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, "only support %d reject reasons",
                   DAT_00151914);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/pool.c",
             0x90, "reject_reason_history_update", 0x1c, 0x2b, 0x14,
             auStack_1010);
    }
    return;
}

void FUN_00032824(void)

{
    undefined4 uVar1;
    undefined1 auStack_18[8];
    int local_10;
    undefined1 *local_c;

    local_c = reject_reason_map;
    map_iter_(auStack_18);
    puts("--------reject_reason_history_dump:-------");
    while (true) {
        local_10 = map_next_(local_c, auStack_18);
        if (local_10 == 0)
            break;
        uVar1 = map_get_(local_c, local_10);
        *(undefined4 *)(local_c + 0xc) = uVar1;
        printf("%s happened %d times\n", local_10,
               **(undefined4 **)(local_c + 0xc));
    }
    puts("---------------------end------------------");
    return;
}

undefined4 get_current_pool(void)

{
    undefined4 uVar1;

    pthread_mutex_lock((pthread_mutex_t *)&DAT_001518a8);
    uVar1 = DAT_001518a4;
    pthread_mutex_unlock((pthread_mutex_t *)&DAT_001518a8);
    return uVar1;
}

bool current_pool_changed(int param_1)

{
    int iVar1;

    iVar1 = get_current_pool();
    return iVar1 != param_1;
}

void wait_pool_to_be_current(int param_1)

{
    pthread_mutex_lock((pthread_mutex_t *)&DAT_001518a8);
    while (param_1 != DAT_001518a4) {
        pthread_cond_wait((pthread_cond_t *)&DAT_001518c0,
                          (pthread_mutex_t *)&DAT_001518a8);
    }
    pthread_mutex_unlock((pthread_mutex_t *)&DAT_001518a8);
    return;
}

void wait_pool_to_be_current_timeout(int param_1)

{
    timespec local_28;
    timespec local_20;
    int local_18;
    timespec *local_14;
    int local_10;
    undefined4 local_c;

    local_c = 1;
    local_10 = 1;
    local_14 = &local_20;
    clock_gettime(1, &local_28);
    local_18 = local_28.tv_nsec + (local_10 % 1000000) * 1000;
    local_14->tv_sec =
        local_28.tv_sec + local_18 / 1000000000 + local_10 / 1000000;
    local_14->tv_nsec = local_18 % 1000000000;
    pthread_mutex_lock((pthread_mutex_t *)&DAT_001518a8);
    if (param_1 != DAT_001518a4) {
        pthread_cond_timedwait((pthread_cond_t *)&DAT_001518c0,
                               (pthread_mutex_t *)&DAT_001518a8, &local_20);
    }
    pthread_mutex_unlock((pthread_mutex_t *)&DAT_001518a8);
    return;
}

void set_current_pool(undefined4 param_1)

{
    pthread_mutex_lock((pthread_mutex_t *)&DAT_001518a8);
    DAT_001518a4 = param_1;
    pthread_cond_broadcast((pthread_cond_t *)&DAT_001518c0);
    pthread_mutex_unlock((pthread_mutex_t *)&DAT_001518a8);
    return;
}

undefined4 *add_pool(void)

{
    int iVar1;
    undefined1 auStack_100c[4096];
    undefined4 *local_c;

    local_c = (undefined4 *)calloc(2000, 1);
    if (local_c == (undefined4 *)0x0) {
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0,
                   "Failed to malloc pool in add_pool");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/pool.c",
             0x90, "add_pool", 8, 0x7d, 100, auStack_100c);
        set_miner_6060info_malloc_failed_err(1);
        /* WARNING: Subroutine does not return */
        exit(1);
    }
    local_c[1] = total_pools;
    *local_c = local_c[1];
    pools = realloc(pools, (total_pools + 2) * 4);
    iVar1 = total_pools * 4;
    total_pools = total_pools + 1;
    *(undefined4 **)((int)pools + iVar1) = local_c;
    local_c[9] = 0xffffffff;
    local_c[0xb] = 0;
    *(undefined1 *)(local_c + 7) = 1;
    *(undefined1 *)(local_c + 0x19c) = 0;
    *(undefined1 *)(local_c + 0x19e) = 0;
    local_c[0x1b5] = 0;
    local_c[0x1b7] = 0;
    *(undefined8 *)(local_c + 0x1ba) = 0;
    local_c[0x1bc] = 0;
    memset(local_c + 0x1a5, 0, 0x40);
    local_c[0x1c4] = 0;
    local_c[0x1c5] = 0;
    pthread_mutex_init((pthread_mutex_t *)(local_c + 0x18e),
                       (pthread_mutexattr_t *)0x0);
    pthread_mutex_init((pthread_mutex_t *)(local_c + 0x1c8),
                       (pthread_mutexattr_t *)0x0);
    pthread_condattr_init((pthread_condattr_t *)(local_c + 0x1ce));
    pthread_condattr_setclock((pthread_condattr_t *)(local_c + 0x1ce), 1);
    pthread_cond_init((pthread_cond_t *)(local_c + 0x1d0),
                      (pthread_condattr_t *)(local_c + 0x1ce));
    pthread_mutex_init((pthread_mutex_t *)(local_c + 0xc),
                       (pthread_mutexattr_t *)0x0);
    pthread_mutex_init((pthread_mutex_t *)(local_c + 0x18e),
                       (pthread_mutexattr_t *)0x0);
    pthread_mutex_init((pthread_mutex_t *)(local_c + 0x1bd),
                       (pthread_mutexattr_t *)0x0);
    pthread_mutex_init((pthread_mutex_t *)(local_c + 0x19f),
                       (pthread_mutexattr_t *)0x0);
    *(undefined1 *)(local_c + 0x1df) = 0;
    *(undefined1 *)(local_c + 0x1dc) = 1;
    local_c[0x1dd] = 0xffffffff;
    return local_c;
}

undefined4 FUN_00032e54(void)

{
    DAT_00151908 = DAT_00151908 + 1;
    if (total_pools < DAT_00151908) {
        add_pool();
    }
    return *(undefined4 *)(pools + (DAT_00151908 + 0x3fffffff) * 4);
}

void FUN_00032ecc(int param_1, char *param_2)

{
    char *pcVar1;
    int iVar2;
    size_t sVar3;
    void *pvVar4;
    undefined1 uVar5;
    bool bVar6;
    undefined1 auStack_100c[4096];
    char *local_c;

    pcVar1 = strstr(param_2, "://");
    local_c = param_2;
    if (pcVar1 != (char *)0x0) {
        local_c = pcVar1 + 3;
    }
    if (local_c == param_2) {
        if (*local_c == '\0') {
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, "invalid URL -- \'%s\'",
                       param_2);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/pool.c",
                 0x90, "setup_url", 9, 0xbb, 100, auStack_100c);
            if (*(int *)(param_1 + 0xc) != 0) {
                free(*(void **)(param_1 + 0xc));
            }
            pcVar1 = strdup("");
            *(char **)(param_1 + 0xc) = pcVar1;
        } else {
            if (*(int *)(param_1 + 0xc) != 0) {
                free(*(void **)(param_1 + 0xc));
            }
            sVar3 = strlen(local_c);
            pvVar4 = malloc(sVar3 + 0x80);
            *(void **)(param_1 + 0xc) = pvVar4;
            sprintf(*(char **)(param_1 + 0xc), "stratum+tcp://%s", local_c);
        }
    } else {
        iVar2 = strncasecmp(param_2, "http://", 7);
        if (((iVar2 != 0) &&
             (iVar2 = strncasecmp(param_2, "https://", 8), iVar2 != 0)) &&
            (iVar2 = strncasecmp(param_2, "stratum+tcp://", 0xe), iVar2 != 0)) {
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, "unknown protocol -- \'%s\'",
                       param_2);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/pool.c",
                 0x90, "setup_url", 9, 0xb2, 100, auStack_100c);
        }
        if (*(int *)(param_1 + 0xc) != 0) {
            free(*(void **)(param_1 + 0xc));
        }
        pcVar1 = strdup(param_2);
        *(char **)(param_1 + 0xc) = pcVar1;
        strcpy(local_c + (*(int *)(param_1 + 0xc) - (int)param_2), local_c);
    }
    iVar2 = strncasecmp(*(char **)(param_1 + 0xc), "stratum", 7);
    bVar6 = iVar2 == 0;
    if (bVar6) {
        iVar2 = 1;
    }
    uVar5 = (undefined1)iVar2;
    if (!bVar6) {
        uVar5 = 0;
    }
    *(undefined1 *)(param_1 + 0x1c) = uVar5;
    return;
}

undefined4 set_url(undefined4 param_1)

{
    undefined4 uVar1;

    uVar1 = FUN_00032e54();
    FUN_00032ecc(uVar1, param_1);
    return 0;
}

undefined4 set_user(char *param_1)

{
    char *pcVar1;
    int iVar2;

    DAT_0015190c = DAT_0015190c + 1;
    if (total_pools < DAT_0015190c) {
        add_pool();
    }
    iVar2 = *(int *)(pools + (DAT_0015190c + 0x3fffffff) * 4);
    if (*(int *)(iVar2 + 0x10) != 0) {
        free(*(void **)(iVar2 + 0x10));
    }
    pcVar1 = strdup(param_1);
    *(char **)(iVar2 + 0x10) = pcVar1;
    return 0;
}

undefined4 set_pass(char *param_1)

{
    char *pcVar1;
    int iVar2;

    DAT_00151910 = DAT_00151910 + 1;
    if (total_pools < DAT_00151910) {
        add_pool();
    }
    iVar2 = *(int *)(pools + (DAT_00151910 + 0x3fffffff) * 4);
    if (*(int *)(iVar2 + 0x14) != 0) {
        free(*(void **)(iVar2 + 0x14));
    }
    pcVar1 = strdup(param_1);
    *(char **)(iVar2 + 0x14) = pcVar1;
    return 0;
}

int FUN_0003345c(int param_1)

{
    int iVar1;
    undefined1 auStack_1014[4096];
    int local_14;
    int local_10;
    int local_c;

    local_c = 0;
    local_10 = 0;
    while ((iVar1 = local_c,
            local_10 < total_pools &&
                (local_14 = *(int *)(pools + local_10 * 4), iVar1 = local_14,
                 param_1 != *(int *)(local_14 + 4)))) {
        local_10 = local_10 + 1;
    }
    local_c = iVar1;
    if (local_c == 0) {
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, "WTF No pool %d found!", param_1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/pool.c",
             0x90, "priority_pool", 0xd, 0xfe, 100, auStack_1014);
        local_c = *(int *)(pools + param_1 * 4);
    }
    return local_c;
}

bool FUN_000335c0(int param_1)

{
    int iVar1;

    iVar1 = pool_tget(param_1, param_1 + 0x770);
    return iVar1 != 0;
}

undefined1 pool_tset(int param_1, undefined1 *param_2, char param_3)

{
    undefined1 uVar1;

    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x720));
    uVar1 = *param_2;
    *param_2 = 1;
    if (param_3 != '\0') {
        pthread_cond_broadcast((pthread_cond_t *)(param_1 + 0x740));
    }
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x720));
    return uVar1;
}

undefined1 pool_tclear(int param_1, undefined1 *param_2, char param_3)

{
    undefined1 uVar1;

    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x720));
    uVar1 = *param_2;
    *param_2 = 0;
    if (param_3 != '\0') {
        pthread_cond_broadcast((pthread_cond_t *)(param_1 + 0x740));
    }
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x720));
    return uVar1;
}

undefined1 pool_tget(int param_1, undefined1 *param_2)

{
    undefined1 uVar1;

    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x720));
    uVar1 = *param_2;
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x720));
    return uVar1;
}

int pool_twait_to_be_expected_and_set(int param_1, char *param_2, char param_3,
                                      char param_4, timespec *param_5)

{
    int iVar1;
    undefined4 local_c;

    local_c = 0;
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x720));
    if (param_5 == (timespec *)0x0) {
        while (param_3 != *param_2) {
            local_c = pthread_cond_wait((pthread_cond_t *)(param_1 + 0x740),
                                        (pthread_mutex_t *)(param_1 + 0x720));
        }
    } else {
        do {
            if ((param_3 == *param_2) ||
                (local_c = pthread_cond_timedwait(
                     (pthread_cond_t *)(param_1 + 0x740),
                     (pthread_mutex_t *)(param_1 + 0x720), param_5),
                 local_c == 0x6e))
                goto LAB_00033858;
        } while ((local_c != 0) ||
                 (iVar1 = current_pool_changed(param_1), iVar1 == 0));
        local_c = 1;
    }
LAB_00033858:
    if (local_c == 0) {
        *param_2 = param_4;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x720));
    return local_c;
}

void switch_pools(void)

{
    int iVar1;
    undefined1 auStack_1018[4096];
    int *local_18;
    int *local_14;
    int local_10;
    int local_c;

    pthread_mutex_lock((pthread_mutex_t *)&DAT_001518a8);
    local_14 = DAT_001518a4;
    local_10 = *DAT_001518a4;
    local_c = 0;
    do {
        if (total_pools <= local_c) {
        LAB_00033934:
            local_18 = *(int **)(pools + local_10 * 4);
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_001518a8);
            set_current_pool(local_18);
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, "Switching pool %d to pool %d",
                       *local_14, *local_18);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/pool.c",
                 0x90, "switch_pools", 0xc, 0x16e, 0x28, auStack_1018);
            if (local_18 != local_14) {
                pthread_mutex_lock((pthread_mutex_t *)(local_14 + 0x1c8));
                pthread_cond_broadcast((pthread_cond_t *)(local_14 + 0x1d0));
                pthread_mutex_unlock((pthread_mutex_t *)(local_14 + 0x1c8));
            }
            return;
        }
        local_18 = (int *)FUN_0003345c(local_c);
        iVar1 = FUN_000335c0(local_18);
        if (iVar1 == 0) {
            local_10 = *local_18;
            goto LAB_00033934;
        }
        local_c = local_c + 1;
    } while (true);
}

void FUN_00033a40(void)

{
    int iVar1;
    int local_18[2];
    int local_10;
    int local_c;

    local_18[0] = 0;
    iVar1 = get_all_created_runtime(local_18);
    for (local_c = 0; local_c < local_18[0]; local_c = local_c + 1) {
        for (local_10 = 0; local_10 < 0x20; local_10 = local_10 + 1) {
            *(undefined1 *)(*(int *)(iVar1 + local_c * 4) + local_10 + 0x218) =
                1;
        }
    }
    return;
}

void FUN_00033ae4(int *param_1, undefined1 param_2)

{
    int iVar1;
    int local_14[2];
    int local_c;

    local_14[0] = 0;
    iVar1 = get_all_created_runtime(local_14);
    for (local_c = 0; local_c < local_14[0]; local_c = local_c + 1) {
        *(undefined1 *)(*(int *)(iVar1 + local_c * 4) + *param_1 + 0x218) =
            param_2;
    }
    return;
}

void pool_alive(int param_1)

{
    int iVar1;

    iVar1 = pool_tclear(param_1, param_1 + 0x770, 0);
    if (iVar1 != 0) {
        FUN_00033ae4(param_1, 0);
    }
    return;
}

void pool_died(int *param_1)

{
    char cVar1;
    int *piVar2;
    undefined1 auStack_1050[4096];
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    undefined4 local_20;
    undefined4 uStack_1c;
    undefined4 uStack_18;
    undefined4 uStack_14;

    cVar1 = pool_tset(param_1, param_1 + 0x1dc, 0);
    if (cVar1 != '\x01') {
        cgtime(param_1 + 0x1dd);
        FUN_00033ae4(param_1, 1);
        piVar2 = (int *)get_current_pool();
        if (param_1 == piVar2) {
            V_LOCK();
            FUN_00032250(&local_50, &local_50, *param_1, *param_1 >> 0x1f);
            logfmt_raw(auStack_1050, 0x1000, 0, uStack_34, local_50, uStack_4c,
                       uStack_48, uStack_44, local_40, uStack_3c, uStack_38,
                       uStack_34, "not responding!");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/pool.c",
                 0x90, "pool_died", 9, 0x194, 0x50, auStack_1050);
            switch_pools(0);
        } else {
            V_LOCK();
            FUN_00032250(&local_30, &local_30, *param_1, *param_1 >> 0x1f);
            logfmt_raw(auStack_1050, 0x1000, 0, uStack_14, local_30, uStack_2c,
                       uStack_28, uStack_24, local_20, uStack_1c, uStack_18,
                       uStack_14, "failed to return work");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/pool.c",
                 0x90, "pool_died", 9, 0x197, 0x14, auStack_1050);
        }
    }
    return;
}

undefined4 check_pool_worker(void)

{
    undefined1 auStack_1014[4096];
    int local_14;
    undefined4 local_10;
    int local_c;

    local_14 = 0;
    local_10 = 0;
    for (local_c = 0; local_c < total_pools; local_c = local_c + 1) {
        if (**(char **)(*(int *)(pools + local_c * 4) + 0xc) != '\0') {
            if (**(char **)(*(int *)(pools + local_c * 4) + 0x10) == '\0') {
                V_LOCK();
                logfmt_raw(auStack_1014, 0x1000, 0, "Blank worker exists.");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/pool.c",
                     0x90, "check_pool_worker", 0x11, 0x1a5, 100, auStack_1014);
            } else {
                local_14 = local_14 + 1;
            }
        }
    }
    if (local_14 == 0) {
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0,
                   "No valid pools, please configure them first!");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/pool.c",
             0x90, "check_pool_worker", 0x11, 0x1ab, 100, auStack_1014);
        local_10 = 0xffffffff;
    }
    return local_10;
}

void load_factory_pools(void)

{
    return;
}

undefined4 share_result(int param_1, undefined4 param_2, int param_3,
                        int *param_4)

{
    uint uVar1;
    time_t tVar2;
    int extraout_r1;
    int extraout_r1_00;
    int iVar3;
    bool bVar4;
    undefined1 auStack_1058[4096];
    undefined4 local_58;
    undefined4 uStack_54;
    undefined4 uStack_50;
    undefined4 uStack_4c;
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    int local_14;

    pthread_mutex_lock((pthread_mutex_t *)&DAT_001518f0);
    if (param_1 == 0) {
        total_diff_rejected =
            *(double *)(param_4 + 0x1c4) + total_diff_rejected;
        *(double *)(param_4 + 0x1ec) =
            *(double *)(param_4 + 0x1ec) + *(double *)(param_4 + 0x1c4);
        uVar1 = param_4[0x1e4];
        param_4[0x1e4] = uVar1 + 1;
        param_4[0x1e5] = param_4[0x1e5] + (uint)(0xfffffffe < uVar1);
        bVar4 = 0xfffffffe < (uint)total_rejected;
        total_rejected._0_4_ = (uint)total_rejected + 1;
        total_rejected._4_4_ = total_rejected._4_4_ + (uint)bVar4;
    } else {
        bVar4 = 0xfffffffe < (uint)total_accepted;
        total_accepted._0_4_ = (uint)total_accepted + 1;
        total_accepted._4_4_ = total_accepted._4_4_ + (uint)bVar4;
        total_diff_accepted =
            *(double *)(param_4 + 0x1c4) + total_diff_accepted;
        uVar1 = param_4[0x1e2];
        param_4[0x1e2] = uVar1 + 1;
        param_4[0x1e3] = param_4[0x1e3] + (uint)(0xfffffffe < uVar1);
        *(double *)(param_4 + 0x1ea) =
            *(double *)(param_4 + 0x1ea) + *(double *)(param_4 + 0x1c4);
        tVar2 = time((time_t *)0x0);
        param_4[0x194] = tVar2;
        param_4[0x196] = param_4[0x1c4];
        param_4[0x197] = param_4[0x1c5];
    }
    pthread_mutex_unlock((pthread_mutex_t *)&DAT_001518f0);
    if (param_1 == 0) {
        local_14 = param_4[0x1e4];
        if (param_3 == 0) {
            FUN_0003260c(&DAT_000d88c0);
            iVar3 = local_14;
            if (local_14 < 1) {
                iVar3 = 1;
            }
            FUN_000cc7ac(
                local_14 % 10 + local_14 * 3 + (local_14 / 100) * -100 +
                    (local_14 / 1000) * -1000 + (local_14 / 10000) * -10000,
                iVar3);
            if (extraout_r1_00 == 0) {
                V_LOCK();
                FUN_00032250(&local_38, &local_38, *param_4, *param_4 >> 0x1f);
                logfmt_raw(auStack_1058, 0x1000, 0, uStack_1c, local_38,
                           uStack_34, uStack_30, uStack_2c, local_28, uStack_24,
                           uStack_20, uStack_1c, "reject reason:: NULL");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/pool.c",
                     0x90, "share_result", 0xc, 0x247, 0x50, auStack_1058);
            }
        } else {
            FUN_0003260c(param_3);
            iVar3 = local_14;
            if (local_14 < 1) {
                iVar3 = 1;
            }
            FUN_000cc7ac(
                local_14 % 10 + local_14 * 3 + (local_14 / 100) * -100 +
                    (local_14 / 1000) * -1000 + (local_14 / 10000) * -10000,
                iVar3);
            if (extraout_r1 == 0) {
                V_LOCK();
                FUN_00032250(&local_58, &local_58, *param_4, *param_4 >> 0x1f);
                logfmt_raw(auStack_1058, 0x1000, 0, uStack_3c, local_58,
                           uStack_54, uStack_50, uStack_4c, local_48, uStack_44,
                           uStack_40, uStack_3c, "reject reason: %s", param_3);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/pool.c",
                     0x90, "share_result", 0xc, 0x241, 0x50, auStack_1058);
            }
        }
    }
    return 1;
}

void update_pool_diff1_of_all_runtimes(int *param_1)

{
    int iVar1;
    uint uVar2;
    uint uVar3;
    uint *puVar4;
    uint uVar5;
    bool bVar6;
    int local_24[2];
    int local_1c;
    uint local_18;
    int iStack_14;

    local_24[0] = 0;
    iVar1 = get_all_created_runtime(local_24);
    local_18 = 0;
    iStack_14 = 0;
    for (local_1c = 0; local_1c < local_24[0]; local_1c = local_1c + 1) {
        puVar4 =
            (uint *)(*(int *)(iVar1 + local_1c * 4) + (*param_1 + 0x47) * 8);
        uVar2 = *puVar4;
        bVar6 = CARRY4(uVar2, local_18);
        local_18 = uVar2 + local_18;
        iStack_14 = puVar4[1] + iStack_14 + (uint)bVar6;
    }
    uVar2 = local_18 - *(uint *)(&DAT_00152228 + *param_1 * 8);
    bVar6 = CARRY4(uVar2, (uint)total_diff1);
    total_diff1._0_4_ = uVar2 + (uint)total_diff1;
    total_diff1._4_4_ =
        (iStack_14 -
         (*(int *)(&DAT_0015222c + *param_1 * 8) +
          (uint)(local_18 < *(uint *)(&DAT_00152228 + *param_1 * 8)))) +
        total_diff1._4_4_ + (uint)bVar6;
    uVar2 = param_1[0x1f2];
    uVar3 = *(uint *)(&DAT_00152228 + *param_1 * 8);
    iVar1 = *(int *)(&DAT_0015222c + *param_1 * 8);
    uVar5 = local_18 - uVar3;
    param_1[0x1f2] = uVar5 + uVar2;
    param_1[499] = (iStack_14 - (iVar1 + (uint)(local_18 < uVar3))) +
                   param_1[499] + (uint)CARRY4(uVar5, uVar2);
    iVar1 = *param_1;
    *(uint *)(&DAT_00152228 + iVar1 * 8) = local_18;
    *(int *)(&DAT_0015222c + iVar1 * 8) = iStack_14;
    return;
}

undefined4 create_pool_stratum_threads(void)

{
    int iVar1;
    undefined1 auStack_101c[4096];
    int local_1c;
    int *local_18;
    int local_14;
    undefined4 local_10;
    int local_c;

    local_10 = 0;
    DAT_00152220 = 1;
    set_current_pool(*pools);
    local_c = 0;
    do {
        if (total_pools <= local_c) {
            return 0;
        }
        local_14 = pools[local_c];
        if (*(char *)(local_14 + 0x1c) != '\0') {
            local_18 = (int *)(stratum_thr_info + local_c * 0x30);
            *local_18 = local_c + 4;
            iVar1 = tq_new();
            local_18[0xb] = iVar1;
            if (local_18[0xb] == 0) {
                return 0xffffffff;
            }
            tq_push(local_18[0xb], local_14);
            local_1c = FUN_00032284(local_18, stratum_thread);
            if (local_1c != 0) {
                V_LOCK();
                logfmt_raw(auStack_101c, 0x1000, 0,
                           "stratum thread create failed");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/pool.c",
                     0x90, "create_pool_stratum_threads", 0x1b, 0x274, 100,
                     auStack_101c);
                return 0xffffffff;
            }
        }
        local_c = local_c + 1;
    } while (true);
}

int check_pools_valid(void)

{
    int iVar1;
    undefined4 local_10;
    undefined4 local_c;

    pools_active = 0;
    update_miner_working_status();
    local_10 = 0;
    for (local_c = 0; local_c < total_pools; local_c = local_c + 1) {
        if ((*(char *)(*(int *)(pools + local_c * 4) + 0x1c) != '\0') &&
            (iVar1 = stratum_check(*(undefined4 *)(pools + local_c * 4)),
             iVar1 != 0)) {
            local_10 = local_10 + 1;
        }
    }
    if (local_10 == 0) {
        set_miner_6060info_network_lost_err(1);
        red_led_on();
    } else {
        set_miner_6060info_network_lost_err(0);
        red_led_off();
    }
    return local_10;
}

undefined4 custom_param_check(void)

{
    undefined1 auStack_1008[4096];

    if (((opt_algo == 0xc) || (opt_algo == 8)) && (fan_pwm_fixed != '\0')) {
        fan_pwm_fixed = '\0';
        V_LOCK();
        logfmt_raw(
            auStack_1008, 0x1000, 0,
            "fan_pwm_ctrl is not allowed. upgrade firmware without selecting "
            "\"Keep the Same Settings\" may resolve this warning");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/pool.c",
             0x90, "custom_param_check", 0x12, 0x2a6, 0x28, auStack_1008);
    }
    return 0;
}

uint judge_load_config(int param_1)

{
    undefined4 uVar1;
    uint uVar2;
    int iVar3;
    char *__nptr;
    undefined1 auStack_112c[4096];
    undefined1 auStack_12c[92];
    undefined1 auStack_d0[160];
    int local_30;
    char local_29;
    uint local_28;
    int *local_24;
    int *local_20;
    int *local_1c;
    int *local_18;
    uint local_14;

    V_LOCK();
    logfmt_raw(auStack_112c, 0x1000, 0, "start %s", "judge_load_config");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/pool.c",
         0x90, "judge_load_config", 0x11, 0x2ae, 0x14, auStack_112c);
    local_28 = 0;
    local_18 = (int *)0x0;
    local_24 = (int *)0x0;
    local_20 = (int *)0x0;
    local_1c = (int *)0x0;
    local_14 = 0;
    if (param_1 == 0) {
        V_LOCK();
        logfmt_raw(auStack_112c, 0x1000, 0, "%s: bad param",
                   "judge_load_config");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/pool.c",
             0x90, "judge_load_config", 0x11, 0x2b7, 100, auStack_112c);
    } else {
        local_18 = (int *)json_load_file(param_1, 0, auStack_12c);
        if ((local_18 == (int *)0x0) || (*local_18 != 0)) {
            V_LOCK();
            logfmt_raw(auStack_112c, 0x1000, 0,
                       "%s: JSON decode of file \'%s\' failed %s",
                       "judge_load_config", param_1, auStack_d0);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/pool.c",
                 0x90, "judge_load_config", 0x11, 0x2bd, 100, auStack_112c);
        } else {
            V_LOCK();
            logfmt_raw(auStack_112c, 0x1000, 0, "%s: after json_load_file",
                       "judge_load_config");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/pool.c",
                 0x90, "judge_load_config", 0x11, 0x2c0, 0x14, auStack_112c);
            local_24 = (int *)json_object_get(local_18, "pools");
            if ((local_24 == (int *)0x0) || (*local_24 != 1)) {
                local_28 = local_28 & 0xfffffffe;
            } else {
                DAT_00152218 = json_array_size(local_24);
                local_14 = 0;
                while (uVar2 = json_array_size(local_24), local_14 < uVar2) {
                    local_20 = (int *)json_array_get(local_24, local_14);
                    if ((((local_20 == (int *)0x0) ||
                          (local_20 == (int *)0x0)) ||
                         (*local_20 != 0)) ||
                        (2 < (int)local_14))
                        break;
                    local_1c = (int *)json_object_get(local_20, &DAT_000d89dc);
                    if ((local_1c == (int *)0x0) || (*local_1c != 2))
                        break;
                    iVar3 = local_14 * 0x300;
                    uVar1 = json_string_value(local_1c);
                    snprintf(&DAT_00151918 + iVar3, 0x100, "%s", uVar1);
                    local_1c = (int *)json_object_get(local_20, &DAT_000d89e4);
                    if ((local_1c == (int *)0x0) || (*local_1c != 2))
                        break;
                    iVar3 = local_14 * 0x300;
                    uVar1 = json_string_value(local_1c);
                    snprintf((char *)(iVar3 + 0x151a18), 0x100, "%s", uVar1);
                    local_1c = (int *)json_object_get(local_20, &DAT_000d89ec);
                    if ((local_1c == (int *)0x0) || (*local_1c != 2))
                        break;
                    iVar3 = local_14 * 0x300;
                    uVar1 = json_string_value(local_1c);
                    snprintf((char *)(iVar3 + 0x151b18), 0x100, "%s", uVar1);
                    V_LOCK();
                    logfmt_raw(auStack_112c, 0x1000, 0, "%s %s %s",
                               &DAT_00151918 + local_14 * 0x300,
                               local_14 * 0x300 + 0x151a18,
                               local_14 * 0x300 + 0x151b18);
                    V_UNLOCK();
                    zlog(
                        g_zc,
                        "/workspace/jenkins/jenkins/workspace/"
                        "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                        "release/build/godminer-origin_godminer-branch1/pool.c",
                        0x90, "judge_load_config", 0x11, 0x2d8, 0x14,
                        auStack_112c);
                    local_14 = local_14 + 1;
                }
                local_28 = local_28 & 0xfffffffe;
                if (total_pools == DAT_00152218) {
                    for (local_14 = 0; (int)local_14 < total_pools;
                         local_14 = local_14 + 1) {
                        iVar3 = strcmp(
                            *(char **)(*(int *)(pools + local_14 * 4) + 0xc),
                            &DAT_00151918 + local_14 * 0x300);
                        if (((iVar3 != 0) ||
                             (iVar3 = strcmp(
                                  *(char **)(*(int *)(pools + local_14 * 4) +
                                             0x10),
                                  (char *)(local_14 * 0x300 + 0x151a18)),
                              iVar3 != 0)) ||
                            (iVar3 = strcmp(
                                 *(char **)(*(int *)(pools + local_14 * 4) +
                                            0x14),
                                 (char *)(local_14 * 0x300 + 0x151b18)),
                             iVar3 != 0)) {
                            local_28 = local_28 | 1;
                            break;
                        }
                    }
                } else {
                    local_28 = local_28 | 1;
                }
            }
            local_1c = (int *)json_object_get(local_18, "bitmain-freq-level");
            if ((local_1c == (int *)0x0) || (*local_1c != 2)) {
                local_28 = local_28 & 0xfffffffd;
            }
            local_1c = (int *)json_object_get(local_18, "bitmain-fan-ctrl");
            if (((local_1c == (int *)0x0) || (*local_1c != 5)) &&
                ((local_1c == (int *)0x0 || (*local_1c != 6)))) {
                local_28 = local_28 & 0xfffffffb;
            } else {
                if ((local_1c == (int *)0x0) || (*local_1c != 5)) {
                    local_29 = '\0';
                } else {
                    local_29 = '\x01';
                }
                if (local_29 == fan_pwm_fixed) {
                    local_28 = local_28 & 0xfffffffb;
                } else {
                    local_28 = local_28 | 4;
                    fan_pwm_fixed = local_29;
                }
            }
            local_1c = (int *)json_object_get(local_18, "bitmain-fan-pwm");
            if ((local_1c == (int *)0x0) || (*local_1c != 2)) {
                local_28 = local_28 & 0xfffffff7;
            } else {
                __nptr = (char *)json_string_value(local_1c);
                local_30 = atoi(__nptr);
                if (local_30 == fan_pwm) {
                    local_28 = local_28 & 0xfffffff7;
                } else {
                    local_28 = local_28 | 8;
                    fan_pwm = local_30;
                }
            }
            FUN_000321e8(local_18);
            V_LOCK();
            logfmt_raw(auStack_112c, 0x1000, 0, "ret = 0x%x", local_28);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/pool.c",
                 0x90, "judge_load_config", 0x11, 0x313, 0x14, auStack_112c);
            custom_param_check();
        }
    }
    return local_28;
}

void FUN_000353b4(int *param_1)

{
    int iVar1;
    int iVar2;
    int local_c;

    iVar1 = total_pools + -1;
    for (local_c = 0; local_c < total_pools; local_c = local_c + 1) {
        iVar2 = *(int *)(pools + local_c * 4);
        if (param_1[1] < *(int *)(iVar2 + 4)) {
            *(int *)(iVar2 + 4) = *(int *)(iVar2 + 4) + -1;
        }
    }
    if (*param_1 < iVar1) {
        for (local_c = *param_1; local_c < iVar1; local_c = local_c + 1) {
            *(undefined4 *)(pools + local_c * 4) =
                *(undefined4 *)(pools + (local_c + 1) * 4);
            **(int **)(pools + local_c * 4) = local_c;
        }
    }
    *param_1 = total_pools;
    total_pools = total_pools + -1;
    return;
}

undefined4 *FUN_00035534(void)

{
    pthread_t __th;
    int iVar1;
    undefined1 auStack_10b4[4096];
    int aiStack_b4[32];
    undefined4 *local_34;
    int local_30;
    undefined4 *local_2c;
    int local_28;
    undefined4 *local_24;
    undefined4 *local_20;
    int local_1c;
    int local_18;
    undefined1 *local_14;
    char local_d;
    int local_c;

    local_d = '\0';
    local_1c = 0;
    local_18 = total_pools;
    V_LOCK();
    logfmt_raw(auStack_10b4, 0x1000, 0, "pool_change_function");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/pool.c",
         0x90, "pool_change_function", 0x14, 0x33a, 0x14, auStack_10b4);
    __th = pthread_self();
    pthread_detach(__th);
    local_14 = (undefined1 *)0x161060;
    if (thr_info._100_4_ != 0) {
        pthread_cancel(thr_info._100_4_);
        *(undefined4 *)(local_14 + 4) = 0;
        usleep(100000);
        local_d = '\x01';
    }
    for (local_c = 0; local_c < local_18; local_c = local_c + 1) {
        local_34 = (undefined4 *)pools[local_c];
        V_LOCK();
        logfmt_raw(auStack_10b4, 0x1000, 0,
                   "before add pool, pool->pool_no = %d, pool->rpc_url = %s",
                   *local_34, local_34[3]);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/pool.c",
             0x90, "pool_change_function", 0x14, 0x34a, 0x14, auStack_10b4);
    }
    for (local_c = 0; local_c < DAT_00152218; local_c = local_c + 1) {
        set_url(&DAT_00151918 + local_c * 0x300);
        set_user(local_c * 0x300 + 0x151a18);
        set_pass(local_c * 0x300 + 0x151b18);
    }
    if (local_18 == total_pools) {
        V_LOCK();
        logfmt_raw(auStack_10b4, 0x1000, 0, "Input pool error, try again");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/pool.c",
             0x90, "pool_change_function", 0x14, 0x354, 100, auStack_10b4);
    } else {
        V_LOCK();
        logfmt_raw(auStack_10b4, 0x1000, 0,
                   "total_pools = %d, need to remove %d pools", total_pools,
                   local_18);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/pool.c",
             0x90, "pool_change_function", 0x14, 0x358, 0x14, auStack_10b4);
        for (local_c = 0; local_c < total_pools; local_c = local_c + 1) {
            local_2c = (undefined4 *)pools[local_c];
            V_LOCK();
            logfmt_raw(auStack_10b4, 0x1000, 0,
                       "after add pool, pool->pool_no = %d, pool->rpc_url = %s",
                       *local_2c, local_2c[3]);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/pool.c",
                 0x90, "pool_change_function", 0x14, 0x35b, 0x14, auStack_10b4);
        }
        local_c = 0;
        while (true) {
            if (local_18 <= local_c)
                break;
            local_28 = *pools;
            iVar1 = local_c * 0x30;
            local_14 = stratum_thr_info + iVar1;
            if (*(int *)(stratum_thr_info + iVar1 + 4) != 0) {
                pthread_cancel(*(pthread_t *)(stratum_thr_info + iVar1 + 4));
                *(undefined4 *)(local_14 + 4) = 0;
            }
            if (*(int *)(local_14 + 0x2c) != 0) {
                tq_free(*(undefined4 *)(local_14 + 0x2c));
                *(undefined4 *)(local_14 + 0x2c) = 0;
            }
            pool_tclear(local_28, local_28 + 0x77c, 0);
            pool_tset(local_28, local_28 + 0x770, 0);
            DAT_00151910 = DAT_00151910 + -1;
            DAT_0015190c = DAT_0015190c + -1;
            DAT_00151908 = DAT_00151908 + -1;
            FUN_000353b4(local_28);
            aiStack_b4[local_c] = local_28;
            local_c = local_c + 1;
        }
        FUN_00033a40();
        V_LOCK();
        logfmt_raw(auStack_10b4, 0x1000, 0, "total_pools after removed = %d",
                   total_pools);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/pool.c",
             0x90, "pool_change_function", 0x14, 0x374, 0x14, auStack_10b4);
        local_c = 0;
        while (true) {
            if (total_pools <= local_c)
                break;
            local_24 = (undefined4 *)pools[local_c];
            V_LOCK();
            logfmt_raw(
                auStack_10b4, 0x1000, 0,
                "after reload pool, pool->pool_no = %d, pool->rpc_url = %s",
                *local_24, local_24[3]);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/pool.c",
                 0x90, "pool_change_function", 0x14, 0x377, 0x14, auStack_10b4);
            local_c = local_c + 1;
        }
        V_LOCK();
        logfmt_raw(auStack_10b4, 0x1000, 0,
                   "reload new pool configuration, check pool connect");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/pool.c",
             0x90, "pool_change_function", 0x14, 0x37a, 0x28, auStack_10b4);
        sleep(5);
        if (DAT_00152220 == '\0') {
            iVar1 = check_pools_valid();
            if (iVar1 < 1) {
                V_LOCK();
                logfmt_raw(auStack_10b4, 0x1000, 0,
                           "no new pools could be valid");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/pool.c",
                     0x90, "pool_change_function", 0x14, 0x385, 0x28,
                     auStack_10b4);
            }
        } else {
            create_pool_stratum_threads();
        }
        do {
            sleep(1);
            local_1c = local_1c + 1;
            if (pools_active == '\x01')
                break;
        } while (local_1c < 8);
        set_miner_start_time();
        api_flush();
        if (pools_active != '\x01') {
            V_LOCK();
            logfmt_raw(auStack_10b4, 0x1000, 0, "error pool input");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/pool.c",
                 0x90, "pool_change_function", 0x14, 0x393, 100, auStack_10b4);
            for (local_c = 0; local_c < total_pools; local_c = local_c + 1) {
                local_20 = (undefined4 *)pools[local_c];
                V_LOCK();
                logfmt_raw(auStack_10b4, 0x1000, 0,
                           "pool%d, url = %s, user = %s, pass = %s", *local_20,
                           local_20[3], local_20[4], local_20[5]);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/pool.c",
                     0x90, "pool_change_function", 0x14, 0x396, 100,
                     auStack_10b4);
            }
        }
    }
    if (local_d != '\0') {
        local_14 = (undefined1 *)0x161060;
        thr_info._96_4_ = 2;
        local_30 = FUN_00032284(0x161060, watchpool_thread);
        if (local_30 != 0) {
            V_LOCK();
            logfmt_raw(auStack_10b4, 0x1000, 0,
                       "watchpool thread create failed!");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/pool.c",
                 0x90, "pool_change_function", 0x14, 0x3a0, 100, auStack_10b4);
            /* WARNING: Subroutine does not return */
            exit(1);
        }
    }
    for (local_c = 0; local_c < local_18; local_c = local_c + 1) {
        if (aiStack_b4[local_c] != 0) {
            pool_tset(aiStack_b4[local_c], aiStack_b4[local_c] + 0x770, 1);
        }
    }
    sleep(10);
    for (local_c = 0; local_c < local_18; local_c = local_c + 1) {
        pool_tset(aiStack_b4[local_c], aiStack_b4[local_c] + 0x770, 1);
        if (aiStack_b4[local_c] != 0) {
            free((void *)aiStack_b4[local_c]);
        }
    }
    DAT_0015221c = 0;
    return &DAT_0015221c;
}

void reload_pool(void)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if (DAT_0015221c == 0) {
        iVar1 =
            pthread_create((pthread_t *)&DAT_0015221c, (pthread_attr_t *)0x0,
                           FUN_00035534, (void *)0x0);
        if (iVar1 != 0) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "Failed to create pool_change_thread");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/pool.c",
                 0x90, "reload_pool", 0xb, 0x3ba, 100, auStack_1008);
        }
    } else {
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0,
                   "config too fast, pool is changing, please wait");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/pool.c",
             0x90, "reload_pool", 0xb, 0x3bc, 100, auStack_1008);
    }
    return;
}

undefined4 FUN_00036270(void)

{
    int *piVar1;
    undefined4 uVar2;

    piVar1 = __errno_location();
    if ((*piVar1 == 0xb) || (piVar1 = __errno_location(), *piVar1 == 0xb)) {
        uVar2 = 1;
    } else {
        uVar2 = 0;
    }
    return uVar2;
}

undefined4 FUN_000362bc(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "poolno", param_3, param_4);
    return param_1;
}

undefined4 FUN_000362f0(undefined4 param_1, undefined4 param_2)

{
    V_STR(param_1, &DAT_000d8e30, param_2);
    return param_1;
}

void FUN_00036328(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_000364b4(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/util.h",
                 0x90, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

void stratum_buffer_append(int param_1, char *param_2)

{
    size_t sVar1;
    size_t sVar2;
    void *pvVar3;
    uint uVar4;

    sVar1 = strlen(*(char **)(param_1 + 0x2c));
    sVar2 = strlen(param_2);
    uVar4 = sVar2 + sVar1 + 1;
    if (*(uint *)(param_1 + 0x28) <= uVar4) {
        *(uint *)(param_1 + 0x28) = (uVar4 & 0xffffc000) + 0x4000;
        pvVar3 =
            realloc(*(void **)(param_1 + 0x2c), *(size_t *)(param_1 + 0x28));
        *(void **)(param_1 + 0x2c) = pvVar3;
    }
    strcpy((char *)(*(int *)(param_1 + 0x2c) + sVar1), param_2);
    return;
}

undefined1 stratum_send_line(int *param_1, undefined4 param_2)

{
    undefined1 auStack_1038[4096];
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    undefined1 local_11;

    local_11 = 0;
    if (opt_protocol != '\0') {
        V_LOCK();
        FUN_000362bc(&local_38, &local_38, *param_1, *param_1 >> 0x1f);
        logfmt_raw(auStack_1038, 0x1000, 0, uStack_1c, local_38, uStack_34,
                   uStack_30, uStack_2c, local_28, uStack_24, uStack_20,
                   uStack_1c, &DAT_000d8f70, param_2);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/stratum_handler.c",
             0x9b, "stratum_send_line", 0x11, 0x1f, 0x3c, auStack_1038);
    }
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0xc));
    local_11 = send_line(param_1[9], param_2);
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0xc));
    return local_11;
}

char *stratum_recv_line(int *param_1)

{
    char cVar1;
    char *pcVar2;
    int *piVar3;
    time_t tVar4;
    undefined1 auStack_506c[4096];
    undefined1 auStack_406c[16384];
    int local_6c;
    undefined4 local_68;
    undefined4 uStack_64;
    undefined4 uStack_60;
    undefined4 uStack_5c;
    undefined4 local_58;
    undefined4 uStack_54;
    undefined4 uStack_50;
    undefined4 uStack_4c;
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    size_t local_28;
    char *local_24;
    size_t local_20;
    char *local_1c;
    ssize_t local_18;
    char local_11;

    local_1c = (char *)0x0;
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0xc));
    pcVar2 = strchr((char *)param_1[0xb], 10);
    if ((pcVar2 == (char *)0x0) && (param_1[9] != -1)) {
        local_11 = '\x01';
        time(&local_6c);
        while (true) {
            memset(auStack_406c, 0, 0x4000);
            local_18 = recv(param_1[9], auStack_406c, 0x3ffc, 0);
            if (local_18 == 0) {
                V_LOCK();
                logfmt_raw(auStack_506c, 0x1000, 0,
                           "stratum_recv_line read 0 bytes");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "stratum_handler.c",
                     0x9b, "stratum_recv_line", 0x11, 0x3a, 0x14, auStack_506c);
                local_11 = '\0';
                goto LAB_00036bb8;
            }
            if (local_18 < 0)
                break;
            stratum_buffer_append(param_1, auStack_406c);
        LAB_00036b74:
            tVar4 = time((time_t *)0x0);
            if ((0x3b < tVar4 - local_6c) ||
                (pcVar2 = strchr((char *)param_1[0xb], 10),
                 pcVar2 != (char *)0x0))
                goto LAB_00036bb8;
        }
        V_LOCK();
        piVar3 = __errno_location();
        logfmt_raw(auStack_506c, 0x1000, 0,
                   "stratum_recv_line recv failed err %zd %d", local_18,
                   *piVar3);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/stratum_handler.c",
             0x9b, "stratum_recv_line", 0x11, 0x3f, 0x14, auStack_506c);
        cVar1 = FUN_00036270();
        if (cVar1 == '\x01') {
            cVar1 = socket_full(param_1[9], 1);
            if (cVar1 == '\x01')
                goto LAB_00036b74;
        }
        V_LOCK();
        piVar3 = __errno_location();
        logfmt_raw(auStack_506c, 0x1000, 0,
                   "stratum_recv_line recv failed detailed error %d", *piVar3);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/stratum_handler.c",
             0x9b, "stratum_recv_line", 0x11, 0x41, 0x14, auStack_506c);
        local_11 = '\0';
    LAB_00036bb8:
        if (local_11 != '\x01') {
            V_LOCK();
            FUN_000362bc(&local_68, &local_68, *param_1, *param_1 >> 0x1f);
            logfmt_raw(auStack_406c, 0x1000, 0, uStack_4c, local_68, uStack_64,
                       uStack_60, uStack_5c, local_58, uStack_54, uStack_50,
                       uStack_4c, "stratum_recv_line failed");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/stratum_handler.c",
                0x9b, "stratum_recv_line", 0x11, 0x4a, 0x14, auStack_406c);
            goto LAB_00036de4;
        }
    }
    local_20 = strlen((char *)param_1[0xb]);
    local_24 = strtok((char *)param_1[0xb], "\n");
    if (local_24 == (char *)0x0) {
        V_LOCK();
        logfmt_raw(
            auStack_406c, 0x1000, 0,
            "stratum_recv_line failed to parse a newline-terminated string");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/stratum_handler.c",
             0x9b, "stratum_recv_line", 0x11, 0x52, 100, auStack_406c);
    } else {
        local_1c = strdup(local_24);
        local_28 = strlen(local_1c);
        if ((int)(local_28 + 1) < (int)local_20) {
            memmove((void *)param_1[0xb], (void *)(param_1[0xb] + local_28 + 1),
                    (local_20 - local_28) + 1);
        } else {
            *(undefined1 *)param_1[0xb] = 0;
        }
    }
LAB_00036de4:
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0xc));
    if ((local_1c != (char *)0x0) && (opt_protocol != '\0')) {
        V_LOCK();
        FUN_000362bc(&local_48, &local_48, *param_1, *param_1 >> 0x1f);
        logfmt_raw(auStack_406c, 0x1000, 0, uStack_2c, local_48, uStack_44,
                   uStack_40, uStack_3c, local_38, uStack_34, uStack_30,
                   uStack_2c, &DAT_000d90f0, local_1c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/stratum_handler.c",
             0x9b, "stratum_recv_line", 0x11, 0x61, 0x3c, auStack_406c);
    }
    return local_1c;
}

undefined4 stratum_socket_full(int param_1, undefined4 param_2)

{
    size_t sVar1;
    int iVar2;
    undefined4 uVar3;
    undefined1 auStack_1008[4096];

    V_LOCK();
    sVar1 = strlen(*(char **)(param_1 + 0x2c));
    logfmt_raw(auStack_1008, 0x1000, 0, "stratum_socket_full sockbuf len %zu",
               sVar1);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/stratum_handler.c",
         0x9b, "stratum_socket_full", 0x13, 0x68, 0x14, auStack_1008);
    if ((**(char **)(param_1 + 0x2c) == '\0') &&
        (iVar2 = socket_full(*(undefined4 *)(param_1 + 0x24), param_2),
         iVar2 == 0)) {
        uVar3 = 0;
    } else {
        uVar3 = 1;
    }
    return uVar3;
}

undefined1 stratum_connect(undefined4 *param_1)

{
    char cVar1;
    int iVar2;
    void *pvVar3;
    int *piVar4;
    char *pcVar5;
    in_addr_t iVar6;
    undefined1 auStack_1158[4096];
    undefined4 local_158;
    uint16_t local_152;
    char acStack_150[256];
    sockaddr local_50;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    undefined4 local_20;
    char **local_1c;
    hostent *local_18;
    undefined1 local_11;

    local_11 = 0;
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0xc));
    iVar2 = strncasecmp((char *)param_1[8], "stratum+tcp://", 0xe);
    if (iVar2 == 0) {
        cVar1 =
            get_server_port_from_url(param_1[8] + 0xe, acStack_150, &local_152);
        if (cVar1 == '\x01') {
            V_LOCK();
            logfmt_raw(auStack_1158, 0x1000, 0, "url: %s, server: %s, port: %d",
                       param_1[8], acStack_150, local_152);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/stratum_handler.c",
                0x9b, "stratum_connect", 0xf, 0x78, 0x14, auStack_1158);
            if (param_1[0xb] == 0) {
                pvVar3 = calloc(0x4000, 1);
                param_1[0xb] = pvVar3;
                param_1[10] = 0x4000;
            }
            *(undefined1 *)param_1[0xb] = 0;
            if (param_1[9] == -1) {
                iVar2 = socket(2, 1, 6);
                param_1[9] = iVar2;
                if (param_1[9] == -1) {
                    V_LOCK();
                    logfmt_raw(auStack_1158, 0x1000, 0,
                               "stratum socket creat failed");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "stratum_handler.c",
                         0x9b, "stratum_connect", 0xf, 0x87, 100, auStack_1158);
                    goto LAB_00037764;
                }
                local_158 = 1;
                iVar2 = setsockopt(param_1[9], 1, 2, &local_158, 4);
                if (iVar2 != 0) {
                    V_LOCK();
                    piVar4 = __errno_location();
                    pcVar5 = strerror(*piVar4);
                    logfmt_raw(
                        auStack_1158, 0x1000, 0,
                        "API setsockopt SO_REUSEADDR failed (ignored): %s",
                        pcVar5);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "stratum_handler.c",
                         0x9b, "stratum_connect", 0xf, 0x91, 100, auStack_1158);
                }
            }
            iVar6 = inet_addr(acStack_150);
            if (iVar6 == 0xffffffff) {
                iVar2 = __res_init();
                if (iVar2 < 0) {
                    close(param_1[9]);
                    param_1[9] = 0xffffffff;
                    V_LOCK();
                    logfmt_raw(auStack_1158, 0x1000, 0,
                               "poolno %d res_init error", *param_1);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "stratum_handler.c",
                         0x9b, "stratum_connect", 0xf, 0xa0, 100, auStack_1158);
                    goto LAB_00037764;
                }
                local_18 = gethostbyname(acStack_150);
                if (local_18 == (hostent *)0x0) {
                    close(param_1[9]);
                    param_1[9] = 0xffffffff;
                    V_LOCK();
                    logfmt_raw(auStack_1158, 0x1000, 0,
                               "ip address config error");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "stratum_handler.c",
                         0x9b, "stratum_connect", 0xf, 0xa9, 0x14,
                         auStack_1158);
                    goto LAB_00037764;
                }
                local_1c = local_18->h_addr_list;
                local_20 = 0;
                if (*local_1c != (char *)0x0) {
                    local_50.sa_data._2_4_ = *(undefined4 *)*local_1c;
                }
            } else {
                local_50.sa_data._2_4_ = inet_addr(acStack_150);
            }
            local_50.sa_family = 2;
            local_50.sa_data._0_2_ = htons(local_152);
            iVar2 = connect(param_1[9], &local_50, 0x10);
            if (iVar2 < 0) {
                if (DAT_00152328 < 4) {
                    V_LOCK();
                    piVar4 = __errno_location();
                    pcVar5 = strerror(*piVar4);
                    logfmt_raw(auStack_1158, 0x1000, 0,
                               "Error connecting to server, error code: %s",
                               pcVar5);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "stratum_handler.c",
                         0x9b, "stratum_connect", 0xf, 0xc5, 100, auStack_1158);
                }
                close(param_1[9]);
                param_1[9] = 0xffffffff;
            } else {
                keep_sockalive(param_1[9]);
                local_11 = 1;
            }
            goto LAB_00037764;
        }
    }
    V_LOCK();
    FUN_000362f0(&local_40, param_1[8]);
    logfmt_raw(auStack_1158, 0x1000, 0, uStack_24, local_40, uStack_3c,
               uStack_38, uStack_34, local_30, uStack_2c, uStack_28, uStack_24,
               "prase url err!");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/stratum_handler.c",
         0x9b, "stratum_connect", 0xf, 0x75, 100, auStack_1158);
LAB_00037764:
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0xc));
    return local_11;
}

void stratum_disconnect(int *param_1)

{
    undefined1 auStack_1030[4096];
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    undefined4 local_20;
    undefined4 uStack_1c;
    undefined4 uStack_18;
    undefined4 uStack_14;

    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0xc));
    if (param_1[9] != -1) {
        shutdown(param_1[9], 2);
        close(param_1[9]);
        param_1[9] = -1;
        *(undefined1 *)param_1[0xb] = 0;
        V_LOCK();
        FUN_000362bc(&local_30, &local_30, *param_1, *param_1 >> 0x1f);
        logfmt_raw(auStack_1030, 0x1000, 0, uStack_14, local_30, uStack_2c,
                   uStack_28, uStack_24, local_20, uStack_1c, uStack_18,
                   uStack_14, "pool disconnect");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/stratum_handler.c",
             0x9b, "stratum_disconnect", 0x12, 0xe3, 0x14, auStack_1030);
    }
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0xc));
    return;
}

undefined4 stratum_thread(int param_1)

{
    uint uVar1;
    char cVar2;
    pthread_t __th;
    long lVar3;
    char *pcVar4;
    undefined4 *puVar5;
    int iVar6;
    int extraout_r2;
    int extraout_r3;
    int iVar7;
    bool bVar8;
    undefined1 auStack_10c0[4096];
    undefined4 local_c0;
    undefined4 uStack_bc;
    undefined4 uStack_b8;
    undefined4 uStack_b4;
    undefined4 local_b0;
    undefined4 uStack_ac;
    undefined4 uStack_a8;
    undefined4 uStack_a4;
    undefined4 local_a0;
    undefined4 uStack_9c;
    undefined4 uStack_98;
    undefined4 uStack_94;
    undefined4 local_90;
    undefined4 uStack_8c;
    undefined4 uStack_88;
    undefined4 uStack_84;
    undefined4 local_80;
    undefined4 uStack_7c;
    undefined4 uStack_78;
    undefined4 uStack_74;
    undefined4 local_70;
    undefined4 uStack_6c;
    undefined4 uStack_68;
    undefined4 uStack_64;
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    void *local_3c;
    uint local_38;
    int iStack_34;
    int local_2c;
    uint local_28;
    char local_21;
    undefined4 *local_20;
    undefined4 local_1c;
    int *local_18;
    char *local_14;

    local_2c = param_1;
    local_20 = (undefined4 *)frontend_runtime_instance();
    local_21 = '\x01';
    local_1c = 0;
    local_28 = 0x1e;
    __th = pthread_self();
    pthread_detach(__th);
    local_1c = *(undefined4 *)(local_20[0x12] + 0x14);
    local_18 = (int *)tq_pop(*(undefined4 *)(local_2c + 0x2c), 0);
    if (local_18 != (int *)0x0) {
        V_LOCK();
        logfmt_raw(auStack_10c0, 0x1000, 0, "stratum_thread pool %s",
                   local_18[3]);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/stratum_handler.c",
             0x9b, "stratum_thread", 0xe, 0xf9, 0x14, auStack_10c0);
        local_14 = (char *)calloc(1, 0x40);
        snprintf(local_14, 0x40, "%.10s_%d", "stratum_thread", *local_18);
        V_LOCK();
        lVar3 = syscall(0xe0);
        logfmt_raw(auStack_10c0, 0x1000, 0, "%s on pid %ld", local_14, lVar3);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/stratum_handler.c",
             0x9b, "stratum_thread", 0xe, 0xfb, 0x28, auStack_10c0);
        prctl(0xf, local_14);
        pcVar4 = strdup((char *)local_18[3]);
        local_18[8] = (int)pcVar4;
        if (local_18[8] != 0) {
            pool_tset(local_18, local_18 + 0x1dc, 0);
            pool_tclear(local_18, local_18 + 0x1df, 0);
            DAT_00152328 = 0;
            do {
                while (true) {
                    local_38 = 0;
                    iStack_34 = 0;
                    while (local_18[9] == -1) {
                        cVar2 = (*(code *)*local_20)(local_18);
                        if ((cVar2 == '\x01') &&
                            (cVar2 = (*(code *)local_20[4])(local_20, local_18),
                             cVar2 == '\x01')) {
                            V_LOCK();
                            iVar6 = *local_18;
                            iVar7 = local_18[8];
                            puVar5 = (undefined4 *)get_current_pool();
                            logfmt_raw(auStack_10c0, 0x1000, 0,
                                       "pool %d is active, pool url %s, "
                                       "current_pool %d",
                                       iVar6, iVar7, *puVar5);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/"
                                 "stratum_handler.c",
                                 0x9b, "stratum_thread", 0xe, 0x122, 0x14,
                                 auStack_10c0);
                            pool_alive(local_18);
                            if (local_21 != '\0') {
                                local_21 = '\0';
                                switch_pools(0);
                            }
                        } else {
                            (*(code *)local_20[1])(local_18);
                            pool_tclear(local_18, local_18 + 0x1df, 0);
                            pool_died(local_18);
                            iVar6 = iStack_34;
                            uVar1 = local_38;
                            bVar8 = 0xfffffffe < local_38;
                            local_38 = local_38 + 1;
                            iStack_34 = iStack_34 + (uint)bVar8;
                            FUN_000ccd5c(uVar1, iVar6, 0x32, 0);
                            if (extraout_r2 == 0 && extraout_r3 == 0) {
                                V_LOCK();
                                FUN_000362bc(&local_c0, &local_c0, *local_18,
                                             *local_18 >> 0x1f);
                                logfmt_raw(
                                    auStack_10c0, 0x1000, 0, uStack_a4,
                                    local_c0, uStack_bc, uStack_b8, uStack_b4,
                                    local_b0, uStack_ac, uStack_a8, uStack_a4,
                                    "...retry after %d seconds failures %d",
                                    local_28, local_38, iStack_34);
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/"
                                     "stratum_handler.c",
                                     0x9b, "stratum_thread", 0xe, 0x11c, 100,
                                     auStack_10c0);
                            }
                            sleep(local_28);
                        }
                    }
                    wait_pool_to_be_current_timeout(local_18);
                    cVar2 = stratum_socket_full(local_18, local_1c);
                    if (cVar2 == '\x01') {
                        local_3c = (void *)(*(code *)local_20[2])(local_18);
                    } else {
                        V_LOCK();
                        FUN_000362bc(&local_a0, &local_a0, *local_18,
                                     *local_18 >> 0x1f);
                        logfmt_raw(auStack_10c0, 0x1000, 0, uStack_84, local_a0,
                                   uStack_9c, uStack_98, uStack_94, local_90,
                                   uStack_8c, uStack_88, uStack_84,
                                   "stratum connection timeout");
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/"
                             "stratum_handler.c",
                             0x9b, "stratum_thread", 0xe, 0x130, 100,
                             auStack_10c0);
                        local_3c = (void *)0x0;
                    }
                    if (local_3c == (void *)0x0)
                        break;
                    iVar6 =
                        (*(code *)local_20[5])(local_20, local_18, local_3c);
                    if (iVar6 == 0) {
                        (*(code *)local_20[7])(local_20, local_3c, local_18);
                    }
                    free(local_3c);
                    pools_active = 1;
                }
                total_go = total_go + 1;
                local_18[0x1e7] = local_18[0x1e7] + 1;
                pools_active = 0;
                (*(code *)local_20[1])(local_18);
                pool_tclear(local_18, local_18 + 0x1df, 0);
                pool_died(local_18);
                V_LOCK();
                FUN_000362bc(&local_80, &local_80, *local_18,
                             *local_18 >> 0x1f);
                logfmt_raw(auStack_10c0, 0x1000, 0, uStack_64, local_80,
                           uStack_7c, uStack_78, uStack_74, local_70, uStack_6c,
                           uStack_68, uStack_64,
                           "stratum connection interrupted");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "stratum_handler.c",
                     0x9b, "stratum_thread", 0xe, 0x14c, 0x14, auStack_10c0);
                sleep(local_28);
            } while (true);
        }
    }
    V_LOCK();
    FUN_000362bc(&local_60, &local_60, *local_18, *local_18 >> 0x1f);
    logfmt_raw(auStack_10c0, 0x1000, 0, uStack_44, local_60, uStack_5c,
               uStack_58, uStack_54, local_50, uStack_4c, uStack_48, uStack_44,
               "stratum thread out");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/stratum_handler.c",
         0x9b, "stratum_thread", 0xe, 0x153, 0x3c, auStack_10c0);
    return 0;
}

undefined4 stratum_check(int *param_1)

{
    char cVar1;
    char *pcVar2;
    int iVar3;
    undefined1 auStack_1064[4096];
    undefined1 auStack_64[4];
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    undefined4 *local_20;
    uint local_1c;
    undefined4 local_18;
    void *local_14;

    local_20 = (undefined4 *)frontend_runtime_instance();
    local_1c = 0x1e;
    local_18 = *(undefined4 *)(local_20[0x12] + 0x14);
    if (((param_1 == (int *)0x0) || (param_1[3] == 0)) || (param_1[4] == 0)) {
        V_LOCK();
        logfmt_raw(auStack_1064, 0x1000, 0,
                   "stratum check, no pool %d, empty url or user", *param_1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/stratum_handler.c",
             0x9b, "stratum_check", 0xd, 0x167, 100, auStack_1064);
    } else {
        if (param_1[8] != 0) {
            free((void *)param_1[8]);
        }
        pcVar2 = strdup((char *)param_1[3]);
        param_1[8] = (int)pcVar2;
        V_LOCK();
        logfmt_raw(auStack_1064, 0x1000, 0,
                   "stratum check pool %d, pool url: %s", *param_1, param_1[3]);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/stratum_handler.c",
             0x9b, "stratum_check", 0xd, 0x16f, 0x28, auStack_1064);
        pool_tset(param_1, param_1 + 0x1dc, 0);
        pool_tclear(param_1, param_1 + 0x1df, 0);
        pool_tclear(param_1, param_1 + 2, 0);
        cVar1 = (*(code *)*local_20)(param_1);
        if (cVar1 == '\x01') {
            cVar1 = (*(code *)local_20[4])(local_20, param_1);
            if (cVar1 == '\x01') {
                while (true) {
                    wait_pool_to_be_current_timeout(param_1);
                    cVar1 = stratum_socket_full(param_1, local_18);
                    if (cVar1 == '\x01') {
                        local_14 = (void *)(*(code *)local_20[2])(param_1);
                    } else {
                        V_LOCK();
                        FUN_000362bc(&local_60, &local_60, *param_1,
                                     *param_1 >> 0x1f);
                        logfmt_raw(auStack_1064, 0x1000, 0, uStack_44, local_60,
                                   uStack_5c, uStack_58, uStack_54, local_50,
                                   uStack_4c, uStack_48, uStack_44,
                                   "stratum connection timeout");
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/"
                             "stratum_handler.c",
                             0x9b, "stratum_check", 0xd, 0x189, 100,
                             auStack_1064);
                        local_14 = (void *)0x0;
                    }
                    if (local_14 != (void *)0x0)
                        break;
                    total_go = total_go + 1;
                    param_1[0x1e7] = param_1[0x1e7] + 1;
                    (*(code *)local_20[1])(param_1);
                    pool_tclear(param_1, param_1 + 0x1df, 0);
                    pool_died(param_1);
                    V_LOCK();
                    FUN_000362bc(&local_40, &local_40, *param_1,
                                 *param_1 >> 0x1f);
                    logfmt_raw(auStack_1064, 0x1000, 0, uStack_24, local_40,
                               uStack_3c, uStack_38, uStack_34, local_30,
                               uStack_2c, uStack_28, uStack_24,
                               "stratum connection interrupted");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "stratum_handler.c",
                         0x9b, "stratum_check", 0xd, 0x198, 0x14, auStack_1064);
                    sleep(local_1c);
                }
                iVar3 = (*(code *)local_20[6])(local_20, param_1, local_14,
                                               auStack_64);
                if (iVar3 == 0) {
                    iVar3 = (*(code *)local_20[7])(local_20, local_14, param_1);
                    if (iVar3 == 0) {
                        free(local_14);
                        (*(code *)local_20[1])(param_1);
                        V_LOCK();
                        logfmt_raw(auStack_1064, 0x1000, 0,
                                   "unsuitable pool configuration, notify from "
                                   "pool:%d dose not match the machine",
                                   *param_1);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/"
                             "stratum_handler.c",
                             0x9b, "stratum_check", 0xd, 0x1aa, 100,
                             auStack_1064);
                        V_LOCK();
                        logfmt_raw(auStack_1064, 0x1000, 0,
                                   "Sweep error string = N%d:2.", *param_1);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/"
                             "stratum_handler.c",
                             0x9b, "stratum_check", 0xd, 0x1ab, 100,
                             auStack_1064);
                        return 0;
                    }
                    free(local_14);
                } else {
                    free(local_14);
                }
                pool_tset(param_1, param_1 + 2, 0);
                pool_tclear(param_1, param_1 + 0x1dc, 0);
                pools_active = 1;
                update_miner_working_status();
                (*(code *)local_20[1])(param_1);
                V_LOCK();
                logfmt_raw(auStack_1064, 0x1000, 0,
                           "pool %d is valid, url: \"%s\"", *param_1,
                           param_1[3]);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "stratum_handler.c",
                     0x9b, "stratum_check", 0xd, 0x1b5, 0x28, auStack_1064);
                return 1;
            }
            (*(code *)local_20[1])(param_1);
            V_LOCK();
            logfmt_raw(auStack_1064, 0x1000, 0, "stratum login failed");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/stratum_handler.c",
                0x9b, "stratum_check", 0xd, 0x17f, 100, auStack_1064);
        } else {
            (*(code *)local_20[1])(param_1);
            V_LOCK();
            logfmt_raw(auStack_1064, 0x1000, 0,
                       "stratum create tcp connection failed");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/stratum_handler.c",
                0x9b, "stratum_check", 0xd, 0x178, 100, auStack_1064);
        }
    }
    V_LOCK();
    logfmt_raw(auStack_1064, 0x1000, 0, "Sweep error string = N%d:1", *param_1);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/stratum_handler.c",
         0x9b, "stratum_check", 0xd, 0x1b9, 100, auStack_1064);
    return 0;
}

void FUN_00038af8(int *param_1, int *param_2, int param_3)

{
    *(int **)(param_3 + 4) = param_1;
    *param_1 = param_3;
    param_1[1] = (int)param_2;
    *param_2 = (int)param_1;
    return;
}

void FUN_00038b50(undefined4 param_1, int param_2)

{
    FUN_00038af8(param_1, *(undefined4 *)(param_2 + 4), param_2);
    return;
}

void FUN_00038b88(int *param_1, int param_2)

{
    *(int **)(param_2 + 4) = param_1;
    *param_1 = param_2;
    return;
}

void FUN_00038bc4(undefined4 *param_1)

{
    FUN_00038b88(param_1[1], *param_1);
    *param_1 = 0;
    param_1[1] = 0;
    return;
}

bool FUN_00038c14(int *param_1)

{
    return param_1 == (int *)*param_1;
}

void FUN_00038c50(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

undefined1 FUN_00038d68(byte param_1)

{
    undefined1 local_9;

    local_9 = 0;
    if ((param_1 < 0x61) || (0x66 < param_1)) {
        if ((0x2f < param_1) && (param_1 < 0x3a)) {
            local_9 = 1;
        }
    } else {
        local_9 = 1;
    }
    return local_9;
}

int FUN_00038ddc(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/util.h",
                 0x90, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

uint extract_byte_from_hex(char *param_1, int param_2)

{
    char cVar1;
    size_t sVar2;
    int iVar3;
    undefined1 auStack_1014[4096];
    uint local_14;
    uint local_10;
    undefined1 local_a;
    undefined1 local_9;

    sVar2 = strlen(param_1);
    if ((sVar2 & 1) != 0) {
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, "Provided hex %s is not valid!",
                   param_1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/util.c",
             0x90, "extract_byte_from_hex", 0x15, 0x1d, 100, auStack_1014);
    }
    iVar3 = tolower((uint)(byte)param_1[param_2]);
    local_a = (undefined1)iVar3;
    iVar3 = tolower((uint)(byte)param_1[param_2 + 1]);
    local_9 = (undefined1)iVar3;
    cVar1 = FUN_00038d68(local_a);
    if (cVar1 != '\x01') {
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, "Hex character %d is not valid!",
                   local_a);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/util.c",
             0x90, "extract_byte_from_hex", 0x15, 0x24, 100, auStack_1014);
    }
    cVar1 = FUN_00038d68(local_9);
    if (cVar1 != '\x01') {
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, "Hex character %d is not valid!",
                   local_9);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/util.c",
             0x90, "extract_byte_from_hex", 0x15, 0x27, 100, auStack_1014);
    }
    iVar3 = FUN_00038ddc(local_a);
    local_10 = iVar3 << 4;
    local_14 = FUN_00038ddc(local_9);
    if (0xff < (int)(local_10 + local_14)) {
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0,
                   "The provided hex %s at index %d is not a valid byte!",
                   param_1, param_2);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/util.c",
             0x90, "extract_byte_from_hex", 0x15, 0x2e, 100, auStack_1014);
    }
    return (local_10 & 0xff) + (local_14 & 0xff) & 0xff;
}

void format_hashrate_string(undefined4 param_1, char *param_2)

{
    double in_d0;
    undefined8 local_1018;
    undefined1 auStack_100c[4099];
    byte local_9;

    local_9 = 0;
    V_LOCK();
    local_1018._0_4_ = SUB84(in_d0, 0);
    local_1018._4_4_ = (undefined4)((ulonglong)in_d0 >> 0x20);
    logfmt_raw(auStack_100c, 0x1000, 0, "format hashrate string %f %s",
               (undefined4)local_1018, local_1018._4_4_, param_1);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/util.c",
         0x90, "format_hashrate_string", 0x16, 0x38, 0x14, auStack_100c);
    local_1018 = in_d0;
    if (10000.0 <= in_d0) {
        if (10000000.0 <= in_d0) {
            if (10000000000.0 <= in_d0) {
                if (10000000000000.0 <= in_d0) {
                    local_9 = 0x47;
                    local_1018 = in_d0 * 1e-09;
                } else {
                    local_9 = 0x47;
                    local_1018 = in_d0 * 1e-09;
                }
            } else {
                local_9 = 0x4d;
                local_1018 = in_d0 * 1e-06;
            }
        } else {
            local_9 = 0x4b;
            local_1018 = in_d0 * 0.001;
        }
    }
    if (local_9 == 0) {
        sprintf(param_2, "%.2f %s/s", (undefined4)local_1018, local_1018._4_4_,
                param_1);
    } else {
        sprintf(param_2, "%.2f %c%s/s", (undefined4)local_1018,
                local_1018._4_4_, (uint)local_9, param_1);
    }
    return;
}

undefined4 format_hashrate_double(undefined4 param_1, double *param_2,
                                  char *param_3)

{
    double in_d0;
    undefined4 local_1020;
    undefined4 uStack_101c;
    undefined1 auStack_1018[4096];
    undefined4 local_18;
    undefined4 uStack_14;
    byte local_9;

    local_9 = 0;
    local_18 = 0;
    uStack_14 = 0;
    V_LOCK();
    local_1020 = SUB84(in_d0, 0);
    uStack_101c = (undefined4)((ulonglong)in_d0 >> 0x20);
    logfmt_raw(auStack_1018, 0x1000, 0, "format hashrate double %f %s",
               local_1020, uStack_101c, param_1);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/util.c",
         0x90, "format_hashrate_double", 0x16, 0x5b, 0x14, auStack_1018);
    if (10000.0 <= in_d0) {
        if (10000000.0 <= in_d0) {
            if (10000000000.0 <= in_d0) {
                if (10000000000000.0 <= in_d0) {
                    local_9 = 0x47;
                    local_18 = 0xe826d695;
                    uStack_14 = 0x3e112e0b;
                } else {
                    local_9 = 0x47;
                    local_18 = 0xe826d695;
                    uStack_14 = 0x3e112e0b;
                }
            } else {
                local_9 = 0x4d;
                local_18 = 0xa0b5ed8d;
                uStack_14 = 0x3eb0c6f7;
            }
        } else {
            local_9 = 0x4b;
            local_18 = 0xd2f1a9fc;
            uStack_14 = 0x3f50624d;
        }
    } else {
        local_18 = 0;
        uStack_14 = 0x3ff00000;
    }
    *param_2 = in_d0 * (double)CONCAT44(uStack_14, local_18);
    if (local_9 == 0) {
        sprintf(param_3, "%s/s", param_1);
    } else {
        sprintf(param_3, "%c%s/s", (uint)local_9, param_1);
    }
    return local_18;
}

void rev(int param_1, int param_2)

{
    undefined1 uVar1;
    undefined4 local_10;
    undefined4 local_c;

    local_10 = param_2 + -1;
    for (local_c = 0; local_c < local_10; local_c = local_c + 1) {
        uVar1 = *(undefined1 *)(param_1 + local_c);
        *(undefined1 *)(param_1 + local_c) =
            *(undefined1 *)(param_1 + local_10);
        *(undefined1 *)(param_1 + local_10) = uVar1;
        local_10 = local_10 + -1;
    }
    return;
}

void bin2hex(int param_1, int param_2, uint param_3)

{
    uint local_c;

    for (local_c = 0; local_c < param_3; local_c = local_c + 1) {
        sprintf((char *)(param_1 + local_c * 2), "%02x",
                (uint) * (byte *)(param_2 + local_c));
    }
    return;
}

void *abin2hex(undefined4 param_1, int param_2)

{
    void *pvVar1;

    pvVar1 = malloc(param_2 * 2 + 1);
    if (pvVar1 == (void *)0x0) {
        set_miner_6060info_malloc_failed_err(1);
        pvVar1 = (void *)0x0;
    } else {
        bin2hex(pvVar1, param_1, param_2);
    }
    return pvVar1;
}

bool hex2bin(undefined1 *param_1, char *param_2, int param_3)

{
    long lVar1;
    int local_101c;
    char *local_1018;
    undefined1 *local_1014;
    undefined1 auStack_1010[4096];
    char *local_10;
    char local_c;
    char local_b;
    undefined1 local_a;

    local_a = 0;
    local_101c = param_3;
    local_1018 = param_2;
    local_1014 = param_1;
    while (true) {
        if ((*local_1018 == '\0') || (local_101c == 0)) {
            return local_101c == 0;
        }
        if (local_1018[1] == '\0') {
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0, "hex2bin str truncated");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/util.c",
                 0x90, "hex2bin", 7, 0xa0, 100, auStack_1010);
            return false;
        }
        local_c = *local_1018;
        local_b = local_1018[1];
        lVar1 = strtol(&local_c, &local_10, 0x10);
        *local_1014 = (char)lVar1;
        if (*local_10 != '\0')
            break;
        local_1014 = local_1014 + 1;
        local_1018 = local_1018 + 2;
        local_101c = local_101c + -1;
    }
    V_LOCK();
    logfmt_raw(auStack_1010, 0x1000, 0, "hex2bin failed on \'%s\'", &local_c);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/util.c",
         0x90, "hex2bin", 7, 0xa7, 100, auStack_1010);
    return false;
}

byte FUN_00039ca0(byte param_1)

{
    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            if ((0x40 < param_1) && (param_1 < 0x47)) {
                param_1 = param_1 - 0x37;
            }
        } else {
            param_1 = param_1 + 0xa9;
        }
    } else {
        param_1 = param_1 - 0x30;
    }
    return param_1;
}

int str2hex(int param_1, int param_2, int param_3)

{
    char cVar1;
    byte bVar2;
    undefined4 local_c;

    for (local_c = 0; local_c < param_3; local_c = local_c + 2) {
        cVar1 = FUN_00039ca0(*(undefined1 *)(param_2 + local_c));
        bVar2 = FUN_00039ca0(*(undefined1 *)(param_2 + local_c + 1));
        *(byte *)(param_1 + local_c / 2) = cVar1 << 4 | bVar2;
    }
    return param_3 / 2;
}

undefined1 valid_hex(char *param_1)

{
    undefined1 auStack_1014[4098];
    byte local_12;
    undefined1 local_11;
    int local_10;
    size_t local_c;

    local_11 = 0;
    if (param_1 == (char *)0x0) {
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, "Null string passed to valid_hex");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/util.c",
             0x90, "valid_hex", 9, 0xe3, 0x14, auStack_1014);
    } else {
        local_c = strlen(param_1);
        for (local_10 = 0; local_10 < (int)local_c; local_10 = local_10 + 1) {
            local_12 = param_1[local_10];
            if (*(int *)(&DAT_000d985c + (uint)local_12 * 4) < 0) {
                V_LOCK();
                logfmt_raw(auStack_1014, 0x1000, 0,
                           "Invalid charpassed to valid_hex");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/util.c",
                     0x90, "valid_hex", 9, 0xed, 0x14, auStack_1014);
                return local_11;
            }
        }
        local_11 = 1;
    }
    return local_11;
}

undefined1 valid_ascii(char *param_1)

{
    undefined1 auStack_1018[4099];
    undefined1 local_15;
    size_t local_14;
    int local_10;
    byte local_9;

    local_15 = 0;
    if (param_1 == (char *)0x0) {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0,
                   "Null string passed to valid_ascii");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/util.c",
             0x90, "valid_ascii", 0xb, 0xfc, 0x14, auStack_1018);
    } else {
        local_14 = strlen(param_1);
        if (local_14 == 0) {
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0,
                       "Zero length string passed to valid_ascii");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/util.c",
                 0x90, "valid_ascii", 0xb, 0x102, 0x14, auStack_1018);
        } else {
            for (local_10 = 0; local_10 < (int)local_14;
                 local_10 = local_10 + 1) {
                local_9 = param_1[local_10];
                if ((local_9 < 0x20) || (0x7e < local_9)) {
                    V_LOCK();
                    logfmt_raw(auStack_1018, 0x1000, 0,
                               "Invalid char passed to valid_ascii");
                    V_UNLOCK();
                    zlog(
                        g_zc,
                        "/workspace/jenkins/jenkins/workspace/"
                        "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                        "release/build/godminer-origin_godminer-branch1/util.c",
                        0x90, "valid_ascii", 0xb, 0x10b, 0x14, auStack_1018);
                    return local_15;
                }
            }
            local_15 = 1;
        }
    }
    return local_15;
}

int reverse_hex(int param_1, uint param_2)

{
    undefined1 uVar1;
    undefined4 local_c;

    for (local_c = 0; local_c < param_2 >> 1; local_c = local_c + 1) {
        uVar1 = *(undefined1 *)(param_1 + local_c);
        *(undefined1 *)(param_1 + local_c) =
            *(undefined1 *)(param_1 + (param_2 - local_c) + -1);
        *(undefined1 *)(param_1 + (param_2 - local_c) + -1) = uVar1;
    }
    return param_1;
}

void *tq_new(void)

{
    void *pvVar1;

    pvVar1 = calloc(1, 0x58);
    if (pvVar1 == (void *)0x0) {
        pvVar1 = (void *)0x0;
    } else {
        *(void **)pvVar1 = pvVar1;
        *(void **)((int)pvVar1 + 4) = pvVar1;
        pthread_mutex_init((pthread_mutex_t *)((int)pvVar1 + 0xc),
                           (pthread_mutexattr_t *)0x0);
        pthread_cond_init((pthread_cond_t *)((int)pvVar1 + 0x28),
                          (pthread_condattr_t *)0x0);
    }
    return pvVar1;
}

void tq_free(int *param_1)

{
    undefined4 *puVar1;
    undefined4 *local_10;
    undefined4 *local_c;

    if (param_1 != (int *)0x0) {
        local_c = (undefined4 *)*param_1 + -1;
        puVar1 = *(undefined4 **)*param_1;
        while (local_10 = puVar1 + -1, local_c + 1 != param_1) {
            FUN_00038bc4(local_c + 1);
            free(local_c);
            local_c = local_10;
            puVar1 = (undefined4 *)*puVar1;
        }
        pthread_cond_destroy((pthread_cond_t *)(param_1 + 10));
        pthread_mutex_destroy((pthread_mutex_t *)(param_1 + 3));
        memset(param_1, 0, 0x58);
        free(param_1);
    }
    return;
}

void FUN_0003a424(int param_1, undefined1 param_2)

{
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0xc));
    *(undefined1 *)(param_1 + 8) = param_2;
    pthread_cond_signal((pthread_cond_t *)(param_1 + 0x28));
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0xc));
    return;
}

void tq_freeze(undefined4 param_1)

{
    FUN_0003a424(param_1, 1);
    return;
}

void tq_thaw(undefined4 param_1)

{
    FUN_0003a424(param_1, 0);
    return;
}

bool tq_push(int param_1, undefined4 param_2)

{
    undefined4 *__ptr;
    bool local_9;

    __ptr = (undefined4 *)calloc(1, 0xc);
    if (__ptr == (undefined4 *)0x0) {
        local_9 = false;
    } else {
        *__ptr = param_2;
        __ptr[1] = __ptr + 1;
        __ptr[2] = __ptr + 1;
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0xc));
        local_9 = *(char *)(param_1 + 8) == '\x01';
        if (local_9) {
            free(__ptr);
        } else {
            FUN_00038b50(__ptr + 1, param_1);
        }
        local_9 = !local_9;
        pthread_cond_signal((pthread_cond_t *)(param_1 + 0x28));
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0xc));
    }
    return local_9;
}

undefined4 tq_pop(int *param_1, timespec *param_2)

{
    int iVar1;
    undefined4 *__ptr;
    int local_10;
    undefined4 local_c;

    local_c = 0;
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 3));
    iVar1 = FUN_00038c14(param_1);
    if (iVar1 != 0) {
        if (param_2 == (timespec *)0x0) {
            local_10 = pthread_cond_wait((pthread_cond_t *)(param_1 + 10),
                                         (pthread_mutex_t *)(param_1 + 3));
        } else {
            local_10 = pthread_cond_timedwait((pthread_cond_t *)(param_1 + 10),
                                              (pthread_mutex_t *)(param_1 + 3),
                                              param_2);
        }
        if ((local_10 != 0) || (iVar1 = FUN_00038c14(param_1), iVar1 != 0))
            goto LAB_0003a6cc;
    }
    __ptr = (undefined4 *)(*param_1 + -4);
    local_c = *__ptr;
    FUN_00038bc4(*param_1);
    free(__ptr);
LAB_0003a6cc:
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 3));
    return local_c;
}

int FUN_0003a6ec(int param_1, int param_2)

{
    int iVar1;
    int local_10;
    int local_c;

    local_c = 0;
    for (local_10 = 0; local_10 < 0x20; local_10 = local_10 + 4) {
        iVar1 = sprintf((char *)(param_1 + local_c), "%02x%02x%02x%02x ",
                        (uint) * (byte *)(param_2 + local_10),
                        (uint) * (byte *)(param_2 + local_10 + 1),
                        (uint) * (byte *)(param_2 + local_10 + 2),
                        (uint) * (byte *)(param_2 + local_10 + 3));
        local_c = local_c + iVar1;
    }
    return param_1;
}

void cgtime(timeval *param_1)

{
    gettimeofday(param_1, (__timezone_ptr_t)0x0);
    return;
}

void cgtimer_sub(int *param_1, int *param_2, int *param_3)

{
    *param_3 = *param_1 - *param_2;
    param_3[1] = param_1[1] - param_2[1];
    if (param_3[1] < 0) {
        *param_3 = *param_3 + -1;
        param_3[1] = (int)(&DAT_000f4240 + param_3[1]);
    }
    return;
}

void FUN_0003a890(char *param_1, int *param_2, int param_3, int param_4)

{
    undefined1 auStack_1010[4096];
    char *local_10;
    long local_c;

    local_c = strtol(param_1, &local_10, 0);
    if ((*local_10 != '\0') || (*param_1 == '\0')) {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, "\'%s\' is not a number", param_1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/util.c",
             0x90, "opt_set_longval", 0xf, 0x1da, 100, auStack_1010);
    }
    if ((local_c == 0x7fffffff) || (local_c == -0x80000000)) {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, "\'%s\' is out of range", param_1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/util.c",
             0x90, "opt_set_longval", 0xf, 0x1dc, 100, auStack_1010);
    }
    if ((local_c < param_3) && (param_4 < local_c)) {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, "\'%s\' is out of range", param_1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/util.c",
             0x90, "opt_set_longval", 0xf, 0x1e0, 100, auStack_1010);
        return;
    }
    *param_2 = local_c;
    return;
}

undefined1 get_server_port_from_url(char *param_1, char *param_2,
                                    undefined2 *param_3)

{
    char *pcVar1;
    char *pcVar2;
    undefined2 local_1c[2];
    char *local_18;
    undefined1 local_11;

    local_11 = 0;
    if (param_1 != (char *)0x0) {
        local_18 = strchr(param_1, 0x3a);
        if ((local_18 != (char *)0x0) && (local_18 != param_1)) {
            strncpy(param_2, param_1, (int)local_18 - (int)param_1);
            param_2[(int)local_18 - (int)param_1] = '\0';
            pcVar2 = local_18 + (1 - (int)param_1);
            pcVar1 = (char *)strlen(param_1);
            if (pcVar2 < pcVar1) {
                FUN_0003a890(local_18 + 1, local_1c, 0, 0xffff);
                *param_3 = local_1c[0];
                local_11 = 1;
            }
        }
    }
    return local_11;
}

void find_min_and_max_float(int param_1, int param_2, float *param_3,
                            float *param_4)

{
    undefined4 local_14;
    undefined4 local_10;
    undefined4 local_c;

    local_c = INFINITY;
    local_10 = -INFINITY;
    for (local_14 = 0; local_14 < param_2; local_14 = local_14 + 1) {
        if (*(float *)(param_1 + local_14 * 4) < local_c) {
            local_c = *(float *)(param_1 + local_14 * 4);
        }
        if (local_10 < *(float *)(param_1 + local_14 * 4)) {
            local_10 = *(float *)(param_1 + local_14 * 4);
        }
    }
    *param_3 = local_c;
    *param_4 = local_10;
    return;
}

void find_min_and_max_int(int *param_1, int param_2, int *param_3, int *param_4)

{
    int local_14;
    int local_10;
    int local_c;

    if (0 < param_2) {
        local_c = *param_1;
        local_10 = *param_1;
        for (local_14 = 1; local_14 < param_2; local_14 = local_14 + 1) {
            if (param_1[local_14] < local_c) {
                local_c = param_1[local_14];
            }
            if (local_10 < param_1[local_14]) {
                local_10 = param_1[local_14];
            }
        }
        *param_3 = local_c;
        *param_4 = local_10;
    }
    return;
}

undefined4 calc_mean(int param_1, int param_2)

{
    undefined4 local_10;
    undefined4 local_c;

    local_c = 0;
    for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
        local_c = local_c + *(int *)(param_1 + local_10 * 4);
    }
    return SUB84((double)(longlong)local_c / (double)(longlong)param_2, 0);
}

undefined4 calc_stdd(int param_1, int param_2)

{
    undefined4 uVar1;
    undefined4 extraout_s1;
    double dVar2;
    undefined4 local_14;
    undefined8 local_10;

    local_10 = 0.0;
    uVar1 = calc_mean(param_1, param_2);
    for (local_14 = 0; local_14 < param_2; local_14 = local_14 + 1) {
        dVar2 = pow((double)(longlong) * (int *)(param_1 + local_14 * 4) -
                        (double)CONCAT44(extraout_s1, uVar1),
                    2.0);
        local_10 = local_10 + dVar2;
    }
    dVar2 = sqrt(local_10 / (double)(longlong)param_2);
    return SUB84(dVar2, 0);
}

undefined4 check_value_valid_with_stdd(undefined4 param_1, undefined4 param_2,
                                       int param_3)

{
    undefined4 uVar1;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;
    undefined1 auStack_1028[4096];
    undefined8 local_28;
    undefined8 local_20;
    undefined8 local_18;
    undefined8 local_10;

    uVar1 = calc_mean(param_1, param_2);
    local_10 = (double)CONCAT44(extraout_s1, uVar1);
    uVar1 = calc_stdd(param_1, param_2);
    local_18 = (double)CONCAT44(extraout_s1_00, uVar1);
    local_20 = local_10 - local_18;
    local_28 = local_10 + local_18;
    V_LOCK();
    logfmt_raw(
        auStack_1028, 0x1000, 0,
        "mean:%.4f, stdd:%.4f, min_value:%.4f, max_value:%.4f, to_check:%.4f",
        (undefined4)local_10, local_10._4_4_, (undefined4)local_18,
        local_18._4_4_, (undefined4)local_20, local_20._4_4_,
        (undefined4)local_28, local_28._4_4_, (double)(longlong)param_3);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/util.c",
         0x90, "check_value_valid_with_stdd", 0x1b, 0x23b, 0x14, auStack_1028);
    if (((local_20 <= (double)(longlong)param_3) &&
         ((double)(longlong)param_3 <= local_28)) ||
        (local_18 < 2.0)) {
        uVar1 = 1;
    } else {
        uVar1 = 0;
    }
    return uVar1;
}

int cmpfunc_float(float *param_1, float *param_2)

{
    return (int)(*param_1 - *param_2);
}

int cmpfunc_int(int *param_1, int *param_2)

{
    return *param_1 - *param_2;
}

uint CalcFileMD5(undefined4 param_1, undefined1 *param_2)

{
    ushort **ppuVar1;
    uint uVar2;
    ushort *puVar3;
    undefined1 *local_1c0;
    char acStack_1b8[412];
    int local_1c;
    FILE *local_18;
    int local_14;

    sprintf(acStack_1b8, "md5sum %.256s 2>/dev/null", param_1);
    local_18 = popen(acStack_1b8, "r");
    if (local_18 == (FILE *)0x0) {
        uVar2 = 0xffffffff;
    } else {
        local_1c0 = param_2;
        for (local_14 = 0; local_14 < 0x20; local_14 = local_14 + 1) {
            ppuVar1 = __ctype_b_loc();
            puVar3 = *ppuVar1;
            local_1c = fgetc(local_18);
            if ((puVar3[local_1c] & 0x1000) == 0)
                break;
            *local_1c0 = (char)local_1c;
            local_1c0 = local_1c0 + 1;
        }
        *local_1c0 = 0;
        pclose(local_18);
        uVar2 = (uint)(local_14 != 0x20);
    }
    return uVar2;
}

void FUN_0003b2a0(void)

{
    return;
}

int FUN_0003b2c0(undefined4 param_1, int param_2)

{
    int iVar1;
    int extraout_r1;
    int extraout_r1_00;
    undefined4 local_18;
    undefined4 local_c;

    FUN_000cc7ac(param_1, param_2);
    local_18 = param_2;
    local_c = extraout_r1;
    while (iVar1 = local_18, local_c != 0) {
        local_18 = local_c;
        FUN_000cc7ac(iVar1, local_c);
        local_c = extraout_r1_00;
    }
    return local_18;
}

void FUN_0003b334(int param_1, int param_2, int param_3, int param_4)

{
    int iVar1;
    int iVar2;
    int iVar3;
    int iVar4;
    undefined4 uVar5;
    int local_14;
    int local_10;
    int local_c;

    iVar2 = FUN_0003b2c0(param_2 - param_1, param_3 - param_2);
    iVar3 = FUN_000cc518(param_3 - param_1, iVar2);
    for (local_c = 0; local_c < iVar2; local_c = local_c + 1) {
        iVar4 = param_2 + local_c;
        local_14 = iVar4;
        for (local_10 = 0; local_10 < iVar3; local_10 = local_10 + 1) {
            iVar1 = param_3 - param_2;
            if (param_2 <= local_14) {
                iVar1 = -(param_2 - param_1);
            }
            local_14 = local_14 + iVar1;
            uVar5 = *(undefined4 *)(param_4 + local_14 * 4);
            *(undefined4 *)(param_4 + local_14 * 4) =
                *(undefined4 *)(param_4 + iVar4 * 4);
            *(undefined4 *)(param_4 + iVar4 * 4) = uVar5;
        }
    }
    return;
}

undefined4 FUN_0003b4a0(int param_1, char *param_2, int param_3, int *param_4,
                        int param_5)

{
    char *__s;
    int iVar1;
    size_t sVar2;
    undefined4 uVar3;
    int local_18;
    int local_14;
    size_t local_10;
    char *local_c;

    __s = DAT_0014de88;
    local_18 = -1;
    optind = optind + 1;
    local_c = strchr(DAT_0014de88, 0x3d);
    if (local_c == (char *)0x0) {
        local_10 = strlen(__s);
        local_c = (char *)0x0;
    } else {
        local_10 = (int)local_c - (int)__s;
        local_c = local_c + 1;
    }
    local_14 = 0;
    do {
        if (*(int *)(param_3 + local_14 * 0x10) == 0) {
        LAB_0003b664:
            if (local_18 == -1) {
                if (param_5 == 0) {
                    if ((opterr != 0) && (*param_2 != ':')) {
                        FUN_0003b2a0("unknown option -- %s", __s);
                    }
                    optopt = 0;
                    uVar3 = 0x3f;
                } else {
                    optind = optind + -1;
                    uVar3 = 0xffffffff;
                }
            } else if ((*(int *)(param_3 + local_18 * 0x10 + 4) == 0) &&
                       (local_c != (char *)0x0)) {
                if ((opterr != 0) && (*param_2 != ':')) {
                    FUN_0003b2a0("option doesn\'t take an argument -- %.*s",
                                 local_10, __s);
                }
                if (*(int *)(param_3 + local_18 * 0x10 + 8) == 0) {
                    optopt = *(undefined4 *)(param_3 + local_18 * 0x10 + 0xc);
                } else {
                    optopt = 0;
                }
                if (*param_2 == ':') {
                    uVar3 = 0x3a;
                } else {
                    uVar3 = 0x3f;
                }
            } else {
                if ((*(int *)(param_3 + local_18 * 0x10 + 4) == 1) ||
                    (*(int *)(param_3 + local_18 * 0x10 + 4) == 2)) {
                    if (local_c == (char *)0x0) {
                        if (*(int *)(param_3 + local_18 * 0x10 + 4) == 1) {
                            optarg = *(char **)(param_1 + optind * 4);
                            optind = optind + 1;
                        }
                    } else {
                        optarg = local_c;
                    }
                }
                if ((*(int *)(param_3 + local_18 * 0x10 + 4) == 1) &&
                    (optarg == (char *)0x0)) {
                    if ((opterr != 0) && (*param_2 != ':')) {
                        FUN_0003b2a0("option requires an argument -- %s", __s);
                    }
                    if (*(int *)(param_3 + local_18 * 0x10 + 8) == 0) {
                        optopt =
                            *(undefined4 *)(param_3 + local_18 * 0x10 + 0xc);
                    } else {
                        optopt = 0;
                    }
                    optind = optind + -1;
                    if (*param_2 == ':') {
                        uVar3 = 0x3a;
                    } else {
                        uVar3 = 0x3f;
                    }
                } else {
                    if (param_4 != (int *)0x0) {
                        *param_4 = local_18;
                    }
                    if (*(int *)(param_3 + local_18 * 0x10 + 8) == 0) {
                        uVar3 =
                            *(undefined4 *)(param_3 + local_18 * 0x10 + 0xc);
                    } else {
                        **(undefined4 **)(param_3 + local_18 * 0x10 + 8) =
                            *(undefined4 *)(param_3 + local_18 * 0x10 + 0xc);
                        uVar3 = 0;
                    }
                }
            }
            return uVar3;
        }
        iVar1 = strncmp(__s, *(char **)(param_3 + local_14 * 0x10), local_10);
        if (iVar1 == 0) {
            sVar2 = strlen(*(char **)(param_3 + local_14 * 0x10));
            if (local_10 == sVar2) {
                local_18 = local_14;
                goto LAB_0003b664;
            }
            if ((param_5 == 0) || (local_10 != 1)) {
                if (local_18 != -1) {
                    if ((opterr != 0) && (*param_2 != ':')) {
                        FUN_0003b2a0("ambiguous option -- %.*s", local_10, __s);
                    }
                    optopt = 0;
                    return 0x3f;
                }
                local_18 = local_14;
            }
        }
        local_14 = local_14 + 1;
    } while (true);
}

uint FUN_0003b9e8(int param_1, int param_2, char *param_3, int param_4,
                  undefined4 param_5, uint param_6)

{
    int iVar1;
    char *pcVar2;
    uint uVar3;
    byte *pbVar4;
    char *local_24;
    undefined4 local_c;

    if (param_3 == (char *)0x0) {
        return 0xffffffff;
    }
    if (DAT_0014de94 == 0xffffffff) {
        pcVar2 = getenv("POSIXLY_CORRECT");
        DAT_0014de94 = (uint)(pcVar2 != (char *)0x0);
    }
    if ((DAT_0014de94 == 0) && (*param_3 != '+')) {
        if (*param_3 == '-') {
            param_6 = param_6 | 2;
        }
    } else {
        param_6 = param_6 & 0xfffffffe;
    }
    if ((*param_3 == '+') || (local_24 = param_3, *param_3 == '-')) {
        local_24 = param_3 + 1;
    }
    if (optind == 0) {
        optreset = 1;
        optind = 1;
    }
    optarg = (byte *)0x0;
    if (optreset != 0) {
        DAT_0014de90 = -1;
        DAT_0014de8c = -1;
    }
    do {
        if ((optreset == 0) && (pbVar4 = DAT_0014de88, *DAT_0014de88 != 0)) {
        LAB_0003bff8:
            DAT_0014de88 = pbVar4;
            if (((param_4 != 0) &&
                 (*(byte **)(param_2 + optind * 4) != DAT_0014de88)) &&
                ((*DAT_0014de88 == 0x2d || ((param_6 & 4) != 0)))) {
                local_c = 0;
                if (*DAT_0014de88 == 0x2d) {
                    DAT_0014de88 = DAT_0014de88 + 1;
                } else if ((*DAT_0014de88 != 0x3a) &&
                           (pcVar2 = strchr(local_24, (uint)*DAT_0014de88),
                            pcVar2 != (char *)0x0)) {
                    local_c = 1;
                }
                uVar3 =
                    FUN_0003b4a0(param_2, local_24, param_4, param_5, local_c);
                if (uVar3 != 0xffffffff) {
                    DAT_0014de88 = &DAT_000d9eac;
                    return uVar3;
                }
            }
            pbVar4 = DAT_0014de88 + 1;
            uVar3 = (uint)*DAT_0014de88;
            DAT_0014de88 = pbVar4;
            if ((uVar3 == 0x3a) ||
                (((uVar3 == 0x2d && (*pbVar4 != 0)) ||
                  (pcVar2 = strchr(local_24, uVar3), pcVar2 == (char *)0x0)))) {
                if ((uVar3 == 0x2d) && (*DAT_0014de88 == 0)) {
                    return 0xffffffff;
                }
                if (*DAT_0014de88 == 0) {
                    optind = optind + 1;
                }
                if ((opterr != 0) && (*local_24 != ':')) {
                    FUN_0003b2a0("unknown option -- %c", uVar3);
                }
                optopt = uVar3;
                return 0x3f;
            }
            if (((param_4 != 0) && (uVar3 == 0x57)) && (pcVar2[1] == ';')) {
                if (*DAT_0014de88 == 0) {
                    optind = optind + 1;
                    if (param_1 <= optind) {
                        DAT_0014de88 = &DAT_000d9eac;
                        if ((opterr != 0) && (*local_24 != ':')) {
                            FUN_0003b2a0("option requires an argument -- %c",
                                         0x57);
                        }
                        if (*local_24 == ':') {
                            optopt = uVar3;
                            return 0x3a;
                        }
                        optopt = uVar3;
                        return 0x3f;
                    }
                    DAT_0014de88 = *(byte **)(param_2 + optind * 4);
                }
                uVar3 = FUN_0003b4a0(param_2, local_24, param_4, param_5, 0);
                DAT_0014de88 = &DAT_000d9eac;
                return uVar3;
            }
            if (pcVar2[1] != ':') {
                if (*DAT_0014de88 != 0) {
                    return uVar3;
                }
                optind = optind + 1;
                return uVar3;
            }
            optarg = (byte *)0x0;
            if (*DAT_0014de88 == 0) {
                if (pcVar2[2] != ':') {
                    optind = optind + 1;
                    if (param_1 <= optind) {
                        DAT_0014de88 = &DAT_000d9eac;
                        if ((opterr != 0) && (*local_24 != ':')) {
                            FUN_0003b2a0("option requires an argument -- %c",
                                         uVar3);
                        }
                        if (*local_24 == ':') {
                            optopt = uVar3;
                            return 0x3a;
                        }
                        optopt = uVar3;
                        return 0x3f;
                    }
                    optarg = *(byte **)(param_2 + optind * 4);
                }
            } else {
                optarg = DAT_0014de88;
            }
            DAT_0014de88 = &DAT_000d9eac;
            optind = optind + 1;
            return uVar3;
        }
        optreset = 0;
        if (param_1 <= optind) {
            DAT_0014de88 = &DAT_000d9eac;
            if (DAT_0014de90 == -1) {
                if (DAT_0014de8c != -1) {
                    optind = DAT_0014de8c;
                }
            } else {
                FUN_0003b334(DAT_0014de8c, DAT_0014de90, optind, param_2);
                optind = optind - (DAT_0014de90 - DAT_0014de8c);
            }
            DAT_0014de8c = 0xffffffff;
            DAT_0014de90 = 0xffffffff;
            return 0xffffffff;
        }
        DAT_0014de88 = *(byte **)(param_2 + optind * 4);
        if ((*DAT_0014de88 == 0x2d) &&
            ((DAT_0014de88[1] != 0 ||
              (pcVar2 = strchr(local_24, 0x2d), pcVar2 != (char *)0x0)))) {
            if ((DAT_0014de8c != -1) && (DAT_0014de90 == -1)) {
                DAT_0014de90 = optind;
            }
            pbVar4 = DAT_0014de88;
            if (((DAT_0014de88[1] != 0) &&
                 (pbVar4 = DAT_0014de88 + 1, *pbVar4 == 0x2d)) &&
                (DAT_0014de88[2] == 0)) {
                optind = optind + 1;
                DAT_0014de88 = &DAT_000d9eac;
                if (DAT_0014de90 != -1) {
                    FUN_0003b334(DAT_0014de8c, DAT_0014de90, optind, param_2);
                    optind = optind - (DAT_0014de90 - DAT_0014de8c);
                }
                DAT_0014de8c = 0xffffffff;
                DAT_0014de90 = 0xffffffff;
                return 0xffffffff;
            }
            goto LAB_0003bff8;
        }
        DAT_0014de88 = &DAT_000d9eac;
        if ((param_6 & 2) != 0) {
            iVar1 = optind * 4;
            optind = optind + 1;
            optarg = (byte *)*(undefined4 *)(param_2 + iVar1);
            return 1;
        }
        if ((param_6 & 1) == 0) {
            return 0xffffffff;
        }
        if (DAT_0014de8c == -1) {
            DAT_0014de8c = optind;
        } else if (DAT_0014de90 != -1) {
            FUN_0003b334(DAT_0014de8c, DAT_0014de90, optind, param_2);
            DAT_0014de8c = optind - (DAT_0014de90 - DAT_0014de8c);
            DAT_0014de90 = -1;
        }
        optind = optind + 1;
    } while (true);
}

int getopt(int ___argc, char **___argv, char *__shortopts)

{
    int iVar1;

    iVar1 = FUN_0003b9e8(___argc, ___argv, __shortopts, 0, 0, 0);
    return iVar1;
}

undefined4 getopt_long(undefined4 param_1, undefined4 param_2,
                       undefined4 param_3, undefined4 param_4,
                       undefined4 param_5)

{
    undefined4 uVar1;

    uVar1 = FUN_0003b9e8(param_1, param_2, param_3, param_4, param_5, 1);
    return uVar1;
}

undefined4 getopt_long_only(undefined4 param_1, undefined4 param_2,
                            undefined4 param_3, undefined4 param_4,
                            undefined4 param_5)

{
    undefined4 uVar1;

    uVar1 = FUN_0003b9e8(param_1, param_2, param_3, param_4, param_5, 5);
    return uVar1;
}

undefined4 FUN_0003c648(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3)

{
    undefined4 uVar1;

    uVar1 = strbuffer_append_bytes(param_3, param_1, param_2);
    return uVar1;
}

undefined4 FUN_0003c680(void *param_1, size_t param_2, uint *param_3)

{
    if (param_3[1] + param_2 <= *param_3) {
        memcpy((void *)(param_3[2] + param_3[1]), param_1, param_2);
    }
    param_3[1] = param_3[1] + param_2;
    return 0;
}

undefined4 FUN_0003c70c(void *param_1, size_t param_2, FILE *param_3)

{
    size_t sVar1;
    undefined4 uVar2;

    sVar1 = fwrite(param_1, param_2, 1, param_3);
    if (sVar1 == 1) {
        uVar2 = 0;
    } else {
        uVar2 = 0xffffffff;
    }
    return uVar2;
}

undefined4 FUN_0003c764(void *param_1, size_t param_2, int *param_3)

{
    size_t sVar1;
    undefined4 uVar2;

    sVar1 = write(*param_3, param_1, param_2);
    if (sVar1 == param_2) {
        uVar2 = 0;
    } else {
        uVar2 = 0xffffffff;
    }
    return uVar2;
}

undefined4 FUN_0003c7c4(uint param_1, int param_2, int param_3, code *param_4,
                        undefined4 param_5)

{
    int iVar1;
    undefined4 uVar2;
    uint uVar3;
    uint local_c;

    if ((param_1 & 0x1f) == 0) {
        if ((param_3 != 0) && ((param_1 & 0x20) == 0)) {
            uVar2 = (*param_4)(&DAT_000d9fa4, 1, param_5);
            return uVar2;
        }
    } else {
        local_c = param_2 * (param_1 & 0x1f);
        iVar1 = (*param_4)(&DAT_000d9fa0, 1, param_5);
        if (iVar1 != 0) {
            return 0xffffffff;
        }
        for (; local_c != 0; local_c = local_c - uVar3) {
            uVar3 = local_c;
            if (0x1f < local_c) {
                uVar3 = 0x20;
            }
            iVar1 =
                (*param_4)("                                ", uVar3, param_5);
            if (iVar1 != 0) {
                return 0xffffffff;
            }
        }
    }
    return 0;
}

undefined4 FUN_0003c8e4(uint param_1, int param_2, code *param_3,
                        undefined4 param_4, uint param_5)

{
    uint uVar1;
    int iVar2;
    undefined4 uVar3;
    char acStack_38[16];
    uint local_28;
    uint local_24;
    uint local_20;
    uint local_1c;
    undefined4 local_18;
    char *local_14;
    uint local_10;
    uint local_c;

    local_28 = 0;
    iVar2 = (*param_3)(&DAT_000d9fa8, 1, param_4);
    if (iVar2 != 0) {
        return 0xffffffff;
    }
    local_1c = param_1 + param_2;
    uVar1 = param_1;
LAB_0003c9f4:
    local_c = uVar1;
    local_10 = local_c;
    if (local_c < local_1c)
        goto LAB_0003c958;
    goto LAB_0003ca14;
LAB_0003c958:
    local_10 = utf8_iterate(local_c, local_1c - local_c, &local_28);
    if (local_10 == 0) {
        return 0xffffffff;
    }
    if (((((local_28 != 0x5c) && (local_28 != 0x22)) &&
          (0x1f < (int)local_28)) &&
         (((param_5 & 0x400) == 0 || (local_28 != 0x2f)))) &&
        ((uVar1 = local_10,
          (param_5 & 0x40) == 0 || (uVar1 = local_10, (int)local_28 < 0x80))))
        goto LAB_0003c9f4;
LAB_0003ca14:
    if ((local_c != param_1) &&
        (iVar2 = (*param_3)(param_1, local_c - param_1, param_4), iVar2 != 0)) {
        return 0xffffffff;
    }
    if (local_10 == local_c) {
        uVar3 = (*param_3)(&DAT_000d9fa8, 1, param_4);
        return uVar3;
    }
    local_18 = 2;
    if (local_28 == 0xc) {
        local_14 = "\\f";
        goto LAB_0003cc04;
    }
    if ((int)local_28 < 0xd) {
        if (local_28 == 9) {
            local_14 = "\\t";
            goto LAB_0003cc04;
        }
        if (local_28 == 10) {
            local_14 = "\\n";
            goto LAB_0003cc04;
        }
        if (local_28 == 8) {
            local_14 = "\\b";
            goto LAB_0003cc04;
        }
    } else {
        if (local_28 == 0x22) {
            local_14 = "\\\"";
            goto LAB_0003cc04;
        }
        if ((int)local_28 < 0x23) {
            if (local_28 == 0xd) {
                local_14 = "\\r";
                goto LAB_0003cc04;
            }
        } else {
            if (local_28 == 0x2f) {
                local_14 = "\\/";
                goto LAB_0003cc04;
            }
            if (local_28 == 0x5c) {
                local_14 = "\\\\";
                goto LAB_0003cc04;
            }
        }
    }
    if ((int)local_28 < 0x10000) {
        snprintf(acStack_38, 0xd, "\\u%04X", local_28);
        local_18 = 6;
    } else {
        local_28 = local_28 - 0x10000;
        local_20 = (int)local_28 >> 10 & 0x3ffU | 0xd800;
        local_24 = local_28 & 0x3ff | 0xdc00;
        snprintf(acStack_38, 0xd, "\\u%04X\\u%04X", local_20, local_24);
        local_18 = 0xc;
    }
    local_14 = acStack_38;
LAB_0003cc04:
    iVar2 = (*param_3)(local_14, local_18, param_4);
    if (iVar2 != 0) {
        return 0xffffffff;
    }
    local_c = local_10;
    uVar1 = local_c;
    param_1 = local_10;
    goto LAB_0003c9f4;
}

int FUN_0003cc4c(undefined4 *param_1, undefined4 *param_2)

{
    int iVar1;

    iVar1 = strcmp((char *)*param_1, (char *)*param_2);
    return iVar1;
}

undefined4 FUN_0003cc8c(undefined4 param_1, undefined4 param_2, char *param_3,
                        size_t param_4)

{
    int iVar1;
    undefined4 uVar2;

    snprintf(param_3, param_4, "%p", param_2);
    iVar1 = hashtable_get(param_1, param_3);
    if (iVar1 == 0) {
        uVar2 = json_null();
        uVar2 = hashtable_set(param_1, param_3, uVar2);
    } else {
        uVar2 = 0xffffffff;
    }
    return uVar2;
}

undefined4 FUN_0003cd08(undefined4 *param_1, uint param_2, int param_3,
                        undefined4 param_4, code *param_5, undefined4 param_6)

{
    undefined4 uVar1;
    int iVar2;
    size_t sVar3;
    uint uVar4;
    undefined4 uVar5;
    undefined4 *puVar6;
    undefined4 extraout_s1;
    undefined8 uVar7;
    char acStack_d0[100];
    undefined1 auStack_6c[12];
    undefined1 auStack_60[12];
    undefined4 local_54;
    char *local_50;
    void *local_4c;
    size_t local_48;
    char *local_44;
    int local_40;
    uint local_3c;
    int local_38;
    int local_34;
    undefined8 uStack_30;
    uint local_28;
    uint local_24;
    undefined4 local_20;
    undefined *local_1c;
    int local_18;
    uint local_14;

    local_28 = param_2 & 0x10000;
    uVar4 = param_2 & 0xfffeffff;
    if (param_1 == (undefined4 *)0x0) {
        uVar5 = 0xffffffff;
    } else {
        switch (*param_1) {
        case 0:
            if ((param_2 & 0x20) == 0) {
                local_1c = &DAT_000da018;
                local_20 = 2;
            } else {
                local_1c = &DAT_000da014;
                local_20 = 1;
            }
            iVar2 = FUN_0003cc8c(param_4, param_1, auStack_6c, 0xb);
            if (iVar2 == 0) {
                local_18 = json_object_iter(param_1);
                if ((local_28 == 0) &&
                    (iVar2 = (*param_5)(&DAT_000da01c, 1, param_6),
                     iVar2 != 0)) {
                    uVar5 = 0xffffffff;
                } else if (local_18 == 0) {
                    hashtable_del(param_4, auStack_6c);
                    if (local_28 == 0) {
                        uVar5 = (*param_5)(&DAT_000da020, 1, param_6);
                    } else {
                        uVar5 = 0;
                    }
                } else {
                    iVar2 =
                        FUN_0003c7c4(uVar4, param_3 + 1, 0, param_5, param_6);
                    if (iVar2 == 0) {
                        if ((param_2 & 0x80) == 0) {
                            while (local_18 != 0) {
                                local_40 =
                                    json_object_iter_next(param_1, local_18);
                                local_44 =
                                    (char *)json_object_iter_key(local_18);
                                sVar3 = strlen(local_44);
                                FUN_0003c8e4(local_44, sVar3, param_5, param_6,
                                             uVar4);
                                iVar2 = (*param_5)(local_1c, local_20, param_6);
                                if (iVar2 != 0) {
                                    return 0xffffffff;
                                }
                                uVar5 = json_object_iter_value(local_18);
                                iVar2 = FUN_0003cd08(uVar5, uVar4, param_3 + 1,
                                                     param_4, param_5, param_6);
                                if (iVar2 != 0) {
                                    return 0xffffffff;
                                }
                                if (local_40 == 0) {
                                    iVar2 = FUN_0003c7c4(uVar4, param_3, 0,
                                                         param_5, param_6);
                                    if (iVar2 != 0) {
                                        return 0xffffffff;
                                    }
                                } else {
                                    iVar2 =
                                        (*param_5)(&DAT_000da010, 1, param_6);
                                    if ((iVar2 != 0) ||
                                        (iVar2 =
                                             FUN_0003c7c4(uVar4, param_3 + 1, 1,
                                                          param_5, param_6),
                                         iVar2 != 0)) {
                                        return 0xffffffff;
                                    }
                                }
                                local_18 = local_40;
                            }
                        } else {
                            local_48 = json_object_size(param_1);
                            local_4c = (void *)jsonp_malloc(local_48 << 2);
                            if (local_4c == (void *)0x0) {
                                return 0xffffffff;
                            }
                            local_24 = 0;
                            while (local_18 != 0) {
                                puVar6 = (undefined4 *)((int)local_4c +
                                                        local_24 * 4);
                                uVar5 = json_object_iter_key(local_18);
                                *puVar6 = uVar5;
                                local_18 =
                                    json_object_iter_next(param_1, local_18);
                                local_24 = local_24 + 1;
                            }
                            qsort(local_4c, local_48, 4, FUN_0003cc4c);
                            for (local_24 = 0; local_24 < local_48;
                                 local_24 = local_24 + 1) {
                                local_50 =
                                    *(char **)((int)local_4c + local_24 * 4);
                                local_54 = json_object_get(param_1, local_50);
                                sVar3 = strlen(local_50);
                                FUN_0003c8e4(local_50, sVar3, param_5, param_6,
                                             uVar4);
                                iVar2 = (*param_5)(local_1c, local_20, param_6);
                                if ((iVar2 != 0) ||
                                    (iVar2 = FUN_0003cd08(local_54, uVar4,
                                                          param_3 + 1, param_4,
                                                          param_5, param_6),
                                     iVar2 != 0)) {
                                    jsonp_free(local_4c);
                                    return 0xffffffff;
                                }
                                if (local_24 < local_48 - 1) {
                                    iVar2 =
                                        (*param_5)(&DAT_000da010, 1, param_6);
                                    if ((iVar2 != 0) ||
                                        (iVar2 =
                                             FUN_0003c7c4(uVar4, param_3 + 1, 1,
                                                          param_5, param_6),
                                         iVar2 != 0)) {
                                        jsonp_free(local_4c);
                                        return 0xffffffff;
                                    }
                                } else {
                                    iVar2 = FUN_0003c7c4(uVar4, param_3, 0,
                                                         param_5, param_6);
                                    if (iVar2 != 0) {
                                        jsonp_free(local_4c);
                                        return 0xffffffff;
                                    }
                                }
                            }
                            jsonp_free(local_4c);
                        }
                        hashtable_del(param_4, auStack_6c);
                        if (local_28 == 0) {
                            uVar5 = (*param_5)(&DAT_000da020, 1, param_6);
                        } else {
                            uVar5 = 0;
                        }
                    } else {
                        uVar5 = 0xffffffff;
                    }
                }
            } else {
                uVar5 = 0xffffffff;
            }
            break;
        case 1:
            iVar2 = FUN_0003cc8c(param_4, param_1, auStack_60, 0xb);
            if (iVar2 == 0) {
                local_3c = json_array_size(param_1);
                if ((local_28 == 0) &&
                    (iVar2 = (*param_5)(&DAT_000da008, 1, param_6),
                     iVar2 != 0)) {
                    uVar5 = 0xffffffff;
                } else if (local_3c == 0) {
                    hashtable_del(param_4, auStack_60);
                    if (local_28 == 0) {
                        uVar5 = (*param_5)(&DAT_000da00c, 1, param_6);
                    } else {
                        uVar5 = 0;
                    }
                } else {
                    iVar2 =
                        FUN_0003c7c4(uVar4, param_3 + 1, 0, param_5, param_6);
                    if (iVar2 == 0) {
                        for (local_14 = 0; local_14 < local_3c;
                             local_14 = local_14 + 1) {
                            uVar5 = json_array_get(param_1, local_14);
                            iVar2 = FUN_0003cd08(uVar5, uVar4, param_3 + 1,
                                                 param_4, param_5, param_6);
                            if (iVar2 != 0) {
                                return 0xffffffff;
                            }
                            if (local_14 < local_3c - 1) {
                                iVar2 = (*param_5)(&DAT_000da010, 1, param_6);
                                if ((iVar2 != 0) ||
                                    (iVar2 = FUN_0003c7c4(uVar4, param_3 + 1, 1,
                                                          param_5, param_6),
                                     iVar2 != 0)) {
                                    return 0xffffffff;
                                }
                            } else {
                                iVar2 = FUN_0003c7c4(uVar4, param_3, 0, param_5,
                                                     param_6);
                                if (iVar2 != 0) {
                                    return 0xffffffff;
                                }
                            }
                        }
                        hashtable_del(param_4, auStack_60);
                        if (local_28 == 0) {
                            uVar5 = (*param_5)(&DAT_000da00c, 1, param_6);
                        } else {
                            uVar5 = 0;
                        }
                    } else {
                        uVar5 = 0xffffffff;
                    }
                }
            } else {
                uVar5 = 0xffffffff;
            }
            break;
        case 2:
            uVar5 = json_string_value(param_1);
            uVar1 = json_string_length(param_1);
            uVar5 = FUN_0003c8e4(uVar5, uVar1, param_5, param_6, uVar4);
            break;
        case 3:
            uVar7 = json_integer_value(param_1);
            uVar5 = (undefined4)((ulonglong)uVar7 >> 0x20);
            local_38 =
                snprintf(acStack_d0, 100, "%lld", uVar5, (int)uVar7, uVar5);
            if ((local_38 < 0) || (99 < local_38)) {
                uVar5 = 0xffffffff;
            } else {
                uVar5 = (*param_5)(acStack_d0, local_38, param_6);
            }
            break;
        case 4:
            uVar5 = json_real_value(param_1);
            uStack_30 = CONCAT44(extraout_s1, uVar5);
            local_34 =
                jsonp_dtostr(uVar5, acStack_d0, 100, uVar4 >> 0xb & 0x1f);
            if (local_34 < 0) {
                uVar5 = 0xffffffff;
            } else {
                uVar5 = (*param_5)(acStack_d0, local_34, param_6);
            }
            break;
        case 5:
            uVar5 = (*param_5)(&DAT_000d9ff0, 4, param_6);
            break;
        case 6:
            uVar5 = (*param_5)("false", 5, param_6);
            break;
        case 7:
            uVar5 = (*param_5)(&DAT_000d9fe8, 4, param_6);
            break;
        default:
            uVar5 = 0xffffffff;
        }
    }
    return uVar5;
}

undefined4 json_dumps(undefined4 param_1, undefined4 param_2)

{
    int iVar1;
    undefined4 uVar2;
    undefined1 auStack_18[12];
    undefined4 local_c;

    iVar1 = strbuffer_init(auStack_18);
    if (iVar1 == 0) {
        iVar1 = json_dump_callback(param_1, FUN_0003c648, auStack_18, param_2);
        if (iVar1 == 0) {
            uVar2 = strbuffer_value(auStack_18);
            local_c = jsonp_strdup(uVar2);
        } else {
            local_c = 0;
        }
        strbuffer_close(auStack_18);
    } else {
        local_c = 0;
    }
    return local_c;
}

undefined4 json_dumpb(undefined4 param_1, undefined4 param_2,
                      undefined4 param_3, undefined4 param_4)

{
    int iVar1;
    undefined4 local_14;
    undefined4 local_10;
    undefined4 local_c;

    local_10 = 0;
    local_14 = param_3;
    local_c = param_2;
    iVar1 = json_dump_callback(param_1, FUN_0003c680, &local_14, param_4);
    if (iVar1 != 0) {
        local_10 = 0;
    }
    return local_10;
}

undefined4 json_dumpf(undefined4 param_1, undefined4 param_2,
                      undefined4 param_3)

{
    undefined4 uVar1;

    uVar1 = json_dump_callback(param_1, FUN_0003c70c, param_2, param_3);
    return uVar1;
}

undefined4 json_dumpfd(undefined4 param_1, undefined4 param_2,
                       undefined4 param_3)

{
    undefined4 uVar1;
    undefined4 local_10;
    undefined4 local_c;

    local_10 = param_2;
    local_c = param_1;
    uVar1 = json_dump_callback(param_1, FUN_0003c764, &local_10, param_3);
    return uVar1;
}

undefined4 json_dump_file(undefined4 param_1, char *param_2, undefined4 param_3)

{
    FILE *__stream;
    int iVar1;
    undefined4 uVar2;

    __stream = fopen(param_2, "w");
    if (__stream == (FILE *)0x0) {
        uVar2 = 0xffffffff;
    } else {
        uVar2 = json_dumpf(param_1, __stream, param_3);
        iVar1 = fclose(__stream);
        if (iVar1 != 0) {
            uVar2 = 0xffffffff;
        }
    }
    return uVar2;
}

undefined4 json_dump_callback(int *param_1, undefined4 param_2,
                              undefined4 param_3, uint param_4)

{
    int iVar1;
    undefined1 auStack_28[28];
    undefined4 local_c;

    if ((((param_4 & 0x200) == 0) &&
         ((param_1 == (int *)0x0 || (*param_1 != 1)))) &&
        ((param_1 == (int *)0x0 || (*param_1 != 0)))) {
        local_c = 0xffffffff;
    } else {
        iVar1 = hashtable_init(auStack_28);
        if (iVar1 == 0) {
            local_c =
                FUN_0003cd08(param_1, param_4, 0, auStack_28, param_2, param_3);
            hashtable_close(auStack_28);
        } else {
            local_c = 0xffffffff;
        }
    }
    return local_c;
}

void jsonp_error_init(undefined4 *param_1, int param_2)

{
    if (param_1 != (undefined4 *)0x0) {
        *(undefined1 *)(param_1 + 0x17) = 0;
        *param_1 = 0xffffffff;
        param_1[1] = 0xffffffff;
        param_1[2] = 0;
        if (param_2 == 0) {
            *(undefined1 *)(param_1 + 3) = 0;
        } else {
            jsonp_error_set_source(param_1, param_2);
        }
    }
    return;
}

void jsonp_error_set_source(int param_1, char *param_2)

{
    size_t sVar1;

    if ((param_1 != 0) && (param_2 != (char *)0x0)) {
        sVar1 = strlen(param_2);
        if (sVar1 < 0x50) {
            strncpy((char *)(param_1 + 0xc), param_2, sVar1 + 1);
        } else {
            memcpy((void *)(param_1 + 0xc), &DAT_000da028, 3);
            strncpy((char *)(param_1 + 0xf), param_2 + (sVar1 - 0x4c),
                    (sVar1 - (sVar1 - 0x4c)) + 1);
        }
    }
    return;
}

void jsonp_error_set(undefined4 param_1, undefined4 param_2, undefined4 param_3,
                     undefined4 param_4, undefined4 param_5, undefined4 param_6)

{
    jsonp_error_vset(param_1, param_2, param_3, param_4, param_5, param_6,
                     &stack0x00000008);
    return;
}

void jsonp_error_vset(undefined4 *param_1, undefined4 param_2,
                      undefined4 param_3, undefined4 param_4,
                      undefined1 param_5, char *param_6, __gnuc_va_list param_7)

{
    if ((param_1 != (undefined4 *)0x0) && (*(char *)(param_1 + 0x17) == '\0')) {
        *param_1 = param_2;
        param_1[1] = param_3;
        param_1[2] = param_4;
        vsnprintf((char *)(param_1 + 0x17), 0x9f, param_6, param_7);
        *(undefined1 *)((int)param_1 + 0xfa) = 0;
        *(undefined1 *)((int)param_1 + 0xfb) = param_5;
    }
    return;
}

void FUN_0003db5c(int param_1)

{
    bool bVar1;
    int iVar2;
    int *piVar3;

    if ((param_1 != 0) && (*(int *)(param_1 + 4) != -1)) {
        piVar3 = (int *)(param_1 + 4);
        DataMemoryBarrier(0xb);
        do {
            iVar2 = *piVar3;
            bVar1 = (bool)hasExclusiveAccess(piVar3);
        } while (!bVar1);
        *piVar3 = iVar2 + -1;
        if (iVar2 + -1 == 0) {
            json_delete(param_1);
        }
    }
    return;
}

uint FUN_0003dbc4(uint *param_1, uint param_2, int param_3)

{
    int iVar1;
    int iVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    uint local_30;
    uint *local_20;
    uint *local_1c;
    uint *local_18;
    uint local_14;
    uint local_10;
    uint local_c;

    local_14 = param_2 + param_3 + 0xdeadbeef;
    local_30 = param_2;
    local_18 = param_1;
    local_10 = local_14;
    local_c = local_14;
    if (((uint)param_1 & 3) == 0) {
        for (; 0xc < local_30; local_30 = local_30 - 0xc) {
            local_14 = local_14 + local_18[2];
            uVar3 = (local_14 >> 0x1c | local_14 * 0x10) ^
                    (local_c + *local_18) - local_14;
            iVar1 = local_14 + local_10 + local_18[1];
            uVar4 =
                (uVar3 >> 0x1a | uVar3 << 6) ^ (local_10 + local_18[1]) - uVar3;
            iVar2 = uVar3 + iVar1;
            uVar3 = (uVar4 >> 0x18 | uVar4 << 8) ^ iVar1 - uVar4;
            iVar1 = uVar4 + iVar2;
            local_c = (uVar3 >> 0x10 | uVar3 << 0x10) ^ iVar2 - uVar3;
            iVar2 = uVar3 + iVar1;
            local_10 = (local_c >> 0xd | local_c << 0x13) ^ iVar1 - local_c;
            local_c = local_c + iVar2;
            local_14 = (local_10 >> 0x1c | local_10 << 4) ^ iVar2 - local_10;
            local_10 = local_10 + local_c;
            local_18 = local_18 + 3;
        }
        switch (local_30) {
        case 0:
            return local_14;
        case 1:
            local_c = local_c + (*local_18 & 0xff);
            break;
        case 2:
            local_c = local_c + (*local_18 & 0xffff);
            break;
        case 3:
            local_c = local_c + (*local_18 & 0xffffff);
            break;
        case 4:
            local_c = local_c + *local_18;
            break;
        case 5:
            local_10 = local_10 + (local_18[1] & 0xff);
            local_c = local_c + *local_18;
            break;
        case 6:
            local_10 = local_10 + (local_18[1] & 0xffff);
            local_c = local_c + *local_18;
            break;
        case 7:
            local_10 = local_10 + (local_18[1] & 0xffffff);
            local_c = local_c + *local_18;
            break;
        case 8:
            local_10 = local_10 + local_18[1];
            local_c = local_c + *local_18;
            break;
        case 9:
            local_14 = local_14 + (local_18[2] & 0xff);
            local_10 = local_10 + local_18[1];
            local_c = local_c + *local_18;
            break;
        case 10:
            local_14 = local_14 + (local_18[2] & 0xffff);
            local_10 = local_10 + local_18[1];
            local_c = local_c + *local_18;
            break;
        case 0xb:
            local_14 = local_14 + (local_18[2] & 0xffffff);
            local_10 = local_10 + local_18[1];
            local_c = local_c + *local_18;
            break;
        case 0xc:
            local_14 = local_14 + local_18[2];
            local_10 = local_10 + local_18[1];
            local_c = local_c + *local_18;
        }
    } else {
        local_20 = param_1;
        local_1c = param_1;
        if (((uint)param_1 & 1) == 0) {
            for (; 0xc < local_30; local_30 = local_30 - 0xc) {
                iVar1 = local_10 + (uint)(ushort)local_1c[1] +
                        (uint) * (ushort *)((int)local_1c + 6) * 0x10000;
                local_14 = local_14 + (uint)(ushort)local_1c[2] +
                           (uint) * (ushort *)((int)local_1c + 10) * 0x10000;
                uVar3 = (local_14 >> 0x1c | local_14 * 0x10) ^
                        (local_c + (uint)(ushort)*local_1c +
                         (uint) * (ushort *)((int)local_1c + 2) * 0x10000) -
                            local_14;
                iVar2 = local_14 + iVar1;
                uVar4 = (uVar3 >> 0x1a | uVar3 << 6) ^ iVar1 - uVar3;
                iVar1 = uVar3 + iVar2;
                uVar3 = (uVar4 >> 0x18 | uVar4 << 8) ^ iVar2 - uVar4;
                iVar2 = uVar4 + iVar1;
                local_c = (uVar3 >> 0x10 | uVar3 << 0x10) ^ iVar1 - uVar3;
                iVar1 = uVar3 + iVar2;
                local_10 = (local_c >> 0xd | local_c << 0x13) ^ iVar2 - local_c;
                local_c = local_c + iVar1;
                local_14 =
                    (local_10 >> 0x1c | local_10 << 4) ^ iVar1 - local_10;
                local_10 = local_10 + local_c;
                local_1c = local_1c + 3;
            }
            switch (local_30) {
            case 0:
                return local_14;
            case 1:
                local_c = local_c + (byte)*local_1c;
                break;
            case 3:
                local_c =
                    local_c + (uint) * (byte *)((int)local_1c + 2) * 0x10000;
            case 2:
                local_c = local_c + (ushort)*local_1c;
                break;
            case 5:
                local_10 = local_10 + (byte)local_1c[1];
            case 4:
                local_c = local_c + (uint)(ushort)*local_1c +
                          (uint) * (ushort *)((int)local_1c + 2) * 0x10000;
                break;
            case 7:
                local_10 =
                    local_10 + (uint) * (byte *)((int)local_1c + 6) * 0x10000;
            case 6:
                local_10 = local_10 + (ushort)local_1c[1];
                local_c = local_c + (uint)(ushort)*local_1c +
                          (uint) * (ushort *)((int)local_1c + 2) * 0x10000;
                break;
            case 9:
                local_14 = local_14 + (byte)local_1c[2];
            case 8:
                local_10 = local_10 + (uint)(ushort)local_1c[1] +
                           (uint) * (ushort *)((int)local_1c + 6) * 0x10000;
                local_c = local_c + (uint)(ushort)*local_1c +
                          (uint) * (ushort *)((int)local_1c + 2) * 0x10000;
                break;
            case 0xb:
                local_14 =
                    local_14 + (uint) * (byte *)((int)local_1c + 10) * 0x10000;
            case 10:
                local_14 = local_14 + (ushort)local_1c[2];
                local_10 = local_10 + (uint)(ushort)local_1c[1] +
                           (uint) * (ushort *)((int)local_1c + 6) * 0x10000;
                local_c = local_c + (uint)(ushort)*local_1c +
                          (uint) * (ushort *)((int)local_1c + 2) * 0x10000;
                break;
            case 0xc:
                local_14 = local_14 + (uint)(ushort)local_1c[2] +
                           (uint) * (ushort *)((int)local_1c + 10) * 0x10000;
                local_10 = local_10 + (uint)(ushort)local_1c[1] +
                           (uint) * (ushort *)((int)local_1c + 6) * 0x10000;
                local_c = local_c + (uint)(ushort)*local_1c +
                          (uint) * (ushort *)((int)local_1c + 2) * 0x10000;
            }
        } else {
            for (; 0xc < local_30; local_30 = local_30 - 0xc) {
                iVar1 = local_10 + (byte)local_20[1] +
                        (uint) * (byte *)((int)local_20 + 5) * 0x100 +
                        (uint) * (byte *)((int)local_20 + 6) * 0x10000 +
                        (uint) * (byte *)((int)local_20 + 7) * 0x1000000;
                uVar3 = local_14 + (byte)local_20[2] +
                        (uint) * (byte *)((int)local_20 + 9) * 0x100 +
                        (uint) * (byte *)((int)local_20 + 10) * 0x10000 +
                        (uint) * (byte *)((int)local_20 + 0xb) * 0x1000000;
                uVar4 = (uVar3 >> 0x1c | uVar3 * 0x10) ^
                        (local_c + (byte)*local_20 +
                         (uint) * (byte *)((int)local_20 + 1) * 0x100 +
                         (uint) * (byte *)((int)local_20 + 2) * 0x10000 +
                         (uint) * (byte *)((int)local_20 + 3) * 0x1000000) -
                            uVar3;
                iVar2 = uVar3 + iVar1;
                uVar3 = (uVar4 >> 0x1a | uVar4 << 6) ^ iVar1 - uVar4;
                iVar1 = uVar4 + iVar2;
                uVar4 = (uVar3 >> 0x18 | uVar3 << 8) ^ iVar2 - uVar3;
                iVar2 = uVar3 + iVar1;
                local_c = (uVar4 >> 0x10 | uVar4 << 0x10) ^ iVar1 - uVar4;
                iVar1 = uVar4 + iVar2;
                local_10 = (local_c >> 0xd | local_c << 0x13) ^ iVar2 - local_c;
                local_c = local_c + iVar1;
                local_14 =
                    (local_10 >> 0x1c | local_10 << 4) ^ iVar1 - local_10;
                local_10 = local_10 + local_c;
                local_20 = local_20 + 3;
            }
            switch (local_30) {
            case 0:
                return local_14;
            case 0xc:
                local_14 = local_14 +
                           (uint) * (byte *)((int)local_20 + 0xb) * 0x1000000;
            case 0xb:
                local_14 =
                    local_14 + (uint) * (byte *)((int)local_20 + 10) * 0x10000;
            case 10:
                local_14 =
                    local_14 + (uint) * (byte *)((int)local_20 + 9) * 0x100;
            case 9:
                local_14 = local_14 + (byte)local_20[2];
            case 8:
                local_10 =
                    local_10 + (uint) * (byte *)((int)local_20 + 7) * 0x1000000;
            case 7:
                local_10 =
                    local_10 + (uint) * (byte *)((int)local_20 + 6) * 0x10000;
            case 6:
                local_10 =
                    local_10 + (uint) * (byte *)((int)local_20 + 5) * 0x100;
            case 5:
                local_10 = local_10 + (byte)local_20[1];
            case 4:
                local_c =
                    local_c + (uint) * (byte *)((int)local_20 + 3) * 0x1000000;
            case 3:
                local_c =
                    local_c + (uint) * (byte *)((int)local_20 + 2) * 0x10000;
            case 2:
                local_c =
                    local_c + (uint) * (byte *)((int)local_20 + 1) * 0x100;
            case 1:
                local_c = local_c + (byte)*local_20;
            }
        }
    }
    uVar3 = (local_10 ^ local_14) - (local_10 >> 0x12 | local_10 << 0xe);
    uVar4 = (uVar3 ^ local_c) - (uVar3 >> 0x15 | uVar3 * 0x800);
    uVar5 = (uVar4 ^ local_10) - (uVar4 >> 7 | uVar4 * 0x2000000);
    uVar3 = (uVar5 ^ uVar3) - (uVar5 >> 0x10 | uVar5 * 0x10000);
    uVar4 = (uVar3 ^ uVar4) - (uVar3 >> 0x1c | uVar3 * 0x10);
    uVar4 = (uVar4 ^ uVar5) - (uVar4 >> 0x12 | uVar4 * 0x4000);
    return (uVar4 ^ uVar3) - (uVar4 >> 8 | uVar4 * 0x1000000);
}

void FUN_0003eae0(int param_1)

{
    *(int *)(param_1 + 4) = param_1;
    *(int *)param_1 = param_1;
    return;
}

void FUN_0003eb18(int *param_1, int *param_2)

{
    param_2[1] = (int)param_1;
    *param_2 = *param_1;
    *(int **)(*param_1 + 4) = param_2;
    *param_1 = (int)param_2;
    return;
}

void FUN_0003eb74(int *param_1)

{
    *(int *)(*param_1 + 4) = param_1[1];
    *(int *)param_1[1] = *param_1;
    return;
}

undefined4 FUN_0003ebbc(int param_1, int *param_2)

{
    undefined4 uVar1;

    if ((*param_2 == param_1 + 0xc) && (*param_2 == param_2[1])) {
        uVar1 = 1;
    } else {
        uVar1 = 0;
    }
    return uVar1;
}

void FUN_0003ec1c(int param_1, undefined4 *param_2, undefined4 param_3)

{
    int iVar1;

    iVar1 = FUN_0003ebbc(param_1, param_2);
    if (iVar1 == 0) {
        FUN_0003eb18(*param_2, param_3);
        *param_2 = param_3;
    } else {
        FUN_0003eb18(param_1 + 0xc, param_3);
        param_2[1] = param_3;
        *param_2 = param_2[1];
    }
    return;
}

int FUN_0003ecac(undefined4 param_1, int *param_2, char *param_3, int param_4)

{
    int iVar1;
    int local_c;

    iVar1 = FUN_0003ebbc(param_1, param_2);
    if (iVar1 == 0) {
        local_c = *param_2;
        while (true) {
            if ((param_4 == *(int *)(local_c + 0x10)) &&
                (iVar1 = strcmp((char *)(local_c + 0x18), param_3),
                 iVar1 == 0)) {
                return local_c;
            }
            if (local_c == param_2[1])
                break;
            local_c = *(int *)(local_c + 4);
        }
    }
    return 0;
}

undefined4 FUN_0003ed70(int *param_1, undefined4 param_2, uint param_3)

{
    undefined4 *puVar1;
    undefined4 *puVar2;
    undefined4 uVar3;

    puVar2 = (undefined4 *)(param_1[1] +
                            ((1 << (param_1[2] & 0xffU)) - 1U & param_3) * 8);
    puVar1 = (undefined4 *)FUN_0003ecac(param_1, puVar2, param_2, param_3);
    if (puVar1 == (undefined4 *)0x0) {
        uVar3 = 0xffffffff;
    } else {
        if ((puVar1 == (undefined4 *)*puVar2) &&
            (puVar1 == (undefined4 *)puVar2[1])) {
            puVar2[1] = param_1 + 3;
            *puVar2 = puVar2[1];
        } else if (puVar1 == (undefined4 *)*puVar2) {
            *puVar2 = puVar1[1];
        } else if (puVar1 == (undefined4 *)puVar2[1]) {
            puVar2[1] = *puVar1;
        }
        FUN_0003eb74(puVar1);
        FUN_0003eb74(puVar1 + 2);
        FUN_0003db5c(puVar1[5]);
        jsonp_free(puVar1);
        *param_1 = *param_1 + -1;
        uVar3 = 0;
    }
    return uVar3;
}

void FUN_0003eedc(int param_1)

{
    int iVar1;
    undefined4 local_c;

    local_c = *(int *)(param_1 + 0x10);
    while (local_c != param_1 + 0xc) {
        iVar1 = *(int *)(local_c + 4);
        FUN_0003db5c(*(undefined4 *)(local_c + 0x14));
        jsonp_free(local_c);
        local_c = iVar1;
    }
    return;
}

undefined4 FUN_0003ef50(int param_1)

{
    int iVar1;
    int iVar2;
    int extraout_r1;
    uint uVar3;
    undefined4 uVar4;
    undefined4 local_10;
    undefined4 local_c;

    uVar3 = *(int *)(param_1 + 8) + 1;
    iVar1 = 1 << (uVar3 & 0xff);
    iVar2 = jsonp_malloc(iVar1 << 3);
    if (iVar2 == 0) {
        uVar4 = 0xffffffff;
    } else {
        jsonp_free(*(undefined4 *)(param_1 + 4));
        *(int *)(param_1 + 4) = iVar2;
        *(uint *)(param_1 + 8) = uVar3;
        for (local_10 = 0;
             local_10 < (uint)(1 << (*(uint *)(param_1 + 8) & 0xff));
             local_10 = local_10 + 1) {
            iVar2 = *(int *)(param_1 + 4) + local_10 * 8;
            *(int *)(iVar2 + 4) = param_1 + 0xc;
            *(undefined4 *)(*(int *)(param_1 + 4) + local_10 * 8) =
                *(undefined4 *)(iVar2 + 4);
        }
        local_c = *(int *)(param_1 + 0x10);
        FUN_0003eae0(param_1 + 0xc);
        while (local_c != param_1 + 0xc) {
            iVar2 = *(int *)(local_c + 4);
            FUN_000cc4fc(*(undefined4 *)(local_c + 0x10), iVar1);
            FUN_0003ec1c(param_1, *(int *)(param_1 + 4) + extraout_r1 * 8,
                         local_c);
            local_c = iVar2;
        }
        uVar4 = 0;
    }
    return uVar4;
}

undefined4 hashtable_init(undefined4 *param_1)

{
    undefined4 uVar1;
    int iVar2;
    uint local_c;

    *param_1 = 0;
    param_1[2] = 3;
    uVar1 = jsonp_malloc(8 << (param_1[2] & 0xff));
    param_1[1] = uVar1;
    if (param_1[1] == 0) {
        uVar1 = 0xffffffff;
    } else {
        FUN_0003eae0(param_1 + 3);
        FUN_0003eae0(param_1 + 5);
        for (local_c = 0; local_c < (uint)(1 << (param_1[2] & 0xff));
             local_c = local_c + 1) {
            iVar2 = param_1[1] + local_c * 8;
            *(undefined4 **)(iVar2 + 4) = param_1 + 3;
            *(undefined4 *)(param_1[1] + local_c * 8) =
                *(undefined4 *)(iVar2 + 4);
        }
        uVar1 = 0;
    }
    return uVar1;
}

void hashtable_close(int param_1)

{
    FUN_0003eedc(param_1);
    jsonp_free(*(undefined4 *)(param_1 + 4));
    return;
}

undefined4 hashtable_set(uint *param_1, char *param_2, undefined4 param_3)

{
    int iVar1;
    size_t sVar2;
    uint uVar3;
    int iVar4;

    if ((*param_1 >> (param_1[2] & 0xff) != 0) &&
        (iVar1 = FUN_0003ef50(param_1), iVar1 != 0)) {
        return 0xffffffff;
    }
    sVar2 = strlen(param_2);
    uVar3 = FUN_0003dbc4(param_2, sVar2, hashtable_seed);
    iVar4 = param_1[1] + ((1 << (param_1[2] & 0xff)) - 1U & uVar3) * 8;
    iVar1 = FUN_0003ecac(param_1, iVar4, param_2, uVar3);
    if (iVar1 == 0) {
        sVar2 = strlen(param_2);
        if (0xffffffe6 < sVar2) {
            return 0xffffffff;
        }
        iVar1 = jsonp_malloc(sVar2 + 0x19);
        if (iVar1 == 0) {
            return 0xffffffff;
        }
        *(uint *)(iVar1 + 0x10) = uVar3;
        strncpy((char *)(iVar1 + 0x18), param_2, sVar2 + 1);
        *(undefined4 *)(iVar1 + 0x14) = param_3;
        FUN_0003eae0(iVar1);
        FUN_0003eae0(iVar1 + 8);
        FUN_0003ec1c(param_1, iVar4, iVar1);
        FUN_0003eb18(param_1 + 5, iVar1 + 8);
        *param_1 = *param_1 + 1;
    } else {
        FUN_0003db5c(*(undefined4 *)(iVar1 + 0x14));
        *(undefined4 *)(iVar1 + 0x14) = param_3;
    }
    return 0;
}

undefined4 hashtable_get(int param_1, char *param_2)

{
    size_t sVar1;
    uint uVar2;
    int iVar3;
    undefined4 uVar4;

    sVar1 = strlen(param_2);
    uVar2 = FUN_0003dbc4(param_2, sVar1, hashtable_seed);
    iVar3 = FUN_0003ecac(
        param_1,
        *(int *)(param_1 + 4) +
            (uVar2 & (1 << (*(uint *)(param_1 + 8) & 0xff)) - 1U) * 8,
        param_2, uVar2);
    if (iVar3 == 0) {
        uVar4 = 0;
    } else {
        uVar4 = *(undefined4 *)(iVar3 + 0x14);
    }
    return uVar4;
}

undefined4 hashtable_del(undefined4 param_1, char *param_2)

{
    size_t sVar1;
    undefined4 uVar2;

    sVar1 = strlen(param_2);
    uVar2 = FUN_0003dbc4(param_2, sVar1, hashtable_seed);
    uVar2 = FUN_0003ed70(param_1, param_2, uVar2);
    return uVar2;
}

void hashtable_clear(undefined4 *param_1)

{
    int iVar1;
    uint local_c;

    FUN_0003eedc(param_1);
    for (local_c = 0; local_c < (uint)(1 << (param_1[2] & 0xff));
         local_c = local_c + 1) {
        iVar1 = param_1[1] + local_c * 8;
        *(undefined4 **)(iVar1 + 4) = param_1 + 3;
        *(undefined4 *)(param_1[1] + local_c * 8) = *(undefined4 *)(iVar1 + 4);
    }
    FUN_0003eae0(param_1 + 3);
    FUN_0003eae0(param_1 + 5);
    *param_1 = 0;
    return;
}

undefined4 hashtable_iter(int param_1)

{
    undefined4 uVar1;

    uVar1 = hashtable_iter_next(param_1, param_1 + 0x14);
    return uVar1;
}

int hashtable_iter_at(int param_1, char *param_2)

{
    size_t sVar1;
    uint uVar2;
    int iVar3;

    sVar1 = strlen(param_2);
    uVar2 = FUN_0003dbc4(param_2, sVar1, hashtable_seed);
    iVar3 = FUN_0003ecac(
        param_1,
        *(int *)(param_1 + 4) +
            (uVar2 & (1 << (*(uint *)(param_1 + 8) & 0xff)) - 1U) * 8,
        param_2, uVar2);
    if (iVar3 == 0) {
        iVar3 = 0;
    } else {
        iVar3 = iVar3 + 8;
    }
    return iVar3;
}

undefined4 hashtable_iter_next(int param_1, int param_2)

{
    undefined4 uVar1;

    if (*(int *)(param_2 + 4) == param_1 + 0x14) {
        uVar1 = 0;
    } else {
        uVar1 = *(undefined4 *)(param_2 + 4);
    }
    return uVar1;
}

int hashtable_iter_key(int param_1)

{
    return param_1 + 0x10;
}

undefined4 hashtable_iter_value(int param_1)

{
    return *(undefined4 *)(param_1 + 0xc);
}

void hashtable_iter_set(int param_1, undefined4 param_2)

{
    FUN_0003db5c(*(undefined4 *)(param_1 + 0xc));
    *(undefined4 *)(param_1 + 0xc) = param_2;
    return;
}

uint FUN_0003f7a4(int param_1)

{
    undefined4 local_10;
    undefined4 local_c;

    local_10 = 0;
    for (local_c = 0; local_c < 4; local_c = local_c + 1) {
        local_10 = local_10 << 8 | (uint) * (byte *)(param_1 + local_c);
    }
    return local_10;
}

undefined4 FUN_0003f814(undefined4 *param_1)

{
    ssize_t sVar1;
    undefined4 uVar2;
    undefined1 auStack_14[4];
    uint local_10;
    int local_c;

    local_c = open("/dev/urandom", 0);
    if (local_c == -1) {
        uVar2 = 1;
    } else {
        sVar1 = read(local_c, auStack_14, 4);
        local_10 = (uint)(sVar1 == 4);
        close(local_c);
        if (local_10 == 0) {
            uVar2 = 1;
        } else {
            uVar2 = FUN_0003f7a4(auStack_14);
            *param_1 = uVar2;
            uVar2 = 0;
        }
    }
    return uVar2;
}

undefined4 FUN_0003f8bc(uint *param_1)

{
    uint uVar1;
    timeval local_10;

    gettimeofday(&local_10, (__timezone_ptr_t)0x0);
    *param_1 = local_10.tv_sec ^ local_10.tv_usec;
    uVar1 = getpid();
    *param_1 = uVar1 ^ *param_1;
    return 0;
}

int FUN_0003f924(void)

{
    int iVar1;
    int local_10;
    int local_c;

    local_10 = 0;
    local_c = 0;
    iVar1 = FUN_0003f814(&local_10);
    if (iVar1 == 0) {
        local_c = 1;
    }
    if (local_c == 0) {
        FUN_0003f8bc(&local_10);
    }
    if (local_10 == 0) {
        local_10 = 1;
    }
    return local_10;
}

void json_object_seed(int param_1)

{
    bool bVar1;
    char cVar2;
    undefined4 local_c;

    cVar2 = DAT_00152330;
    if (hashtable_seed == 0) {
        do {
            bVar1 = (bool)hasExclusiveAccess(0x152330);
        } while (!bVar1);
        DAT_00152330 = '\x01';
        if (cVar2 == '\x01') {
            do {
                sched_yield();
                DataMemoryBarrier(0xb);
            } while (hashtable_seed == 0);
        } else {
            local_c = param_1;
            if (param_1 == 0) {
                local_c = FUN_0003f924();
            }
            DataMemoryBarrier(0xb);
            hashtable_seed = local_c;
        }
    }
    return;
}

void FUN_0003fa50(int param_1)

{
    bool bVar1;
    int iVar2;
    int *piVar3;

    if ((param_1 != 0) && (*(int *)(param_1 + 4) != -1)) {
        piVar3 = (int *)(param_1 + 4);
        DataMemoryBarrier(0xb);
        do {
            iVar2 = *piVar3;
            bVar1 = (bool)hasExclusiveAccess(piVar3);
        } while (!bVar1);
        *piVar3 = iVar2 + -1;
        if (iVar2 + -1 == 0) {
            json_delete(param_1);
        }
    }
    return;
}

void FUN_0003fab8(int param_1, int param_2, int param_3, char *param_4)

{
    char *pcVar1;
    int local_174;
    char acStack_168[159];
    undefined1 local_c9;
    char acStack_c8[159];
    undefined1 local_29;
    char *local_20;
    undefined4 local_1c;
    undefined4 local_18;
    undefined4 local_14;

    local_14 = 0xffffffff;
    local_18 = 0xffffffff;
    local_1c = 0;
    local_20 = acStack_c8;
    if (param_1 != 0) {
        vsnprintf(acStack_c8, 0xa0, param_4, &stack0x00000000);
        local_29 = 0;
        local_174 = param_3;
        if (param_2 != 0) {
            pcVar1 = (char *)strbuffer_value(param_2 + 0x28);
            local_14 = *(undefined4 *)(param_2 + 0x18);
            local_18 = *(undefined4 *)(param_2 + 0x1c);
            local_1c = *(undefined4 *)(param_2 + 0x24);
            if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\0')) {
                if (param_3 == 8) {
                    local_174 = 6;
                }
                if (*(int *)(param_2 + 0x14) == -2) {
                    local_20 = acStack_c8;
                } else {
                    snprintf(acStack_168, 0xa0, "%s near end of file",
                             acStack_c8);
                    local_c9 = 0;
                    local_20 = acStack_168;
                }
            } else if (*(uint *)(param_2 + 0x2c) < 0x15) {
                snprintf(acStack_168, 0xa0, "%s near \'%s\'", acStack_c8,
                         pcVar1);
                local_c9 = 0;
                local_20 = acStack_168;
            }
        }
        jsonp_error_set(param_1, local_14, local_18, local_1c, local_174,
                        &DAT_000da060, local_20);
    }
    return;
}

void FUN_0003fc6c(undefined4 *param_1, undefined4 param_2, undefined4 param_3)

{
    *param_1 = param_2;
    param_1[1] = param_3;
    *(undefined1 *)(param_1 + 2) = 0;
    param_1[4] = 0;
    param_1[5] = 0;
    param_1[6] = 1;
    param_1[7] = 0;
    param_1[9] = 0;
    return;
}

uint FUN_0003fcf4(undefined4 *param_1, undefined4 param_2)

{
    undefined1 uVar1;
    uint uVar2;
    uint uVar3;
    int iVar4;
    uint local_c;

    if (param_1[5] != 0) {
        return param_1[5];
    }
    if (*(char *)((int)param_1 + param_1[4] + 8) == '\0') {
        uVar2 = (*(code *)*param_1)(param_1[1]);
        if (uVar2 == 0xffffffff) {
            param_1[5] = 0xffffffff;
            return 0xffffffff;
        }
        *(char *)(param_1 + 2) = (char)uVar2;
        param_1[4] = 0;
        if ((0x7f < (int)uVar2) && ((int)uVar2 < 0x100)) {
            uVar3 = utf8_check_first(uVar2 & 0xff);
            if (uVar3 != 0) {
                for (local_c = 1; local_c < uVar3; local_c = local_c + 1) {
                    uVar1 = (*(code *)*param_1)(param_1[1]);
                    *(undefined1 *)((int)param_1 + local_c + 8) = uVar1;
                }
                iVar4 = utf8_check_full(param_1 + 2, uVar3, 0);
                if (iVar4 != 0) {
                    *(undefined1 *)((int)param_1 + uVar3 + 8) = 0;
                    goto LAB_0003fe7c;
                }
            }
            param_1[5] = 0xfffffffe;
            FUN_0003fab8(param_2, param_1, 5, "unable to decode byte 0x%x",
                         uVar2);
            return 0xfffffffe;
        }
        *(undefined1 *)((int)param_1 + 9) = 0;
    }
LAB_0003fe7c:
    iVar4 = param_1[4];
    param_1[4] = iVar4 + 1;
    uVar2 = (uint) * (byte *)((int)param_1 + iVar4 + 8);
    param_1[9] = param_1[9] + 1;
    if (uVar2 == 10) {
        param_1[6] = param_1[6] + 1;
        param_1[8] = param_1[7];
        param_1[7] = 0;
    } else {
        iVar4 = utf8_check_first(uVar2);
        if (iVar4 != 0) {
            param_1[7] = param_1[7] + 1;
        }
    }
    return uVar2;
}

void FUN_0003ff74(int param_1, uint param_2)

{
    int iVar1;

    if ((param_2 != 0xffffffff) && (param_2 != 0xfffffffe)) {
        *(int *)(param_1 + 0x24) = *(int *)(param_1 + 0x24) + -1;
        if (param_2 == 10) {
            *(int *)(param_1 + 0x18) = *(int *)(param_1 + 0x18) + -1;
            *(undefined4 *)(param_1 + 0x1c) = *(undefined4 *)(param_1 + 0x20);
        } else {
            iVar1 = utf8_check_first(param_2 & 0xff);
            if (iVar1 != 0) {
                *(int *)(param_1 + 0x1c) = *(int *)(param_1 + 0x1c) + -1;
            }
        }
        *(int *)(param_1 + 0x10) = *(int *)(param_1 + 0x10) + -1;
    }
    return;
}

undefined4 FUN_0004003c(undefined4 param_1, undefined4 param_2)

{
    undefined4 uVar1;

    uVar1 = FUN_0003fcf4(param_1, param_2);
    return uVar1;
}

void FUN_00040070(int param_1, undefined1 param_2)

{
    strbuffer_append_byte(param_1 + 0x28, param_2);
    return;
}

int FUN_000400ac(undefined4 param_1, undefined4 param_2)

{
    int iVar1;

    iVar1 = FUN_0003fcf4(param_1, param_2);
    if ((iVar1 != -1) && (iVar1 != -2)) {
        FUN_00040070(param_1, iVar1);
    }
    return iVar1;
}

void FUN_00040108(undefined4 param_1, undefined4 param_2)

{
    FUN_0003ff74(param_1, param_2);
    return;
}

void FUN_00040138(int param_1, int param_2)

{
    if ((param_2 != -1) && (param_2 != -2)) {
        FUN_0003ff74(param_1, param_2);
        strbuffer_pop(param_1 + 0x28);
    }
    return;
}

void FUN_00040190(int param_1)

{
    while (*(char *)(param_1 + *(int *)(param_1 + 0x10) + 8) != '\0') {
        FUN_00040070(param_1,
                     *(undefined1 *)(param_1 + *(int *)(param_1 + 0x10) + 8));
        *(int *)(param_1 + 0x10) = *(int *)(param_1 + 0x10) + 1;
        *(int *)(param_1 + 0x24) = *(int *)(param_1 + 0x24) + 1;
    }
    return;
}

void FUN_00040214(int param_1)

{
    jsonp_free(*(undefined4 *)(param_1 + 0x40));
    *(undefined4 *)(param_1 + 0x40) = 0;
    *(undefined4 *)(param_1 + 0x44) = 0;
    return;
}

int FUN_00040258(int param_1)

{
    byte bVar1;
    int local_10;
    int local_c;

    local_10 = 0;
    local_c = 1;
    do {
        if (4 < local_c) {
            return local_10;
        }
        bVar1 = *(byte *)(param_1 + local_c);
        local_10 = local_10 * 0x10;
        if ((bVar1 < 0x30) || (0x39 < bVar1)) {
            if ((bVar1 < 0x61) || (0x7a < bVar1)) {
                if ((bVar1 < 0x41) || (0x5a < bVar1)) {
                    return -1;
                }
                local_10 = local_10 + (bVar1 - 0x37);
            } else {
                local_10 = local_10 + (bVar1 - 0x57);
            }
        } else {
            local_10 = local_10 + (bVar1 - 0x30);
        }
        local_c = local_c + 1;
    } while (true);
}

void FUN_00040360(int param_1, undefined4 param_2)

{
    byte bVar1;
    int iVar2;
    byte *pbVar3;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    byte *local_14;
    byte *local_10;
    int local_c;

    *(undefined4 *)(param_1 + 0x40) = 0;
    *(undefined4 *)(param_1 + 0x3c) = 0xffffffff;
    local_c = FUN_000400ac(param_1, param_2);
    while (local_c != 0x22) {
        if (local_c == -2)
            goto LAB_00040970;
        if (local_c == -1) {
            FUN_0003fab8(param_2, param_1, 6, "premature end of input");
            goto LAB_00040970;
        }
        if ((-1 < local_c) && (local_c < 0x20)) {
            FUN_00040138(param_1, local_c);
            if (local_c == 10) {
                FUN_0003fab8(param_2, param_1, 8, "unexpected newline");
            } else {
                FUN_0003fab8(param_2, param_1, 8, "control character 0x%x",
                             local_c);
            }
            goto LAB_00040970;
        }
        if (local_c == 0x5c) {
            local_c = FUN_000400ac(param_1, param_2);
            if (local_c == 0x75) {
                local_c = FUN_000400ac(param_1, param_2);
                for (local_18 = 0; local_18 < 4; local_18 = local_18 + 1) {
                    if ((((local_c < 0x30) || (0x39 < local_c)) &&
                         ((local_c < 0x41 || (0x46 < local_c)))) &&
                        ((local_c < 0x61 || (0x66 < local_c)))) {
                        FUN_0003fab8(param_2, param_1, 8, "invalid escape");
                        goto LAB_00040970;
                    }
                    local_c = FUN_000400ac(param_1, param_2);
                }
            } else {
                if (((((local_c != 0x22) && (local_c != 0x5c)) &&
                      (local_c != 0x2f)) &&
                     ((local_c != 0x62 && (local_c != 0x66)))) &&
                    ((local_c != 0x6e &&
                      ((local_c != 0x72 && (local_c != 0x74)))))) {
                    FUN_0003fab8(param_2, param_1, 8, "invalid escape");
                    goto LAB_00040970;
                }
                local_c = FUN_000400ac(param_1, param_2);
            }
        } else {
            local_c = FUN_000400ac(param_1, param_2);
        }
    }
    local_14 = (byte *)jsonp_malloc(*(int *)(param_1 + 0x2c) + 1);
    if (local_14 == (byte *)0x0) {
    LAB_00040970:
        FUN_00040214(param_1);
    } else {
        *(byte **)(param_1 + 0x40) = local_14;
        iVar2 = strbuffer_value(param_1 + 0x28);
        local_10 = (byte *)(iVar2 + 1);
        while (*local_10 != 0x22) {
            if (*local_10 == 0x5c) {
                pbVar3 = local_10 + 1;
                if (*pbVar3 == 0x75) {
                    local_10 = pbVar3;
                    local_1c = FUN_00040258(pbVar3);
                    if (local_1c < 0) {
                        FUN_0003fab8(param_2, param_1, 8,
                                     "invalid Unicode escape \'%.6s\'",
                                     local_10 + -1);
                        goto LAB_00040970;
                    }
                    pbVar3 = local_10 + 5;
                    if ((local_1c < 0xd800) || (0xdbff < local_1c)) {
                        local_10 = pbVar3;
                        if ((0xdbff < local_1c) && (local_1c < 0xe000)) {
                            FUN_0003fab8(param_2, param_1, 8,
                                         "invalid Unicode \'\\u%04X\'",
                                         local_1c);
                            goto LAB_00040970;
                        }
                    } else {
                        if ((*pbVar3 != 0x5c) || (local_10[6] != 0x75)) {
                            local_10 = pbVar3;
                            FUN_0003fab8(param_2, param_1, 8,
                                         "invalid Unicode \'\\u%04X\'",
                                         local_1c);
                            goto LAB_00040970;
                        }
                        local_10 = local_10 + 6;
                        local_20 = FUN_00040258(local_10);
                        if (local_20 < 0) {
                            FUN_0003fab8(param_2, param_1, 8,
                                         "invalid Unicode escape \'%.6s\'",
                                         local_10 + -1);
                            goto LAB_00040970;
                        }
                        local_10 = local_10 + 5;
                        if ((local_20 < 0xdc00) || (0xdfff < local_20)) {
                            FUN_0003fab8(param_2, param_1, 8,
                                         "invalid Unicode \'\\u%04X\\u%04X\'",
                                         local_1c, local_20);
                            goto LAB_00040970;
                        }
                        local_1c =
                            (local_1c + -0xd800) * 0x400 + local_20 + 0x2400;
                    }
                    utf8_encode(local_1c, local_14, &local_24);
                    local_14 = local_14 + local_24;
                } else {
                    bVar1 = *pbVar3;
                    if (bVar1 == 0x62) {
                        *local_14 = 8;
                    } else if (bVar1 < 99) {
                        if (((bVar1 == 0x2f) || (bVar1 == 0x5c)) ||
                            (bVar1 == 0x22)) {
                            *local_14 = *pbVar3;
                        }
                    } else if (bVar1 == 0x6e) {
                        *local_14 = 10;
                    } else if (bVar1 < 0x6f) {
                        if (bVar1 == 0x66) {
                            *local_14 = 0xc;
                        }
                    } else if (bVar1 == 0x72) {
                        *local_14 = 0xd;
                    } else if (bVar1 == 0x74) {
                        *local_14 = 9;
                    }
                    local_14 = local_14 + 1;
                    local_10 = local_10 + 2;
                }
            } else {
                *local_14 = *local_10;
                local_14 = local_14 + 1;
                local_10 = local_10 + 1;
            }
        }
        *local_14 = 0;
        *(int *)(param_1 + 0x44) = (int)local_14 - *(int *)(param_1 + 0x40);
        *(undefined4 *)(param_1 + 0x3c) = 0x100;
    }
    return;
}

undefined4 FUN_00040980(int param_1, int param_2, undefined4 param_3)

{
    int *piVar1;
    int iVar2;
    int local_28;
    undefined4 local_20;
    undefined4 uStack_1c;
    char *pcStack_18;
    char *local_14;
    undefined8 local_10;

    *(undefined4 *)(param_1 + 0x3c) = 0xffffffff;
    local_28 = param_2;
    if (param_2 == 0x2d) {
        local_28 = FUN_000400ac(param_1, param_3);
    }
    if (local_28 == 0x30) {
        local_28 = FUN_000400ac(param_1, param_3);
        if ((0x2f < local_28) && (local_28 < 0x3a)) {
            FUN_00040138(param_1, local_28);
            return 0xffffffff;
        }
    } else {
        if ((local_28 < 0x30) || (0x39 < local_28)) {
            FUN_00040138(param_1, local_28);
            return 0xffffffff;
        }
        do {
            local_28 = FUN_000400ac(param_1, param_3);
            if (local_28 < 0x30)
                break;
        } while (local_28 < 0x3a);
    }
    if (((((*(uint *)(param_1 + 0x34) & 8) == 0) && (local_28 != 0x2e)) &&
         (local_28 != 0x45)) &&
        (local_28 != 0x65)) {
        FUN_00040138(param_1, local_28);
        local_14 = (char *)strbuffer_value(param_1 + 0x28);
        piVar1 = __errno_location();
        *piVar1 = 0;
        local_10 = strtoll(local_14, &pcStack_18, 10);
        piVar1 = __errno_location();
        if (*piVar1 == 0x22) {
            if ((longlong)local_10 < 0) {
                FUN_0003fab8(param_3, param_1, 0xf, "too big negative integer");
            } else {
                piVar1 = __errno_location();
                *piVar1 = 0;
                local_10 = strtoull(local_14, &pcStack_18, 10);
                piVar1 = __errno_location();
                if (*piVar1 == 0x22) {
                    FUN_0003fab8(param_3, param_1, 0xf, "too big integer");
                    return 0xffffffff;
                }
            }
        }
        *(undefined4 *)(param_1 + 0x3c) = 0x101;
        *(undefined4 *)(param_1 + 0x40) = (undefined4)local_10;
        *(undefined4 *)(param_1 + 0x44) = local_10._4_4_;
        return 0;
    }
    if (local_28 == 0x2e) {
        iVar2 = FUN_0004003c(param_1, param_3);
        if ((iVar2 < 0x30) || (0x39 < iVar2)) {
            FUN_00040108(param_1, iVar2);
            return 0xffffffff;
        }
        FUN_00040070(param_1, iVar2);
        do {
            local_28 = FUN_000400ac(param_1, param_3);
            if (local_28 < 0x30)
                break;
        } while (local_28 < 0x3a);
    }
    if ((local_28 == 0x45) || (local_28 == 0x65)) {
        local_28 = FUN_000400ac(param_1, param_3);
        if ((local_28 == 0x2b) || (local_28 == 0x2d)) {
            local_28 = FUN_000400ac(param_1, param_3);
        }
        if ((local_28 < 0x30) || (0x39 < local_28)) {
            FUN_00040138(param_1, local_28);
            return 0xffffffff;
        }
        do {
            local_28 = FUN_000400ac(param_1, param_3);
            if (local_28 < 0x30)
                break;
        } while (local_28 < 0x3a);
    }
    FUN_00040138(param_1, local_28);
    iVar2 = jsonp_strtod(param_1 + 0x28, &local_20);
    if (iVar2 != 0) {
        FUN_0003fab8(param_3, param_1, 0xf, "real number overflow");
        return 0xffffffff;
    }
    *(undefined4 *)(param_1 + 0x3c) = 0x102;
    *(undefined4 *)(param_1 + 0x40) = local_20;
    *(undefined4 *)(param_1 + 0x44) = uStack_1c;
    return 0;
}

undefined4 FUN_00040d30(int param_1, undefined4 param_2)

{
    int iVar1;
    char *__s1;

    strbuffer_clear(param_1 + 0x28);
    if (*(int *)(param_1 + 0x3c) == 0x100) {
        FUN_00040214(param_1);
    }
    do {
        do {
            iVar1 = FUN_0004003c(param_1, param_2);
        } while (iVar1 == 0x20);
    } while (((iVar1 == 9) || (iVar1 == 10)) || (iVar1 == 0xd));
    if (iVar1 == -1) {
        *(undefined4 *)(param_1 + 0x3c) = 0;
    } else if (iVar1 == -2) {
        *(undefined4 *)(param_1 + 0x3c) = 0xffffffff;
    } else {
        FUN_00040070(param_1, iVar1);
        if ((((iVar1 == 0x7b) || (iVar1 == 0x7d)) ||
             ((iVar1 == 0x5b || ((iVar1 == 0x5d || (iVar1 == 0x3a)))))) ||
            (iVar1 == 0x2c)) {
            *(int *)(param_1 + 0x3c) = iVar1;
        } else if (iVar1 == 0x22) {
            FUN_00040360(param_1, param_2);
        } else if (((iVar1 < 0x30) || (0x39 < iVar1)) && (iVar1 != 0x2d)) {
            if (((0x40 < iVar1) && (iVar1 < 0x5b)) ||
                ((0x60 < iVar1 && (iVar1 < 0x7b)))) {
            LAB_00040ed4:
                do {
                    iVar1 = FUN_000400ac(param_1, param_2);
                    if (0x40 < iVar1) {
                        if (iVar1 < 0x5b)
                            goto LAB_00040ed4;
                    }
                    if ((iVar1 < 0x61) || (0x7a < iVar1))
                        goto LAB_00040f14;
                } while (true);
            }
            FUN_00040190(param_1);
            *(undefined4 *)(param_1 + 0x3c) = 0xffffffff;
        } else {
            FUN_00040980(param_1, iVar1, param_2);
        }
    }
LAB_00040fdc:
    return *(undefined4 *)(param_1 + 0x3c);
LAB_00040f14:
    FUN_00040138(param_1, iVar1);
    __s1 = (char *)strbuffer_value(param_1 + 0x28);
    iVar1 = strcmp(__s1, "true");
    if (iVar1 == 0) {
        *(undefined4 *)(param_1 + 0x3c) = 0x103;
    } else {
        iVar1 = strcmp(__s1, "false");
        if (iVar1 == 0) {
            *(undefined4 *)(param_1 + 0x3c) = 0x104;
        } else {
            iVar1 = strcmp(__s1, "null");
            if (iVar1 == 0) {
                *(undefined4 *)(param_1 + 0x3c) = 0x105;
            } else {
                *(undefined4 *)(param_1 + 0x3c) = 0xffffffff;
            }
        }
    }
    goto LAB_00040fdc;
}

undefined4 FUN_00040ff0(int param_1, undefined4 *param_2)

{
    undefined4 local_c;

    local_c = 0;
    if (*(int *)(param_1 + 0x3c) == 0x100) {
        local_c = *(undefined4 *)(param_1 + 0x40);
        *param_2 = *(undefined4 *)(param_1 + 0x44);
        *(undefined4 *)(param_1 + 0x40) = 0;
        *(undefined4 *)(param_1 + 0x44) = 0;
    }
    return local_c;
}

undefined4 FUN_00041064(int param_1, undefined4 param_2, undefined4 param_3,
                        undefined4 param_4)

{
    int iVar1;
    undefined4 uVar2;

    FUN_0003fc6c(param_1, param_2, param_4);
    iVar1 = strbuffer_init(param_1 + 0x28);
    if (iVar1 == 0) {
        *(undefined4 *)(param_1 + 0x34) = param_3;
        *(undefined4 *)(param_1 + 0x3c) = 0xffffffff;
        uVar2 = 0;
    } else {
        uVar2 = 0xffffffff;
    }
    return uVar2;
}

void FUN_000410e0(int param_1)

{
    if (*(int *)(param_1 + 0x3c) == 0x100) {
        FUN_00040214(param_1);
    }
    strbuffer_close(param_1 + 0x28);
    return;
}

int FUN_00041124(int param_1, uint param_2, undefined4 param_3)

{
    void *pvVar1;
    int iVar2;
    size_t local_18;
    int local_14;
    void *local_10;
    int local_c;

    local_c = json_object();
    if (local_c == 0) {
        local_c = 0;
    } else {
        FUN_00040d30(param_1, param_3);
        if (*(int *)(param_1 + 0x3c) != 0x7d) {
            while (*(int *)(param_1 + 0x3c) == 0x100) {
                local_10 = (void *)FUN_00040ff0(param_1, &local_18);
                if (local_10 == (void *)0x0) {
                    return 0;
                }
                pvVar1 = memchr(local_10, 0, local_18);
                if (pvVar1 != (void *)0x0) {
                    jsonp_free(local_10);
                    FUN_0003fab8(param_3, param_1, 0xd,
                                 "NUL byte in object key not supported");
                    goto LAB_00041370;
                }
                if (((param_2 & 1) != 0) &&
                    (iVar2 = json_object_get(local_c, local_10), iVar2 != 0)) {
                    jsonp_free(local_10);
                    FUN_0003fab8(param_3, param_1, 0xe, "duplicate object key");
                    goto LAB_00041370;
                }
                FUN_00040d30(param_1, param_3);
                if (*(int *)(param_1 + 0x3c) != 0x3a) {
                    jsonp_free(local_10);
                    FUN_0003fab8(param_3, param_1, 8, "\':\' expected");
                    goto LAB_00041370;
                }
                FUN_00040d30(param_1, param_3);
                local_14 = FUN_000414b0(param_1, param_2, param_3);
                if (local_14 == 0) {
                    jsonp_free(local_10);
                    goto LAB_00041370;
                }
                iVar2 =
                    json_object_set_new_nocheck(local_c, local_10, local_14);
                if (iVar2 != 0) {
                    jsonp_free(local_10);
                    goto LAB_00041370;
                }
                jsonp_free(local_10);
                FUN_00040d30(param_1, param_3);
                if (*(int *)(param_1 + 0x3c) != 0x2c) {
                    if (*(int *)(param_1 + 0x3c) == 0x7d) {
                        return local_c;
                    }
                    FUN_0003fab8(param_3, param_1, 8, "\'}\' expected");
                    goto LAB_00041370;
                }
                FUN_00040d30(param_1, param_3);
            }
            FUN_0003fab8(param_3, param_1, 8, "string or \'}\' expected");
        LAB_00041370:
            FUN_0003fa50(local_c);
            local_c = 0;
        }
    }
    return local_c;
}

int FUN_00041388(int param_1, undefined4 param_2, undefined4 param_3)

{
    int iVar1;
    int iVar2;

    iVar1 = json_array();
    if (iVar1 == 0) {
        iVar1 = 0;
    } else {
        FUN_00040d30(param_1, param_3);
        if (*(int *)(param_1 + 0x3c) != 0x5d) {
            while (*(int *)(param_1 + 0x3c) != 0) {
                iVar2 = FUN_000414b0(param_1, param_2, param_3);
                if ((iVar2 == 0) ||
                    (iVar2 = json_array_append_new(iVar1, iVar2), iVar2 != 0))
                    goto LAB_00041498;
                FUN_00040d30(param_1, param_3);
                if (*(int *)(param_1 + 0x3c) != 0x2c)
                    break;
                FUN_00040d30(param_1, param_3);
            }
            if (*(int *)(param_1 + 0x3c) != 0x5d) {
                FUN_0003fab8(param_3, param_1, 8, "\']\' expected");
            LAB_00041498:
                FUN_0003fa50(iVar1);
                iVar1 = 0;
            }
        }
    }
    return iVar1;
}

int FUN_000414b0(int param_1, uint param_2, undefined4 param_3)

{
    void *pvVar1;
    int iVar2;
    void *__s;
    size_t __n;
    int local_c;

    *(int *)(param_1 + 0x38) = *(int *)(param_1 + 0x38) + 1;
    if (0x800 < *(uint *)(param_1 + 0x38)) {
        FUN_0003fab8(param_3, param_1, 2, "maximum parsing depth reached");
        return 0;
    }
    iVar2 = *(int *)(param_1 + 0x3c);
    if (iVar2 == 0x101) {
        local_c = json_integer(*(undefined4 *)(param_1 + 0x40),
                               *(undefined4 *)(param_1 + 0x44));
    } else if (iVar2 < 0x102) {
        if (iVar2 == 0x5b) {
            local_c = FUN_00041388(param_1, param_2, param_3);
        } else {
            if (iVar2 < 0x5c) {
                if (iVar2 == -1) {
                    FUN_0003fab8(param_3, param_1, 8, "invalid token");
                    return 0;
                }
            LAB_000416c4:
                FUN_0003fab8(param_3, param_1, 8, "unexpected token");
                return 0;
            }
            if (iVar2 == 0x7b) {
                local_c = FUN_00041124(param_1, param_2, param_3);
            } else {
                if (iVar2 != 0x100)
                    goto LAB_000416c4;
                __s = *(void **)(param_1 + 0x40);
                __n = *(size_t *)(param_1 + 0x44);
                if (((param_2 & 0x10) == 0) &&
                    (pvVar1 = memchr(__s, 0, __n), pvVar1 != (void *)0x0)) {
                    FUN_0003fab8(
                        param_3, param_1, 0xb,
                        "\\u0000 is not allowed without JSON_ALLOW_NUL");
                    return 0;
                }
                local_c = jsonp_stringn_nocheck_own(__s, __n);
                *(undefined4 *)(param_1 + 0x40) = 0;
                *(undefined4 *)(param_1 + 0x44) = 0;
            }
        }
    } else if (iVar2 == 0x103) {
        local_c = json_true();
    } else if (iVar2 < 0x103) {
        local_c = json_real((int)*(undefined8 *)(param_1 + 0x40));
    } else if (iVar2 == 0x104) {
        local_c = json_false();
    } else {
        if (iVar2 != 0x105)
            goto LAB_000416c4;
        local_c = json_null();
    }
    if (local_c == 0) {
        local_c = 0;
    } else {
        *(int *)(param_1 + 0x38) = *(int *)(param_1 + 0x38) + -1;
    }
    return local_c;
}

int FUN_0004171c(int param_1, uint param_2, int param_3)

{
    int iVar1;

    *(undefined4 *)(param_1 + 0x38) = 0;
    FUN_00040d30(param_1, param_3);
    if ((((param_2 & 4) == 0) && (*(int *)(param_1 + 0x3c) != 0x5b)) &&
        (*(int *)(param_1 + 0x3c) != 0x7b)) {
        FUN_0003fab8(param_3, param_1, 8, "\'[\' or \'{\' expected");
        iVar1 = 0;
    } else {
        iVar1 = FUN_000414b0(param_1, param_2, param_3);
        if (iVar1 == 0) {
            iVar1 = 0;
        } else if (((param_2 & 2) == 0) && (FUN_00040d30(param_1, param_3),
                                            *(int *)(param_1 + 0x3c) != 0)) {
            FUN_0003fab8(param_3, param_1, 7, "end of file expected");
            FUN_0003fa50(iVar1);
            iVar1 = 0;
        } else if (param_3 != 0) {
            *(undefined4 *)(param_3 + 8) = *(undefined4 *)(param_1 + 0x24);
        }
    }
    return iVar1;
}

undefined4 json_loads(int param_1, undefined4 param_2, undefined4 param_3)

{
    int iVar1;
    int local_60[2];
    undefined1 auStack_58[76];
    undefined4 local_c;

    jsonp_error_init(param_3, "<string>");
    if (param_1 == 0) {
        FUN_0003fab8(param_3, 0, 4, "wrong arguments");
        local_c = 0;
    } else {
        local_60[1] = 0;
        local_60[0] = param_1;
        iVar1 = FUN_00041064(auStack_58, &LAB_00041848, param_2, local_60);
        if (iVar1 == 0) {
            local_c = FUN_0004171c(auStack_58, param_2, param_3);
            FUN_000410e0(auStack_58);
        } else {
            local_c = 0;
        }
    }
    return local_c;
}

undefined4 json_loadb(int param_1, undefined4 param_2, undefined4 param_3,
                      undefined4 param_4)

{
    int iVar1;
    int local_64;
    undefined4 local_60;
    undefined4 local_5c;
    undefined1 auStack_58[76];
    undefined4 local_c;

    jsonp_error_init(param_4, "<buffer>");
    if (param_1 == 0) {
        FUN_0003fab8(param_4, 0, 4, "wrong arguments", param_4, param_3,
                     param_2);
        local_c = 0;
    } else {
        local_5c = 0;
        local_64 = param_1;
        local_60 = param_2;
        iVar1 = FUN_00041064(auStack_58, &LAB_0004197c, param_3, &local_64);
        if (iVar1 == 0) {
            local_c = FUN_0004171c(auStack_58, param_3, param_4);
            FUN_000410e0(auStack_58);
        } else {
            local_c = 0;
        }
    }
    return local_c;
}

undefined4 json_loadf(int param_1, undefined4 param_2, undefined4 param_3)

{
    int iVar1;
    undefined1 auStack_58[72];
    undefined4 local_10;
    char *local_c;

    if (param_1 == stdin) {
        local_c = "<stdin>";
    } else {
        local_c = "<stream>";
    }
    jsonp_error_init(param_3, local_c);
    if (param_1 == 0) {
        FUN_0003fab8(param_3, 0, 4, "wrong arguments");
        local_10 = 0;
    } else {
        iVar1 = FUN_00041064(auStack_58, fgetc, param_2, param_1);
        if (iVar1 == 0) {
            local_10 = FUN_0004171c(auStack_58, param_2, param_3);
            FUN_000410e0(auStack_58);
        } else {
            local_10 = 0;
        }
    }
    return local_10;
}

uint FUN_00041bac(int *param_1)

{
    ssize_t sVar1;
    uint uVar2;
    byte local_9;

    sVar1 = read(*param_1, &local_9, 1);
    if (sVar1 == 1) {
        uVar2 = (uint)local_9;
    } else {
        uVar2 = 0xffffffff;
    }
    return uVar2;
}

undefined4 json_loadfd(int param_1, undefined4 param_2, undefined4 param_3)

{
    int iVar1;
    int local_5c;
    undefined1 auStack_58[72];
    undefined4 local_10;
    char *local_c;

    if (param_1 == 0) {
        local_c = "<stdin>";
    } else {
        local_c = "<stream>";
    }
    local_5c = param_1;
    jsonp_error_init(param_3, local_c);
    if (local_5c < 0) {
        FUN_0003fab8(param_3, 0, 4, "wrong arguments");
        local_10 = 0;
    } else {
        iVar1 = FUN_00041064(auStack_58, FUN_00041bac, param_2, &local_5c);
        if (iVar1 == 0) {
            local_10 = FUN_0004171c(auStack_58, param_2, param_3);
            FUN_000410e0(auStack_58);
        } else {
            local_10 = 0;
        }
    }
    return local_10;
}

undefined4 json_load_file(char *param_1, undefined4 param_2, undefined4 param_3)

{
    FILE *__stream;
    int *piVar1;
    char *pcVar2;
    undefined4 uVar3;

    jsonp_error_init(param_3, param_1);
    if (param_1 == (char *)0x0) {
        FUN_0003fab8(param_3, 0, 4, "wrong arguments");
        uVar3 = 0;
    } else {
        __stream = fopen(param_1, "rb");
        if (__stream == (FILE *)0x0) {
            piVar1 = __errno_location();
            pcVar2 = strerror(*piVar1);
            FUN_0003fab8(param_3, 0, 3, "unable to open %s: %s", param_1,
                         pcVar2);
            uVar3 = 0;
        } else {
            uVar3 = json_loadf(__stream, param_2, param_3);
            fclose(__stream);
        }
    }
    return uVar3;
}

uint FUN_00041db0(int param_1)

{
    byte bVar1;
    undefined4 uVar2;

    if (*(uint *)(param_1 + 0x400) <= *(uint *)(param_1 + 0x404)) {
        *(undefined4 *)(param_1 + 0x404) = 0;
        uVar2 = (**(code **)(param_1 + 0x408))(
            param_1, 0x400, *(undefined4 *)(param_1 + 0x40c));
        *(undefined4 *)(param_1 + 0x400) = uVar2;
        if ((*(int *)(param_1 + 0x400) == 0) ||
            (*(int *)(param_1 + 0x400) == -1)) {
            return 0xffffffff;
        }
    }
    bVar1 = *(byte *)(param_1 + *(int *)(param_1 + 0x404));
    *(int *)(param_1 + 0x404) = *(int *)(param_1 + 0x404) + 1;
    return (uint)bVar1;
}

undefined4 json_load_callback(int param_1, undefined4 param_2,
                              undefined4 param_3, undefined4 param_4)

{
    int iVar1;
    undefined1 auStack_468[1032];
    int local_60;
    undefined4 local_5c;
    undefined1 auStack_58[76];
    undefined4 local_c;

    memset(auStack_468, 0, 0x410);
    local_60 = param_1;
    local_5c = param_2;
    jsonp_error_init(param_4, "<callback>");
    if (param_1 == 0) {
        FUN_0003fab8(param_4, 0, 4, "wrong arguments");
        local_c = 0;
    } else {
        iVar1 = FUN_00041064(auStack_58, FUN_00041db0, param_3, auStack_468,
                             param_4, param_3, param_2);
        if (iVar1 == 0) {
            local_c = FUN_0004171c(auStack_58, param_3, param_4);
            FUN_000410e0(auStack_58);
        } else {
            local_c = 0;
        }
    }
    return local_c;
}

undefined4 jsonp_malloc(int param_1)

{
    undefined4 uVar1;

    if (param_1 == 0) {
        uVar1 = 0;
    } else {
        uVar1 = (*DAT_0014de98)(param_1);
    }
    return uVar1;
}

void jsonp_free(int param_1)

{
    if (param_1 != 0) {
        (*DAT_0014de9c)(param_1);
    }
    return;
}

undefined4 jsonp_strdup(char *param_1)

{
    size_t sVar1;
    undefined4 uVar2;

    sVar1 = strlen(param_1);
    uVar2 = jsonp_strndup(param_1, sVar1);
    return uVar2;
}

void *jsonp_strndup(void *param_1, size_t param_2)

{
    void *__dest;

    __dest = (void *)jsonp_malloc(param_2 + 1);
    if (__dest == (void *)0x0) {
        __dest = (void *)0x0;
    } else {
        memcpy(__dest, param_1, param_2);
        *(undefined1 *)((int)__dest + param_2) = 0;
    }
    return __dest;
}

void json_set_alloc_funcs(undefined4 param_1, undefined4 param_2)

{
    DAT_0014de98 = param_1;
    DAT_0014de9c = param_2;
    return;
}

void json_get_alloc_funcs(undefined4 *param_1, undefined4 *param_2)

{
    if (param_1 != (undefined4 *)0x0) {
        *param_1 = DAT_0014de98;
    }
    if (param_2 != (undefined4 *)0x0) {
        *param_2 = DAT_0014de9c;
    }
    return;
}

int FUN_00042130(int param_1)

{
    bool bVar1;
    int *piVar2;

    if ((param_1 != 0) && (*(int *)(param_1 + 4) != -1)) {
        piVar2 = (int *)(param_1 + 4);
        do {
            bVar1 = (bool)hasExclusiveAccess(piVar2);
        } while (!bVar1);
        *piVar2 = *piVar2 + 1;
        DataMemoryBarrier(0xb);
    }
    return param_1;
}

void FUN_00042190(int param_1)

{
    bool bVar1;
    int iVar2;
    int *piVar3;

    if ((param_1 != 0) && (*(int *)(param_1 + 4) != -1)) {
        piVar3 = (int *)(param_1 + 4);
        DataMemoryBarrier(0xb);
        do {
            iVar2 = *piVar3;
            bVar1 = (bool)hasExclusiveAccess(piVar3);
        } while (!bVar1);
        *piVar3 = iVar2 + -1;
        if (iVar2 + -1 == 0) {
            json_delete(param_1);
        }
    }
    return;
}

void FUN_000421f8(undefined4 *param_1, undefined4 param_2, undefined4 param_3,
                  undefined4 param_4)

{
    param_1[0xe] = param_2;
    param_1[0xf] = param_3;
    *param_1 = param_4;
    param_1[1] = *param_1;
    memset(param_1 + 2, 0, 0x10);
    memset(param_1 + 6, 0, 0x10);
    memset(param_1 + 10, 0, 0x10);
    param_1[0x10] = 1;
    param_1[0x11] = 0;
    param_1[0x12] = 0;
    param_1[0x13] = 0;
    return;
}

void FUN_000422cc(int param_1)

{
    char *local_c;

    *(undefined4 *)(param_1 + 8) = *(undefined4 *)(param_1 + 0x18);
    *(undefined4 *)(param_1 + 0xc) = *(undefined4 *)(param_1 + 0x1c);
    *(undefined4 *)(param_1 + 0x10) = *(undefined4 *)(param_1 + 0x20);
    *(undefined4 *)(param_1 + 0x14) = *(undefined4 *)(param_1 + 0x24);
    if (*(int *)(param_1 + 0x28) == 0) {
        if ((*(char *)(param_1 + 0x24) != '\0') ||
            (**(char **)(param_1 + 4) != '\0')) {
            local_c = *(char **)(param_1 + 4);
            *(int *)(param_1 + 0x44) = *(int *)(param_1 + 0x44) + 1;
            *(int *)(param_1 + 0x48) = *(int *)(param_1 + 0x48) + 1;
            for (; (((*local_c == ' ' || (*local_c == '\t')) ||
                     (*local_c == '\n')) ||
                    ((*local_c == ',' || (*local_c == ':'))));
                 local_c = local_c + 1) {
                if (*local_c == '\n') {
                    *(int *)(param_1 + 0x40) = *(int *)(param_1 + 0x40) + 1;
                    *(undefined4 *)(param_1 + 0x44) = 1;
                } else {
                    *(int *)(param_1 + 0x44) = *(int *)(param_1 + 0x44) + 1;
                }
                *(int *)(param_1 + 0x48) = *(int *)(param_1 + 0x48) + 1;
            }
            *(char *)(param_1 + 0x24) = *local_c;
            *(undefined4 *)(param_1 + 0x18) = *(undefined4 *)(param_1 + 0x40);
            *(undefined4 *)(param_1 + 0x1c) = *(undefined4 *)(param_1 + 0x44);
            *(undefined4 *)(param_1 + 0x20) = *(undefined4 *)(param_1 + 0x48);
            if (*local_c != '\0') {
                local_c = local_c + 1;
            }
            *(char **)(param_1 + 4) = local_c;
        }
    } else {
        *(undefined4 *)(param_1 + 0x18) = *(undefined4 *)(param_1 + 0x28);
        *(undefined4 *)(param_1 + 0x1c) = *(undefined4 *)(param_1 + 0x2c);
        *(undefined4 *)(param_1 + 0x20) = *(undefined4 *)(param_1 + 0x30);
        *(undefined4 *)(param_1 + 0x24) = *(undefined4 *)(param_1 + 0x34);
        *(undefined4 *)(param_1 + 0x28) = 0;
    }
    return;
}

void FUN_000424bc(int param_1)

{
    *(undefined4 *)(param_1 + 0x28) = *(undefined4 *)(param_1 + 0x18);
    *(undefined4 *)(param_1 + 0x2c) = *(undefined4 *)(param_1 + 0x1c);
    *(undefined4 *)(param_1 + 0x30) = *(undefined4 *)(param_1 + 0x20);
    *(undefined4 *)(param_1 + 0x34) = *(undefined4 *)(param_1 + 0x24);
    *(undefined4 *)(param_1 + 0x18) = *(undefined4 *)(param_1 + 8);
    *(undefined4 *)(param_1 + 0x1c) = *(undefined4 *)(param_1 + 0xc);
    *(undefined4 *)(param_1 + 0x20) = *(undefined4 *)(param_1 + 0x10);
    *(undefined4 *)(param_1 + 0x24) = *(undefined4 *)(param_1 + 0x14);
    return;
}

void FUN_0004250c(int param_1, undefined4 param_2, undefined4 param_3,
                  undefined4 param_4)

{
    jsonp_error_vset(
        *(undefined4 *)(param_1 + 0x38), *(undefined4 *)(param_1 + 0x18),
        *(undefined4 *)(param_1 + 0x1c), *(undefined4 *)(param_1 + 0x20),
        param_3, param_4, &stack0x00000000);
    jsonp_error_set_source(*(undefined4 *)(param_1 + 0x38), param_2);
    return;
}

char *FUN_00042598(int param_1, int *param_2, undefined4 param_3,
                   size_t *param_4, undefined4 *param_5, int param_6)

{
    int iVar1;
    undefined4 *puVar2;
    int *piVar3;
    size_t *psVar4;
    undefined4 local_20;
    size_t local_1c;
    char *local_14;
    char local_d;
    size_t local_c;

    FUN_000422cc(param_1);
    local_d = *(char *)(param_1 + 0x24);
    FUN_000424bc(param_1);
    *param_5 = 0;
    if (((local_d == '#') || (local_d == '%')) || (local_d == '+')) {
        if (param_6 == 0) {
            iVar1 = strbuffer_init(&local_20);
            if (iVar1 != 0) {
                FUN_0004250c(param_1, "<internal>", 1, "Out of memory");
                *(undefined4 *)(param_1 + 0x4c) = 1;
            }
            do {
                piVar3 = (int *)*param_2;
                *param_2 = (int)(piVar3 + 1);
                local_14 = (char *)*piVar3;
                if (local_14 == (char *)0x0) {
                    FUN_0004250c(param_1, "<args>", 0xc, "NULL %s", param_3);
                    *(undefined4 *)(param_1 + 0x4c) = 1;
                }
                FUN_000422cc(param_1);
                if (*(char *)(param_1 + 0x24) == '#') {
                    psVar4 = (size_t *)*param_2;
                    *param_2 = (int)(psVar4 + 1);
                    local_c = *psVar4;
                } else if (*(char *)(param_1 + 0x24) == '%') {
                    psVar4 = (size_t *)*param_2;
                    *param_2 = (int)(psVar4 + 1);
                    local_c = *psVar4;
                } else {
                    FUN_000424bc(param_1);
                    if (*(int *)(param_1 + 0x4c) == 0) {
                        local_c = strlen(local_14);
                    } else {
                        local_c = 0;
                    }
                }
                if ((*(int *)(param_1 + 0x4c) == 0) &&
                    (iVar1 =
                         strbuffer_append_bytes(&local_20, local_14, local_c),
                     iVar1 == -1)) {
                    FUN_0004250c(param_1, "<internal>", 1, "Out of memory");
                    *(undefined4 *)(param_1 + 0x4c) = 1;
                }
                FUN_000422cc(param_1);
            } while (*(char *)(param_1 + 0x24) == '+');
            FUN_000424bc(param_1);
            if (*(int *)(param_1 + 0x4c) == 0) {
                iVar1 = utf8_check_string(local_20, local_1c);
                if (iVar1 == 0) {
                    FUN_0004250c(param_1, "<args>", 5, "Invalid UTF-8 %s",
                                 param_3);
                    strbuffer_close(&local_20);
                    *(undefined4 *)(param_1 + 0x4c) = 1;
                    local_14 = (char *)0x0;
                } else {
                    *param_4 = local_1c;
                    *param_5 = 1;
                    local_14 = (char *)strbuffer_steal_value(&local_20);
                }
            } else {
                strbuffer_close(&local_20);
                local_14 = (char *)0x0;
            }
        } else {
            FUN_0004250c(param_1, "<format>", 9,
                         "Cannot use \'%c\' on optional strings", local_d);
            *(undefined4 *)(param_1 + 0x4c) = 1;
            local_14 = (char *)0x0;
        }
    } else {
        puVar2 = (undefined4 *)*param_2;
        *param_2 = (int)(puVar2 + 1);
        local_14 = (char *)*puVar2;
        if (local_14 == (char *)0x0) {
            if (param_6 == 0) {
                FUN_0004250c(param_1, "<args>", 0xc, "NULL %s", param_3);
                *(undefined4 *)(param_1 + 0x4c) = 1;
            }
            local_14 = (char *)0x0;
        } else {
            local_c = strlen(local_14);
            iVar1 = utf8_check_string(local_14, local_c);
            if (iVar1 == 0) {
                FUN_0004250c(param_1, "<args>", 5, "Invalid UTF-8 %s", param_3);
                *(undefined4 *)(param_1 + 0x4c) = 1;
                local_14 = (char *)0x0;
            } else {
                *param_4 = local_c;
            }
        }
    }
    return local_14;
}

undefined4 FUN_00042988(int param_1, undefined4 param_2)

{
    int iVar1;
    int local_20;
    undefined1 auStack_1c[4];
    int local_18;
    char local_11;
    undefined4 local_10;
    undefined4 local_c;

    local_c = json_object();
    FUN_000422cc(param_1);
    do {
        if (*(char *)(param_1 + 0x24) == '}') {
            if (*(int *)(param_1 + 0x4c) != 0) {
            LAB_00042ba0:
                FUN_00042190(local_c);
                local_c = 0;
            }
            return local_c;
        }
        if (*(char *)(param_1 + 0x24) == '\0') {
            FUN_0004250c(param_1, "<format>", 9,
                         "Unexpected end of format string");
            goto LAB_00042ba0;
        }
        if (*(char *)(param_1 + 0x24) != 's') {
            FUN_0004250c(param_1, "<format>", 9,
                         "Expected format \'s\', got \'%c\'",
                         *(undefined1 *)(param_1 + 0x24));
            goto LAB_00042ba0;
        }
        local_10 = FUN_00042598(param_1, param_2, "object key", auStack_1c,
                                &local_20, 0);
        FUN_000422cc(param_1);
        FUN_000422cc(param_1);
        local_11 = *(char *)(param_1 + 0x24);
        FUN_000424bc(param_1);
        local_18 = FUN_00043068(param_1, param_2);
        if (local_18 == 0) {
            if (local_20 != 0) {
                jsonp_free(local_10);
            }
            if (local_11 != '*') {
                FUN_0004250c(param_1, "<args>", 0xc, "NULL object value");
                *(undefined4 *)(param_1 + 0x4c) = 1;
            }
            FUN_000422cc(param_1);
        } else {
            if (*(int *)(param_1 + 0x4c) != 0) {
                FUN_00042190(local_18);
            }
            if ((*(int *)(param_1 + 0x4c) == 0) &&
                (iVar1 =
                     json_object_set_new_nocheck(local_c, local_10, local_18),
                 iVar1 != 0)) {
                FUN_0004250c(param_1, "<internal>", 1,
                             "Unable to add key \"%s\"", local_10);
                *(undefined4 *)(param_1 + 0x4c) = 1;
            }
            if (local_20 != 0) {
                jsonp_free(local_10);
            }
            FUN_000422cc(param_1);
        }
    } while (true);
}

undefined4 FUN_00042bb8(int param_1, undefined4 param_2)

{
    char cVar1;
    undefined4 uVar2;
    int iVar3;

    uVar2 = json_array();
    FUN_000422cc(param_1);
    do {
        if (*(char *)(param_1 + 0x24) == ']') {
            if (*(int *)(param_1 + 0x4c) != 0) {
            LAB_00042d08:
                FUN_00042190(uVar2);
                uVar2 = 0;
            }
            return uVar2;
        }
        if (*(char *)(param_1 + 0x24) == '\0') {
            FUN_0004250c(param_1, "<format>", 9,
                         "Unexpected end of format string");
            goto LAB_00042d08;
        }
        FUN_000422cc(param_1);
        cVar1 = *(char *)(param_1 + 0x24);
        FUN_000424bc(param_1);
        iVar3 = FUN_00043068(param_1, param_2);
        if (iVar3 == 0) {
            if (cVar1 != '*') {
                *(undefined4 *)(param_1 + 0x4c) = 1;
            }
            FUN_000422cc(param_1);
        } else {
            if (*(int *)(param_1 + 0x4c) != 0) {
                FUN_00042190(iVar3);
            }
            if ((*(int *)(param_1 + 0x4c) == 0) &&
                (iVar3 = json_array_append_new(uVar2, iVar3), iVar3 != 0)) {
                FUN_0004250c(param_1, "<internal>", 1,
                             "Unable to append to array");
                *(undefined4 *)(param_1 + 0x4c) = 1;
            }
            FUN_000422cc(param_1);
        }
    } while (true);
}

undefined4 FUN_00042d20(int param_1, undefined4 param_2)

{
    undefined4 uVar1;
    int local_1c;
    undefined4 local_18;
    int local_14;
    int local_10;
    char local_9;

    FUN_000422cc(param_1);
    local_9 = *(char *)(param_1 + 0x24);
    if ((local_9 == '?') || (local_9 == '*')) {
        local_10 = 1;
    } else {
        local_10 = 0;
    }
    if (local_10 == 0) {
        FUN_000424bc(param_1);
    }
    local_14 = FUN_00042598(param_1, param_2, "string", &local_18, &local_1c,
                            local_10);
    if (local_14 == 0) {
        if ((local_9 == '?') && (*(int *)(param_1 + 0x4c) == 0)) {
            uVar1 = json_null();
        } else {
            uVar1 = 0;
        }
    } else if (*(int *)(param_1 + 0x4c) == 0) {
        if (local_1c == 0) {
            uVar1 = json_stringn_nocheck(local_14, local_18);
        } else {
            uVar1 = jsonp_stringn_nocheck_own(local_14, local_18);
        }
    } else {
        uVar1 = 0;
    }
    return uVar1;
}

int FUN_00042e4c(int param_1, int *param_2, int param_3)

{
    char cVar1;
    int *piVar2;
    int iVar3;

    FUN_000422cc(param_1);
    cVar1 = *(char *)(param_1 + 0x24);
    if ((cVar1 != '?') && (cVar1 != '*')) {
        FUN_000424bc(param_1);
    }
    piVar2 = (int *)*param_2;
    *param_2 = (int)(piVar2 + 1);
    iVar3 = *piVar2;
    if (iVar3 == 0) {
        if (cVar1 == '*') {
            iVar3 = 0;
        } else if (cVar1 == '?') {
            iVar3 = json_null();
        } else {
            FUN_0004250c(param_1, "<args>", 0xc, "NULL object");
            *(undefined4 *)(param_1 + 0x4c) = 1;
            iVar3 = 0;
        }
    } else if (param_3 != 0) {
        iVar3 = FUN_00042130(iVar3);
    }
    return iVar3;
}

int FUN_00042f48(int param_1, undefined4 param_2, undefined4 param_3,
                 undefined4 param_4)

{
    int iVar1;

    iVar1 = json_integer(param_3, param_4);
    if (iVar1 == 0) {
        FUN_0004250c(param_1, "<internal>", 1, "Out of memory");
        *(undefined4 *)(param_1 + 0x4c) = 1;
    }
    return iVar1;
}

int FUN_00042fac(undefined4 param_1, int param_2)

{
    int iVar1;
    int iVar2;

    iVar1 = json_real(0);
    if (iVar1 == 0) {
        FUN_0004250c(param_2, "<internal>", 1, "Out of memory");
        *(undefined4 *)(param_2 + 0x4c) = 1;
        iVar1 = 0;
    } else {
        iVar2 = json_real_set(param_1, iVar1);
        if (iVar2 != 0) {
            FUN_00042190(iVar1);
            FUN_0004250c(param_2, "<args>", 0xf,
                         "Invalid floating point value");
            *(undefined4 *)(param_2 + 0x4c) = 1;
            iVar1 = 0;
        }
    }
    return iVar1;
}

undefined4 FUN_00043068(int param_1, int *param_2)

{
    int *piVar1;
    int *piVar2;
    int iVar3;
    undefined4 *puVar4;
    undefined8 *puVar5;
    undefined4 uVar6;

    switch (*(undefined1 *)(param_1 + 0x24)) {
    case 0x49:
        puVar4 = (undefined4 *)(*param_2 + 7U & 0xfffffff8);
        *param_2 = (int)(puVar4 + 2);
        uVar6 = FUN_00042f48(param_1, puVar4 + 2, *puVar4, puVar4[1]);
        break;
    default:
        FUN_0004250c(param_1, "<format>", 9,
                     "Unexpected format character \'%c\'",
                     *(undefined1 *)(param_1 + 0x24));
        *(undefined4 *)(param_1 + 0x4c) = 1;
        uVar6 = 0;
        break;
    case 0x4f:
        uVar6 = FUN_00042e4c(param_1, param_2, 1);
        break;
    case 0x5b:
        uVar6 = FUN_00042bb8(param_1, param_2);
        break;
    case 0x62:
        piVar1 = (int *)*param_2;
        *param_2 = (int)(piVar1 + 1);
        if (*piVar1 == 0) {
            uVar6 = json_false();
        } else {
            uVar6 = json_true();
        }
        break;
    case 0x66:
        puVar5 = (undefined8 *)(*param_2 + 7U & 0xfffffff8);
        *param_2 = (int)(puVar5 + 1);
        uVar6 = FUN_00042fac((int)*puVar5, param_1);
        break;
    case 0x69:
        piVar2 = (int *)*param_2;
        piVar1 = piVar2 + 1;
        *param_2 = (int)piVar1;
        iVar3 = *piVar2;
        uVar6 = FUN_00042f48(param_1, piVar1, iVar3, iVar3 >> 0x1f);
        break;
    case 0x6e:
        uVar6 = json_null();
        break;
    case 0x6f:
        uVar6 = FUN_00042e4c(param_1, param_2, 0);
        break;
    case 0x73:
        uVar6 = FUN_00042d20(param_1, param_2);
        break;
    case 0x7b:
        uVar6 = FUN_00042988(param_1, param_2);
    }
    return uVar6;
}

undefined4 FUN_000432e8(int param_1, int *param_2, int *param_3)

{
    int iVar1;
    undefined4 uVar2;
    size_t sVar3;
    char *pcVar4;
    int *piVar5;
    undefined1 auStack_58[12];
    int local_4c[7];
    int local_30;
    int local_2c;
    int local_28;
    int local_24;
    char *local_20;
    int local_1c;
    int local_18;
    int local_14;
    int local_10;
    undefined4 local_c;

    local_c = 0xffffffff;
    local_10 = 0;
    local_14 = 0;
    iVar1 = hashtable_init(local_4c);
    if (iVar1 != 0) {
        FUN_0004250c(param_1, "<internal>", 1, "Out of memory");
        return 0xffffffff;
    }
    if ((param_2 == (int *)0x0) ||
        ((param_2 != (int *)0x0 && (*param_2 == 0)))) {
        FUN_000422cc(param_1);
        while (*(char *)(param_1 + 0x24) != '}') {
            local_1c = 0;
            if (local_10 != 0) {
                if (local_10 == 1) {
                    uVar2 = 0x21;
                } else {
                    uVar2 = 0x2a;
                }
                FUN_0004250c(param_1, "<format>", 9,
                             "Expected \'}\' after \'%c\', got \'%c\'", uVar2,
                             *(undefined1 *)(param_1 + 0x24));
                goto LAB_00043800;
            }
            if (*(char *)(param_1 + 0x24) == '\0') {
                FUN_0004250c(param_1, "<format>", 9,
                             "Unexpected end of format string");
                goto LAB_00043800;
            }
            if ((*(char *)(param_1 + 0x24) == '!') ||
                (*(char *)(param_1 + 0x24) == '*')) {
                if (*(char *)(param_1 + 0x24) == '!') {
                    local_10 = 1;
                } else {
                    local_10 = -1;
                }
                FUN_000422cc(param_1);
            } else {
                if (*(char *)(param_1 + 0x24) != 's') {
                    FUN_0004250c(param_1, "<format>", 9,
                                 "Expected format \'s\', got \'%c\'",
                                 *(undefined1 *)(param_1 + 0x24));
                    goto LAB_00043800;
                }
                piVar5 = (int *)*param_3;
                *param_3 = (int)(piVar5 + 1);
                local_30 = *piVar5;
                if (local_30 == 0) {
                    FUN_0004250c(param_1, "<args>", 0xc, "NULL object key");
                    goto LAB_00043800;
                }
                FUN_000422cc(param_1);
                if (*(char *)(param_1 + 0x24) == '?') {
                    local_14 = 1;
                    local_1c = 1;
                    FUN_000422cc(param_1);
                }
                if (param_2 == (int *)0x0) {
                    local_18 = 0;
                } else {
                    local_18 = json_object_get(param_2, local_30);
                    if ((local_18 == 0) && (local_1c == 0)) {
                        FUN_0004250c(param_1, "<validation>", 0x10,
                                     "Object item not found: %s", local_30);
                        goto LAB_00043800;
                    }
                }
                iVar1 = FUN_00043b38(param_1, local_18, param_3);
                if (iVar1 != 0)
                    goto LAB_00043800;
                uVar2 = json_null();
                hashtable_set(local_4c, local_30, uVar2);
                FUN_000422cc(param_1);
            }
        }
        if ((local_10 == 0) && ((*(uint *)(param_1 + 0x3c) & 2) != 0)) {
            local_10 = 1;
        }
        if ((param_2 != (int *)0x0) && (local_10 == 1)) {
            local_24 = 1;
            local_28 = 0;
            if ((local_14 != 0) ||
                (iVar1 = json_object_size(param_2), iVar1 != local_4c[0])) {
                uVar2 = json_object_iter(param_2);
                local_20 = (char *)json_object_iter_key(uVar2);
                while (local_20 != (char *)0x0) {
                    uVar2 = json_object_key_to_iter(local_20);
                    local_2c = json_object_iter_value(uVar2);
                    if (local_2c == 0)
                        break;
                    iVar1 = hashtable_get(local_4c, local_20);
                    if (iVar1 == 0) {
                        local_28 = local_28 + 1;
                        if (local_24 == 1) {
                            local_24 = strbuffer_init(auStack_58);
                        } else if (local_24 == 0) {
                            local_24 = strbuffer_append_bytes(auStack_58,
                                                              &DAT_000da550, 2);
                        }
                        if (local_24 == 0) {
                            sVar3 = strlen(local_20);
                            local_24 = strbuffer_append_bytes(auStack_58,
                                                              local_20, sVar3);
                        }
                    }
                    uVar2 = json_object_key_to_iter(local_20);
                    uVar2 = json_object_iter_next(param_2, uVar2);
                    local_20 = (char *)json_object_iter_key(uVar2);
                }
            }
            if (local_28 != 0) {
                if (local_24 == 0) {
                    pcVar4 = (char *)strbuffer_value(auStack_58);
                } else {
                    pcVar4 = "<unknown>";
                }
                FUN_0004250c(param_1, "<validation>", 7,
                             "%li object item(s) left unpacked: %s", local_28,
                             pcVar4);
                strbuffer_close(auStack_58);
                goto LAB_00043800;
            }
        }
        local_c = 0;
    } else {
        FUN_0004250c(param_1, "<validation>", 10, "Expected object, got %s",
                     (&PTR_s_object_000da358)[*param_2]);
    }
LAB_00043800:
    hashtable_close(local_4c);
    return local_c;
}

undefined4 FUN_0004381c(int param_1, int *param_2, undefined4 param_3)

{
    char *pcVar1;
    int iVar2;
    undefined4 uVar3;
    int local_14;
    int local_10;
    int local_c;

    local_c = 0;
    local_10 = 0;
    if ((param_2 == (int *)0x0) ||
        ((param_2 != (int *)0x0 && (*param_2 == 1)))) {
        FUN_000422cc(param_1);
        while (*(char *)(param_1 + 0x24) != ']') {
            if (local_10 != 0) {
                if (local_10 == 1) {
                    uVar3 = 0x21;
                } else {
                    uVar3 = 0x2a;
                }
                FUN_0004250c(param_1, "<format>", 9,
                             "Expected \']\' after \'%c\', got \'%c\'", uVar3,
                             *(undefined1 *)(param_1 + 0x24));
                return 0xffffffff;
            }
            if (*(char *)(param_1 + 0x24) == '\0') {
                FUN_0004250c(param_1, "<format>", 9,
                             "Unexpected end of format string");
                return 0xffffffff;
            }
            if ((*(char *)(param_1 + 0x24) == '!') ||
                (*(char *)(param_1 + 0x24) == '*')) {
                if (*(char *)(param_1 + 0x24) == '!') {
                    local_10 = 1;
                } else {
                    local_10 = -1;
                }
                FUN_000422cc(param_1);
            } else {
                pcVar1 =
                    strchr("{[siIbfFOon", (uint) * (byte *)(param_1 + 0x24));
                if (pcVar1 == (char *)0x0) {
                    FUN_0004250c(param_1, "<format>", 9,
                                 "Unexpected format character \'%c\'",
                                 *(undefined1 *)(param_1 + 0x24));
                    return 0xffffffff;
                }
                if (param_2 == (int *)0x0) {
                    local_14 = 0;
                } else {
                    local_14 = json_array_get(param_2, local_c);
                    if (local_14 == 0) {
                        FUN_0004250c(param_1, "<validation>", 0x11,
                                     "Array index %lu out of range", local_c);
                        return 0xffffffff;
                    }
                }
                iVar2 = FUN_00043b38(param_1, local_14, param_3);
                if (iVar2 != 0) {
                    return 0xffffffff;
                }
                FUN_000422cc(param_1);
                local_c = local_c + 1;
            }
        }
        if ((local_10 == 0) && ((*(uint *)(param_1 + 0x3c) & 2) != 0)) {
            local_10 = 1;
        }
        if (((param_2 != (int *)0x0) && (local_10 == 1)) &&
            (iVar2 = json_array_size(param_2), local_c != iVar2)) {
            iVar2 = json_array_size(param_2);
            FUN_0004250c(param_1, "<validation>", 7,
                         "%li array item(s) left unpacked", iVar2 - local_c);
            return 0xffffffff;
        }
        uVar3 = 0;
    } else {
        FUN_0004250c(param_1, "<validation>", 10, "Expected array, got %s",
                     (&PTR_s_object_000da358)[*param_2]);
        uVar3 = 0xffffffff;
    }
    return uVar3;
}

undefined4 FUN_00043b38(int param_1, int *param_2, int *param_3)

{
    undefined4 *puVar1;
    undefined8 *puVar2;
    undefined4 uVar3;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;
    undefined8 uVar4;
    undefined4 *local_c;

    switch (*(undefined1 *)(param_1 + 0x24)) {
    case 0x46:
        if (((param_2 == (int *)0x0) ||
             ((param_2 != (int *)0x0 && (*param_2 == 3)))) ||
            ((param_2 != (int *)0x0 && (*param_2 == 4)))) {
            if ((*(uint *)(param_1 + 0x3c) & 1) == 0) {
                puVar1 = (undefined4 *)*param_3;
                *param_3 = (int)(puVar1 + 1);
                puVar2 = (undefined8 *)*puVar1;
                if (param_2 != (int *)0x0) {
                    uVar3 = json_number_value(param_2);
                    *puVar2 = CONCAT44(extraout_s1_00, uVar3);
                }
            }
            uVar3 = 0;
        } else {
            FUN_0004250c(param_1, "<validation>", 10,
                         "Expected real or integer, got %s",
                         (&PTR_s_object_000da358)[*param_2]);
            uVar3 = 0xffffffff;
        }
        break;
    default:
        FUN_0004250c(param_1, "<format>", 9,
                     "Unexpected format character \'%c\'",
                     *(undefined1 *)(param_1 + 0x24));
        uVar3 = 0xffffffff;
        break;
    case 0x49:
        if ((param_2 == (int *)0x0) ||
            ((param_2 != (int *)0x0 && (*param_2 == 3)))) {
            if ((*(uint *)(param_1 + 0x3c) & 1) == 0) {
                puVar1 = (undefined4 *)*param_3;
                *param_3 = (int)(puVar1 + 1);
                puVar2 = (undefined8 *)*puVar1;
                if (param_2 != (int *)0x0) {
                    uVar4 = json_integer_value(param_2);
                    *puVar2 = uVar4;
                }
            }
            uVar3 = 0;
        } else {
            FUN_0004250c(param_1, "<validation>", 10,
                         "Expected integer, got %s",
                         (&PTR_s_object_000da358)[*param_2]);
            uVar3 = 0xffffffff;
        }
        break;
    case 0x4f:
        if ((param_2 != (int *)0x0) && ((*(uint *)(param_1 + 0x3c) & 1) == 0)) {
            FUN_00042130(param_2);
        }
    case 0x6f:
        if ((*(uint *)(param_1 + 0x3c) & 1) == 0) {
            puVar1 = (undefined4 *)*param_3;
            *param_3 = (int)(puVar1 + 1);
            if (param_2 != (int *)0x0) {
                *(int **)*puVar1 = param_2;
            }
        }
        uVar3 = 0;
        break;
    case 0x5b:
        uVar3 = FUN_0004381c(param_1, param_2, param_3);
        break;
    case 0x62:
        if (((param_2 == (int *)0x0) ||
             ((param_2 != (int *)0x0 && (*param_2 == 5)))) ||
            ((param_2 != (int *)0x0 && (*param_2 == 6)))) {
            if ((*(uint *)(param_1 + 0x3c) & 1) == 0) {
                puVar1 = (undefined4 *)*param_3;
                *param_3 = (int)(puVar1 + 1);
                if (param_2 != (int *)0x0) {
                    if ((param_2 == (int *)0x0) || (*param_2 != 5)) {
                        uVar3 = 0;
                    } else {
                        uVar3 = 1;
                    }
                    *(undefined4 *)*puVar1 = uVar3;
                }
            }
            uVar3 = 0;
        } else {
            FUN_0004250c(param_1, "<validation>", 10,
                         "Expected true or false, got %s",
                         (&PTR_s_object_000da358)[*param_2]);
            uVar3 = 0xffffffff;
        }
        break;
    case 0x66:
        if ((param_2 == (int *)0x0) ||
            ((param_2 != (int *)0x0 && (*param_2 == 4)))) {
            if ((*(uint *)(param_1 + 0x3c) & 1) == 0) {
                puVar1 = (undefined4 *)*param_3;
                *param_3 = (int)(puVar1 + 1);
                puVar2 = (undefined8 *)*puVar1;
                if (param_2 != (int *)0x0) {
                    uVar3 = json_real_value(param_2);
                    *puVar2 = CONCAT44(extraout_s1, uVar3);
                }
            }
            uVar3 = 0;
        } else {
            FUN_0004250c(param_1, "<validation>", 10, "Expected real, got %s",
                         (&PTR_s_object_000da358)[*param_2]);
            uVar3 = 0xffffffff;
        }
        break;
    case 0x69:
        if ((param_2 == (int *)0x0) ||
            ((param_2 != (int *)0x0 && (*param_2 == 3)))) {
            if ((*(uint *)(param_1 + 0x3c) & 1) == 0) {
                puVar1 = (undefined4 *)*param_3;
                *param_3 = (int)(puVar1 + 1);
                puVar1 = (undefined4 *)*puVar1;
                if (param_2 != (int *)0x0) {
                    uVar3 = json_integer_value(param_2);
                    *puVar1 = uVar3;
                }
            }
            uVar3 = 0;
        } else {
            FUN_0004250c(param_1, "<validation>", 10,
                         "Expected integer, got %s",
                         (&PTR_s_object_000da358)[*param_2]);
            uVar3 = 0xffffffff;
        }
        break;
    case 0x6e:
        if ((param_2 == (int *)0x0) ||
            ((param_2 != (int *)0x0 && (*param_2 == 7)))) {
            uVar3 = 0;
        } else {
            FUN_0004250c(param_1, "<validation>", 10, "Expected null, got %s",
                         (&PTR_s_object_000da358)[*param_2]);
            uVar3 = 0xffffffff;
        }
        break;
    case 0x73:
        if ((param_2 == (int *)0x0) ||
            ((param_2 != (int *)0x0 && (*param_2 == 2)))) {
            if ((*(uint *)(param_1 + 0x3c) & 1) == 0) {
                local_c = (undefined4 *)0x0;
                puVar1 = (undefined4 *)*param_3;
                *param_3 = (int)(puVar1 + 1);
                puVar1 = (undefined4 *)*puVar1;
                if (puVar1 == (undefined4 *)0x0) {
                    FUN_0004250c(param_1, "<args>", 0xc,
                                 "NULL string argument");
                    return 0xffffffff;
                }
                FUN_000422cc(param_1);
                if (*(char *)(param_1 + 0x24) == '%') {
                    local_c = (undefined4 *)*param_3;
                    *param_3 = (int)(local_c + 1);
                    local_c = (undefined4 *)*local_c;
                    if (local_c == (undefined4 *)0x0) {
                        FUN_0004250c(param_1, "<args>", 0xc,
                                     "NULL string length argument");
                        return 0xffffffff;
                    }
                } else {
                    FUN_000424bc(param_1);
                }
                if (param_2 != (int *)0x0) {
                    uVar3 = json_string_value(param_2);
                    *puVar1 = uVar3;
                    if (local_c != (undefined4 *)0x0) {
                        uVar3 = json_string_length(param_2);
                        *local_c = uVar3;
                    }
                }
            }
            uVar3 = 0;
        } else {
            FUN_0004250c(param_1, "<validation>", 10, "Expected string, got %s",
                         (&PTR_s_object_000da358)[*param_2]);
            uVar3 = 0xffffffff;
        }
        break;
    case 0x7b:
        uVar3 = FUN_000432e8(param_1, param_2, param_3);
    }
    return uVar3;
}

int json_vpack_ex(undefined4 param_1, undefined4 param_2, char *param_3,
                  undefined4 param_4)

{
    undefined4 local_60;
    undefined1 auStack_5c[36];
    char local_38;
    int local_c;

    if ((param_3 == (char *)0x0) || (*param_3 == '\0')) {
        jsonp_error_init(param_1, "<format>");
        jsonp_error_set(param_1, 0xffffffff, 0xffffffff, 0, 4,
                        "NULL or empty format string", param_4);
        local_c = 0;
    } else {
        jsonp_error_init(param_1, 0);
        FUN_000421f8(auStack_5c, param_1, param_2, param_3);
        FUN_000422cc(auStack_5c);
        local_60 = param_4;
        local_c = FUN_00043068(auStack_5c, &local_60);
        if (local_c == 0) {
            local_c = 0;
        } else {
            FUN_000422cc(auStack_5c);
            if (local_38 != '\0') {
                FUN_00042190(local_c);
                FUN_0004250c(auStack_5c, "<format>", 9,
                             "Garbage after format string");
                local_c = 0;
            }
        }
    }
    return local_c;
}

undefined4 json_pack_ex(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    undefined4 uVar1;
    undefined4 uStack_4;

    uStack_4 = param_4;
    uVar1 = json_vpack_ex(param_1, param_2, param_3, &uStack_4);
    return uVar1;
}

undefined4 json_pack(undefined4 param_1, undefined4 param_2, undefined4 param_3,
                     undefined4 param_4)

{
    undefined4 uVar1;
    undefined4 uStack_c;
    undefined4 uStack_8;
    undefined4 uStack_4;

    uStack_c = param_2;
    uStack_8 = param_3;
    uStack_4 = param_4;
    uVar1 = json_vpack_ex(0, 0, param_1, &uStack_c);
    return uVar1;
}

undefined4 json_vunpack_ex(int param_1, undefined4 param_2, undefined4 param_3,
                           char *param_4, undefined4 param_5)

{
    int iVar1;
    undefined4 uVar2;
    undefined4 local_5c;
    undefined1 auStack_58[36];
    char local_34;

    if (param_1 == 0) {
        jsonp_error_init(param_2, "<root>");
        jsonp_error_set(param_2, 0xffffffff, 0xffffffff, 0, 0xc,
                        "NULL root value");
        uVar2 = 0xffffffff;
    } else if ((param_4 == (char *)0x0) || (*param_4 == '\0')) {
        jsonp_error_init(param_2, "<format>");
        jsonp_error_set(param_2, 0xffffffff, 0xffffffff, 0, 4,
                        "NULL or empty format string");
        uVar2 = 0xffffffff;
    } else {
        jsonp_error_init(param_2, 0);
        FUN_000421f8(auStack_58, param_2, param_3, param_4);
        FUN_000422cc(auStack_58);
        local_5c = param_5;
        iVar1 = FUN_00043b38(auStack_58, param_1, &local_5c);
        if (iVar1 == 0) {
            FUN_000422cc(auStack_58);
            if (local_34 == '\0') {
                uVar2 = 0;
            } else {
                FUN_0004250c(auStack_58, "<format>", 9,
                             "Garbage after format string");
                uVar2 = 0xffffffff;
            }
        } else {
            uVar2 = 0xffffffff;
        }
    }
    return uVar2;
}

undefined4 json_unpack_ex(undefined4 param_1, undefined4 param_2,
                          undefined4 param_3, undefined4 param_4)

{
    undefined4 uVar1;

    uVar1 =
        json_vunpack_ex(param_1, param_2, param_3, param_4, &stack0x00000000);
    return uVar1;
}

undefined4 json_unpack(undefined4 param_1, undefined4 param_2,
                       undefined4 param_3, undefined4 param_4)

{
    undefined4 uVar1;
    undefined4 uStack_8;
    undefined4 uStack_4;

    uStack_8 = param_3;
    uStack_4 = param_4;
    uVar1 = json_vunpack_ex(param_1, 0, 0, param_2, &uStack_8);
    return uVar1;
}

undefined4 strbuffer_init(int *param_1)

{
    int iVar1;
    undefined4 uVar2;

    param_1[2] = 0x10;
    param_1[1] = 0;
    iVar1 = jsonp_malloc(param_1[2]);
    *param_1 = iVar1;
    if (*param_1 == 0) {
        uVar2 = 0xffffffff;
    } else {
        *(undefined1 *)*param_1 = 0;
        uVar2 = 0;
    }
    return uVar2;
}

void strbuffer_close(int *param_1)

{
    if (*param_1 != 0) {
        jsonp_free(*param_1);
    }
    param_1[2] = 0;
    param_1[1] = 0;
    *param_1 = 0;
    return;
}

void strbuffer_clear(undefined4 *param_1)

{
    param_1[1] = 0;
    *(undefined1 *)*param_1 = 0;
    return;
}

undefined4 strbuffer_value(undefined4 *param_1)

{
    return *param_1;
}

undefined4 strbuffer_steal_value(undefined4 *param_1)

{
    undefined4 uVar1;

    uVar1 = *param_1;
    *param_1 = 0;
    return uVar1;
}

undefined4 strbuffer_append_byte(undefined4 param_1, undefined1 param_2)

{
    undefined4 uVar1;
    undefined1 local_d;
    undefined4 local_c;

    local_d = param_2;
    local_c = param_1;
    uVar1 = strbuffer_append_bytes(param_1, &local_d, 1);
    return uVar1;
}

undefined4 strbuffer_append_bytes(int *param_1, void *param_2, uint param_3)

{
    void *__dest;
    uint uVar1;

    if ((uint)(param_1[2] - param_1[1]) <= param_3) {
        if (((param_1[2] < 0) || (param_3 == 0xffffffff)) ||
            (-param_3 - 2 < (uint)param_1[1])) {
            return 0xffffffff;
        }
        uVar1 = param_1[1] + param_3 + 1;
        if (uVar1 < (uint)(param_1[2] << 1)) {
            uVar1 = param_1[2] << 1;
        }
        __dest = (void *)jsonp_malloc(uVar1);
        if (__dest == (void *)0x0) {
            return 0xffffffff;
        }
        memcpy(__dest, (void *)*param_1, param_1[1]);
        jsonp_free(*param_1);
        *param_1 = (int)__dest;
        param_1[2] = uVar1;
    }
    memcpy((void *)(*param_1 + param_1[1]), param_2, param_3);
    param_1[1] = param_1[1] + param_3;
    *(undefined1 *)(*param_1 + param_1[1]) = 0;
    return 0;
}

undefined1 strbuffer_pop(int *param_1)

{
    undefined1 uVar1;

    if (param_1[1] == 0) {
        uVar1 = 0;
    } else {
        param_1[1] = param_1[1] + -1;
        uVar1 = *(undefined1 *)(*param_1 + param_1[1]);
        *(undefined1 *)(*param_1 + param_1[1]) = 0;
    }
    return uVar1;
}

void FUN_00044ab0(undefined4 *param_1)

{
    lconv *plVar1;
    char *pcVar2;
    char *pcVar3;

    plVar1 = localeconv();
    pcVar3 = plVar1->decimal_point;
    if (*pcVar3 != '.') {
        pcVar2 = strchr((char *)*param_1, 0x2e);
        if (pcVar2 != (char *)0x0) {
            *pcVar2 = *pcVar3;
        }
    }
    return;
}

void FUN_00044b24(char *param_1)

{
    lconv *plVar1;
    char *pcVar2;

    plVar1 = localeconv();
    if (*plVar1->decimal_point != 0x2e) {
        pcVar2 = strchr(param_1, (uint)(byte)*plVar1->decimal_point);
        if (pcVar2 != (char *)0x0) {
            *pcVar2 = '.';
        }
    }
    return;
}

undefined4 jsonp_strtod(undefined4 *param_1, undefined4 *param_2)

{
    int *piVar1;
    undefined4 uVar2;
    char *pcStack_14;
    undefined8 local_10;

    FUN_00044ab0(param_1);
    piVar1 = __errno_location();
    *piVar1 = 0;
    local_10 = strtod((char *)*param_1, &pcStack_14);
    if (((local_10 <= 1.79769313486232e+308) &&
         (-1.79769313486232e+308 <= local_10)) ||
        (piVar1 = __errno_location(), *piVar1 != 0x22)) {
        *param_2 = (undefined4)local_10;
        param_2[1] = local_10._4_4_;
        uVar2 = 0;
    } else {
        uVar2 = 0xffffffff;
    }
    return uVar2;
}

uint jsonp_dtostr(char *param_1, uint param_2, int param_3)

{
    char *pcVar1;
    int local_2c;
    uint local_14;
    char *local_10;
    char *local_c;

    local_2c = param_3;
    if (param_3 == 0) {
        local_2c = 0x11;
    }
    local_14 = snprintf(param_1, param_2, "%.*g", local_2c);
    if ((int)local_14 < 0) {
        local_14 = 0xffffffff;
    } else if (local_14 < param_2) {
        FUN_00044b24(param_1);
        pcVar1 = strchr(param_1, 0x2e);
        if ((pcVar1 == (char *)0x0) &&
            (pcVar1 = strchr(param_1, 0x65), pcVar1 == (char *)0x0)) {
            if (param_2 <= local_14 + 3) {
                return 0xffffffff;
            }
            param_1[local_14] = '.';
            param_1[local_14 + 1] = '0';
            param_1[local_14 + 2] = '\0';
            local_14 = local_14 + 2;
        }
        pcVar1 = strchr(param_1, 0x65);
        if (pcVar1 != (char *)0x0) {
            local_c = pcVar1 + 1;
            local_10 = pcVar1 + 2;
            if (*local_c == '-') {
                local_c = pcVar1 + 2;
            }
            for (; *local_10 == '0'; local_10 = local_10 + 1) {
            }
            if (local_10 != local_c) {
                memmove(local_c, local_10,
                        local_14 - ((int)local_10 - (int)param_1));
                local_14 = local_14 - ((int)local_10 - (int)local_c);
            }
        }
    } else {
        local_14 = 0xffffffff;
    }
    return local_14;
}

undefined4 utf8_encode(int param_1, byte *param_2, undefined4 *param_3)

{
    byte bVar1;
    byte bVar2;
    byte bVar3;
    undefined4 uVar4;

    if (param_1 < 0) {
        uVar4 = 0xffffffff;
    } else {
        bVar1 = (byte)param_1;
        if (param_1 < 0x80) {
            *param_2 = bVar1;
            *param_3 = 1;
        } else {
            bVar2 = (byte)(param_1 >> 6);
            if (param_1 < 0x800) {
                *param_2 = (bVar2 & 0x1f) - 0x40;
                param_2[1] = (bVar1 & 0x3f) + 0x80;
                *param_3 = 2;
            } else {
                bVar3 = (byte)(param_1 >> 0xc);
                if (param_1 < 0x10000) {
                    *param_2 = (bVar3 & 0xf) - 0x20;
                    param_2[1] = (bVar2 & 0x3f) + 0x80;
                    param_2[2] = (bVar1 & 0x3f) + 0x80;
                    *param_3 = 3;
                } else {
                    if (0x10ffff < param_1) {
                        return 0xffffffff;
                    }
                    *param_2 = ((byte)(param_1 >> 0x12) & 7) - 0x10;
                    param_2[1] = (bVar3 & 0x3f) + 0x80;
                    param_2[2] = (bVar2 & 0x3f) + 0x80;
                    param_2[3] = (bVar1 & 0x3f) + 0x80;
                    *param_3 = 4;
                }
            }
        }
        uVar4 = 0;
    }
    return uVar4;
}

undefined4 utf8_check_first(byte param_1)

{
    undefined4 uVar1;

    if ((char)param_1 < '\0') {
        if (((char)param_1 < '\0') && (param_1 < 0xc0)) {
            uVar1 = 0;
        } else if ((param_1 == 0xc0) || (param_1 == 0xc1)) {
            uVar1 = 0;
        } else if ((param_1 < 0xc2) || (0xdf < param_1)) {
            if ((param_1 < 0xe0) || (0xef < param_1)) {
                if ((param_1 < 0xf0) || (0xf4 < param_1)) {
                    uVar1 = 0;
                } else {
                    uVar1 = 4;
                }
            } else {
                uVar1 = 3;
            }
        } else {
            uVar1 = 2;
        }
    } else {
        uVar1 = 1;
    }
    return uVar1;
}

undefined4 utf8_check_full(byte *param_1, uint param_2, uint *param_3)

{
    byte bVar1;
    undefined4 uVar2;
    uint local_10;
    uint local_c;

    bVar1 = *param_1;
    if (param_2 == 2) {
        local_10 = bVar1 & 0x1f;
    } else if (param_2 == 3) {
        local_10 = bVar1 & 0xf;
    } else {
        if (param_2 != 4) {
            return 0;
        }
        local_10 = bVar1 & 7;
    }
    local_c = 1;
    while (true) {
        if (param_2 <= local_c) {
            if ((int)local_10 < 0x110000) {
                if (((int)local_10 < 0xd800) || (0xdfff < (int)local_10)) {
                    if ((((param_2 == 2) && ((int)local_10 < 0x80)) ||
                         ((param_2 == 3 && ((int)local_10 < 0x800)))) ||
                        ((param_2 == 4 && ((int)local_10 < 0x10000)))) {
                        uVar2 = 0;
                    } else {
                        if (param_3 != (uint *)0x0) {
                            *param_3 = local_10;
                        }
                        uVar2 = 1;
                    }
                } else {
                    uVar2 = 0;
                }
            } else {
                uVar2 = 0;
            }
            return uVar2;
        }
        bVar1 = param_1[local_c];
        if ((-1 < (char)bVar1) || (0xbf < bVar1))
            break;
        local_10 = local_10 * 0x40 + (bVar1 & 0x3f);
        local_c = local_c + 1;
    }
    return 0;
}

byte *utf8_iterate(byte *param_1, uint param_2, uint *param_3)

{
    int iVar1;
    uint local_10;
    uint local_c;

    if (param_2 != 0) {
        local_c = utf8_check_first(*param_1);
        if (local_c == 0) {
            param_1 = (byte *)0x0;
        } else {
            if (local_c == 1) {
                local_10 = (uint)*param_1;
            } else if ((param_2 < local_c) ||
                       (iVar1 = utf8_check_full(param_1, local_c, &local_10),
                        iVar1 == 0)) {
                return (byte *)0x0;
            }
            if (param_3 != (uint *)0x0) {
                *param_3 = local_10;
            }
            param_1 = param_1 + local_c;
        }
    }
    return param_1;
}

undefined4 utf8_check_string(int param_1, uint param_2)

{
    uint uVar1;
    int iVar2;
    uint local_c;

    local_c = 0;
    do {
        if (param_2 <= local_c) {
            return 1;
        }
        uVar1 = utf8_check_first(*(undefined1 *)(param_1 + local_c));
        if (uVar1 == 0) {
            return 0;
        }
        if (1 < uVar1) {
            if (param_2 - local_c < uVar1) {
                return 0;
            }
            iVar2 = utf8_check_full(param_1 + local_c, uVar1, 0);
            if (iVar2 == 0) {
                return 0;
            }
            local_c = (uVar1 + local_c) - 1;
        }
        local_c = local_c + 1;
    } while (true);
}

int FUN_000454c0(int param_1)

{
    bool bVar1;
    int *piVar2;

    if ((param_1 != 0) && (*(int *)(param_1 + 4) != -1)) {
        piVar2 = (int *)(param_1 + 4);
        do {
            bVar1 = (bool)hasExclusiveAccess(piVar2);
        } while (!bVar1);
        *piVar2 = *piVar2 + 1;
        DataMemoryBarrier(0xb);
    }
    return param_1;
}

void FUN_00045520(int param_1)

{
    bool bVar1;
    int iVar2;
    int *piVar3;

    if ((param_1 != 0) && (*(int *)(param_1 + 4) != -1)) {
        piVar3 = (int *)(param_1 + 4);
        DataMemoryBarrier(0xb);
        do {
            iVar2 = *piVar3;
            bVar1 = (bool)hasExclusiveAccess(piVar3);
        } while (!bVar1);
        *piVar3 = iVar2 + -1;
        if (iVar2 + -1 == 0) {
            json_delete(param_1);
        }
    }
    return;
}

undefined4 FUN_00045588(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3)

{
    undefined4 uVar1;

    uVar1 = FUN_000454c0(param_3);
    uVar1 = json_object_set_new_nocheck(param_1, param_2, uVar1);
    return uVar1;
}

undefined4 FUN_000455cc(undefined4 param_1, undefined4 param_2)

{
    undefined4 uVar1;

    uVar1 = FUN_000454c0(param_2);
    uVar1 = json_array_append_new(param_1, uVar1);
    return uVar1;
}

void FUN_00045608(undefined4 *param_1, undefined4 param_2)

{
    *param_1 = param_2;
    param_1[1] = 1;
    return;
}

int json_object(void)

{
    int iVar1;
    int iVar2;

    iVar1 = jsonp_malloc(0x24);
    if (iVar1 == 0) {
        iVar1 = 0;
    } else {
        if (hashtable_seed == 0) {
            json_object_seed(0);
        }
        FUN_00045608(iVar1, 0);
        iVar2 = hashtable_init(iVar1 + 8);
        if (iVar2 != 0) {
            jsonp_free(iVar1);
            iVar1 = 0;
        }
    }
    return iVar1;
}

void FUN_000456d8(int param_1)

{
    hashtable_close(param_1 + 8);
    jsonp_free(param_1);
    return;
}

int json_object_size(int *param_1)

{
    int iVar1;

    if ((param_1 == (int *)0x0) || (*param_1 != 0)) {
        iVar1 = 0;
    } else {
        iVar1 = param_1[2];
    }
    return iVar1;
}

undefined4 json_object_get(int *param_1, int param_2)

{
    undefined4 uVar1;

    if (((param_2 == 0) || (param_1 == (int *)0x0)) || (*param_1 != 0)) {
        uVar1 = 0;
    } else {
        uVar1 = hashtable_get(param_1 + 2, param_2);
    }
    return uVar1;
}

undefined4 json_object_set_new_nocheck(int *param_1, int param_2, int *param_3)

{
    int iVar1;

    if (param_3 != (int *)0x0) {
        if ((((param_2 != 0) && (param_1 != (int *)0x0)) && (*param_1 == 0)) &&
            (param_1 != param_3)) {
            iVar1 = hashtable_set(param_1 + 2, param_2, param_3);
            if (iVar1 == 0) {
                return 0;
            }
            FUN_00045520(param_3);
            return 0xffffffff;
        }
        FUN_00045520(param_3);
    }
    return 0xffffffff;
}

undefined4 json_object_set_new(undefined4 param_1, char *param_2,
                               undefined4 param_3)

{
    size_t sVar1;
    int iVar2;
    undefined4 uVar3;

    if (param_2 != (char *)0x0) {
        sVar1 = strlen(param_2);
        iVar2 = utf8_check_string(param_2, sVar1);
        if (iVar2 != 0) {
            uVar3 = json_object_set_new_nocheck(param_1, param_2, param_3);
            return uVar3;
        }
    }
    FUN_00045520(param_3);
    return 0xffffffff;
}

undefined4 json_object_del(int *param_1, int param_2)

{
    undefined4 uVar1;

    if (((param_2 == 0) || (param_1 == (int *)0x0)) || (*param_1 != 0)) {
        uVar1 = 0xffffffff;
    } else {
        uVar1 = hashtable_del(param_1 + 2, param_2);
    }
    return uVar1;
}

undefined4 json_object_clear(int *param_1)

{
    undefined4 uVar1;

    if ((param_1 == (int *)0x0) || (*param_1 != 0)) {
        uVar1 = 0xffffffff;
    } else {
        hashtable_clear(param_1 + 2);
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 json_object_update(int *param_1, int *param_2)

{
    int iVar1;
    undefined4 uVar2;
    int local_c;

    if ((((param_1 == (int *)0x0) || (*param_1 != 0)) ||
         (param_2 == (int *)0x0)) ||
        (*param_2 != 0)) {
        uVar2 = 0xffffffff;
    } else {
        uVar2 = json_object_iter(param_2);
        local_c = json_object_iter_key(uVar2);
        while (local_c != 0) {
            uVar2 = json_object_key_to_iter(local_c);
            iVar1 = json_object_iter_value(uVar2);
            if (iVar1 == 0)
                break;
            iVar1 = FUN_00045588(param_1, local_c, iVar1);
            if (iVar1 != 0) {
                return 0xffffffff;
            }
            uVar2 = json_object_key_to_iter(local_c);
            uVar2 = json_object_iter_next(param_2, uVar2);
            local_c = json_object_iter_key(uVar2);
        }
        uVar2 = 0;
    }
    return uVar2;
}

undefined4 json_object_update_existing(int *param_1, int *param_2)

{
    int iVar1;
    int iVar2;
    undefined4 uVar3;
    undefined4 local_c;

    if ((((param_1 == (int *)0x0) || (*param_1 != 0)) ||
         (param_2 == (int *)0x0)) ||
        (*param_2 != 0)) {
        uVar3 = 0xffffffff;
    } else {
        uVar3 = json_object_iter(param_2);
        local_c = json_object_iter_key(uVar3);
        while (local_c != 0) {
            uVar3 = json_object_key_to_iter(local_c);
            iVar2 = json_object_iter_value(uVar3);
            if (iVar2 == 0)
                break;
            iVar1 = json_object_get(param_1, local_c);
            if (iVar1 != 0) {
                FUN_00045588(param_1, local_c, iVar2);
            }
            uVar3 = json_object_key_to_iter(local_c);
            uVar3 = json_object_iter_next(param_2, uVar3);
            local_c = json_object_iter_key(uVar3);
        }
        uVar3 = 0;
    }
    return uVar3;
}

undefined4 json_object_update_missing(int *param_1, int *param_2)

{
    int iVar1;
    int iVar2;
    undefined4 uVar3;
    undefined4 local_c;

    if ((((param_1 == (int *)0x0) || (*param_1 != 0)) ||
         (param_2 == (int *)0x0)) ||
        (*param_2 != 0)) {
        uVar3 = 0xffffffff;
    } else {
        uVar3 = json_object_iter(param_2);
        local_c = json_object_iter_key(uVar3);
        while (local_c != 0) {
            uVar3 = json_object_key_to_iter(local_c);
            iVar2 = json_object_iter_value(uVar3);
            if (iVar2 == 0)
                break;
            iVar1 = json_object_get(param_1, local_c);
            if (iVar1 == 0) {
                FUN_00045588(param_1, local_c, iVar2);
            }
            uVar3 = json_object_key_to_iter(local_c);
            uVar3 = json_object_iter_next(param_2, uVar3);
            local_c = json_object_iter_key(uVar3);
        }
        uVar3 = 0;
    }
    return uVar3;
}

undefined4 json_object_iter(int *param_1)

{
    undefined4 uVar1;

    if ((param_1 == (int *)0x0) || (*param_1 != 0)) {
        uVar1 = 0;
    } else {
        uVar1 = hashtable_iter(param_1 + 2);
    }
    return uVar1;
}

undefined4 json_object_iter_at(int *param_1, int param_2)

{
    undefined4 uVar1;

    if (((param_2 == 0) || (param_1 == (int *)0x0)) || (*param_1 != 0)) {
        uVar1 = 0;
    } else {
        uVar1 = hashtable_iter_at(param_1 + 2, param_2);
    }
    return uVar1;
}

undefined4 json_object_iter_next(int *param_1, int param_2)

{
    undefined4 uVar1;

    if (((param_1 == (int *)0x0) || (*param_1 != 0)) || (param_2 == 0)) {
        uVar1 = 0;
    } else {
        uVar1 = hashtable_iter_next(param_1 + 2, param_2);
    }
    return uVar1;
}

undefined4 json_object_iter_key(int param_1)

{
    undefined4 uVar1;

    if (param_1 == 0) {
        uVar1 = 0;
    } else {
        uVar1 = hashtable_iter_key(param_1);
    }
    return uVar1;
}

undefined4 json_object_iter_value(int param_1)

{
    undefined4 uVar1;

    if (param_1 == 0) {
        uVar1 = 0;
    } else {
        uVar1 = hashtable_iter_value(param_1);
    }
    return uVar1;
}

undefined4 json_object_iter_set_new(int *param_1, int param_2, int param_3)

{
    undefined4 uVar1;

    if ((((param_1 == (int *)0x0) || (*param_1 != 0)) || (param_2 == 0)) ||
        (param_3 == 0)) {
        FUN_00045520(param_3);
        uVar1 = 0xffffffff;
    } else {
        hashtable_iter_set(param_2, param_3);
        uVar1 = 0;
    }
    return uVar1;
}

int json_object_key_to_iter(int param_1)

{
    if (param_1 == 0) {
        param_1 = 0;
    } else {
        param_1 = param_1 + -0x10;
    }
    return param_1;
}

undefined4 FUN_00045f3c(undefined4 param_1, undefined4 param_2)

{
    int iVar1;
    int iVar2;
    undefined4 uVar3;
    int local_14;

    iVar1 = json_object_size(param_1);
    iVar2 = json_object_size(param_2);
    if (iVar1 == iVar2) {
        uVar3 = json_object_iter(param_1);
        local_14 = json_object_iter_key(uVar3);
        while (local_14 != 0) {
            uVar3 = json_object_key_to_iter(local_14);
            iVar1 = json_object_iter_value(uVar3);
            if (iVar1 == 0)
                break;
            uVar3 = json_object_get(param_2, local_14);
            iVar1 = json_equal(iVar1, uVar3);
            if (iVar1 == 0) {
                return 0;
            }
            uVar3 = json_object_key_to_iter(local_14);
            uVar3 = json_object_iter_next(param_1, uVar3);
            local_14 = json_object_iter_key(uVar3);
        }
        uVar3 = 1;
    } else {
        uVar3 = 0;
    }
    return uVar3;
}

int FUN_0004602c(undefined4 param_1)

{
    int iVar1;
    undefined4 uVar2;
    int iVar3;
    int local_c;

    iVar1 = json_object();
    if (iVar1 == 0) {
        iVar1 = 0;
    } else {
        uVar2 = json_object_iter(param_1);
        local_c = json_object_iter_key(uVar2);
        while (local_c != 0) {
            uVar2 = json_object_key_to_iter(local_c);
            iVar3 = json_object_iter_value(uVar2);
            if (iVar3 == 0) {
                return iVar1;
            }
            FUN_00045588(iVar1, local_c, iVar3);
            uVar2 = json_object_key_to_iter(local_c);
            uVar2 = json_object_iter_next(param_1, uVar2);
            local_c = json_object_iter_key(uVar2);
        }
    }
    return iVar1;
}

int FUN_000460ec(undefined4 param_1)

{
    int iVar1;
    undefined4 uVar2;
    undefined4 uVar3;
    undefined4 local_c;

    iVar1 = json_object();
    if (iVar1 == 0) {
        iVar1 = 0;
    } else {
        for (local_c = json_object_iter(param_1); local_c != 0;
             local_c = json_object_iter_next(param_1, local_c)) {
            uVar2 = json_object_iter_key(local_c);
            uVar3 = json_object_iter_value(local_c);
            uVar3 = json_deep_copy(uVar3);
            json_object_set_new_nocheck(iVar1, uVar2, uVar3);
        }
    }
    return iVar1;
}

int json_array(void)

{
    int iVar1;
    undefined4 uVar2;

    iVar1 = jsonp_malloc(0x14);
    if (iVar1 == 0) {
        iVar1 = 0;
    } else {
        FUN_00045608(iVar1, 1);
        *(undefined4 *)(iVar1 + 0xc) = 0;
        *(undefined4 *)(iVar1 + 8) = 8;
        uVar2 = jsonp_malloc(*(int *)(iVar1 + 8) << 2);
        *(undefined4 *)(iVar1 + 0x10) = uVar2;
        if (*(int *)(iVar1 + 0x10) == 0) {
            jsonp_free(iVar1);
            iVar1 = 0;
        }
    }
    return iVar1;
}

void FUN_0004622c(int param_1)

{
    undefined4 local_c;

    for (local_c = 0; local_c < *(uint *)(param_1 + 0xc);
         local_c = local_c + 1) {
        FUN_00045520(*(undefined4 *)(*(int *)(param_1 + 0x10) + local_c * 4));
    }
    jsonp_free(*(undefined4 *)(param_1 + 0x10));
    jsonp_free(param_1);
    return;
}

int json_array_size(int *param_1)

{
    int iVar1;

    if ((param_1 == (int *)0x0) || (*param_1 != 1)) {
        iVar1 = 0;
    } else {
        iVar1 = param_1[3];
    }
    return iVar1;
}

undefined4 json_array_get(int *param_1, uint param_2)

{
    undefined4 uVar1;

    if ((param_1 == (int *)0x0) || (*param_1 != 1)) {
        uVar1 = 0;
    } else if (param_2 < (uint)param_1[3]) {
        uVar1 = *(undefined4 *)(param_1[4] + param_2 * 4);
    } else {
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 json_array_set_new(int *param_1, uint param_2, int *param_3)

{
    if (param_3 != (int *)0x0) {
        if (((param_1 != (int *)0x0) && (*param_1 == 1)) &&
            (param_1 != param_3)) {
            if (param_2 < (uint)param_1[3]) {
                FUN_00045520(*(undefined4 *)(param_1[4] + param_2 * 4));
                *(int **)(param_1[4] + param_2 * 4) = param_3;
                return 0;
            }
            FUN_00045520(param_3);
            return 0xffffffff;
        }
        FUN_00045520(param_3);
    }
    return 0xffffffff;
}

void FUN_0004645c(int param_1, int param_2, int param_3, int param_4)

{
    memmove((void *)(*(int *)(param_1 + 0x10) + param_2 * 4),
            (void *)(*(int *)(param_1 + 0x10) + param_3 * 4), param_4 << 2);
    return;
}

void FUN_000464bc(int param_1, int param_2, int param_3, int param_4,
                  int param_5)

{
    memcpy((void *)(param_1 + param_2 * 4), (void *)(param_3 + param_4 * 4),
           param_5 << 2);
    return;
}

undefined4 FUN_00046514(int param_1, int param_2, int param_3)

{
    uint uVar1;
    int iVar2;
    undefined4 uVar3;
    uint uVar4;

    if (*(uint *)(param_1 + 8) < (uint)(*(int *)(param_1 + 0xc) + param_2)) {
        uVar3 = *(undefined4 *)(param_1 + 0x10);
        uVar1 = *(int *)(param_1 + 8) << 1;
        uVar4 = *(int *)(param_1 + 8) + param_2;
        if (uVar1 < uVar4) {
            uVar1 = uVar4;
        }
        iVar2 = jsonp_malloc(uVar1 << 2);
        if (iVar2 == 0) {
            uVar3 = 0;
        } else {
            *(uint *)(param_1 + 8) = uVar1;
            *(int *)(param_1 + 0x10) = iVar2;
            if (param_3 != 0) {
                FUN_000464bc(*(undefined4 *)(param_1 + 0x10), 0, uVar3, 0,
                             *(undefined4 *)(param_1 + 0xc));
                jsonp_free(uVar3);
                uVar3 = *(undefined4 *)(param_1 + 0x10);
            }
        }
    } else {
        uVar3 = *(undefined4 *)(param_1 + 0x10);
    }
    return uVar3;
}

undefined4 json_array_append_new(int *param_1, int *param_2)

{
    int iVar1;

    if (param_2 != (int *)0x0) {
        if (((param_1 != (int *)0x0) && (*param_1 == 1)) &&
            (param_1 != param_2)) {
            iVar1 = FUN_00046514(param_1, 1, 1);
            if (iVar1 != 0) {
                *(int **)(param_1[4] + param_1[3] * 4) = param_2;
                param_1[3] = param_1[3] + 1;
                return 0;
            }
            FUN_00045520(param_2);
            return 0xffffffff;
        }
        FUN_00045520(param_2);
    }
    return 0xffffffff;
}

undefined4 json_array_insert_new(int *param_1, uint param_2, int *param_3)

{
    int iVar1;

    if (param_3 != (int *)0x0) {
        if (((param_1 != (int *)0x0) && (*param_1 == 1)) &&
            (param_1 != param_3)) {
            if ((uint)param_1[3] < param_2) {
                FUN_00045520(param_3);
                return 0xffffffff;
            }
            iVar1 = FUN_00046514(param_1, 1, 0);
            if (iVar1 != 0) {
                if (iVar1 == param_1[4]) {
                    FUN_0004645c(param_1, param_2 + 1, param_2,
                                 param_1[3] - param_2);
                } else {
                    FUN_000464bc(param_1[4], 0, iVar1, 0, param_2);
                    FUN_000464bc(param_1[4], param_2 + 1, iVar1, param_2,
                                 param_1[3] - param_2);
                    jsonp_free(iVar1);
                }
                *(int **)(param_1[4] + param_2 * 4) = param_3;
                param_1[3] = param_1[3] + 1;
                return 0;
            }
            FUN_00045520(param_3);
            return 0xffffffff;
        }
        FUN_00045520(param_3);
    }
    return 0xffffffff;
}

undefined4 json_array_remove(int *param_1, uint param_2)

{
    undefined4 uVar1;

    if ((param_1 == (int *)0x0) || (*param_1 != 1)) {
        uVar1 = 0xffffffff;
    } else if (param_2 < (uint)param_1[3]) {
        FUN_00045520(*(undefined4 *)(param_1[4] + param_2 * 4));
        if (param_2 < param_1[3] - 1U) {
            FUN_0004645c(param_1, param_2, param_2 + 1,
                         (param_1[3] - param_2) + -1);
        }
        param_1[3] = param_1[3] + -1;
        uVar1 = 0;
    } else {
        uVar1 = 0xffffffff;
    }
    return uVar1;
}

undefined4 json_array_clear(int *param_1)

{
    undefined4 uVar1;
    uint local_c;

    if ((param_1 == (int *)0x0) || (*param_1 != 1)) {
        uVar1 = 0xffffffff;
    } else {
        for (local_c = 0; local_c < (uint)param_1[3]; local_c = local_c + 1) {
            FUN_00045520(*(undefined4 *)(param_1[4] + local_c * 4));
        }
        param_1[3] = 0;
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 json_array_extend(int *param_1, int *param_2)

{
    int iVar1;
    undefined4 uVar2;
    uint local_c;

    if ((((param_1 == (int *)0x0) || (*param_1 != 1)) ||
         (param_2 == (int *)0x0)) ||
        (*param_2 != 1)) {
        uVar2 = 0xffffffff;
    } else {
        iVar1 = FUN_00046514(param_1, param_2[3], 1);
        if (iVar1 == 0) {
            uVar2 = 0xffffffff;
        } else {
            for (local_c = 0; local_c < (uint)param_2[3];
                 local_c = local_c + 1) {
                FUN_000454c0(*(undefined4 *)(param_2[4] + local_c * 4));
            }
            FUN_000464bc(param_1[4], param_1[3], param_2[4], 0, param_2[3]);
            param_1[3] = param_1[3] + param_2[3];
            uVar2 = 0;
        }
    }
    return uVar2;
}

undefined4 FUN_00046b54(undefined4 param_1, undefined4 param_2)

{
    uint uVar1;
    uint uVar2;
    undefined4 uVar3;
    int iVar4;
    undefined4 uVar5;
    uint local_c;

    uVar1 = json_array_size(param_1);
    uVar2 = json_array_size(param_2);
    if (uVar1 == uVar2) {
        for (local_c = 0; local_c < uVar1; local_c = local_c + 1) {
            uVar5 = json_array_get(param_1, local_c);
            uVar3 = json_array_get(param_2, local_c);
            iVar4 = json_equal(uVar5, uVar3);
            if (iVar4 == 0) {
                return 0;
            }
        }
        uVar5 = 1;
    } else {
        uVar5 = 0;
    }
    return uVar5;
}

int FUN_00046c0c(undefined4 param_1)

{
    int iVar1;
    undefined4 uVar2;
    uint uVar3;
    uint local_c;

    iVar1 = json_array();
    if (iVar1 == 0) {
        iVar1 = 0;
    } else {
        for (local_c = 0; uVar3 = json_array_size(param_1), local_c < uVar3;
             local_c = local_c + 1) {
            uVar2 = json_array_get(param_1, local_c);
            FUN_000455cc(iVar1, uVar2);
        }
    }
    return iVar1;
}

int FUN_00046c94(undefined4 param_1)

{
    int iVar1;
    undefined4 uVar2;
    uint uVar3;
    uint local_c;

    iVar1 = json_array();
    if (iVar1 == 0) {
        iVar1 = 0;
    } else {
        for (local_c = 0; uVar3 = json_array_size(param_1), local_c < uVar3;
             local_c = local_c + 1) {
            uVar2 = json_array_get(param_1, local_c);
            uVar2 = json_deep_copy(uVar2);
            json_array_append_new(iVar1, uVar2);
        }
    }
    return iVar1;
}

int FUN_00046d28(int param_1, undefined4 param_2, int param_3)

{
    int iVar1;
    int local_c;

    if (param_1 == 0) {
        iVar1 = 0;
    } else {
        local_c = param_1;
        if ((param_3 == 0) &&
            (local_c = jsonp_strndup(param_1, param_2), local_c == 0)) {
            iVar1 = 0;
        } else {
            iVar1 = jsonp_malloc(0x10);
            if (iVar1 == 0) {
                jsonp_free(local_c);
                iVar1 = 0;
            } else {
                FUN_00045608(iVar1, 2);
                *(int *)(iVar1 + 8) = local_c;
                *(undefined4 *)(iVar1 + 0xc) = param_2;
            }
        }
    }
    return iVar1;
}

undefined4 json_string_nocheck(char *param_1)

{
    size_t sVar1;
    undefined4 uVar2;

    if (param_1 == (char *)0x0) {
        uVar2 = 0;
    } else {
        sVar1 = strlen(param_1);
        uVar2 = FUN_00046d28(param_1, sVar1, 0);
    }
    return uVar2;
}

undefined4 json_stringn_nocheck(undefined4 param_1, undefined4 param_2)

{
    undefined4 uVar1;

    uVar1 = FUN_00046d28(param_1, param_2, 0);
    return uVar1;
}

undefined4 jsonp_stringn_nocheck_own(undefined4 param_1, undefined4 param_2)

{
    undefined4 uVar1;

    uVar1 = FUN_00046d28(param_1, param_2, 1);
    return uVar1;
}

undefined4 json_string(char *param_1)

{
    size_t sVar1;
    undefined4 uVar2;

    if (param_1 == (char *)0x0) {
        uVar2 = 0;
    } else {
        sVar1 = strlen(param_1);
        uVar2 = json_stringn(param_1, sVar1);
    }
    return uVar2;
}

undefined4 json_stringn(int param_1, undefined4 param_2)

{
    int iVar1;
    undefined4 uVar2;

    if ((param_1 == 0) ||
        (iVar1 = utf8_check_string(param_1, param_2), iVar1 == 0)) {
        uVar2 = 0;
    } else {
        uVar2 = json_stringn_nocheck(param_1, param_2);
    }
    return uVar2;
}

int json_string_value(int *param_1)

{
    int iVar1;

    if ((param_1 == (int *)0x0) || (*param_1 != 2)) {
        iVar1 = 0;
    } else {
        iVar1 = param_1[2];
    }
    return iVar1;
}

int json_string_length(int *param_1)

{
    int iVar1;

    if ((param_1 == (int *)0x0) || (*param_1 != 2)) {
        iVar1 = 0;
    } else {
        iVar1 = param_1[3];
    }
    return iVar1;
}

undefined4 json_string_set_nocheck(undefined4 param_1, char *param_2)

{
    size_t sVar1;
    undefined4 uVar2;

    if (param_2 == (char *)0x0) {
        uVar2 = 0xffffffff;
    } else {
        sVar1 = strlen(param_2);
        uVar2 = json_string_setn_nocheck(param_1, param_2, sVar1);
    }
    return uVar2;
}

undefined4 json_string_setn_nocheck(int *param_1, int param_2, int param_3)

{
    int iVar1;
    undefined4 uVar2;

    if (((param_1 == (int *)0x0) || (*param_1 != 2)) || (param_2 == 0)) {
        uVar2 = 0xffffffff;
    } else {
        iVar1 = jsonp_strndup(param_2, param_3);
        if (iVar1 == 0) {
            uVar2 = 0xffffffff;
        } else {
            jsonp_free(param_1[2]);
            param_1[2] = iVar1;
            param_1[3] = param_3;
            uVar2 = 0;
        }
    }
    return uVar2;
}

undefined4 json_string_set(undefined4 param_1, char *param_2)

{
    size_t sVar1;
    undefined4 uVar2;

    if (param_2 == (char *)0x0) {
        uVar2 = 0xffffffff;
    } else {
        sVar1 = strlen(param_2);
        uVar2 = json_string_setn(param_1, param_2, sVar1);
    }
    return uVar2;
}

undefined4 json_string_setn(undefined4 param_1, int param_2, undefined4 param_3)

{
    int iVar1;
    undefined4 uVar2;

    if ((param_2 == 0) ||
        (iVar1 = utf8_check_string(param_2, param_3), iVar1 == 0)) {
        uVar2 = 0xffffffff;
    } else {
        uVar2 = json_string_setn_nocheck(param_1, param_2, param_3);
    }
    return uVar2;
}

void FUN_000471a0(int param_1)

{
    jsonp_free(*(undefined4 *)(param_1 + 8));
    jsonp_free(param_1);
    return;
}

undefined4 FUN_000471d4(int param_1, int param_2)

{
    int iVar1;
    undefined4 uVar2;

    if ((*(int *)(param_1 + 0xc) == *(int *)(param_2 + 0xc)) &&
        (iVar1 = memcmp(*(void **)(param_1 + 8), *(void **)(param_2 + 8),
                        *(size_t *)(param_1 + 0xc)),
         iVar1 == 0)) {
        uVar2 = 1;
    } else {
        uVar2 = 0;
    }
    return uVar2;
}

undefined4 FUN_00047254(int param_1)

{
    undefined4 uVar1;

    uVar1 = json_stringn_nocheck(*(undefined4 *)(param_1 + 8),
                                 *(undefined4 *)(param_1 + 0xc));
    return uVar1;
}

undefined4 json_vsprintf(char *param_1, __gnuc_va_list param_2)

{
    int iVar1;
    char *__s;
    int iVar2;
    undefined4 local_c;

    local_c = 0;
    iVar1 = vsnprintf((char *)0x0, 0, param_1, param_2);
    if (iVar1 == 0) {
        local_c = json_string(&DAT_000da738);
    } else {
        __s = (char *)jsonp_malloc(iVar1 + 1);
        if (__s != (char *)0x0) {
            vsnprintf(__s, iVar1 + 1, param_1, param_2);
            iVar2 = utf8_check_string(__s, iVar1);
            if (iVar2 == 0) {
                jsonp_free(__s);
            } else {
                local_c = jsonp_stringn_nocheck_own(__s, iVar1);
            }
        }
    }
    return local_c;
}

undefined4 json_sprintf(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    undefined4 uVar1;
    undefined4 uStack_c;
    undefined4 uStack_8;
    undefined4 uStack_4;

    uStack_c = param_2;
    uStack_8 = param_3;
    uStack_4 = param_4;
    uVar1 = json_vsprintf(param_1, &uStack_c);
    return uVar1;
}

int json_integer(undefined4 param_1, undefined4 param_2)

{
    int iVar1;

    iVar1 = jsonp_malloc(0x10);
    if (iVar1 == 0) {
        iVar1 = 0;
    } else {
        FUN_00045608(iVar1, 3);
        *(undefined4 *)(iVar1 + 8) = param_1;
        *(undefined4 *)(iVar1 + 0xc) = param_2;
    }
    return iVar1;
}

undefined8 json_integer_value(int *param_1)

{
    undefined8 uVar1;

    if ((param_1 == (int *)0x0) || (*param_1 != 3)) {
        uVar1 = 0;
    } else {
        uVar1 = *(undefined8 *)(param_1 + 2);
    }
    return uVar1;
}

undefined4 json_integer_set(int *param_1, undefined4 param_2, int param_3,
                            int param_4)

{
    undefined4 uVar1;

    if ((param_1 == (int *)0x0) || (*param_1 != 3)) {
        uVar1 = 0xffffffff;
    } else {
        param_1[2] = param_3;
        param_1[3] = param_4;
        uVar1 = 0;
    }
    return uVar1;
}

void FUN_000474cc(undefined4 param_1)

{
    jsonp_free(param_1);
    return;
}

bool FUN_000474f0(undefined4 param_1, undefined4 param_2)

{
    longlong lVar1;
    longlong lVar2;

    lVar1 = json_integer_value(param_1);
    lVar2 = json_integer_value(param_2);
    return lVar1 == lVar2;
}

undefined4 FUN_00047544(undefined4 param_1)

{
    undefined4 uVar1;
    undefined8 uVar2;

    uVar2 = json_integer_value(param_1);
    uVar1 = json_integer((int)uVar2, (int)((ulonglong)uVar2 >> 0x20));
    return uVar1;
}

int json_real(void)

{
    int iVar1;
    double in_d0;
    undefined4 local_18;
    undefined4 uStack_14;

    if ((NAN(in_d0)) || (1.79769313486232e+308 < ABS(in_d0))) {
        iVar1 = 0;
    } else {
        iVar1 = jsonp_malloc(0x10);
        if (iVar1 == 0) {
            iVar1 = 0;
        } else {
            FUN_00045608(iVar1, 4);
            local_18 = SUB84(in_d0, 0);
            uStack_14 = (undefined4)((ulonglong)in_d0 >> 0x20);
            *(undefined4 *)(iVar1 + 8) = local_18;
            *(undefined4 *)(iVar1 + 0xc) = uStack_14;
        }
    }
    return iVar1;
}

int json_real_value(int *param_1)

{
    int iVar1;

    if ((param_1 == (int *)0x0) || (*param_1 != 4)) {
        iVar1 = 0;
    } else {
        iVar1 = param_1[2];
    }
    return iVar1;
}

undefined4 json_real_set(int *param_1)

{
    undefined4 uVar1;
    double in_d0;
    int local_18;
    int iStack_14;

    if ((((param_1 == (int *)0x0) || (*param_1 != 4)) || (NAN(in_d0))) ||
        (1.79769313486232e+308 < ABS(in_d0))) {
        uVar1 = 0xffffffff;
    } else {
        local_18 = SUB84(in_d0, 0);
        iStack_14 = (int)((ulonglong)in_d0 >> 0x20);
        param_1[2] = local_18;
        param_1[3] = iStack_14;
        uVar1 = 0;
    }
    return uVar1;
}

void FUN_00047728(undefined4 param_1)

{
    jsonp_free(param_1);
    return;
}

bool FUN_0004774c(undefined4 param_1, undefined4 param_2)

{
    undefined4 uVar1;
    undefined4 uVar2;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;

    uVar1 = json_real_value(param_1);
    uVar2 = json_real_value(param_2);
    return (double)CONCAT44(extraout_s1, uVar1) ==
           (double)CONCAT44(extraout_s1_00, uVar2);
}

undefined4 FUN_000477a0(undefined4 param_1)

{
    undefined4 uVar1;

    uVar1 = json_real_value(param_1);
    uVar1 = json_real(uVar1);
    return uVar1;
}

undefined4 json_number_value(int *param_1)

{
    undefined4 uVar1;
    undefined8 uVar2;

    if ((param_1 == (int *)0x0) || (*param_1 != 3)) {
        if ((param_1 == (int *)0x0) || (*param_1 != 4)) {
            uVar1 = 0;
        } else {
            uVar1 = json_real_value(param_1);
        }
    } else {
        uVar2 = json_integer_value(param_1);
        uVar1 = FUN_000ccae4((int)uVar2, (int)((ulonglong)uVar2 >> 0x20));
    }
    return uVar1;
}

undefined *json_true(void)

{
    return &DAT_0014dea0;
}

undefined *json_false(void)

{
    return &DAT_0014dea8;
}

undefined *json_null(void)

{
    return &DAT_0014deb0;
}

void json_delete(undefined4 *param_1)

{
    if (param_1 != (undefined4 *)0x0) {
        switch (*param_1) {
        case 0:
            FUN_000456d8(param_1);
            break;
        case 1:
            FUN_0004622c(param_1);
            break;
        case 2:
            FUN_000471a0(param_1);
            break;
        case 3:
            FUN_000474cc(param_1);
            break;
        case 4:
            FUN_00047728(param_1);
        }
    }
    return;
}

undefined4 json_equal(int *param_1, int *param_2)

{
    undefined4 uVar1;

    if ((param_1 == (int *)0x0) || (param_2 == (int *)0x0)) {
        uVar1 = 0;
    } else if (*param_1 == *param_2) {
        if (param_1 == param_2) {
            uVar1 = 1;
        } else {
            switch (*param_1) {
            case 0:
                uVar1 = FUN_00045f3c(param_1, param_2);
                break;
            case 1:
                uVar1 = FUN_00046b54(param_1, param_2);
                break;
            case 2:
                uVar1 = FUN_000471d4(param_1, param_2);
                break;
            case 3:
                uVar1 = FUN_000474f0(param_1, param_2);
                break;
            case 4:
                uVar1 = FUN_0004774c(param_1, param_2);
                break;
            default:
                uVar1 = 0;
            }
        }
    } else {
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 *json_copy(undefined4 *param_1)

{
    if (param_1 == (undefined4 *)0x0) {
        param_1 = (undefined4 *)0x0;
    } else {
        switch (*param_1) {
        case 0:
            param_1 = (undefined4 *)FUN_0004602c(param_1);
            break;
        case 1:
            param_1 = (undefined4 *)FUN_00046c0c(param_1);
            break;
        case 2:
            param_1 = (undefined4 *)FUN_00047254(param_1);
            break;
        case 3:
            param_1 = (undefined4 *)FUN_00047544(param_1);
            break;
        case 4:
            param_1 = (undefined4 *)FUN_000477a0(param_1);
            break;
        case 5:
        case 6:
        case 7:
            break;
        default:
            param_1 = (undefined4 *)0x0;
        }
    }
    return param_1;
}

undefined4 *json_deep_copy(undefined4 *param_1)

{
    if (param_1 == (undefined4 *)0x0) {
        param_1 = (undefined4 *)0x0;
    } else {
        switch (*param_1) {
        case 0:
            param_1 = (undefined4 *)FUN_000460ec(param_1);
            break;
        case 1:
            param_1 = (undefined4 *)FUN_00046c94(param_1);
            break;
        case 2:
            param_1 = (undefined4 *)FUN_00047254(param_1);
            break;
        case 3:
            param_1 = (undefined4 *)FUN_00047544(param_1);
            break;
        case 4:
            param_1 = (undefined4 *)FUN_000477a0(param_1);
            break;
        case 5:
        case 6:
        case 7:
            break;
        default:
            param_1 = (undefined4 *)0x0;
        }
    }
    return param_1;
}

void FUN_00047be8(int param_1)

{
    bool bVar1;
    int iVar2;
    int *piVar3;

    if ((param_1 != 0) && (*(int *)(param_1 + 4) != -1)) {
        piVar3 = (int *)(param_1 + 4);
        DataMemoryBarrier(0xb);
        do {
            iVar2 = *piVar3;
            bVar1 = (bool)hasExclusiveAccess(piVar3);
        } while (!bVar1);
        *piVar3 = iVar2 + -1;
        if (iVar2 + -1 == 0) {
            json_delete(param_1);
        }
    }
    return;
}

undefined4 FUN_00047c50(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "poolno", param_3, param_4);
    return param_1;
}

void FUN_00047c84(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_00047e10(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

undefined4 stratum_set_diff_or_target_base(int param_1, int param_2,
                                           undefined4 param_3)

{
    int iVar1;
    int *piVar2;
    undefined4 uVar3;
    size_t sVar4;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;
    undefined1 auStack_1028[4096];
    undefined8 local_28;
    int local_20;
    char *local_1c;

    local_20 = param_2 + 0x1c8;
    iVar1 = json_array_get(param_3, 0);
    if ((iVar1 == 0) ||
        (piVar2 = (int *)json_array_get(param_3, 0), *piVar2 != 2)) {
        uVar3 = json_array_get(param_3, 0);
        uVar3 = json_number_value(uVar3);
        local_28 = (double)CONCAT44(extraout_s1_00, uVar3);
        if (local_28 == 0.0) {
            V_LOCK();
            logfmt_raw(auStack_1028, 0x1000, 0,
                       "Stratum set target: invalid parameters");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/frontend/"
                 "frontend_base.c",
                 0xa2, "stratum_set_diff_or_target_base", 0x1f, 0x23, 100,
                 auStack_1028);
            return 0;
        }
        pthread_mutex_lock((pthread_mutex_t *)(param_2 + 0x638));
        *(undefined4 *)(local_20 + 0x428) = (undefined4)local_28;
        *(undefined4 *)(local_20 + 0x42c) = local_28._4_4_;
        uVar3 = *(undefined4 *)(local_20 + 0x42c);
        *(undefined4 *)(param_2 + 0x1c0) = *(undefined4 *)(local_20 + 0x428);
        *(undefined4 *)(param_2 + 0x1c4) = uVar3;
        *(undefined4 *)(param_2 + 0x710) = *(undefined4 *)(param_2 + 0x1c0);
        *(undefined4 *)(param_2 + 0x714) = *(undefined4 *)(param_2 + 0x1c4);
        (**(code **)(param_1 + 0x40))((undefined4)local_28, local_20 + 0x408);
        V_LOCK();
        logfmt_raw(auStack_1028, 0x1000, 0, "%s diff from pool: %lf",
                   "stratum_set_diff_or_target_base");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_base.c",
             0xa2, "stratum_set_diff_or_target_base", 0x1f, 0x2a, 0x14,
             auStack_1028);
        V_LOCK();
        logfmt_raw(auStack_1028, 0x1000, 0,
                   "%s target:%08x %08x %08x %08x %08x %08x %08x %08x ",
                   "stratum_set_diff_or_target_base",
                   *(undefined4 *)(local_20 + 0x408),
                   *(undefined4 *)(local_20 + 0x40c),
                   *(undefined4 *)(local_20 + 0x410),
                   *(undefined4 *)(local_20 + 0x414),
                   *(undefined4 *)(local_20 + 0x418),
                   *(undefined4 *)(local_20 + 0x41c),
                   *(undefined4 *)(local_20 + 0x420),
                   *(undefined4 *)(local_20 + 0x424));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_base.c",
             0xa2, "stratum_set_diff_or_target_base", 0x1f, 0x2b, 0x14,
             auStack_1028);
        pthread_mutex_unlock((pthread_mutex_t *)(param_2 + 0x638));
    } else {
        uVar3 = json_array_get(param_3, 0);
        local_1c = (char *)json_string_value(uVar3);
        if ((local_1c == (char *)0x0) ||
            (sVar4 = strlen(local_1c), sVar4 != 0x40)) {
            V_LOCK();
            logfmt_raw(auStack_1028, 0x1000, 0,
                       "Stratum set target: invalid parameters");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/frontend/"
                 "frontend_base.c",
                 0xa2, "stratum_set_diff_or_target_base", 0x1f, 0x14, 100,
                 auStack_1028);
            return 0;
        }
        V_LOCK();
        logfmt_raw(auStack_1028, 0x1000, 0, "%s target from pool: %s",
                   "stratum_set_diff_or_target_base", local_1c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_base.c",
             0xa2, "stratum_set_diff_or_target_base", 0x1f, 0x18, 0x14,
             auStack_1028);
        sVar4 = strlen(local_1c);
        hex2bin(auStack_1028, local_1c, sVar4 >> 1);
        pthread_mutex_lock((pthread_mutex_t *)(param_2 + 0x638));
        memcpy((void *)(local_20 + 0x408), auStack_1028, 0x20);
        uVar3 = (**(code **)(param_1 + 0x44))(auStack_1028);
        *(ulonglong *)(local_20 + 0x428) = CONCAT44(extraout_s1, uVar3);
        uVar3 = *(undefined4 *)(local_20 + 0x42c);
        *(undefined4 *)(param_2 + 0x1c0) = *(undefined4 *)(local_20 + 0x428);
        *(undefined4 *)(param_2 + 0x1c4) = uVar3;
        *(undefined4 *)(param_2 + 0x710) = *(undefined4 *)(param_2 + 0x1c0);
        *(undefined4 *)(param_2 + 0x714) = *(undefined4 *)(param_2 + 0x1c4);
        pthread_mutex_unlock((pthread_mutex_t *)(param_2 + 0x638));
    }
    return 1;
}

char stratum_handle_method_base(int param_1, int param_2, undefined4 param_3)

{
    undefined4 uVar1;
    int iVar2;
    undefined1 auStack_1120[4096];
    undefined4 local_120[23];
    undefined1 auStack_c4[160];
    undefined4 local_24;
    char *local_20;
    int local_1c;
    int local_18;
    char local_11;

    local_11 = '\0';
    local_1c = json_loads(param_3, 0, local_120);
    if (local_1c == 0) {
        V_LOCK();
        logfmt_raw(auStack_1120, 0x1000, 0, "JSON decode failed(%d): %s",
                   local_120[0], auStack_c4);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_base.c",
             0xa2, "stratum_handle_method_base", 0x1a, 0x41, 100, auStack_1120);
    } else {
        uVar1 = json_object_get(local_1c, "method");
        local_20 = (char *)json_string_value(uVar1);
        if (local_20 != (char *)0x0) {
            local_18 = json_object_get(local_1c, "params");
            if (local_18 == 0) {
                local_18 = json_object_get(local_1c, "result");
            }
            local_24 = json_object_get(local_1c, &DAT_000daa8c);
            iVar2 = strcasecmp(local_20, "mining.notify");
            if (iVar2 == 0) {
                local_11 =
                    (**(code **)(param_1 + 0x30))(param_1, param_2, local_18);
                if (local_11 == '\0') {
                    pool_tclear(param_2, param_2 + 0x77c, 0);
                } else {
                    pool_tset(param_2, param_2 + 0x77c, 1);
                }
            } else {
                iVar2 = strcasecmp(local_20, "mining.set_difficulty");
                if ((iVar2 == 0) ||
                    (iVar2 = strcasecmp(local_20, "mining.set_target"),
                     iVar2 == 0)) {
                    local_11 = (**(code **)(param_1 + 0x38))(param_1, param_2,
                                                             local_18);
                } else {
                    iVar2 = strcasecmp(local_20, "mining.set_extranonce");
                    if (iVar2 == 0) {
                        local_11 = (**(code **)(param_1 + 0x34))(
                            param_1, param_2, local_18, 0);
                        if (local_11 == '\0') {
                            pool_tclear(param_2, param_2 + 0x77c, 0);
                        } else {
                            pool_tset(param_2, param_2 + 0x77c, 1);
                        }
                    } else if (local_11 != '\x01') {
                        V_LOCK();
                        logfmt_raw(auStack_1120, 0x1000, 0,
                                   "unknown stratum method %s!", param_3);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/frontend/"
                             "frontend_base.c",
                             0xa2, "stratum_handle_method_base", 0x1a, 0x69,
                             0x50, auStack_1120);
                    }
                }
            }
        }
    }
    if (local_1c != 0) {
        FUN_00047be8(local_1c);
    }
    return local_11;
}

char pre_stratum_handle_method_base(int param_1, int param_2,
                                    undefined4 param_3, undefined4 *param_4)

{
    undefined4 uVar1;
    int iVar2;
    undefined1 auStack_1118[4096];
    undefined4 local_118[23];
    undefined1 auStack_bc[160];
    undefined4 local_1c;
    char *local_18;
    int local_14;
    int local_10;
    char local_9;

    local_9 = '\0';
    local_14 = json_loads(param_3, 0, local_118);
    if (local_14 == 0) {
        V_LOCK();
        logfmt_raw(auStack_1118, 0x1000, 0, "JSON decode failed(%d): %s",
                   local_118[0], auStack_bc);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_base.c",
             0xa2, "pre_stratum_handle_method_base", 0x1e, 0x7b, 100,
             auStack_1118);
    } else {
        uVar1 = json_object_get(local_14, "method");
        local_18 = (char *)json_string_value(uVar1);
        if (local_18 != (char *)0x0) {
            local_10 = json_object_get(local_14, "params");
            if (local_10 == 0) {
                local_10 = json_object_get(local_14, "result");
            }
            local_1c = json_object_get(local_14, &DAT_000daa8c);
            iVar2 = strcasecmp(local_18, "mining.notify");
            if (iVar2 == 0) {
                local_9 =
                    (**(code **)(param_1 + 0x30))(param_1, param_2, local_10);
                if (local_9 == '\0') {
                    pool_tclear(param_2, param_2 + 0x77c, 0);
                } else {
                    *param_4 = "notify";
                    pool_tset(param_2, param_2 + 0x77c, 1);
                }
            } else {
                iVar2 = strcasecmp(local_18, "mining.set_difficulty");
                if ((iVar2 == 0) ||
                    (iVar2 = strcasecmp(local_18, "mining.set_target"),
                     iVar2 == 0)) {
                    *param_4 = "set diff or target";
                    local_9 = (**(code **)(param_1 + 0x38))(param_1, param_2,
                                                            local_10);
                } else if (local_9 != '\x01') {
                    V_LOCK();
                    logfmt_raw(auStack_1118, 0x1000, 0,
                               "unknown stratum method %s!", param_3);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "frontend/frontend_base.c",
                         0xa2, "pre_stratum_handle_method_base", 0x1e, 0x9c,
                         0x50, auStack_1118);
                }
            }
        }
    }
    if (local_14 != 0) {
        FUN_00047be8(local_14);
    }
    return local_9;
}

char stratum_subscribe_base(int param_1, int *param_2)

{
    char cVar1;
    size_t sVar2;
    undefined4 uVar3;
    char *pcVar4;
    int iVar5;
    undefined1 auStack_114c[4096];
    undefined4 local_14c[23];
    undefined1 auStack_f0[160];
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    int *local_2c;
    int *local_28;
    int local_24;
    char *local_20;
    char local_1a;
    char local_19;
    int local_18;
    void *local_14;

    local_14 = (void *)0x0;
    local_18 = 0;
    local_19 = '\0';
    local_1a = '\0';
    local_24 = 0;
    if ((char)param_2[0x19e] == '\0') {
        while (true) {
            if (param_2[0x12] == 0) {
                sVar2 = 0x80;
            } else {
                sVar2 = strlen((char *)param_2[0x12]);
                sVar2 = sVar2 + 0x80;
            }
            local_20 = (char *)malloc(sVar2);
            if (local_1a == '\0') {
                memcpy(local_20,
                       "{\"id\": 1, \"method\": \"mining.subscribe\", "
                       "\"params\": [\"GodMiner/2.0.0\", null]}",
                       0x4c);
            } else {
                memcpy(local_20,
                       "{\"id\": 1, \"method\": \"mining.subscribe\", "
                       "\"params\": [\"ckbminer-v1.0.0\", null]}",
                       0x4d);
            }
            cVar1 = (**(code **)(param_1 + 0xc))(param_2, local_20);
            if (cVar1 == '\x01') {
                cVar1 = socket_full(param_2[9], 0x1e);
                if (cVar1 == '\x01') {
                    local_14 = (void *)(**(code **)(param_1 + 8))(param_2);
                    if (local_14 != (void *)0x0) {
                        local_18 = json_loads(local_14, 0, local_14c);
                        if (local_14 != (void *)0x0) {
                            free(local_14);
                        }
                        if (local_18 == 0) {
                            V_LOCK();
                            logfmt_raw(auStack_114c, 0x1000, 0,
                                       "JSON decode failed(%d): %s",
                                       local_14c[0], auStack_f0);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/frontend/"
                                 "frontend_base.c",
                                 0xa2, "stratum_subscribe_base", 0x16, 0xce,
                                 100, auStack_114c);
                        } else {
                            local_28 =
                                (int *)json_object_get(local_18, "result");
                            local_2c =
                                (int *)json_object_get(local_18, "error");
                            uVar3 = json_object_get(local_18, &DAT_000daa8c);
                            local_24 = json_integer_value(uVar3);
                            if ((((local_24 == 1) &&
                                  (local_28 != (int *)0x0)) &&
                                 ((local_28 == (int *)0x0 ||
                                   (*local_28 != 7)))) &&
                                ((local_2c == (int *)0x0 ||
                                  ((local_2c != (int *)0x0 &&
                                    (*local_2c == 7)))))) {
                                cVar1 = (**(code **)(param_1 + 0x34))(
                                    param_1, param_2, local_28, 1);
                                if (cVar1 == '\x01') {
                                    local_19 = '\x01';
                                    param_2[0x1e0] = 2;
                                }
                            } else if (local_1a != '\0') {
                                if (local_2c == (int *)0x0) {
                                    local_20 = strdup("(unknown reason)");
                                } else {
                                    local_20 = (char *)json_dumps(local_2c, 3);
                                }
                                V_LOCK();
                                logfmt_raw(
                                    auStack_114c, 0x1000, 0,
                                    "JSON-RPC call failed: %s, req_id=%d",
                                    local_20, local_24);
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/"
                                     "frontend/frontend_base.c",
                                     0xa2, "stratum_subscribe_base", 0x16, 0xdd,
                                     100, auStack_114c);
                            }
                        }
                    }
                } else {
                    V_LOCK();
                    FUN_00047c50(&local_50, &local_50, *param_2,
                                 *param_2 >> 0x1f);
                    logfmt_raw(auStack_114c, 0x1000, 0, uStack_34, local_50,
                               uStack_4c, uStack_48, uStack_44, local_40,
                               uStack_3c, uStack_38, uStack_34,
                               "stratum_subscribe timed out");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "frontend/frontend_base.c",
                         0xa2, "stratum_subscribe_base", 0x16, 0xc3, 100,
                         auStack_114c);
                }
            } else {
                V_LOCK();
                logfmt_raw(auStack_114c, 0x1000, 0,
                           "stratum_subscribe send failed");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/frontend/"
                     "frontend_base.c",
                     0xa2, "stratum_subscribe_base", 0x16, 0xbe, 100,
                     auStack_114c);
            }
            if (((local_19 != '\0') && (param_2[8] != 0)) &&
                (pcVar4 = strstr((char *)param_2[8], "nicehash"),
                 pcVar4 != (char *)0x0)) {
                iVar5 = param_2[0x1e0];
                param_2[0x1e0] = iVar5 + 1;
                sprintf(local_20,
                        "{\"id\": %d, \"method\": "
                        "\"mining.extranonce.subscribe\", \"params\": []}",
                        iVar5);
                iVar5 = (**(code **)(param_1 + 0xc))(param_2, local_20);
                if ((iVar5 != 0) &&
                    (iVar5 = socket_full(param_2[9], 0x1e), iVar5 != 0)) {
                    (**(code **)(param_1 + 8))(param_2);
                }
            }
            if (local_20 != (char *)0x0) {
                free(local_20);
            }
            if (local_18 != 0) {
                FUN_00047be8(local_18);
            }
            if (((local_19 == '\x01') || (local_14 == (void *)0x0)) ||
                (local_1a == '\x01'))
                break;
            local_1a = '\x01';
        }
    } else {
        V_LOCK();
        logfmt_raw(auStack_114c, 0x1000, 0,
                   "pool %d is jsonrpc_2, no need to subscribe", *param_2);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_base.c",
             0xa2, "stratum_subscribe_base", 0x16, 0xae, 0x14, auStack_114c);
        local_19 = '\x01';
    }
    return local_19;
}

undefined1 stratum_authorize_base(int param_1, int param_2)

{
    char cVar1;
    size_t sVar2;
    size_t sVar3;
    undefined4 uVar4;
    int iVar5;
    undefined1 auStack_1128[4096];
    undefined4 local_128[23];
    undefined1 auStack_cc[160];
    int *local_2c;
    int *local_28;
    void *local_24;
    char *local_20;
    int local_1c;
    int local_18;
    undefined1 local_11;

    local_18 = 0;
    local_11 = 0;
    local_1c = 0;
    sVar2 = strlen(*(char **)(param_2 + 0x10));
    sVar3 = strlen(*(char **)(param_2 + 0x14));
    local_20 = (char *)malloc(sVar2 + sVar3 + 0x50);
    iVar5 = *(int *)(param_2 + 0x780);
    *(int *)(param_2 + 0x780) = iVar5 + 1;
    sprintf(local_20,
            "{\"id\":%d,\"method\":\"mining.authorize\",\"params\":[\"%s\",\"%"
            "s\"]}",
            iVar5, *(undefined4 *)(param_2 + 0x10),
            *(undefined4 *)(param_2 + 0x14));
    cVar1 = (**(code **)(param_1 + 0xc))(param_2, local_20);
    if (cVar1 == '\x01') {
        while (local_24 = (void *)(**(code **)(param_1 + 8))(param_2),
               local_24 != (void *)0x0) {
            cVar1 = (**(code **)(param_1 + 0x14))(param_1, param_2, local_24);
            if (cVar1 != '\x01') {
                local_18 = json_loads(local_24, 0, local_128);
                if (local_24 != (void *)0x0) {
                    free(local_24);
                }
                if (local_18 == 0) {
                    V_LOCK();
                    logfmt_raw(auStack_1128, 0x1000, 0,
                               "JSON decode failed(%d): %s", local_128[0],
                               auStack_cc);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "frontend/frontend_base.c",
                         0xa2, "stratum_authorize_base", 0x16, 0x11b, 100,
                         auStack_1128);
                } else {
                    local_28 = (int *)json_object_get(local_18, "result");
                    local_2c = (int *)json_object_get(local_18, "error");
                    uVar4 = json_object_get(local_18, &DAT_000daa8c);
                    local_1c = json_integer_value(uVar4);
                    if ((((local_1c == *(int *)(param_2 + 0x780) + -1) &&
                          (local_28 != (int *)0x0)) &&
                         ((local_28 == (int *)0x0 || (*local_28 != 6)))) &&
                        ((local_2c == (int *)0x0 ||
                          ((local_2c != (int *)0x0 && (*local_2c == 7)))))) {
                        local_11 = 1;
                    } else {
                        V_LOCK();
                        logfmt_raw(auStack_1128, 0x1000, 0,
                                   "Stratum authentication failed, req_id=%d",
                                   local_1c);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/frontend/"
                             "frontend_base.c",
                             0xa2, "stratum_authorize_base", 0x16, 0x125, 100,
                             auStack_1128);
                    }
                }
                break;
            }
            if (local_24 != (void *)0x0) {
                free(local_24);
            }
        }
    }
    if (local_20 != (char *)0x0) {
        free(local_20);
    }
    if (local_18 != 0) {
        FUN_00047be8(local_18);
    }
    return local_11;
}

undefined4 stratum_login_base(int param_1, undefined4 param_2)

{
    int iVar1;
    undefined4 uVar2;

    iVar1 = (**(code **)(param_1 + 0x28))(param_1, param_2);
    if ((iVar1 == 0) ||
        (iVar1 = (**(code **)(param_1 + 0x2c))(param_1, param_2), iVar1 == 0)) {
        uVar2 = 0;
    } else {
        uVar2 = 1;
    }
    return uVar2;
}

undefined1 stratum_handle_response_base(undefined4 param_1, undefined4 param_2,
                                        int param_3)

{
    undefined1 uVar1;
    int iVar2;
    int *piVar3;
    undefined4 uVar4;
    bool bVar5;
    undefined8 uVar6;
    undefined1 auStack_1124[4096];
    undefined4 local_124[23];
    undefined1 auStack_c8[160];
    char *local_28;
    int *local_24;
    int *local_20;
    int *local_1c;
    int local_18;
    undefined1 local_12;
    undefined1 local_11;

    local_11 = 0;
    local_12 = 0;
    local_18 = json_loads(param_2, 0, local_124);
    if (local_18 == 0) {
        V_LOCK();
        logfmt_raw(auStack_1124, 0x1000, 0, "JSON decode failed(%d): %s",
                   local_124[0], auStack_c8);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_base.c",
             0xa2, "stratum_handle_response_base", 0x1c, 0x141, 0x28,
             auStack_1124);
    } else {
        local_1c = (int *)json_object_get(local_18, "result");
        local_20 = (int *)json_object_get(local_18, "error");
        local_24 = (int *)json_object_get(local_18, &DAT_000daa8c);
        if ((local_1c == (int *)0x0) ||
            ((local_1c != (int *)0x0 && (*local_1c == 7)))) {
            local_12 = 0;
        } else {
            piVar3 = (int *)json_false();
            if (local_1c == piVar3) {
                local_12 = 0;
            } else {
                local_28 = (char *)json_string_value(local_1c);
                if ((((local_28 == (char *)0x0) ||
                      (iVar2 = strcmp(local_28, "ok"), iVar2 != 0)) ||
                     (local_20 == (int *)0x0)) ||
                    (*local_20 != 7)) {
                    local_12 = 0;
                } else {
                    local_12 = 1;
                }
            }
        }
        piVar3 = (int *)json_true();
        if (local_1c == piVar3) {
            if ((local_20 == (int *)0x0) || (*local_20 != 7)) {
                bVar5 = false;
            } else {
                bVar5 = true;
            }
            if (bVar5 || local_20 == (int *)0x0) {
                local_12 = 1;
            }
        }
        uVar1 = local_12;
        if ((local_24 == (int *)0x0) ||
            ((local_24 != (int *)0x0 && (*local_24 == 7)))) {
            V_LOCK();
            logfmt_raw(auStack_1124, 0x1000, 0, "%s json id is null!",
                       "stratum_handle_response_base");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/frontend/"
                 "frontend_base.c",
                 0xa2, "stratum_handle_response_base", 0x1c, 0x159, 0x14,
                 auStack_1124);
        } else {
            if (*(char *)(param_3 + 0x678) == '\0') {
                if ((local_1c == (int *)0x0) ||
                    (uVar6 = json_integer_value(local_24), uVar1 = local_12,
                     (int)((ulonglong)uVar6 >> 0x20) <
                         (int)(uint)((uint)uVar6 < 4)))
                    goto LAB_00049d98;
                if (local_20 == (int *)0x0) {
                    uVar4 = 0;
                } else {
                    uVar4 = json_array_get(local_20, 1);
                    uVar4 = json_string_value(uVar4);
                }
                share_result(uVar1, 0, uVar4, param_3);
            } else {
                if ((local_1c == (int *)0x0) && (local_20 == (int *)0x0))
                    goto LAB_00049d98;
                if (local_20 == (int *)0x0) {
                    uVar4 = 0;
                } else {
                    uVar4 = json_string_value(local_20);
                }
                share_result(uVar1, 0, uVar4, param_3);
            }
            local_11 = 1;
        }
    }
LAB_00049d98:
    if (local_18 != 0) {
        FUN_00047be8(local_18);
    }
    return local_11;
}

undefined4 settime_based_notify_ntime(char *param_1)

{
    undefined4 uVar1;
    undefined1 auStack_1014[4096];
    timeval local_14;
    uint local_c;

    local_c = 0xffffffff;
    local_c = strtol(param_1, (char **)0x0, 0x10);
    if ((DAT_00152331 == '\x01') || (local_c == 0)) {
        uVar1 = 0;
    } else {
        local_14.tv_sec = 0;
        local_14.tv_usec = 0;
        gettimeofday(&local_14, (__timezone_ptr_t)0x0);
        if ((uint)local_14.tv_sec < local_c) {
            local_14.tv_sec = local_c;
            settimeofday(&local_14, (timezone *)0x0);
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0,
                       "settime notify.ntime successfuly");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/frontend/"
                 "frontend_base.c",
                 0xa2, "settime_based_notify_ntime", 0x1a, 0x17f, 0x3c,
                 auStack_1014);
            DAT_00152331 = '\x01';
            uVar1 = 1;
        } else {
            uVar1 = 0;
        }
    }
    return uVar1;
}

void *set_frontend_runtime_type(undefined4 param_1, int param_2)

{
    undefined1 auStack_1010[4096];
    uint local_10;
    void *local_c;

    local_c = (void *)0x0;
    for (local_10 = 0; (local_10 < 2 &&
                        (param_2 != *(int *)(&DAT_000daf50 + local_10 * 0xc)));
         local_10 = local_10 + 1) {
    }
    if ((local_10 == 2) || (*(int *)(&DAT_000daf58 + local_10 * 0xc) == 0)) {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0,
                   "ALGO %d does not define Frontend_Base", param_2);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_interface.c",
             0xa7, "set_frontend_runtime_type", 0x19, 0x42, 100, auStack_1010);
    } else {
        local_c = (void *)(**(code **)(&DAT_000daf58 + local_10 * 0xc))();
        if (local_c != (void *)0x0) {
            *(undefined4 *)((int)local_c + 0x48) = param_1;
            if (DAT_00152334 != (void *)0x0) {
                free(DAT_00152334);
            }
            *(int *)((int)local_c + 0x4c) = param_2;
            DAT_00152334 = local_c;
        }
    }
    return local_c;
}

int frontend_runtime_instance(void)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    iVar1 = DAT_00152334;
    if (DAT_00152334 == 0) {
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, "frontend runtime type not set");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_interface.c",
             0xa7, "frontend_runtime_instance", 0x19, 0x55, 100, auStack_1008);
        iVar1 = 0;
    }
    return iVar1;
}

void FUN_0004a1b0(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_0004a33c(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

uint FUN_0004a4cc(uint param_1)

{
    return param_1 << 0x18 | (param_1 >> 8 & 0xff) << 0x10 |
           (param_1 >> 0x10 & 0xff) << 8 | param_1 >> 0x18;
}

undefined1 FUN_0004a4f4(undefined4 param_1, int *param_2, undefined4 param_3)

{
    char cVar1;
    undefined4 uVar2;
    int *piVar3;
    size_t sVar4;
    char *pcVar5;
    void *pvVar6;
    int iVar7;
    int iVar8;
    undefined1 auStack_1094[4096];
    int local_94;
    int local_90;
    int local_8c;
    int local_88;
    int iStack_84;
    int iStack_80;
    int iStack_7c;
    int local_78;
    int iStack_74;
    int iStack_70;
    int iStack_6c;
    undefined4 local_68;
    size_t local_64;
    void *local_60;
    uint local_5c;
    uint local_58;
    undefined1 local_51;
    int local_50;
    int *local_4c;
    int *local_48;
    void *local_44;
    int local_40;
    int local_3c;
    char *local_38;
    char *local_34;
    char *local_30;
    char *local_2c;
    char *local_28;
    char *local_24;
    char *local_20;
    undefined1 local_19;
    int local_18;
    void *local_14;

    local_38 = (char *)0x0;
    local_34 = (char *)0x0;
    local_30 = (char *)0x0;
    local_2c = (char *)0x0;
    local_28 = (char *)0x0;
    local_24 = (char *)0x0;
    local_20 = (char *)0x0;
    local_19 = 0;
    local_18 = 0;
    local_14 = (void *)0x0;
    local_44 = (void *)0x0;
    local_48 = param_2 + 0x72;
    local_4c = (int *)json_array_get(param_3, 4);
    if (((local_4c != (int *)0x0) && (local_4c != (int *)0x0)) &&
        (*local_4c == 1)) {
        local_50 = json_array_size(local_4c);
        iVar8 = local_18;
        local_18 = local_18 + 1;
        uVar2 = json_array_get(param_3, iVar8);
        local_38 = (char *)json_string_value(uVar2);
        iVar8 = local_18;
        local_18 = local_18 + 1;
        uVar2 = json_array_get(param_3, iVar8);
        local_34 = (char *)json_string_value(uVar2);
        iVar8 = local_18;
        local_18 = local_18 + 1;
        uVar2 = json_array_get(param_3, iVar8);
        local_30 = (char *)json_string_value(uVar2);
        iVar8 = local_18;
        local_18 = local_18 + 1;
        uVar2 = json_array_get(param_3, iVar8);
        local_2c = (char *)json_string_value(uVar2);
        iVar8 = local_18 + 1;
        local_18 = local_18 + 2;
        uVar2 = json_array_get(param_3, iVar8);
        local_28 = (char *)json_string_value(uVar2);
        iVar8 = local_18;
        local_18 = local_18 + 1;
        uVar2 = json_array_get(param_3, iVar8);
        local_24 = (char *)json_string_value(uVar2);
        iVar8 = local_18;
        local_18 = local_18 + 1;
        uVar2 = json_array_get(param_3, iVar8);
        local_20 = (char *)json_string_value(uVar2);
        iVar8 = json_array_get(param_3, local_18);
        if ((iVar8 == 0) ||
            (piVar3 = (int *)json_array_get(param_3, local_18), *piVar3 != 5)) {
            local_51 = 0;
        } else {
            local_51 = 1;
        }
        cVar1 = valid_ascii(local_38);
        if (cVar1 == '\x01') {
            cVar1 = valid_hex(local_34);
            if (cVar1 == '\x01') {
                cVar1 = valid_hex(local_30);
                if (cVar1 == '\x01') {
                    cVar1 = valid_hex(local_2c);
                    if (cVar1 == '\x01') {
                        cVar1 = valid_hex(local_28);
                        if (cVar1 == '\x01') {
                            cVar1 = valid_hex(local_24);
                            if (cVar1 == '\x01') {
                                cVar1 = valid_hex(local_20);
                                if (cVar1 == '\x01') {
                                    sVar4 = strlen(local_34);
                                    hex2bin(&local_88, local_34, sVar4 >> 1);
                                    sVar4 = strlen(local_30);
                                    local_58 = sVar4 >> 1;
                                    local_14 = calloc(local_58, 1);
                                    if (local_14 == (void *)0x0) {
                                        V_LOCK();
                                        logfmt_raw(
                                            auStack_1094, 0x1000, 0,
                                            "Failed to calloc pool coinbase1");
                                        V_UNLOCK();
                                        zlog(g_zc,
                                             "/workspace/jenkins/jenkins/"
                                             "workspace/"
                                             "Antminer_L9_CVCtrl_release/build/"
                                             "rootfs/buildroot/tmp/release/"
                                             "build/"
                                             "godminer-origin_godminer-branch1/"
                                             "frontend/frontend_ltc/"
                                             "fronted_ltc.c",
                                             0xad, "stratum_notify_ltc", 0x12,
                                             0x43, 100, auStack_1094);
                                    } else {
                                        hex2bin(local_14, local_30, local_58);
                                        sVar4 = strlen(local_2c);
                                        local_5c = sVar4 >> 1;
                                        local_44 = calloc(local_5c, 1);
                                        if (local_44 == (void *)0x0) {
                                            V_LOCK();
                                            logfmt_raw(auStack_1094, 0x1000, 0,
                                                       "Failed to calloc pool "
                                                       "coinbase2");
                                            V_UNLOCK();
                                            zlog(g_zc,
                                                 "/workspace/jenkins/jenkins/"
                                                 "workspace/"
                                                 "Antminer_L9_CVCtrl_release/"
                                                 "build/rootfs/buildroot/tmp/"
                                                 "release/build/"
                                                 "godminer-origin_godminer-"
                                                 "branch1/frontend/"
                                                 "frontend_ltc/fronted_ltc.c",
                                                 0xad, "stratum_notify_ltc",
                                                 0x12, 0x4a, 100, auStack_1094);
                                        } else {
                                            hex2bin(local_44, local_2c,
                                                    local_5c);
                                            sVar4 = strlen(local_28);
                                            hex2bin(&local_8c, local_28,
                                                    sVar4 >> 1);
                                            sVar4 = strlen(local_24);
                                            hex2bin(&local_90, local_24,
                                                    sVar4 >> 1);
                                            sVar4 = strlen(local_20);
                                            hex2bin(&local_94, local_20,
                                                    sVar4 >> 1);
                                            if (local_48 != (int *)0x0) {
                                                if ((local_48[0x119] != 0) &&
                                                    (iVar8 = strcmp(
                                                         (char *)
                                                             local_48[0x119],
                                                         local_38),
                                                     iVar8 == 0)) {
                                                    V_LOCK();
                                                    logfmt_raw(
                                                        auStack_1094, 0x1000, 0,
                                                        "Stratum notify: new "
                                                        "job\'s job_id doesnot "
                                                        "change, %s, %s",
                                                        local_48[0x119],
                                                        local_38);
                                                    V_UNLOCK();
                                                    zlog(
                                                        g_zc,
                                                        "/workspace/jenkins/"
                                                        "jenkins/workspace/"
                                                        "Antminer_L9_CVCtrl_"
                                                        "release/build/rootfs/"
                                                        "buildroot/tmp/release/"
                                                        "build/"
                                                        "godminer-origin_"
                                                        "godminer-branch1/"
                                                        "frontend/frontend_ltc/"
                                                        "fronted_ltc.c",
                                                        0xad,
                                                        "stratum_notify_ltc",
                                                        0x12, 0x54, 0x50,
                                                        auStack_1094);
                                                }
                                                sVar4 = strlen(local_38);
                                                if (0x3f < sVar4) {
                                                    V_LOCK();
                                                    sVar4 = strlen(local_38);
                                                    logfmt_raw(
                                                        auStack_1094, 0x1000, 0,
                                                        "Stratum notify: "
                                                        "job_id len = %s, len "
                                                        "%d >= %d",
                                                        local_38, sVar4, 0x40);
                                                    V_UNLOCK();
                                                    zlog(
                                                        g_zc,
                                                        "/workspace/jenkins/"
                                                        "jenkins/workspace/"
                                                        "Antminer_L9_CVCtrl_"
                                                        "release/build/rootfs/"
                                                        "buildroot/tmp/release/"
                                                        "build/"
                                                        "godminer-origin_"
                                                        "godminer-branch1/"
                                                        "frontend/frontend_ltc/"
                                                        "fronted_ltc.c",
                                                        0xad,
                                                        "stratum_notify_ltc",
                                                        0x12, 0x57, 0x50,
                                                        auStack_1094);
                                                }
                                                pthread_mutex_lock((
                                                    pthread_mutex_t *)(param_2 +
                                                                       0x18e));
                                                local_60 =
                                                    (void *)local_48[0x119];
                                                pcVar5 = strdup(local_38);
                                                local_48[0x119] = (int)pcVar5;
                                                if (local_60 != (void *)0x0) {
                                                    free(local_60);
                                                    local_60 = (void *)0x0;
                                                }
                                                if (param_2[0x4b] != 0) {
                                                    free((void *)param_2[0x4b]);
                                                    param_2[0x4b] = 0;
                                                }
                                                param_2[0x4a] =
                                                    param_2[0x13] + local_58 +
                                                    param_2[0x15] + local_5c;
                                                local_64 = param_2[0x4a];
                                                pvVar6 = calloc(local_64, 1);
                                                param_2[0x4b] = (int)pvVar6;
                                                if (param_2[0x4b] == 0) {
                                                    V_LOCK();
                                                    logfmt_raw(
                                                        auStack_1094, 0x1000, 0,
                                                        "Failed to calloc pool "
                                                        "coinbase");
                                                    V_UNLOCK();
                                                    zlog(
                                                        g_zc,
                                                        "/workspace/jenkins/"
                                                        "jenkins/workspace/"
                                                        "Antminer_L9_CVCtrl_"
                                                        "release/build/rootfs/"
                                                        "buildroot/tmp/release/"
                                                        "build/"
                                                        "godminer-origin_"
                                                        "godminer-branch1/"
                                                        "frontend/frontend_ltc/"
                                                        "fronted_ltc.c",
                                                        0xad,
                                                        "stratum_notify_ltc",
                                                        0x12, 0x62, 100,
                                                        auStack_1094);
                                                    pthread_mutex_unlock(
                                                        (pthread_mutex_t
                                                             *)(param_2 +
                                                                0x18e));
                                                } else {
                                                    memcpy(
                                                        (void *)param_2[0x4b],
                                                        local_14, local_58);
                                                    memcpy(
                                                        (void *)(param_2[0x4b] +
                                                                 local_58),
                                                        (void *)param_2[0x14],
                                                        param_2[0x13]);
                                                    memcpy(
                                                        (void *)(param_2[0x4b] +
                                                                 param_2[0x13] +
                                                                 local_58 +
                                                                 param_2[0x15]),
                                                        local_44, local_5c);
                                                    param_2[0x16] =
                                                        param_2[0x13] +
                                                        local_58;
                                                    param_2[0x19] = local_88;
                                                    param_2[0x1a] = iStack_84;
                                                    param_2[0x1b] = iStack_80;
                                                    param_2[0x1c] = iStack_7c;
                                                    param_2[0x1d] = local_78;
                                                    param_2[0x1e] = iStack_74;
                                                    param_2[0x1f] = iStack_70;
                                                    param_2[0x20] = iStack_6c;
                                                    param_2[0x53] = local_8c;
                                                    param_2[0x56] = local_90;
                                                    param_2[0x59] = local_94;
                                                    for (local_40 = 0;
                                                         local_40 <
                                                         param_2[0x51];
                                                         local_40 =
                                                             local_40 + 1) {
                                                        if (*(int *)(param_2
                                                                         [0x52] +
                                                                     local_40 *
                                                                         4) !=
                                                            0) {
                                                            free(*(
                                                                void *
                                                                    *)(param_2
                                                                           [0x52] +
                                                                       local_40 *
                                                                           4));
                                                            *(undefined4
                                                                  *)(param_2
                                                                         [0x52] +
                                                                     local_40 *
                                                                         4) = 0;
                                                        }
                                                    }
                                                    param_2[0x51] = 0;
                                                    if (local_50 != 0) {
                                                        pvVar6 = realloc(
                                                            (void *)
                                                                param_2[0x52],
                                                            local_50 << 2);
                                                        param_2[0x52] =
                                                            (int)pvVar6;
                                                        for (local_3c = 0;
                                                             local_3c <
                                                             local_50;
                                                             local_3c =
                                                                 local_3c + 1) {
                                                            uVar2 =
                                                                json_array_get(
                                                                    local_4c,
                                                                    local_3c);
                                                            local_68 =
                                                                json_string_value(
                                                                    uVar2);
                                                            iVar7 =
                                                                param_2[0x52];
                                                            iVar8 =
                                                                local_3c * 4;
                                                            pvVar6 =
                                                                malloc(0x20);
                                                            *(void **)(iVar7 +
                                                                       iVar8) =
                                                                pvVar6;
                                                            hex2bin(
                                                                *(undefined4
                                                                      *)(param_2
                                                                             [0x52] +
                                                                         local_3c *
                                                                             4),
                                                                local_68, 0x20);
                                                        }
                                                        param_2[0x51] =
                                                            local_50;
                                                    }
                                                    memset(local_48 + 2, 0,
                                                           0x50);
                                                    local_48[2] = local_8c;
                                                    local_48[3] = local_88;
                                                    local_48[4] = iStack_84;
                                                    local_48[5] = iStack_80;
                                                    local_48[6] = iStack_7c;
                                                    local_48[7] = local_78;
                                                    local_48[8] = iStack_74;
                                                    local_48[9] = iStack_70;
                                                    local_48[10] = iStack_6c;
                                                    local_48[0x13] = local_94;
                                                    local_48[0x14] = local_90;
                                                    *(undefined1 *)(param_2 +
                                                                    0x6f) =
                                                        local_51;
                                                    iVar8 = *param_2;
                                                    *local_48 = iVar8;
                                                    local_48[1] = iVar8 >> 0x1f;
                                                    local_19 = 1;
                                                    pthread_mutex_unlock(
                                                        (pthread_mutex_t
                                                             *)(param_2 +
                                                                0x18e));
                                                }
                                            }
                                        }
                                    }
                                    goto LAB_0004b248;
                                }
                            }
                        }
                    }
                }
            }
        }
        V_LOCK();
        logfmt_raw(auStack_1094, 0x1000, 0,
                   "Stratum notify: invalid parameters");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_ltc/"
             "fronted_ltc.c",
             0xad, "stratum_notify_ltc", 0x12, 0x3b, 100, auStack_1094);
    }
LAB_0004b248:
    if (local_44 != (void *)0x0) {
        free(local_44);
        local_44 = (void *)0x0;
    }
    if (local_14 != (void *)0x0) {
        free(local_14);
    }
    return local_19;
}

undefined4 FUN_0004b290(undefined4 param_1, int param_2, undefined4 param_3,
                        int param_4)

{
    undefined4 uVar1;
    size_t sVar2;
    void *pvVar3;
    undefined1 auStack_1018[4096];
    size_t *local_18;
    int local_14;
    char *local_10;
    size_t local_c;

    local_10 = (char *)0x0;
    local_c = 0;
    local_14 = param_2 + 0x1c8;
    uVar1 = json_array_get(param_3, param_4);
    local_10 = (char *)json_string_value(uVar1);
    if ((local_10 == (char *)0x0) ||
        (sVar2 = strlen(local_10), (sVar2 & 1) != 0)) {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, "Failed to get extranonce1");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_ltc/"
             "fronted_ltc.c",
             0xad, "stratum_parse_extranonce_ltc", 0x1c, 0x9a, 100,
             auStack_1018);
    } else {
        uVar1 = json_array_get(param_3, param_4 + 1);
        local_c = json_integer_value(uVar1);
        if (((local_c == 0) || ((int)local_c < 2)) || (0x10 < (int)local_c)) {
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0,
                       "Get invalid n2size in parse_extranonce, xn2_size=%d",
                       local_c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/frontend/"
                 "frontend_ltc/fronted_ltc.c",
                 0xad, "stratum_parse_extranonce_ltc", 0x1c, 0x9f, 0x3c,
                 auStack_1018);
        } else {
            pthread_mutex_lock((pthread_mutex_t *)(param_2 + 0x638));
            if (*(int *)(param_2 + 0x50) != 0) {
                free(*(void **)(param_2 + 0x50));
                *(undefined4 *)(param_2 + 0x50) = 0;
            }
            sVar2 = strlen(local_10);
            *(size_t *)(param_2 + 0x4c) = sVar2 >> 1;
            pvVar3 = calloc(1, *(size_t *)(param_2 + 0x4c));
            *(void **)(param_2 + 0x50) = pvVar3;
            if (*(int *)(param_2 + 0x50) != 0) {
                hex2bin(*(undefined4 *)(param_2 + 0x50), local_10,
                        *(undefined4 *)(param_2 + 0x4c));
                *(size_t *)(param_2 + 0x54) = local_c;
                if (*(int *)(local_14 + 0x46c) != 0) {
                    free(*(void **)(local_14 + 0x46c));
                    *(undefined4 *)(local_14 + 0x46c) = 0;
                }
                pvVar3 = calloc(1, 0x14);
                *(void **)(local_14 + 0x46c) = pvVar3;
                if (*(int *)(local_14 + 0x46c) == 0) {
                    printf("invalid pointer(%s)!\n", "work->private");
                    return 0;
                }
                local_18 = *(size_t **)(local_14 + 0x46c);
                *local_18 = local_c;
                memset(local_18 + 1, 0, *local_18);
                pthread_mutex_unlock((pthread_mutex_t *)(param_2 + 0x638));
                V_LOCK();
                logfmt_raw(auStack_1018, 0x1000, 0,
                           "Stratum set nonce1 %s, nonce2 size=%d", local_10,
                           local_c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/frontend/"
                     "frontend_ltc/fronted_ltc.c",
                     0xad, "stratum_parse_extranonce_ltc", 0x1c, 0xc2, 0x14,
                     auStack_1018);
                return 1;
            }
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, "Failed to alloc xnonce1");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/frontend/"
                 "frontend_ltc/fronted_ltc.c",
                 0xad, "stratum_parse_extranonce_ltc", 0x1c, 0xa8, 100,
                 auStack_1018);
            pthread_mutex_unlock((pthread_mutex_t *)(param_2 + 0x638));
        }
    }
    return 0;
}

undefined4 FUN_0004b7a8(int param_1, int param_2)

{
    int iVar1;
    undefined4 local_c;

    if (((*(int *)(param_1 + 0x464) == 0) ||
         (*(int *)(param_2 + 0x62c) == 0)) ||
        (iVar1 =
             strcmp(*(char **)(param_1 + 0x464), *(char **)(param_2 + 0x62c)),
         iVar1 != 0)) {
        local_c = 2;
    } else {
        local_c = 0;
    }
    return local_c;
}

void FUN_0004b828(undefined4 param_1, undefined4 param_2, undefined4 param_3)

{
    undefined1 auStack_28[32];

    sha256(param_1, param_3, auStack_28);
    sha256(auStack_28, 0x20, param_2);
    return;
}

void FUN_0004b874(int param_1, int param_2)

{
    undefined4 uVar1;
    undefined4 local_14;

    for (local_14 = 0; local_14 < 8; local_14 = local_14 + 1) {
        uVar1 = FUN_0004a4cc(*(undefined4 *)(param_2 + local_14 * 4));
        *(undefined4 *)(param_1 + local_14 * 4) = uVar1;
    }
    return;
}

undefined4 FUN_0004b8fc(int param_1, int param_2, char *param_3)

{
    undefined4 uVar1;
    int iVar2;
    undefined1 auStack_48[12];
    undefined1 auStack_3c[36];
    undefined1 auStack_18[12];
    undefined4 *local_c;

    local_c = *(undefined4 **)(param_1 + 0x46c);
    if (local_c == (undefined4 *)0x0) {
        printf("invalid pointer(%s)!\n", "private");
        uVar1 = 3;
    } else {
        bin2hex(auStack_18, param_1 + 0x430, 4);
        bin2hex(auStack_3c, local_c + 1, *local_c);
        bin2hex(auStack_48, param_1 + 0x44c, 4);
        iVar2 = *(int *)(param_2 + 0x780);
        *(int *)(param_2 + 0x780) = iVar2 + 1;
        snprintf(param_3, 0xc00,
                 "{\"id\":%d,\"method\":\"mining.submit\",\"params\":[\"%s\","
                 "\"%s\",\"%s\",\"%s\",\"%s\"]}",
                 iVar2, *(undefined4 *)(param_2 + 0x10),
                 *(undefined4 *)(param_1 + 0x464), auStack_3c, auStack_48,
                 auStack_18);
        uVar1 = 0;
    }
    return uVar1;
}

void *frontend_runtime_ltc(void)

{
    void *__dest;

    DAT_00152338 = stratum_connect;
    DAT_0015233c = stratum_disconnect;
    DAT_00152340 = stratum_recv_line;
    DAT_00152344 = stratum_send_line;
    DAT_00152348 = stratum_login_base;
    DAT_0015234c = stratum_handle_method_base;
    DAT_00152350 = pre_stratum_handle_method_base;
    DAT_00152354 = stratum_handle_response_base;
    DAT_00152358 = FUN_0004b8fc;
    DAT_0015235c = FUN_0004b7a8;
    DAT_00152360 = stratum_subscribe_base;
    DAT_00152364 = stratum_authorize_base;
    DAT_00152368 = FUN_0004a4f4;
    DAT_0015236c = FUN_0004b290;
    DAT_00152370 = stratum_set_diff_or_target_base;
    DAT_00152374 = target_to_diff_ltc;
    DAT_00152378 = diff_to_target_ltc;
    DAT_0015237c = target_to_double_diff_ltc;
    __dest = calloc(1, 0x50);
    memcpy(__dest, &DAT_00152338, 0x50);
    return __dest;
}

uint FUN_0004bbb0(uint param_1)

{
    return param_1 << 0x18 | (param_1 >> 8 & 0xff) << 0x10 |
           (param_1 >> 0x10 & 0xff) << 8 | param_1 >> 0x18;
}

void FUN_0004bbd8(int param_1)

{
    bool bVar1;
    int iVar2;
    int *piVar3;

    if ((param_1 != 0) && (*(int *)(param_1 + 4) != -1)) {
        piVar3 = (int *)(param_1 + 4);
        DataMemoryBarrier(0xb);
        do {
            iVar2 = *piVar3;
            bVar1 = (bool)hasExclusiveAccess(piVar3);
        } while (!bVar1);
        *piVar3 = iVar2 + -1;
        if (iVar2 + -1 == 0) {
            json_delete(param_1);
        }
    }
    return;
}

undefined4 FUN_0004bc40(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "poolno", param_3, param_4);
    return param_1;
}

void FUN_0004bc74(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_0004be00(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

char stratum_handle_method_x7(int param_1, int param_2, undefined4 param_3)

{
    undefined4 uVar1;
    int iVar2;
    undefined1 auStack_1114[4096];
    undefined4 local_114[23];
    undefined1 auStack_b8[160];
    int local_18;
    char *local_14;
    char local_d;
    int local_c;

    local_d = '\0';
    local_c = json_loads(param_3, 0, local_114);
    if (local_c == 0) {
        V_LOCK();
        logfmt_raw(auStack_1114, 0x1000, 0, "JSON decode failed(%d): %s",
                   local_114[0], auStack_b8);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_x7/"
             "frontend_x7.c",
             0xac, "stratum_handle_method_x7", 0x18, 0x14, 100, auStack_1114);
    } else {
        uVar1 = json_object_get(local_c, "method");
        local_14 = (char *)json_string_value(uVar1);
        if ((local_14 != (char *)0x0) &&
            (local_18 = json_object_get(local_c, "params"), local_18 != 0)) {
            iVar2 = strcasecmp(local_14, "job");
            if (iVar2 == 0) {
                local_d =
                    (**(code **)(param_1 + 0x30))(param_1, param_2, local_18);
                if (local_d == '\0') {
                    pool_tclear(param_2, param_2 + 0x77c, 0);
                } else {
                    pool_tset(param_2, param_2 + 0x77c, 1);
                }
            } else if (local_d != '\x01') {
                V_LOCK();
                logfmt_raw(auStack_1114, 0x1000, 0,
                           "unknown stratum method %s!", param_3);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/frontend/"
                     "frontend_x7/frontend_x7.c",
                     0xac, "stratum_handle_method_x7", 0x18, 0x2a, 0x50,
                     auStack_1114);
            }
        }
    }
    if (local_c != 0) {
        FUN_0004bbd8(local_c);
    }
    return local_d;
}

char pre_stratum_handle_method_x7(int param_1, int param_2, undefined4 param_3,
                                  undefined4 *param_4)

{
    undefined4 uVar1;
    int iVar2;
    undefined1 auStack_1114[4096];
    undefined4 local_114[23];
    undefined1 auStack_b8[160];
    int local_18;
    char *local_14;
    char local_d;
    int local_c;

    local_d = '\0';
    local_c = json_loads(param_3, 0, local_114);
    if (local_c == 0) {
        V_LOCK();
        logfmt_raw(auStack_1114, 0x1000, 0, "JSON decode failed(%d): %s",
                   local_114[0], auStack_b8);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_x7/"
             "frontend_x7.c",
             0xac, "pre_stratum_handle_method_x7", 0x1c, 0x3c, 100,
             auStack_1114);
    } else {
        uVar1 = json_object_get(local_c, "method");
        local_14 = (char *)json_string_value(uVar1);
        if ((local_14 != (char *)0x0) &&
            (local_18 = json_object_get(local_c, "params"), local_18 != 0)) {
            iVar2 = strcasecmp(local_14, "job");
            if (iVar2 == 0) {
                local_d =
                    (**(code **)(param_1 + 0x30))(param_1, param_2, local_18);
                if (local_d == '\0') {
                    pool_tclear(param_2, param_2 + 0x77c, 0);
                } else {
                    *param_4 = "notify";
                    pool_tset(param_2, param_2 + 0x77c, 1);
                }
            } else if (local_d != '\x01') {
                V_LOCK();
                logfmt_raw(auStack_1114, 0x1000, 0,
                           "unknown stratum method %s!", param_3);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/frontend/"
                     "frontend_x7/frontend_x7.c",
                     0xac, "pre_stratum_handle_method_x7", 0x1c, 0x53, 0x50,
                     auStack_1114);
            }
        }
    }
    if (local_c != 0) {
        FUN_0004bbd8(local_c);
    }
    return local_d;
}

undefined1 stratum_login_x7(int param_1, int *param_2)

{
    char cVar1;
    size_t sVar2;
    size_t sVar3;
    undefined4 uVar4;
    char *pcVar5;
    int iVar6;
    undefined8 uVar7;
    undefined1 auStack_11ec[4096];
    undefined4 local_1ec[23];
    undefined1 auStack_190[160];
    undefined4 local_f0;
    undefined4 uStack_ec;
    undefined4 uStack_e8;
    undefined4 uStack_e4;
    undefined4 local_e0;
    undefined4 uStack_dc;
    undefined4 uStack_d8;
    undefined4 uStack_d4;
    undefined4 local_d0;
    undefined4 uStack_cc;
    undefined4 uStack_c8;
    undefined4 uStack_c4;
    undefined4 local_c0;
    undefined4 uStack_bc;
    undefined4 uStack_b8;
    undefined4 uStack_b4;
    undefined4 local_b0;
    undefined4 uStack_ac;
    undefined4 uStack_a8;
    undefined4 uStack_a4;
    undefined4 local_a0;
    undefined4 uStack_9c;
    undefined4 uStack_98;
    undefined4 uStack_94;
    undefined4 local_90;
    undefined4 uStack_8c;
    undefined4 uStack_88;
    undefined4 uStack_84;
    undefined4 local_80;
    undefined4 uStack_7c;
    undefined4 uStack_78;
    undefined4 uStack_74;
    undefined4 local_70;
    undefined4 uStack_6c;
    undefined4 uStack_68;
    undefined4 uStack_64;
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    int *local_30;
    int *local_2c;
    undefined1 local_25;
    char *local_24;
    void *local_20;
    int local_1c;
    int local_18;
    int *local_14;

    local_1c = 0;
    local_25 = 0;
    local_18 = 0;
    *(undefined1 *)(param_2 + 0x19e) = 1;
    sVar2 = strlen((char *)param_2[4]);
    sVar3 = strlen((char *)param_2[5]);
    local_24 = (char *)malloc(sVar2 + sVar3 + 0x80);
    sprintf(local_24,
            "{\"id\": %d, \"jsonrpc\":\"2.0\", \"method\":\"login\", "
            "\"params\": {\"login\":\"%s\", \"pass\":\"%s\", "
            "\"agent\":\"USER_AGENT\", \"algo\":[\"rx/0\"]}}",
            1, param_2[4], param_2[5]);
    cVar1 = (**(code **)(param_1 + 0xc))(param_2, local_24);
    if (cVar1 == '\x01') {
        while (local_20 = (void *)(**(code **)(param_1 + 8))(param_2),
               local_20 != (void *)0x0) {
            cVar1 = (**(code **)(param_1 + 0x14))(param_1, param_2, local_20);
            if (cVar1 != '\x01') {
                local_1c = json_loads(local_20, 0, local_1ec);
                if (local_20 != (void *)0x0) {
                    free(local_20);
                }
                if (local_1c == 0) {
                    V_LOCK();
                    logfmt_raw(auStack_11ec, 0x1000, 0,
                               "JSON decode failed(%d): %s", local_1ec[0],
                               auStack_190);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "frontend/frontend_x7/frontend_x7.c",
                         0xac, "stratum_login_x7", 0x10, 0x7b, 100,
                         auStack_11ec);
                } else {
                    uVar4 = json_object_get(local_1c, &DAT_000eb8d8);
                    local_18 = json_integer_value(uVar4);
                    if (local_18 == 1) {
                        local_14 = (int *)json_object_get(local_1c, "error");
                        if ((local_14 == (int *)0x0) ||
                            ((local_14 != (int *)0x0 && (*local_14 == 7)))) {
                            local_2c =
                                (int *)json_object_get(local_1c, "result");
                            if ((local_2c == (int *)0x0) ||
                                ((local_2c == (int *)0x0 ||
                                  (*local_2c != 0)))) {
                                V_LOCK();
                                FUN_0004bc40(&local_b0, &local_b0, *param_2,
                                             *param_2 >> 0x1f);
                                logfmt_raw(auStack_11ec, 0x1000, 0, uStack_94,
                                           local_b0, uStack_ac, uStack_a8,
                                           uStack_a4, local_a0, uStack_9c,
                                           uStack_98, uStack_94,
                                           "login failed, result object error");
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/"
                                     "frontend/frontend_x7/frontend_x7.c",
                                     0xac, "stratum_login_x7", 0x10, 0x8f, 0x50,
                                     auStack_11ec);
                            } else {
                                uVar4 = json_object_get(local_2c, "status");
                                pcVar5 = (char *)json_string_value(uVar4);
                                iVar6 = strcasecmp(pcVar5, "OK");
                                if (iVar6 == 0) {
                                    pthread_mutex_lock(
                                        (pthread_mutex_t *)(param_2 + 0x19f));
                                    uVar4 = json_object_get(local_2c,
                                                            &DAT_000eb8d8);
                                    pcVar5 = (char *)json_string_value(uVar4);
                                    strcpy((char *)(param_2 + 0x1a5), pcVar5);
                                    uVar4 = json_object_get(local_2c,
                                                            &DAT_000eb8d8);
                                    pcVar5 = (char *)json_string_value(uVar4);
                                    sVar2 = strlen(pcVar5);
                                    if (0x3f < sVar2) {
                                        V_LOCK();
                                        FUN_0004bc40(&local_70, &local_70,
                                                     *param_2,
                                                     *param_2 >> 0x1f);
                                        logfmt_raw(
                                            auStack_11ec, 0x1000, 0, uStack_54,
                                            local_70, uStack_6c, uStack_68,
                                            uStack_64, local_60, uStack_5c,
                                            uStack_58, uStack_54,
                                            "rpc id len larger than 64!");
                                        V_UNLOCK();
                                        zlog(g_zc,
                                             "/workspace/jenkins/jenkins/"
                                             "workspace/"
                                             "Antminer_L9_CVCtrl_release/build/"
                                             "rootfs/buildroot/tmp/release/"
                                             "build/"
                                             "godminer-origin_godminer-branch1/"
                                             "frontend/frontend_x7/"
                                             "frontend_x7.c",
                                             0xac, "stratum_login_x7", 0x10,
                                             0x9b, 0x50, auStack_11ec);
                                    }
                                    pthread_mutex_unlock(
                                        (pthread_mutex_t *)(param_2 + 0x19f));
                                    local_30 = (int *)json_object_get(
                                        local_2c, &DAT_000eb834);
                                    if (((local_30 == (int *)0x0) ||
                                         (local_30 == (int *)0x0)) ||
                                        (*local_30 != 0)) {
                                        V_LOCK();
                                        FUN_0004bc40(&local_50, &local_50,
                                                     *param_2,
                                                     *param_2 >> 0x1f);
                                        logfmt_raw(
                                            auStack_11ec, 0x1000, 0, uStack_34,
                                            local_50, uStack_4c, uStack_48,
                                            uStack_44, local_40, uStack_3c,
                                            uStack_38, uStack_34,
                                            "login failed result job object "
                                            "error");
                                        V_UNLOCK();
                                        zlog(g_zc,
                                             "/workspace/jenkins/jenkins/"
                                             "workspace/"
                                             "Antminer_L9_CVCtrl_release/build/"
                                             "rootfs/buildroot/tmp/release/"
                                             "build/"
                                             "godminer-origin_godminer-branch1/"
                                             "frontend/frontend_x7/"
                                             "frontend_x7.c",
                                             0xac, "stratum_login_x7", 0x10,
                                             0xa1, 0x50, auStack_11ec);
                                    } else {
                                        iVar6 = (**(code **)(param_1 + 0x30))(
                                            param_1, param_2, local_30);
                                        if (iVar6 == 0) {
                                            pool_tclear(param_2,
                                                        param_2 + 0x1df, 0);
                                        } else {
                                            pool_tset(param_2, param_2 + 0x1df,
                                                      1);
                                        }
                                        param_2[0x1e0] = 2;
                                        local_25 = 1;
                                    }
                                } else {
                                    V_LOCK();
                                    FUN_0004bc40(&local_90, &local_90, *param_2,
                                                 *param_2 >> 0x1f);
                                    logfmt_raw(auStack_11ec, 0x1000, 0,
                                               uStack_74, local_90, uStack_8c,
                                               uStack_88, uStack_84, local_80,
                                               uStack_7c, uStack_78, uStack_74,
                                               "login failed, status error");
                                    V_UNLOCK();
                                    zlog(g_zc,
                                         "/workspace/jenkins/jenkins/workspace/"
                                         "Antminer_L9_CVCtrl_release/build/"
                                         "rootfs/buildroot/tmp/release/build/"
                                         "godminer-origin_godminer-branch1/"
                                         "frontend/frontend_x7/frontend_x7.c",
                                         0xac, "stratum_login_x7", 0x10, 0x94,
                                         0x50, auStack_11ec);
                                }
                            }
                        } else {
                            V_LOCK();
                            FUN_0004bc40(&local_d0, &local_d0, *param_2,
                                         *param_2 >> 0x1f);
                            uVar4 = json_object_get(local_14, &DAT_000eb904);
                            uVar7 = json_integer_value(uVar4);
                            uVar4 = json_object_get(
                                local_14, "message", (int)uVar7,
                                (int)((ulonglong)uVar7 >> 0x20));
                            uVar4 = json_string_value(uVar4);
                            logfmt_raw(auStack_11ec, 0x1000, 0, uStack_b4,
                                       local_d0, uStack_cc, uStack_c8,
                                       uStack_c4, local_c0, uStack_bc,
                                       uStack_b8, uStack_b4,
                                       "login failed, reason: %d %s",
                                       (int)uVar7, uVar4);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/frontend/"
                                 "frontend_x7/frontend_x7.c",
                                 0xac, "stratum_login_x7", 0x10, 0x88, 0x14,
                                 auStack_11ec);
                        }
                    } else {
                        V_LOCK();
                        FUN_0004bc40(&local_f0, &local_f0, *param_2,
                                     *param_2 >> 0x1f);
                        logfmt_raw(auStack_11ec, 0x1000, 0, uStack_d4, local_f0,
                                   uStack_ec, uStack_e8, uStack_e4, local_e0,
                                   uStack_dc, uStack_d8, uStack_d4,
                                   "login failed, req id %d != 1", local_18);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/frontend/"
                             "frontend_x7/frontend_x7.c",
                             0xac, "stratum_login_x7", 0x10, 0x81, 0x50,
                             auStack_11ec);
                    }
                }
                break;
            }
            if (local_20 != (void *)0x0) {
                free(local_20);
            }
        }
    }
    if (local_24 != (char *)0x0) {
        free(local_24);
    }
    if (local_1c != 0) {
        FUN_0004bbd8(local_1c);
    }
    return local_25;
}

undefined1 FUN_0004cf84(undefined4 param_1, int *param_2, int *param_3)

{
    char cVar1;
    undefined4 uVar2;
    size_t sVar3;
    int iVar4;
    int *piVar5;
    char *pcVar6;
    void *pvVar7;
    double dVar8;
    undefined8 uVar9;
    undefined1 auStack_10e4[4099];
    undefined1 local_e1;
    int local_e0;
    int iStack_dc;
    int local_d4;
    undefined4 local_d0;
    undefined4 uStack_cc;
    undefined4 uStack_c8;
    undefined4 uStack_c4;
    undefined4 local_c0;
    undefined4 uStack_bc;
    undefined4 uStack_b8;
    undefined4 uStack_b4;
    undefined4 local_b0;
    undefined4 uStack_ac;
    undefined4 uStack_a8;
    undefined4 uStack_a4;
    undefined4 local_a0;
    undefined4 uStack_9c;
    undefined4 uStack_98;
    undefined4 uStack_94;
    undefined4 local_90;
    undefined4 uStack_8c;
    undefined4 uStack_88;
    undefined4 uStack_84;
    undefined4 local_80;
    undefined4 uStack_7c;
    undefined4 uStack_78;
    undefined4 uStack_74;
    undefined4 local_70;
    undefined4 uStack_6c;
    undefined4 uStack_68;
    undefined4 uStack_64;
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    char *local_50;
    int *local_4c;
    int local_48;
    int local_44;
    uint local_40;
    char *local_3c;
    char *local_38;
    undefined1 local_31;
    int *local_30;
    char *local_2c;
    char *local_28;
    char *local_24;
    undefined8 local_20;
    char *local_14;

    local_14 = (char *)0x0;
    local_2c = (char *)0x0;
    local_24 = (char *)0x0;
    local_3c = (char *)0x0;
    local_28 = (char *)0x0;
    local_38 = (char *)0x0;
    local_31 = 0;
    local_30 = param_2 + 0x72;
    if ((param_3 == (int *)0x0) || (*param_3 != 1)) {
        uVar2 = json_object_get(param_3, &DAT_000eb9c8);
        local_14 = (char *)json_string_value(uVar2);
        uVar2 = json_object_get(param_3, "job_id");
        local_2c = (char *)json_string_value(uVar2);
        uVar2 = json_object_get(param_3, "target");
        local_24 = (char *)json_string_value(uVar2);
        uVar2 = json_object_get(param_3, "seed_hash");
        local_28 = (char *)json_string_value(uVar2);
        uVar2 = json_object_get(param_3, "height");
        local_20 = json_integer_value(uVar2);
    } else {
        uVar2 = json_array_get(param_3, 0);
        local_2c = (char *)json_string_value(uVar2);
        uVar2 = json_array_get(param_3, 1);
        local_14 = (char *)json_string_value(uVar2);
        uVar2 = json_array_get(param_3, 2);
        local_28 = (char *)json_string_value(uVar2);
        uVar2 = json_array_get(param_3, 3);
        local_24 = (char *)json_string_value(uVar2);
        uVar2 = json_array_get(param_3, 5);
        local_20 = json_integer_value(uVar2);
    }
    uVar2 = json_object_get(param_3, &DAT_000eb8d8);
    local_3c = (char *)json_string_value(uVar2);
    uVar2 = json_object_get(param_3, &DAT_000eb9f4);
    local_38 = (char *)json_string_value(uVar2);
    cVar1 = valid_ascii(local_2c);
    if (cVar1 == '\x01') {
        cVar1 = valid_hex(local_14);
        if (cVar1 == '\x01') {
            cVar1 = valid_hex(local_24);
            if (cVar1 == '\x01') {
                cVar1 = valid_hex(local_28);
                if (cVar1 == '\x01') {
                    sVar3 = strlen(local_28);
                    if (sVar3 - 0x40 < 2) {
                        if (local_38 != (char *)0x0) {
                            iVar4 = valid_ascii(local_38);
                            if (iVar4 != 0) {
                                iVar4 = strcasecmp(local_38, "rx/0");
                                if (iVar4 != 0) {
                                    V_LOCK();
                                    FUN_0004bc40(&local_d0, &local_d0, *param_2,
                                                 *param_2 >> 0x1f);
                                    logfmt_raw(auStack_10e4, 0x1000, 0,
                                               uStack_b4, local_d0, uStack_cc,
                                               uStack_c8, uStack_c4, local_c0,
                                               uStack_bc, uStack_b8, uStack_b4,
                                               "Stratum notify: algo type is "
                                               "not rx/0");
                                    V_UNLOCK();
                                    zlog(g_zc,
                                         "/workspace/jenkins/jenkins/workspace/"
                                         "Antminer_L9_CVCtrl_release/build/"
                                         "rootfs/buildroot/tmp/release/build/"
                                         "godminer-origin_godminer-branch1/"
                                         "frontend/frontend_x7/frontend_x7.c",
                                         0xac, "stratum_notify_x7", 0x11, 0xd9,
                                         100, auStack_10e4);
                                    return local_31;
                                }
                            }
                        }
                        if (local_3c != (char *)0x0) {
                            iVar4 = valid_ascii(local_3c);
                            if (iVar4 != 0) {
                                pthread_mutex_lock(
                                    (pthread_mutex_t *)(param_2 + 0x19f));
                                strcpy((char *)(param_2 + 0x1a5), local_3c);
                                sVar3 = strlen(local_3c);
                                if (0x3f < sVar3) {
                                    V_LOCK();
                                    FUN_0004bc40(&local_b0, &local_b0, *param_2,
                                                 *param_2 >> 0x1f);
                                    logfmt_raw(auStack_10e4, 0x1000, 0,
                                               uStack_94, local_b0, uStack_ac,
                                               uStack_a8, uStack_a4, local_a0,
                                               uStack_9c, uStack_98, uStack_94,
                                               "rpc id len larger than 64!");
                                    V_UNLOCK();
                                    zlog(g_zc,
                                         "/workspace/jenkins/jenkins/workspace/"
                                         "Antminer_L9_CVCtrl_release/build/"
                                         "rootfs/buildroot/tmp/release/build/"
                                         "godminer-origin_godminer-branch1/"
                                         "frontend/frontend_x7/frontend_x7.c",
                                         0xac, "stratum_notify_x7", 0x11, 0xe2,
                                         0x50, auStack_10e4);
                                }
                                pthread_mutex_unlock(
                                    (pthread_mutex_t *)(param_2 + 0x19f));
                            }
                        }
                        if (param_2[0x1bc] != 0) {
                            iVar4 = strcmp((char *)param_2[0x1bc], local_2c);
                            if (iVar4 == 0) {
                                piVar5 = (int *)get_current_pool();
                                if (param_2 == piVar5) {
                                    V_LOCK();
                                    logfmt_raw(auStack_10e4, 0x1000, 0,
                                               "Stratum notify: new job\'s "
                                               "job_id doesnot change, %s, %s",
                                               param_2[0x1bc], local_2c);
                                    V_UNLOCK();
                                    zlog(g_zc,
                                         "/workspace/jenkins/jenkins/workspace/"
                                         "Antminer_L9_CVCtrl_release/build/"
                                         "rootfs/buildroot/tmp/release/build/"
                                         "godminer-origin_godminer-branch1/"
                                         "frontend/frontend_x7/frontend_x7.c",
                                         0xac, "stratum_notify_x7", 0x11, 0xe9,
                                         0x50, auStack_10e4);
                                }
                            }
                        }
                        pthread_mutex_lock(
                            (pthread_mutex_t *)(param_2 + 0x1bd));
                        if (param_2[0x1bc] != 0) {
                            free((void *)param_2[0x1bc]);
                            param_2[0x1bc] = 0;
                        }
                        pcVar6 = strdup(local_2c);
                        param_2[0x1bc] = (int)pcVar6;
                        if (param_2[0x1b5] != 0) {
                            free((void *)param_2[0x1b5]);
                            param_2[0x1b5] = 0;
                        }
                        sVar3 = strlen(local_14);
                        param_2[0x1b7] = sVar3 >> 1;
                        pvVar7 = calloc(param_2[0x1b7], 1);
                        param_2[0x1b5] = (int)pvVar7;
                        if (param_2[0x1b5] == 0) {
                            V_LOCK();
                            logfmt_raw(auStack_10e4, 0x1000, 0,
                                       "Failed to calloc pool rpc2_blob");
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/frontend/"
                                 "frontend_x7/frontend_x7.c",
                                 0xac, "stratum_notify_x7", 0x11, 0xf4, 100,
                                 auStack_10e4);
                            pthread_mutex_unlock(
                                (pthread_mutex_t *)(param_2 + 0x1bd));
                            return local_31;
                        }
                        if (((uint)param_2[0x1b7] < 0x2b) ||
                            (0xc6 < (uint)param_2[0x1b7])) {
                            V_LOCK();
                            FUN_0004bc40(&local_90, &local_90, *param_2,
                                         *param_2 >> 0x1f);
                            logfmt_raw(
                                auStack_10e4, 0x1000, 0, uStack_74, local_90,
                                uStack_8c, uStack_88, uStack_84, local_80,
                                uStack_7c, uStack_78, uStack_74,
                                "rpc blob len (%d) error!", param_2[0x1b7]);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/frontend/"
                                 "frontend_x7/frontend_x7.c",
                                 0xac, "stratum_notify_x7", 0x11, 0xfa, 100,
                                 auStack_10e4);
                            V_LOCK();
                            FUN_0004bc40(&local_70, &local_70, *param_2,
                                         *param_2 >> 0x1f);
                            logfmt_raw(auStack_10e4, 0x1000, 0, uStack_54,
                                       local_70, uStack_6c, uStack_68,
                                       uStack_64, local_60, uStack_5c,
                                       uStack_58, uStack_54, "blob %s",
                                       local_14);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/frontend/"
                                 "frontend_x7/frontend_x7.c",
                                 0xac, "stratum_notify_x7", 0x11, 0xfb, 100,
                                 auStack_10e4);
                            pthread_mutex_unlock(
                                (pthread_mutex_t *)(param_2 + 0x1bd));
                            return local_31;
                        }
                        hex2bin(param_2[0x1b5], local_14, param_2[0x1b7]);
                        sVar3 = strlen(local_24);
                        local_40 = sVar3 >> 1;
                        if (((local_40 != 4) && (local_40 != 8)) &&
                            (local_40 != 0x20)) {
                            V_LOCK();
                            logfmt_raw(
                                auStack_10e4, 0x1000, 0,
                                "Stratum notify target len larger than 32");
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/frontend/"
                                 "frontend_x7/frontend_x7.c",
                                 0xac, "stratum_notify_x7", 0x11, 0x104, 0x50,
                                 auStack_10e4);
                        }
                        if (local_40 == 4) {
                            hex2bin(&local_d4, local_24, 4);
                            if (local_d4 == 0) {
                                V_LOCK();
                                logfmt_raw(auStack_10e4, 0x1000, 0,
                                           "Stratum notify target is zero!");
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/"
                                     "frontend/frontend_x7/frontend_x7.c",
                                     0xac, "stratum_notify_x7", 0x11, 0x10b,
                                     100, auStack_10e4);
                            } else {
                                uVar2 = FUN_000cc2a0(0xffffffff, local_d4);
                                uVar9 = FUN_000ccdfc(0xffffffff, 0xffffffff,
                                                     uVar2, 0);
                                *(undefined8 *)(param_2 + 0x1ba) = uVar9;
                            }
                        } else if (local_40 == 0x20) {
                            local_48 = FUN_0004bbb0(*local_24);
                            local_44 = local_48;
                            if (local_48 == 0) {
                                V_LOCK();
                                logfmt_raw(auStack_10e4, 0x1000, 0,
                                           "Stratum notify target is zero!");
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/"
                                     "frontend/frontend_x7/frontend_x7.c",
                                     0xac, "stratum_notify_x7", 0x11, 0x11a,
                                     100, auStack_10e4);
                            } else {
                                uVar2 = FUN_000cc2a0(0xffffffff, local_48);
                                uVar9 = FUN_000ccdfc(0xffffffff, 0xffffffff,
                                                     uVar2, 0);
                                param_2[0x1ba] = (uint)uVar9 + 0x80000000;
                                param_2[0x1bb] =
                                    (int)((ulonglong)uVar9 >> 0x20) -
                                    (uint)((uint)uVar9 < 0x80000000);
                            }
                        } else if (local_40 == 8) {
                            hex2bin(&local_e0, local_24, 8);
                            param_2[0x1ba] = local_e0;
                            param_2[0x1bb] = iStack_dc;
                        }
                        if (param_2[0x1b6] != 0) {
                            free((void *)param_2[0x1b6]);
                            param_2[0x1b6] = 0;
                        }
                        if (param_2[0x1b8] != 0) {
                            free((void *)param_2[0x1b8]);
                            param_2[0x1b8] = 0;
                        }
                        pvVar7 = calloc(1, 4);
                        param_2[0x1b8] = (int)pvVar7;
                        *(undefined4 *)param_2[0x1b8] = 0x20;
                        pvVar7 = calloc(*(size_t *)param_2[0x1b8], 1);
                        param_2[0x1b6] = (int)pvVar7;
                        if (param_2[0x1b6] == 0) {
                            V_LOCK();
                            logfmt_raw(auStack_10e4, 0x1000, 0,
                                       "Failed to calloc pool rpc2_blob2");
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/frontend/"
                                 "frontend_x7/frontend_x7.c",
                                 0xac, "stratum_notify_x7", 0x11, 0x12d, 100,
                                 auStack_10e4);
                            pthread_mutex_unlock(
                                (pthread_mutex_t *)(param_2 + 0x1bd));
                            return local_31;
                        }
                        hex2bin(param_2[0x1b6], local_28,
                                *(undefined4 *)param_2[0x1b8]);
                        pthread_mutex_unlock(
                            (pthread_mutex_t *)(param_2 + 0x1bd));
                        if (local_30 == (int *)0x0) {
                            return local_31;
                        }
                        pthread_mutex_lock(
                            (pthread_mutex_t *)(param_2 + 0x18e));
                        iVar4 = *param_2;
                        *local_30 = iVar4;
                        local_30[1] = iVar4 >> 0x1f;
                        if (local_30[0x119] != 0) {
                            free((void *)local_30[0x119]);
                            local_30[0x119] = 0;
                        }
                        pcVar6 = strdup(local_2c);
                        local_30[0x119] = (int)pcVar6;
                        local_e1 = (undefined1)param_2[0x1b7];
                        *(undefined1 *)(local_30 + 2) = local_e1;
                        memcpy((void *)((int)local_30 + 9),
                               (void *)param_2[0x1b5], param_2[0x1b7]);
                        local_4c = local_30 + 0xc;
                        *local_4c = -1;
                        if (local_30[0x11b] != 0) {
                            free((void *)local_30[0x11b]);
                            local_30[0x11b] = 0;
                        }
                        pvVar7 = calloc(1, 0x90);
                        local_30[0x11b] = (int)pvVar7;
                        if (local_30[0x11b] != 0) {
                            local_50 = (char *)local_30[0x11b];
                            strcpy(local_50, (char *)(param_2 + 0x1a5));
                            memcpy(local_50 + 0x40, (void *)param_2[0x1b6],
                                   0x20);
                            *(undefined8 *)(local_50 + 0x60) = local_20;
                            iVar4 = param_2[0x1bb];
                            *(int *)(local_50 + 0x68) = param_2[0x1ba];
                            *(int *)(local_50 + 0x6c) = iVar4;
                            dVar8 = (double)FUN_000ccad4(param_2[0x1ba],
                                                         param_2[0x1bb]);
                            *(double *)(local_30 + 0x10a) =
                                1.8446744073709552e+19 / dVar8;
                            iVar4 = local_30[0x10b];
                            param_2[0x1c4] = local_30[0x10a];
                            param_2[0x1c5] = iVar4;
                            sprintf((char *)(param_2 + 0x1ee), "%13.2f",
                                    param_2[0x1c4], param_2[0x1c5]);
                            pthread_mutex_unlock(
                                (pthread_mutex_t *)(param_2 + 0x18e));
                            return 1;
                        }
                        printf("invalid pointer(%s)!\n", "work->private");
                        return 0;
                    }
                }
            }
        }
    }
    V_LOCK();
    logfmt_raw(auStack_10e4, 0x1000, 0, "Stratum notify: invalid parameters");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
         0xac, "stratum_notify_x7", 0x11, 0xd3, 100, auStack_10e4);
    return local_31;
}

undefined4 FUN_0004e190(int param_1, int param_2)

{
    int iVar1;
    undefined4 local_c;

    if (((*(int *)(param_1 + 0x464) == 0) ||
         (*(int *)(param_2 + 0x62c) == 0)) ||
        (iVar1 =
             strcmp(*(char **)(param_1 + 0x464), *(char **)(param_2 + 0x62c)),
         iVar1 != 0)) {
        local_c = 2;
    } else {
        local_c = 0;
    }
    return local_c;
}

undefined4 FUN_0004e210(int param_1, int param_2, char *param_3)

{
    undefined4 uVar1;
    int iVar2;
    undefined1 auStack_5c[68];
    undefined1 auStack_18[12];
    int local_c;

    local_c = *(int *)(param_1 + 0x46c);
    if (local_c == 0) {
        printf("invalid pointer(%s)!\n", "private");
        uVar1 = 3;
    } else {
        bin2hex(auStack_18, param_1 + 0x430, 4);
        bin2hex(auStack_5c, local_c + 0x70, 0x20);
        iVar2 = *(int *)(param_2 + 0x780);
        *(int *)(param_2 + 0x780) = iVar2 + 1;
        snprintf(param_3, 0xc00,
                 "{\"id\":%d,\"jsonrpc\":\"2.0\",\"method\":\"submit\","
                 "\"params\":{\"id\":\"%s\",\"job_id\":\"%s\",\"nonce\":\"%s\","
                 "\"result\":\"%s\",\"algo\":\"rx/0\"}}",
                 iVar2, local_c, *(undefined4 *)(param_1 + 0x464), auStack_18,
                 auStack_5c);
        uVar1 = 0;
    }
    return uVar1;
}

char stratum_handle_response_x7(int param_1, undefined4 param_2, int param_3)

{
    int iVar1;
    int *piVar2;
    undefined4 uVar3;
    char *__s1;
    undefined1 auStack_1124[4096];
    undefined4 local_124[23];
    undefined1 auStack_c8[160];
    undefined4 local_28;
    char local_21;
    int *local_20;
    int local_1c;
    int *local_18;
    int *local_14;
    undefined4 local_10;
    int local_c;

    local_21 = '\0';
    local_1c = json_loads(param_2, 0, local_124);
    if (local_1c == 0) {
        V_LOCK();
        logfmt_raw(auStack_1124, 0x1000, 0, "JSON decode failed(%d): %s",
                   local_124[0], auStack_c8);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_x7/"
             "frontend_x7.c",
             0xac, "stratum_handle_response_x7", 0x1a, 0x17c, 0x28,
             auStack_1124);
        goto LAB_0004e8cc;
    }
    local_20 = (int *)json_object_get(local_1c, &DAT_000eb8d8);
    local_10 = json_object_get(local_1c, "jsonrpc");
    local_14 = (int *)json_object_get(local_1c, "error");
    local_18 = (int *)json_object_get(local_1c, "result");
    local_c = json_object_get(local_18, &DAT_000eb834);
    if (local_c != 0) {
        local_21 = (**(code **)(param_1 + 0x30))(param_1, param_3, local_c);
        if (local_21 == '\0') {
            pool_tclear(param_3, param_3 + 0x77c, 0);
        } else {
            pool_tset(param_3, param_3 + 0x77c, 1);
        }
        goto LAB_0004e8cc;
    }
    if ((local_20 == (int *)0x0) ||
        ((local_20 != (int *)0x0 && (*local_20 == 7)))) {
        V_LOCK();
        logfmt_raw(auStack_1124, 0x1000, 0, "%s json id is null!",
                   "stratum_handle_response_x7");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_x7/"
             "frontend_x7.c",
             0xac, "stratum_handle_response_x7", 0x1a, 400, 0x14, auStack_1124);
        goto LAB_0004e8cc;
    }
    if (local_14 == (int *)0x0) {
        V_LOCK();
        logfmt_raw(auStack_1124, 0x1000, 0, "%s no error value!",
                   "stratum_handle_response_x7");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_x7/"
             "frontend_x7.c",
             0xac, "stratum_handle_response_x7", 0x1a, 0x19a, 0x14,
             auStack_1124);
        goto LAB_0004e8cc;
    }
    if ((local_14 == (int *)0x0) || (*local_14 != 7)) {
        if ((local_14 != (int *)0x0) &&
            ((*local_14 == 0 &&
              (iVar1 = json_object_get(local_14, "message"), iVar1 != 0)))) {
            piVar2 = (int *)json_object_get(local_14, "message");
            if (*piVar2 == 2) {
                uVar3 = json_object_get(local_14, "message");
                uVar3 = json_string_value(uVar3);
                share_result(0, 0, uVar3, param_3);
                local_28 = json_integer_value(local_20);
            LAB_0004e8c4:
                local_21 = '\x01';
                goto LAB_0004e8cc;
            }
        }
        V_LOCK();
        logfmt_raw(auStack_1124, 0x1000, 0, "%s error value error!",
                   "stratum_handle_response_x7");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_x7/"
             "frontend_x7.c",
             0xac, "stratum_handle_response_x7", 0x1a, 0x1ac, 0x14,
             auStack_1124);
    } else {
        if ((((local_18 != (int *)0x0) && (local_18 != (int *)0x0)) &&
             (*local_18 == 0)) &&
            (iVar1 = json_object_get(local_18, "status"), iVar1 != 0)) {
            piVar2 = (int *)json_object_get(local_18, "status");
            if (*piVar2 == 2) {
                uVar3 = json_object_get(local_18, "status");
                __s1 = (char *)json_string_value(uVar3);
                iVar1 = strcasecmp(__s1, "OK");
                if (iVar1 == 0) {
                    share_result(1, 0, 0, param_3);
                    goto LAB_0004e8c4;
                }
            }
        }
        V_LOCK();
        logfmt_raw(auStack_1124, 0x1000, 0, "%s result value error!",
                   "stratum_handle_response_x7");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/frontend/frontend_x7/"
             "frontend_x7.c",
             0xac, "stratum_handle_response_x7", 0x1a, 0x1a3, 0x14,
             auStack_1124);
    }
LAB_0004e8cc:
    if (local_1c != 0) {
        FUN_0004bbd8(local_1c);
    }
    return local_21;
}

void *frontend_runtime_x7(void)

{
    void *__dest;

    DAT_00152388 = stratum_connect;
    DAT_0015238c = stratum_disconnect;
    DAT_00152390 = stratum_recv_line;
    DAT_00152394 = stratum_send_line;
    DAT_00152398 = stratum_login_x7;
    DAT_0015239c = stratum_handle_method_x7;
    DAT_001523a0 = pre_stratum_handle_method_x7;
    DAT_001523a4 = stratum_handle_response_x7;
    DAT_001523a8 = FUN_0004e210;
    DAT_001523ac = FUN_0004e190;
    DAT_001523b0 = stratum_subscribe_base;
    DAT_001523b4 = stratum_authorize_base;
    DAT_001523b8 = FUN_0004cf84;
    DAT_001523bc = 0;
    DAT_001523c0 = 0;
    DAT_001523c4 = 0;
    DAT_001523c8 = 0;
    DAT_001523cc = 0;
    __dest = calloc(1, 0x54);
    memcpy(__dest, &DAT_00152388, 0x54);
    return __dest;
}

void FUN_0004ea88(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_0004ec14(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

/* WARNING: Restarted to delay deadcode elimination for space: stack */

int FUN_0004eda4(int param_1, int param_2)

{
    int iVar1;
    int local_68;
    int local_60[19];
    undefined4 local_14;
    int local_10;
    int local_c;

    local_c = 0;
    local_60[9] = 0x3c;
    local_60[10] = 0x32;
    local_60[0xb] = 0x25;
    local_60[0xc] = 0x20;
    local_60[0xd] = 0x11;
    local_60[0xe] = 8;
    local_60[0xf] = 0;
    local_60[0x10] = 0xfffffffa;
    local_60[0x11] = 0xffffffed;
    local_60[0] = -10;
    local_60[1] = 0;
    local_60[2] = 10;
    local_60[3] = 0x14;
    local_60[4] = 0x1e;
    local_60[5] = 0x28;
    local_60[6] = 0x32;
    local_60[7] = 0x3c;
    local_60[8] = 0x46;
    local_14 = 9;
    if (param_2 < DAT_0014e3a4) {
        local_68 = param_2 + 1;
    } else {
        local_68 = param_2;
        if (DAT_0014e3a4 < param_2) {
            local_68 = param_2 + -1;
        }
    }
    local_60[0x12] = local_68 - *(int *)(param_1 + 0x60);
    DAT_0014e3a4 = local_68;
    local_10 = 0;
    do {
        if (7 < local_10) {
        LAB_0004ef14:
            if (0x3c < local_60[0x12]) {
                local_c = -10;
            }
            if (local_60[0x12] < -0x12) {
                local_c = 0x46;
            }
            iVar1 = -10;
            if (99 < local_c) {
                local_c = 100;
            }
            if (-10 < local_c) {
                iVar1 = local_c;
            }
            return iVar1;
        }
        if ((local_60[local_10 + 10] < local_60[0x12]) &&
            (local_60[0x12] <= local_60[local_10 + 9])) {
            local_c = local_60[local_10];
            goto LAB_0004ef14;
        }
        local_10 = local_10 + 1;
    } while (true);
}

int set_frequency_with_voltage_1491(undefined4 *param_1)

{
    undefined4 uVar1;
    int iVar2;
    uint uVar3;
    undefined8 uVar4;
    undefined1 auStack_1094[4096];
    pthread_t local_94;
    timespec local_90;
    timespec local_88;
    int local_80;
    int local_7c;
    int local_78;
    timespec *local_74;
    timespec *local_70;
    undefined4 local_6c;
    int local_68;
    undefined4 local_64;
    int local_60;
    undefined4 local_5c;
    int local_58;
    float fStack_54;
    int local_50;
    int local_4c;
    int local_48;
    int local_44;
    float local_40;
    float local_3c;
    int *local_38;
    int local_34;
    int local_30;
    float local_2c;
    int local_28;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;

    local_34 = 0;
    local_78 = 0;
    local_38 = (int *)get_all_created_runtime(&local_78);
    local_3c = 12.5;
    local_2c = (float)(longlong) * (int *)(*local_38 + 0x1d0);
    if (*(float *)(*local_38 + 0x450) <= (float)param_1[0x1c]) {
        local_40 = *(float *)(*local_38 + 0x450);
    } else {
        local_40 = (float)param_1[0x1c];
    }
    local_20 = 120000;
    local_44 = (int)((local_40 - local_2c) / 12.5);
    local_7c = -0x40;
    local_80 = 0xff;
    local_48 = 10;
    local_24 = get_current_voltage();
    local_4c = get_working_voltage();
    local_50 = 0;
    local_28 = local_4c;
    local_1c = FUN_000cc518(local_24 - local_4c, local_48);
    fStack_54 = local_40 * (float)param_1[0x1e];
    if (param_1[0x19] != -0x40) {
        local_50 = (*(code *)*param_1)(param_1, param_1[0x19]);
        local_28 = local_50 + local_4c;
        local_1c = FUN_000cc518(local_24 - local_28, local_48);
    }
    local_14 = 0;
    do {
        if (local_44 <= local_14) {
        LAB_0004f3d8:
            local_34 = check_temperature_base(param_1, &local_7c, &local_80);
            if (local_34 == 0) {
                if ((local_7c < 0x46) && (local_80 < 0x46)) {
                    V_LOCK();
                    logfmt_raw(auStack_1094, 0x1000, 0,
                               "Warming up chains, please wait...");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "machine_runtime/ltc_1491/machine_runtime_ltc_1491.c",
                         0xbd, "set_frequency_with_voltage_1491", 0x1f, 0xbc,
                         0x3c, auStack_1094);
                }
                for (;
                     ((local_7c < 0x46 && (local_80 < 0x46)) && (0 < local_20));
                     local_20 =
                         local_20 -
                         ((local_74[1].tv_nsec - local_74->tv_nsec) / 1000000 +
                          (int)uVar4)) {
                    local_70 = &local_90;
                    clock_gettime(1, local_70);
                    fan_pwm_set(0x1e);
                    sleep(1);
                    for (local_30 = 0; local_30 < local_78;
                         local_30 = local_30 + 1) {
                        local_34 = check_temperature_base(param_1, &local_7c,
                                                          &local_80);
                        if (local_34 != 0) {
                            return local_34;
                        }
                        if (DAT_001523dc == 0) {
                            V_LOCK();
                            logfmt_raw(auStack_1094, 0x1000, 0,
                                       "warming up, min temp %d max temp %d",
                                       local_7c, local_80);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/"
                                 "machine_runtime/ltc_1491/"
                                 "machine_runtime_ltc_1491.c",
                                 0xbd, "set_frequency_with_voltage_1491", 0x1f,
                                 0xc6, 0x28, auStack_1094);
                        }
                        DAT_001523dc = (DAT_001523dc + 1) % 10;
                    }
                    local_74 = &local_90;
                    clock_gettime(1, &local_88);
                    iVar2 = local_74[1].tv_sec - local_74->tv_sec;
                    uVar4 = VectorShiftLeft((longlong)iVar2, 5, 0x40, 0);
                    uVar4 = VectorSub(uVar4, (longlong)iVar2, 8);
                    uVar4 = VectorAdd(uVar4, uVar4, 8);
                    uVar3 = (uint)uVar4;
                    uVar4 =
                        VectorAdd(CONCAT44((int)((ulonglong)uVar4 >> 0x20) * 2 +
                                               (uint)CARRY4(uVar3, uVar3),
                                           uVar3 * 2),
                                  (longlong)iVar2, 8);
                    uVar4 = VectorShiftLeft(uVar4, 3, 0x40, 0);
                }
                fan_pwm_set(0x32);
                pthread_create(&local_94, (pthread_attr_t *)0x0,
                               thread_monitor_temperature_in_startup_stage,
                               param_1);
                if ((int)param_1[0x19] < 8) {
                    local_68 = get_current_voltage();
                    local_6c = 0x58c;
                    iVar2 = local_68 + -0x58c;
                    if (iVar2 < 0) {
                        iVar2 = -iVar2;
                    }
                    if (9 < iVar2) {
                        V_LOCK();
                        logfmt_raw(auStack_1094, 0x1000, 0,
                                   "cur_voltage:%d, set voltage to %d",
                                   local_68, local_6c);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/machine_runtime/"
                             "ltc_1491/machine_runtime_ltc_1491.c",
                             0xbd, "set_frequency_with_voltage_1491", 0x1f,
                             0xd4, 0x28, auStack_1094);
                        uVar1 = is_power_init();
                        set_voltage_by_steps(local_6c, uVar1, 100);
                    }
                } else if ((int)param_1[0x19] < 0x21) {
                    local_60 = get_current_voltage();
                    local_64 = 0x56e;
                    iVar2 = local_60 + -0x56e;
                    if (iVar2 < 0) {
                        iVar2 = -iVar2;
                    }
                    if (9 < iVar2) {
                        V_LOCK();
                        logfmt_raw(auStack_1094, 0x1000, 0,
                                   "cur_voltage:%d, set voltage to %d",
                                   local_60, local_64);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/machine_runtime/"
                             "ltc_1491/machine_runtime_ltc_1491.c",
                             0xbd, "set_frequency_with_voltage_1491", 0x1f,
                             0xde, 0x28, auStack_1094);
                        uVar1 = is_power_init();
                        set_voltage_by_steps(local_64, uVar1, 100);
                    }
                } else {
                    local_58 = get_current_voltage();
                    local_5c = 0x546;
                    iVar2 = local_58 + -0x546;
                    if (iVar2 < 0) {
                        iVar2 = -iVar2;
                    }
                    if (9 < iVar2) {
                        V_LOCK();
                        logfmt_raw(auStack_1094, 0x1000, 0,
                                   "cur_voltage:%d, set voltage to %d",
                                   local_58, local_5c);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/machine_runtime/"
                             "ltc_1491/machine_runtime_ltc_1491.c",
                             0xbd, "set_frequency_with_voltage_1491", 0x1f,
                             0xe8, 0x28, auStack_1094);
                        uVar1 = is_power_init();
                        set_voltage_by_steps(local_5c, uVar1, 100);
                    }
                }
                *(undefined1 *)(param_1 + 0x20) = 1;
                sleep(1);
                pthread_join(local_94, (void **)0x0);
                local_3c = 6.25;
                local_44 = (int)((local_40 - local_2c) / 6.25);
                for (local_18 = 0; local_18 < local_44;
                     local_18 = local_18 + 1) {
                    local_2c = local_2c + local_3c;
                    for (local_30 = 0; local_30 < local_78;
                         local_30 = local_30 + 1) {
                        if (local_38[local_30] == 0) {
                            printf("invalid pointer(%s)!\n", "be_runtimes[b]");
                            return 3;
                        }
                        iVar2 = (**(code **)(local_38[local_30] + 0xc0))(
                            local_2c, local_38[local_30], 0);
                        if (iVar2 != 0) {
                            return iVar2;
                        }
                        local_34 = 0;
                    }
                    usleep(param_1[0x1b]);
                }
            }
            return local_34;
        }
        local_2c = local_2c + local_3c;
        if (850.0 < local_2c) {
            local_2c = 850.0;
            goto LAB_0004f3d8;
        }
        for (local_30 = 0; local_30 < local_78; local_30 = local_30 + 1) {
            if (local_38[local_30] == 0) {
                printf("invalid pointer(%s)!\n", "be_runtimes[b]");
                return 3;
            }
            iVar2 = (**(code **)(local_38[local_30] + 0xc0))(
                local_2c, local_38[local_30], 0);
            if (iVar2 != 0) {
                return iVar2;
            }
            local_34 = 0;
        }
        usleep(param_1[0x1b]);
        if (((local_48 * 2 + local_28 < local_24) && (fStack_54 < local_2c)) &&
            (local_44 - local_1c <= local_14)) {
            local_24 = local_24 - local_48;
            local_34 = (*(code *)param_1[7])(param_1, local_24);
            if (local_34 != 0) {
                return local_34;
            }
            usleep(200000);
        }
        local_14 = local_14 + 1;
    } while (true);
}

void *machine_runtime_ctrl_ltc_1491(void)

{
    code *local_90;
    undefined1 *local_8c;
    code *local_88;
    code *local_84;
    undefined1 *local_78;
    code *local_74;
    code *local_70;
    code *local_6c;
    code *local_68;
    code *local_64;
    code *local_60;
    code *local_58;
    code *local_54;
    code *local_50;
    code *local_4c;
    code *local_48;
    word *local_38;
    undefined4 local_34;
    undefined4 local_28;
    undefined4 local_24;
    undefined4 local_20;
    undefined4 local_18;
    char *local_14;
    void *local_c;

    memset(&local_90, 0, 0x84);
    local_90 = FUN_0004eda4;
    local_8c = &LAB_0004ef98;
    local_88 = get_working_voltage_base;
    local_84 = start_voltage_monitor_base;
    local_78 = &LAB_0004efd0;
    local_74 = set_voltage_base;
    local_70 = start_freq_compensate_thread_base;
    local_6c = calc_freq_compensate_by_temp_base;
    local_68 = set_baud_base;
    local_64 = set_frequency_with_voltage_1491;
    local_60 = start_mining_base;
    local_58 = stop_mining_base;
    local_54 = reset_mining_base;
    local_50 = check_asic_num_base;
    local_4c = check_bringup_temperature_base;
    local_48 = hot_cold_restart_base;
    local_38 = &WORD_0001c200;
    local_34 = 1500000;
    local_28 = 0x5dc;
    local_24 = 500000;
    local_20 = 0x44fa0000;
    local_18 = 0x3f800000;
    local_14 = "/config/sn";
    local_c = calloc(1, 0x84);
    if (local_c == (void *)0x0) {
        printf("invalid pointer(%s)!\n", "new_machine_runtime");
        local_c = (void *)0x0;
    } else {
        memcpy(local_c, &local_90, 0x84);
    }
    return local_c;
}

undefined4 FUN_0004fc8c(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "chain", param_3, param_4);
    return param_1;
}

void FUN_0004fcc0(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_0004fe4c(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

char *FUN_0004ffdc(char *param_1)

{
    char *__dest;
    char *pcVar1;

    __dest = (char *)calloc(1, 8);
    pcVar1 = strchr(param_1, 0x5f);
    if ((pcVar1 != (char *)0x0) && ((int)pcVar1 - (int)param_1 < 8)) {
        strncpy(__dest, param_1, (int)pcVar1 - (int)param_1);
    }
    return __dest;
}

char *FUN_0005005c(char *param_1)

{
    char *__dest;
    char *__s;
    size_t sVar1;
    size_t sVar2;

    __dest = (char *)calloc(1, 8);
    __s = strchr(param_1, 0x5f);
    if (__s != (char *)0x0) {
        sVar1 = strlen(param_1);
        sVar2 = strlen(__s);
        if (sVar1 - sVar2 < 8) {
            strcpy(__dest, __s + 1);
        }
    }
    return __dest;
}

undefined4 get_chip_ft_correspond(undefined4 *param_1, undefined4 *param_2)

{
    if (opt_algo == 0xb) {
        *param_1 = &DAT_0014e4a8;
    } else {
        *param_1 = &DAT_0014e5d4;
    }
    *param_2 = 0x19;
    return 0;
}

undefined4 support_of_sleepmode(int param_1)

{
    undefined4 uVar1;

    if ((((param_1 == 0) || (param_1 == 1)) || (param_1 == 2)) ||
        (((param_1 == 4 || (param_1 == 3)) ||
          ((param_1 == 5 || (param_1 == 8)))))) {
        uVar1 = 1;
    } else {
        uVar1 = 0;
    }
    return uVar1;
}

void FUN_000501d8(void)

{
    undefined1 auStack_1014[4096];
    int local_14;
    int local_10;
    int local_c;

    local_14 = 0;
    local_c = get_all_created_runtime(&local_14);
    local_10 = 0;
    while (true) {
        if (local_14 <= local_10)
            break;
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, "chain[%d] %s", local_10,
                   *(int *)(local_c + local_10 * 4) + 0x140);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "show_backend_info", 0x11, 0x52, 0x14, auStack_1014);
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, "chain[%d] %x", local_10,
                   *(undefined4 *)(*(int *)(local_c + local_10 * 4) + 0x148));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "show_backend_info", 0x11, 0x53, 0x14, auStack_1014);
        local_10 = local_10 + 1;
    }
    return;
}

undefined4 FUN_00050364(int param_1)

{
    undefined4 uVar1;
    int iVar2;
    int local_28;
    undefined2 local_24;
    int local_20;
    void *local_1c;
    char *local_18;
    int local_14;

    local_18 = (char *)FUN_0004ffdc((&PTR_s_ckb_2040_0014e3ac)[param_1]);
    local_1c = (void *)FUN_0005005c((&PTR_s_ckb_2040_0014e3ac)[param_1]);
    local_24 = 0;
    str2hex(&local_24, local_1c, 4);
    local_28 = 0;
    local_20 = get_all_created_runtime(&local_28);
    for (local_14 = 0; local_14 < local_28; local_14 = local_14 + 1) {
        strcpy((char *)(*(int *)(local_20 + local_14 * 4) + 0x140), local_18);
        *(uint *)(*(int *)(local_20 + local_14 * 4) + 0x148) =
            (uint)CONCAT11((undefined1)local_24, local_24._1_1_);
        uVar1 = platform_is_adjustable_power();
        *(undefined4 *)(*(int *)(local_20 + local_14 * 4) + 0x468) = uVar1;
        iVar2 = *(int *)(local_20 + local_14 * 4);
        uVar1 = platform_get_chain_sensor_num(local_14);
        *(undefined4 *)(iVar2 + 0x18c) = uVar1;
        iVar2 = *(int *)(local_20 + local_14 * 4);
        uVar1 = platform_get_sensor_max_chip_temp(local_14);
        *(undefined4 *)(iVar2 + 400) = uVar1;
        iVar2 = *(int *)(local_20 + local_14 * 4);
        uVar1 = platform_get_sensor_max_pcb_temp(local_14);
        *(undefined4 *)(iVar2 + 0x194) = uVar1;
        iVar2 = *(int *)(local_20 + local_14 * 4);
        uVar1 = platform_get_sensor_min_pcb_temp(local_14);
        *(undefined4 *)(iVar2 + 0x198) = uVar1;
        iVar2 = *(int *)(local_20 + local_14 * 4);
        uVar1 = platform_get_sensor_max_uneffective_count(local_14);
        *(undefined4 *)(iVar2 + 0x19c) = uVar1;
    }
    free(local_18);
    free(local_1c);
    uVar1 = platform_get_psu_gpio_port();
    set_bitmain_power_gpio_port(uVar1);
    return 0;
}

undefined4 FUN_00050564(void)

{
    return 0;
}

undefined4 set_baud_base(undefined4 param_1, int param_2)

{
    undefined4 uVar1;
    int iVar2;
    int iVar3;
    undefined1 auStack_1038[4096];
    int local_38;
    char local_31;
    int local_30;
    int local_2c;
    int local_28;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    undefined4 local_14;

    local_14 = 0;
    local_38 = 0;
    local_24 = get_all_created_runtime(&local_38);
    if (3000000 < param_2) {
        local_28 = 3;
        local_1c = 0;
        V_LOCK();
        uVar1 = platform_get_chain_domain_num();
        logfmt_raw(auStack_1038, 0x1000, 0, "chain_domain_num:%d", uVar1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "set_baud_base", 0xd, 0x99, 0x14, auStack_1038);
        V_LOCK();
        uVar1 = platform_get_domain_asic_num();
        logfmt_raw(auStack_1038, 0x1000, 0, "domain_asic_num :%d", uVar1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "set_baud_base", 0xd, 0x9a, 0x14, auStack_1038);
        local_20 = platform_get_chain_domain_num();
        for (local_20 = local_20 - local_28; -1 < local_20;
             local_20 = local_20 - local_28) {
            iVar3 = local_20 + 1;
            iVar2 = platform_get_domain_asic_num();
            local_2c = iVar2 * iVar3 + -1;
            local_1c = local_1c + 1;
            local_30 = local_1c * 3 + 0xf;
            local_18 = 0;
            while (true) {
                if (local_38 <= local_18)
                    break;
                local_31 = platform_get_asic_addr_interval(local_18);
                local_31 = local_31 * (char)local_2c;
                (**(code **)(*(int *)(local_24 + local_18 * 4) + 0x68))(
                    *(undefined4 *)(local_24 + local_18 * 4), local_31,
                    local_30);
                local_18 = local_18 + 1;
            }
        }
        usleep(100000);
    }
    local_18 = 0;
    while (true) {
        if (local_38 <= local_18)
            break;
        (**(code **)(*(int *)(local_24 + local_18 * 4) + 0x58))(
            *(undefined4 *)(local_24 + local_18 * 4), param_2);
        usleep(10000);
        local_18 = local_18 + 1;
    }
    iVar2 = dev_ctrl();
    (**(code **)(iVar2 + 0x10))(param_2);
    usleep(10000);
    return local_14;
}

undefined4 check_bringup_temperature_base(int param_1)

{
    undefined4 *puVar1;
    int iVar2;
    undefined1 auStack_1324[4096];
    int local_324;
    undefined4 uStack_320;
    undefined4 uStack_31c;
    undefined4 uStack_318;
    undefined4 local_314;
    undefined4 uStack_310;
    undefined4 uStack_30c;
    int local_308;
    undefined4 uStack_304;
    undefined4 uStack_300;
    undefined4 uStack_2fc;
    undefined4 local_2f8;
    undefined4 uStack_2f4;
    undefined4 uStack_2f0;
    int local_2ec;
    undefined4 auStack_2e8[64];
    undefined4 auStack_1e8[64];
    undefined4 local_e8;
    undefined4 uStack_e4;
    undefined4 uStack_e0;
    undefined4 uStack_dc;
    undefined4 local_d8;
    undefined4 uStack_d4;
    undefined4 uStack_d0;
    undefined4 uStack_cc;
    undefined4 local_c8;
    undefined4 uStack_c4;
    undefined4 uStack_c0;
    undefined4 uStack_bc;
    undefined4 local_b8;
    undefined4 uStack_b4;
    undefined4 uStack_b0;
    undefined4 uStack_ac;
    undefined4 local_a8;
    undefined4 uStack_a4;
    undefined4 uStack_a0;
    undefined4 uStack_9c;
    undefined4 local_98;
    undefined4 uStack_94;
    undefined4 uStack_90;
    undefined4 uStack_8c;
    undefined4 local_88;
    undefined4 uStack_84;
    undefined4 uStack_80;
    undefined4 uStack_7c;
    undefined4 local_78;
    undefined4 uStack_74;
    undefined4 uStack_70;
    undefined4 uStack_6c;
    undefined4 local_68;
    undefined4 uStack_64;
    undefined4 uStack_60;
    undefined4 uStack_5c;
    undefined4 local_58;
    undefined4 uStack_54;
    undefined4 uStack_50;
    undefined4 uStack_4c;
    int local_48;
    int local_44;
    void *local_40;
    int local_3c;
    undefined4 local_38;
    int local_34;
    int local_30;
    int local_2c;
    int local_28;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;

    local_38 = 0;
    local_34 = 0x100;
    local_30 = 0xff;
    local_2c = 0;
    local_28 = 0;
    local_24 = 0;
    local_20 = 0;
    local_2ec = 0;
    local_3c = get_all_created_runtime(&local_2ec);
    for (local_18 = 0; local_18 < local_2ec; local_18 = local_18 + 1) {
        iVar2 = *(int *)(*(int *)(local_3c + local_18 * 4) + 0x18c);
        if (iVar2 <= local_34) {
            local_34 = iVar2;
        }
    }
    if (local_34 == 0x100) {
        local_34 = 2;
    }
    local_40 = calloc(local_34 * local_2ec, 0xc);
    if (local_40 == (void *)0x0) {
        printf("invalid pointer(%s)!\n", "sensor_status");
        local_38 = 3;
    } else {
        for (local_18 = 0; local_18 < local_2ec; local_18 = local_18 + 1) {
            (**(code **)(*(int *)(local_3c + local_18 * 4) + 0xe4))(
                *(undefined4 *)(local_3c + local_18 * 4),
                (void *)((int)local_40 + local_34 * local_18 * 0xc));
        }
        for (local_1c = 0; local_1c < local_34; local_1c = local_1c + 1) {
            for (local_18 = 0; local_18 < local_2ec; local_18 = local_18 + 1) {
                iVar2 = *(int *)(local_3c + local_18 * 4);
                local_308 = *(int *)(iVar2 + 0x184);
                uStack_304 = *(undefined4 *)(iVar2 + 0x188);
                uStack_300 = *(undefined4 *)(iVar2 + 0x18c);
                uStack_2fc = *(undefined4 *)(iVar2 + 400);
                local_2f8 = *(undefined4 *)(iVar2 + 0x194);
                uStack_2f4 = *(undefined4 *)(iVar2 + 0x198);
                uStack_2f0 = *(undefined4 *)(iVar2 + 0x19c);
                local_48 = local_308 + local_1c * 0x18;
                if (*(int *)((int)local_40 +
                             (local_34 * local_18 + local_1c) * 0xc + 4) !=
                    -0x40) {
                    if (*(int *)(local_48 + 0xc) == 0) {
                        puVar1 = auStack_1e8 + local_2c;
                        local_2c = local_2c + 1;
                        *puVar1 =
                            *(undefined4 *)((int)local_40 +
                                            (local_34 * local_18 + local_1c) *
                                                0xc +
                                            4);
                        V_LOCK();
                        iVar2 =
                            *(int *)(*(int *)(local_3c + local_18 * 4) + 0xfc);
                        FUN_0004fc8c(&local_e8, &local_e8, iVar2,
                                     iVar2 >> 0x1f);
                        logfmt_raw(
                            auStack_1324, 0x1000, 0, uStack_cc, local_e8,
                            uStack_e4, uStack_e0, uStack_dc, local_d8,
                            uStack_d4, uStack_d0, uStack_cc,
                            "chip temp min: %d",
                            *(undefined4 *)((int)local_40 +
                                            (local_34 * local_18 + local_1c) *
                                                0xc +
                                            4));
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/machine_runtime/"
                             "machine_runtime_base.c",
                             0xb0, "check_bringup_temperature_base", 0x1e, 0xda,
                             0x28, auStack_1324);
                    } else if (*(int *)(local_48 + 0xc) == 1) {
                        puVar1 = auStack_2e8 + local_28;
                        local_28 = local_28 + 1;
                        *puVar1 =
                            *(undefined4 *)((int)local_40 +
                                            (local_34 * local_18 + local_1c) *
                                                0xc +
                                            4);
                        V_LOCK();
                        iVar2 =
                            *(int *)(*(int *)(local_3c + local_18 * 4) + 0xfc);
                        FUN_0004fc8c(&local_c8, &local_c8, iVar2,
                                     iVar2 >> 0x1f);
                        logfmt_raw(
                            auStack_1324, 0x1000, 0, uStack_ac, local_c8,
                            uStack_c4, uStack_c0, uStack_bc, local_b8,
                            uStack_b4, uStack_b0, uStack_ac,
                            "chip temp max: %d",
                            *(undefined4 *)((int)local_40 +
                                            (local_34 * local_18 + local_1c) *
                                                0xc +
                                            4));
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/machine_runtime/"
                             "machine_runtime_base.c",
                             0xb0, "check_bringup_temperature_base", 0x1e, 0xdd,
                             0x28, auStack_1324);
                    }
                }
            }
        }
        for (local_18 = 0; local_18 < local_2ec; local_18 = local_18 + 1) {
            iVar2 = *(int *)(local_3c + local_18 * 4);
            local_324 = *(int *)(iVar2 + 0x184);
            uStack_320 = *(undefined4 *)(iVar2 + 0x188);
            uStack_31c = *(undefined4 *)(iVar2 + 0x18c);
            uStack_318 = *(undefined4 *)(iVar2 + 400);
            local_314 = *(undefined4 *)(iVar2 + 0x194);
            uStack_310 = *(undefined4 *)(iVar2 + 0x198);
            uStack_30c = *(undefined4 *)(iVar2 + 0x19c);
            for (local_14 = 0; local_14 < local_34; local_14 = local_14 + 1) {
                if (*(int *)((int)local_40 +
                             (local_34 * local_18 + local_14) * 0xc + 4) ==
                    -0x40) {
                    V_LOCK();
                    iVar2 = *(int *)(*(int *)(local_3c + local_18 * 4) + 0xfc);
                    FUN_0004fc8c(&local_a8, &local_a8, iVar2, iVar2 >> 0x1f);
                    logfmt_raw(
                        auStack_1324, 0x1000, 0, uStack_8c, local_a8, uStack_a4,
                        uStack_a0, uStack_9c, local_98, uStack_94, uStack_90,
                        uStack_8c, "sensor_addr %02x, J0:6",
                        *(undefined4 *)(local_324 + local_14 * 0x18 + 0x14));
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "machine_runtime/machine_runtime_base.c",
                         0xb0, "check_bringup_temperature_base", 0x1e, 0xf4,
                         100, auStack_1324);
                } else {
                    local_44 = local_324 + local_14 * 0x18;
                    if (*(int *)(local_44 + 0xc) == 0) {
                        iVar2 = check_value_valid_with_stdd(
                            auStack_1e8, local_2c,
                            *(undefined4 *)((int)local_40 +
                                            (local_34 * local_18 + local_14) *
                                                0xc +
                                            4));
                        if (iVar2 == 0) {
                            V_LOCK();
                            iVar2 = *(int *)(*(int *)(local_3c + local_18 * 4) +
                                             0xfc);
                            FUN_0004fc8c(&local_88, &local_88, iVar2,
                                         iVar2 >> 0x1f);
                            logfmt_raw(auStack_1324, 0x1000, 0, uStack_6c,
                                       local_88, uStack_84, uStack_80,
                                       uStack_7c, local_78, uStack_74,
                                       uStack_70, uStack_6c,
                                       "sensor_addr %02x, J0:6",
                                       *(undefined4 *)(local_44 + 0x14));
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/"
                                 "machine_runtime/machine_runtime_base.c",
                                 0xb0, "check_bringup_temperature_base", 0x1e,
                                 0xfb, 100, auStack_1324);
                        } else {
                            local_24 = local_24 + 1;
                            iVar2 = *(int *)((int)local_40 +
                                             (local_34 * local_18 + local_14) *
                                                 0xc +
                                             4);
                            if (iVar2 <= local_30) {
                                local_30 = iVar2;
                            }
                        }
                    } else if (*(int *)(local_44 + 0xc) == 1) {
                        iVar2 = check_value_valid_with_stdd(
                            auStack_2e8, local_28,
                            *(undefined4 *)((int)local_40 +
                                            (local_34 * local_18 + local_14) *
                                                0xc +
                                            4));
                        if (iVar2 == 0) {
                            V_LOCK();
                            iVar2 = *(int *)(*(int *)(local_3c + local_18 * 4) +
                                             0xfc);
                            FUN_0004fc8c(&local_68, &local_68, iVar2,
                                         iVar2 >> 0x1f);
                            logfmt_raw(auStack_1324, 0x1000, 0, uStack_4c,
                                       local_68, uStack_64, uStack_60,
                                       uStack_5c, local_58, uStack_54,
                                       uStack_50, uStack_4c,
                                       "sensor_addr %02x, J0:6",
                                       *(undefined4 *)(local_44 + 0x14));
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/"
                                 "machine_runtime/machine_runtime_base.c",
                                 0xb0, "check_bringup_temperature_base", 0x1e,
                                 0x103, 100, auStack_1324);
                        } else {
                            local_20 = local_20 + 1;
                        }
                    }
                }
            }
        }
        free(local_40);
        if ((local_24 < 1) || (local_20 < 1)) {
            V_LOCK();
            logfmt_raw(
                auStack_1324, 0x1000, 0,
                "J0:6, temp sensor error, pls check it, and reboot system");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/machine_runtime_base.c",
                 0xb0, "check_bringup_temperature_base", 0x1e, 0x10f, 100,
                 auStack_1324);
            do {
                /* WARNING: Do nothing block with infinite loop */
            } while (true);
        }
        *(int *)(param_1 + 100) = local_30;
    }
    return local_38;
}

undefined4 calc_startup_fan_pwm_base(int param_1)

{
    undefined4 uVar1;

    if (param_1 == -0x40) {
        uVar1 = 0x28;
    } else if (param_1 + 10 < 0 == SCARRY4(param_1, 10)) {
        if (param_1 < 0x23) {
            uVar1 = 0x3c;
        } else {
            uVar1 = 0x50;
        }
    } else {
        uVar1 = 0x28;
    }
    return uVar1;
}

int get_working_voltage_base(undefined4 *param_1)

{
    int iVar1;
    undefined1 auStack_1028[24];
    undefined4 local_1010;
    undefined4 local_28;
    undefined4 local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;

    local_14 = 0;
    local_18 = 0;
    local_1c = 0;
    local_20 = get_temp(1);
    local_24 = get_temp(2);
    local_1c = get_working_voltage();
    if (local_20 != -0x40) {
        if (DAT_0014e700 - local_20 < 6) {
            DAT_001523f0 = 0;
            local_14 = 0;
        } else {
            DAT_001523f0 = DAT_001523f0 + 1;
            if (1 < DAT_001523f0) {
                local_14 = 0x14;
            }
        }
        DAT_0014e700 = local_20;
        local_18 = (*(code *)*param_1)(param_1, local_20);
        local_28 = 0x41;
        platform_get_fan_control_info(auStack_1028);
        local_28 = local_1010;
        iVar1 = (*(code *)param_1[1])(param_1, local_20, local_24, local_1010);
        local_14 = local_14 + iVar1;
    }
    V_LOCK();
    logfmt_raw(auStack_1028, 0x1000, 0,
               "pcb_temp_min:%d, chip_temp_max:%d, working_voltage:%d, "
               "compensate:%d, bias:%d",
               local_20, local_24, local_1c, local_18, local_14);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "machine_runtime/machine_runtime_base.c",
        0xb0, "get_working_voltage_base", 0x18, 0x14a, 0x14, auStack_1028);
    local_14 = local_1c + local_18 + local_14;
    if ((int)param_1[0x1a] <= local_14) {
        local_14 = param_1[0x1a];
    }
    return local_14;
}

void check_working_voltage(int param_1)

{
    undefined4 uVar1;
    int iVar2;
    undefined1 auStack_101c[4096];
    undefined4 local_1c;
    int local_18;
    int local_14;
    undefined4 local_10;
    int local_c;

    local_1c = 0;
    local_c = param_1;
    local_10 = get_all_created_runtime(&local_1c);
    do {
        local_14 = get_current_voltage();
        local_18 = (**(code **)(local_c + 8))(local_c);
        iVar2 = local_14 - local_18;
        if (iVar2 < 0) {
            iVar2 = -iVar2;
        }
        if (9 < iVar2) {
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0,
                       "cur_voltage:%d, set voltage to %d", local_14, local_18);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/machine_runtime_base.c",
                 0xb0, "check_working_voltage", 0x15, 0x15f, 0x28,
                 auStack_101c);
            if (opt_algo == 9) {
                (**(code **)(local_c + 0x1c))(local_c, local_18);
            } else if ((opt_algo == 0xb) || (opt_algo == 0xc)) {
                uVar1 = is_power_init();
                set_voltage_by_steps(local_18, uVar1, 0x14);
            } else {
                uVar1 = is_power_init();
                set_voltage_by_steps(local_18, uVar1, 100);
            }
        }
        sleep(1);
    } while (true);
}

void check_working_freq(int param_1)

{
    int iVar1;
    undefined1 auStack_1054[4096];
    int local_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    float local_30;
    float fStack_2c;
    float local_28;
    int local_24;
    int local_20;
    int local_1c;
    uint local_18;
    int local_14;

    local_54 = 0;
    local_1c = param_1;
    local_20 = get_all_created_runtime(&local_54);
    do {
        local_24 = get_temp(1);
        if (local_24 != -0x40) {
            local_28 =
                (float)(**(code **)(local_1c + 0x24))(local_1c, local_24);
            for (local_14 = 0; local_14 < local_54; local_14 = local_14 + 1) {
                for (local_18 = 0;
                     (int)local_18 <
                     *(int *)(*(int *)(local_20 + local_14 * 4) + 0x150);
                     local_18 = local_18 + 1) {
                    pthread_mutex_lock(
                        (pthread_mutex_t *)(*(int *)(*(int *)(local_20 +
                                                              local_14 * 4) +
                                                     0x210) +
                                            local_18 * 0x2c + 0x14));
                    *(float *)(*(int *)(*(int *)(local_20 + local_14 * 4) +
                                        0x210) +
                               local_18 * 0x2c + 8) = local_28;
                    fStack_2c =
                        local_28 +
                        *(float *)(*(int *)(*(int *)(local_20 + local_14 * 4) +
                                            0x210) +
                                   local_18 * 0x2c + 4);
                    local_30 =
                        *(float *)(*(int *)(*(int *)(local_20 + local_14 * 4) +
                                            0x210) +
                                   local_18 * 0x2c + 0xc);
                    pthread_mutex_unlock(
                        (pthread_mutex_t *)(*(int *)(*(int *)(local_20 +
                                                              local_14 * 4) +
                                                     0x210) +
                                            local_18 * 0x2c + 0x14));
                    if (local_30 != fStack_2c) {
                        if (local_18 == 0) {
                            V_LOCK();
                            logfmt_raw(
                                auStack_1054, 0x1000, 0,
                                "before set_frequency_by_temp base freq %.2f "
                                "bias freq %.2f cur freq %.2f",
                                (double)*(
                                    float *)(*(int *)(*(int *)(local_20 +
                                                               local_14 * 4) +
                                                      0x210) +
                                             local_18 * 0x2c + 4),
                                (double)*(
                                    float *)(*(int *)(*(int *)(local_20 +
                                                               local_14 * 4) +
                                                      0x210) +
                                             local_18 * 0x2c + 8),
                                (double)*(
                                    float *)(*(int *)(*(int *)(local_20 +
                                                               local_14 * 4) +
                                                      0x210) +
                                             local_18 * 0x2c + 0xc));
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/"
                                 "machine_runtime/machine_runtime_base.c",
                                 0xb0, "check_working_freq", 0x12, 399, 0x14,
                                 auStack_1054);
                            if ((fStack_2c < local_30) && (local_28 < -1.0)) {
                                V_LOCK();
                                iVar1 =
                                    *(int *)(*(int *)(local_20 + local_14 * 4) +
                                             0xfc);
                                FUN_0004fc8c(&local_50, &local_50, iVar1,
                                             iVar1 >> 0x1f);
                                logfmt_raw(auStack_1054, 0x1000, 0, uStack_34,
                                           local_50, uStack_4c, uStack_48,
                                           uStack_44, local_40, uStack_3c,
                                           uStack_38, uStack_34,
                                           "Chip temperature is too high, "
                                           "enable protection. Bias freq:%.2f");
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/"
                                     "machine_runtime/machine_runtime_base.c",
                                     0xb0, "check_working_freq", 0x12, 0x192,
                                     0x50, auStack_1054);
                            }
                        }
                        (**(code **)(*(int *)(local_20 + local_14 * 4) + 0xc4))(
                            fStack_2c, *(undefined4 *)(local_20 + local_14 * 4),
                            0, local_18 & 0xff);
                    }
                }
            }
        }
        sleep(1);
    } while (true);
}

undefined1 update_and_automatic_set_freq(undefined1 *param_1)

{
    int local_28;
    char local_21;
    int local_20;
    int local_1c;
    uint local_18;
    undefined1 local_11;
    float local_10;
    int local_c;

    local_28 = 0;
    local_10 = 0.0;
    local_1c = get_all_created_runtime(&local_28);
    local_20 = get_temp(1);
    local_11 = 0;
    local_21 = '\0';
    if (local_20 == -0x40) {
        *param_1 = 0;
    } else {
        *param_1 = 1;
        for (local_c = 0; local_c < local_28; local_c = local_c + 1) {
            (**(code **)(*(int *)(local_1c + local_c * 4) + 200))(
                *(undefined4 *)(local_1c + local_c * 4), local_20);
            local_10 = 0.0;
            for (local_18 = 0;
                 (int)local_18 <
                 *(int *)(*(int *)(local_1c + local_c * 4) + 0x150);
                 local_18 = local_18 + 1) {
                local_21 =
                    (**(code **)(*(int *)(local_1c + local_c * 4) + 0xcc))(
                        *(undefined4 *)(local_1c + local_c * 4), 0,
                        local_18 & 0xff);
                if (local_21 != '\0') {
                    local_11 = 1;
                }
                pthread_mutex_lock(
                    (pthread_mutex_t *)(*(int *)(*(int *)(local_1c +
                                                          local_c * 4) +
                                                 0x210) +
                                        local_18 * 0x2c + 0x14));
                local_10 =
                    local_10 +
                    *(float *)(*(int *)(*(int *)(local_1c + local_c * 4) +
                                        0x210) +
                               local_18 * 0x2c + 0xc);
                pthread_mutex_unlock(
                    (pthread_mutex_t *)(*(int *)(*(int *)(local_1c +
                                                          local_c * 4) +
                                                 0x210) +
                                        local_18 * 0x2c + 0x14));
            }
            *(int *)(*(int *)(local_1c + local_c * 4) + 0x1d0) =
                (int)(local_10 / (float)(longlong) *
                      (int *)(*(int *)(local_1c + local_c * 4) + 0x150));
            *(float *)(*(int *)(local_1c + local_c * 4) + 0x450) =
                local_10 / (float)(longlong) *
                (int *)(*(int *)(local_1c + local_c * 4) + 0x150);
        }
    }
    return local_11;
}

void check_working_freq_new(void)

{
    undefined1 auStack_100c[4099];
    char local_9;

    local_9 = '\x01';
    do {
        update_and_automatic_set_freq(&local_9);
        if (local_9 != '\x01') {
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, "%s, read temp failed",
                       "check_working_freq_new");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/machine_runtime_base.c",
                 0xb0, "check_working_freq_new", 0x16, 0x1d2, 100,
                 auStack_100c);
        }
        sleep(1);
    } while (true);
}

undefined4 start_voltage_monitor_base(void *param_1)

{
    undefined4 uVar1;
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = pthread_create(&DAT_001523e0, (pthread_attr_t *)0x0,
                             check_working_voltage, param_1);
    if (local_c == 0) {
        pthread_detach(DAT_001523e0);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, "start_voltage_monitor");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "start_voltage_monitor_base", 0x1a, 0x1e1, 0x3c,
             auStack_100c);
        uVar1 = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, "voltage monitor create failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "start_voltage_monitor_base", 0x1a, 0x1dd, 100,
             auStack_100c);
        uVar1 = 5;
    }
    return uVar1;
}

undefined4 start_freq_compensate_thread_base(void *param_1)

{
    undefined4 uVar1;
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = pthread_create(&DAT_001523e4, (pthread_attr_t *)0x0,
                             check_working_freq_new, param_1);
    if (local_c == 0) {
        pthread_detach(DAT_001523e4);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, "start freq_compensate_thread");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "start_freq_compensate_thread_base", 0x21, 0x1ef, 0x3c,
             auStack_100c);
        uVar1 = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0,
                   "freq_compensate_thread create failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "start_freq_compensate_thread_base", 0x21, 0x1eb, 100,
             auStack_100c);
        uVar1 = 5;
    }
    return uVar1;
}

void check_working_temp(int param_1)

{
    do {
        get_current_voltage();
        (**(code **)(param_1 + 0x44))(param_1);
        sleep(300);
    } while (true);
}

undefined4 start_temp_monitor_base(void *param_1)

{
    undefined4 uVar1;
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = pthread_create(&DAT_001523e8, (pthread_attr_t *)0x0,
                             check_working_temp, param_1);
    if (local_c == 0) {
        pthread_detach(DAT_001523e8);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, "start_temp_monitor");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "start_temp_monitor_base", 0x17, 0x208, 0x3c, auStack_100c);
        uVar1 = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, "temp monitor create failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "start_temp_monitor_base", 0x17, 0x204, 100, auStack_100c);
        uVar1 = 5;
    }
    return uVar1;
}

void stop_voltage_monitor_base(void)

{
    /* WARNING: Subroutine does not return */
    pthread_exit(&DAT_001523e0);
}

void stop_temp_monitor_base(void)

{
    /* WARNING: Subroutine does not return */
    pthread_exit(&DAT_001523e8);
}

undefined4 set_voltage_base(undefined4 param_1, undefined4 param_2)

{
    undefined4 uVar1;

    uVar1 = is_power_init();
    set_voltage(param_2, uVar1);
    return 0;
}

int set_frequency_with_voltage_base(undefined4 *param_1)

{
    char cVar1;
    int iVar2;
    size_t sVar3;
    undefined4 uVar4;
    undefined4 uVar5;
    undefined1 auStack_2280[4096];
    char acStack_1280[32];
    char acStack_1260[4096];
    undefined4 uStack_260;
    float afStack_25c[128];
    int local_5c;
    undefined4 local_58;
    int local_54;
    int local_50;
    float fStack_4c;
    int local_48;
    int local_44;
    int local_40;
    float local_3c;
    float local_38;
    int *local_34;
    int local_30;
    int local_2c;
    float local_28;
    float local_24;
    int local_20;
    int local_1c;
    int local_18;
    uint local_14;

    local_30 = 0;
    local_5c = 0;
    local_34 = (int *)get_all_created_runtime(&local_5c);
    local_20 = 0;
    local_38 = 6.25;
    local_24 = *(float *)(*local_34 + 0x44c);
    if (*(float *)(*local_34 + 0x450) <= (float)param_1[0x1c]) {
        local_3c = *(float *)(*local_34 + 0x450);
    } else {
        local_3c = (float)param_1[0x1c];
    }
    local_40 = 10;
    local_1c = 0;
    local_44 = get_working_voltage();
    cVar1 = is_check_asic_voltage_enable();
    if (cVar1 != '\x01') {
        local_30 = set_check_asic_voltage(1);
        V_LOCK();
        logfmt_raw(auStack_2280, 0x1000, 0,
                   "set high voltage befor rise freq.");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "set_frequency_with_voltage_base", 0x1f, 0x23e, 0x28,
             auStack_2280);
    }
    if (param_1[0x19] != -0x40) {
        local_1c = (*(code *)*param_1)(param_1, param_1[0x19]);
    }
    local_48 = local_1c + local_44;
    fStack_4c = local_3c * (float)param_1[0x1e];
    V_LOCK();
    logfmt_raw(auStack_2280, 0x1000, 0,
               "Initializing chip cluster, please wait, this may take up to 2 "
               "minutes...");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "machine_runtime/machine_runtime_base.c",
        0xb0, "set_frequency_with_voltage_base", 0x1f, 0x248, 0x3c,
        auStack_2280);
    local_20 = get_current_voltage();
    local_50 = FUN_000cc518(local_20 - local_48, local_40);
    local_54 = (int)((local_3c - local_24) / local_38);
    local_18 = 0;
    do {
        if (local_54 <= local_18) {
            if (local_24 != local_3c) {
                for (local_2c = 0; local_2c < local_5c;
                     local_2c = local_2c + 1) {
                    local_30 = (**(code **)(local_34[local_2c] + 0xc0))(
                        local_3c, local_34[local_2c], 0);
                    if (local_30 != 0) {
                        return local_30;
                    }
                    usleep(param_1[0x1b]);
                }
            }
            V_LOCK();
            logfmt_raw(auStack_2280, 0x1000, 0,
                       "set PT2_freq to %.2f, current voltage %d",
                       (double)local_3c, local_20);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/machine_runtime_base.c",
                 0xb0, "set_frequency_with_voltage_base", 0x1f, 0x26b, 0x3c,
                 auStack_2280);
            if (DAT_001523ed != '\x01') {
                for (local_2c = 0; local_2c < local_5c;
                     local_2c = local_2c + 1) {
                    iVar2 = api_get_eeprom_fmt_version(
                        *(undefined4 *)(local_34[local_2c] + 0xf8));
                    if ((iVar2 == 4) &&
                        (iVar2 = api_get_eeprom_asic_freqs(
                             *(undefined4 *)(local_34[local_2c] + 0xf8),
                             afStack_25c, &uStack_260),
                         iVar2 == 0)) {
                        local_28 = 0.0;
                        memset(acStack_1260, 0, 0x1000);
                        for (local_14 = 0;
                             local_14 < *(uint *)(local_34[local_2c] + 0x150);
                             local_14 = local_14 + 1) {
                            local_28 = local_28 + afStack_25c[local_14];
                            sprintf(acStack_1280, "ASIC-%03d [%.2f] ", local_14,
                                    acStack_1280,
                                    (double)afStack_25c[local_14]);
                            strcat(acStack_1260, acStack_1280);
                            if ((local_14 & 7) == 7) {
                                sVar3 = strlen(acStack_1260);
                                (acStack_1260 + sVar3)[0] = '\n';
                                (acStack_1260 + sVar3)[1] = '\0';
                            }
                        }
                        local_28 = local_28 / (float)(longlong) *
                                   (int *)(local_34[local_2c] + 0x150);
                        (**(code **)(local_34[local_2c] + 0xd8))(
                            uStack_260, local_34[local_2c], afStack_25c);
                        iVar2 = local_34[local_2c];
                        *(int *)(iVar2 + 0x1d0) = (int)local_28;
                        *(float *)(local_34[local_2c] + 0x450) =
                            (float)(longlong) * (int *)(iVar2 + 0x1d0);
                        local_58 = api_get_eeprom_sweep_freq(local_2c);
                        V_LOCK();
                        uVar5 = *(undefined4 *)(local_34[local_2c] + 0xf8);
                        uVar4 = api_get_eeprom_PT2_freq(local_2c);
                        logfmt_raw(
                            auStack_2280, 0x1000, 0,
                            "chain:%d, PT2_freq: %d, sweep_average_freq: %.2f, "
                            "sweep_level_freq: %d  sweep_matrix:\n%s",
                            uVar5, uVar4, (double)local_28, local_58,
                            acStack_1260);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/machine_runtime/"
                             "machine_runtime_base.c",
                             0xb0, "set_frequency_with_voltage_base", 0x1f,
                             0x28c, 0x28, auStack_2280);
                    }
                }
            }
            return local_30;
        }
        local_24 = local_24 + local_38;
        for (local_2c = 0; local_2c < local_5c; local_2c = local_2c + 1) {
            if (local_34[local_2c] == 0) {
                printf("invalid pointer(%s)!\n", "be_runtimes[b]");
                return 3;
            }
            local_30 = (**(code **)(local_34[local_2c] + 0xc0))(
                local_24, local_34[local_2c], 0);
            if (local_30 != 0) {
                return local_30;
            }
            usleep(param_1[0x1b]);
        }
        if (((local_40 * 2 + local_48 < local_20) && (fStack_4c < local_24)) &&
            (local_54 - local_50 <= local_18)) {
            local_20 = local_20 - local_40;
            local_30 = (*(code *)param_1[7])(param_1, local_20);
            if (local_30 != 0) {
                return local_30;
            }
            usleep(200000);
        }
        local_18 = local_18 + 1;
    } while (true);
}

undefined4 check_asic_num_base(int param_1)

{
    int iVar1;
    undefined1 auStack_10a0[4096];
    int aiStack_a0[32];
    int local_20;
    int local_1c;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    local_14 = 0;
    local_20 = 0;
    local_10 = get_all_created_runtime(&local_20);
    for (local_c = 0; local_c < local_20; local_c = local_c + 1) {
        if (*(int *)(local_10 + local_c * 4) == 0) {
            printf("invalid pointer(%s)!\n", "be_runtimes[c]");
            return 3;
        }
        iVar1 = dev_ctrl();
        (**(code **)(iVar1 + 0x1c))(local_c);
    }
    V_LOCK();
    logfmt_raw(auStack_10a0, 0x1000, 0,
               "all backend runtimes have been poweroff.");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "machine_runtime/machine_runtime_base.c",
        0xb0, "check_asic_num_base", 0x13, 0x2a1, 0x3c, auStack_10a0);
    memset(aiStack_a0, 0, 0x80);
    V_LOCK();
    logfmt_raw(auStack_10a0, 0x1000, 0, "start to check asic num test loop");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "machine_runtime/machine_runtime_base.c",
        0xb0, "check_asic_num_base", 0x13, 0x2a6, 0x3c, auStack_10a0);
    local_1c = 1;
    do {
        if (1000 < local_1c) {
            return 0;
        }
        for (local_c = 0; local_c < local_20; local_c = local_c + 1) {
            iVar1 = dev_ctrl();
            (**(code **)(iVar1 + 0x28))(local_c);
        }
        iVar1 = power_init(DAT_001523ec, local_20);
        if (iVar1 != 0) {
            V_LOCK();
            logfmt_raw(auStack_10a0, 0x1000, 0, "power init error!");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/machine_runtime_base.c",
                 0xb0, "check_asic_num_base", 0x13, 0x2af, 100, auStack_10a0);
            V_LOCK();
            logfmt_raw(auStack_10a0, 0x1000, 0, "Sweep error string = %s.",
                       &DAT_000ec7c8);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/machine_runtime_base.c",
                 0xb0, "check_asic_num_base", 0x13, 0x2b0, 100, auStack_10a0);
            return 300;
        }
        for (local_c = 0; local_c < local_20; local_c = local_c + 1) {
            iVar1 = dev_ctrl();
            (**(code **)(iVar1 + 0x24))(local_c);
        }
        (**(code **)(param_1 + 0x28))(param_1, *(undefined4 *)(param_1 + 0x58));
        for (local_c = 0; local_c < local_20; local_c = local_c + 1) {
            local_14 = (*(code *)**(undefined4 **)(local_10 + local_c * 4))(
                *(undefined4 *)(local_10 + local_c * 4));
            if (local_14 == 0) {
                for (local_18 = 0; local_18 < 3; local_18 = local_18 + 1) {
                    iVar1 = dev_ctrl();
                    (**(code **)(iVar1 + 0x18))(
                        *(undefined4 *)(*(int *)(local_10 + local_c * 4) +
                                        0xf8),
                        *(undefined4 *)(*(int *)(local_10 + local_c * 4) +
                                        0x454),
                        *(undefined4 *)(*(int *)(local_10 + local_c * 4) +
                                        0x468));
                    (**(code **)(*(int *)(local_10 + local_c * 4) + 0xe8))(
                        *(undefined4 *)(local_10 + local_c * 4));
                    local_14 =
                        (**(code **)(*(int *)(local_10 + local_c * 4) + 0xdc))(
                            *(undefined4 *)(local_10 + local_c * 4));
                    if (local_14 == 0)
                        break;
                }
                if (local_14 != 0) {
                    aiStack_a0[local_c * 2] = aiStack_a0[local_c * 2] + 1;
                }
                (**(code **)(*(int *)(local_10 + local_c * 4) + 0x1c))(
                    *(undefined4 *)(local_10 + local_c * 4));
                V_LOCK();
                logfmt_raw(auStack_10a0, 0x1000, 0,
                           "chain[%d] check asic num test, loop:%d done, total "
                           "failed times:%d",
                           local_c, local_1c, aiStack_a0[local_c * 2]);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "machine_runtime/machine_runtime_base.c",
                     0xb0, "check_asic_num_base", 0x13, 0x2cf, 0x3c,
                     auStack_10a0);
            }
        }
        local_1c = local_1c + 1;
    } while (true);
}

undefined4 check_temperature_base(undefined4 param_1, int *param_2,
                                  int *param_3)

{
    undefined4 *puVar1;
    int iVar2;
    undefined1 auStack_12f4[4096];
    int local_2f4;
    undefined4 uStack_2f0;
    undefined4 uStack_2ec;
    undefined4 uStack_2e8;
    undefined4 local_2e4;
    undefined4 uStack_2e0;
    undefined4 uStack_2dc;
    int local_2d8;
    undefined4 uStack_2d4;
    undefined4 uStack_2d0;
    undefined4 uStack_2cc;
    undefined4 local_2c8;
    undefined4 uStack_2c4;
    undefined4 uStack_2c0;
    int local_2bc;
    undefined4 auStack_2b8[64];
    undefined4 auStack_1b8[64];
    undefined4 local_b8;
    undefined4 uStack_b4;
    undefined4 uStack_b0;
    undefined4 uStack_ac;
    undefined4 local_a8;
    undefined4 uStack_a4;
    undefined4 uStack_a0;
    undefined4 uStack_9c;
    undefined4 local_98;
    undefined4 uStack_94;
    undefined4 uStack_90;
    undefined4 uStack_8c;
    undefined4 local_88;
    undefined4 uStack_84;
    undefined4 uStack_80;
    undefined4 uStack_7c;
    undefined4 local_78;
    undefined4 uStack_74;
    undefined4 uStack_70;
    undefined4 uStack_6c;
    undefined4 local_68;
    undefined4 uStack_64;
    undefined4 uStack_60;
    undefined4 uStack_5c;
    int local_54;
    int local_50;
    void *local_4c;
    int local_48;
    int local_44;
    int local_40;
    int local_3c;
    int local_38;
    int local_34;
    int local_30;
    undefined4 local_2c;
    int local_28;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;

    local_2c = 0;
    local_28 = 0x100;
    local_24 = 0xff;
    local_1c = -0x40;
    local_20 = 0;
    local_18 = 0;
    local_14 = 0;
    local_30 = 0;
    local_2bc = 0;
    local_44 = 3;
    local_38 = 0;
    local_48 = get_all_created_runtime(&local_2bc);
    for (local_34 = 0; local_34 < local_2bc; local_34 = local_34 + 1) {
        iVar2 = *(int *)(*(int *)(local_48 + local_34 * 4) + 0x18c);
        if (iVar2 <= local_28) {
            local_28 = iVar2;
        }
    }
    if (local_28 == 0x100) {
        local_28 = 2;
    }
    local_4c = calloc(local_28 * local_2bc, 0xc);
    if (local_4c == (void *)0x0) {
        printf("invalid pointer(%s)!\n", "sensor_status");
        local_2c = 3;
    } else {
        for (local_34 = 0; local_34 < local_2bc; local_34 = local_34 + 1) {
            local_38 = 0;
            while (iVar2 =
                       (**(code **)(*(int *)(local_48 + local_34 * 4) + 0xe4))(
                           *(undefined4 *)(local_48 + local_34 * 4),
                           (void *)((int)local_4c + local_28 * local_34 * 0xc)),
                   iVar2 != 0) {
                if (local_44 <= local_38) {
                    V_LOCK();
                    logfmt_raw(auStack_12f4, 0x1000, 0, "%s, %d read temp err",
                               "check_temperature_base", 0x2f9);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "machine_runtime/machine_runtime_base.c",
                         0xb0, "check_temperature_base", 0x16, 0x2f9, 100,
                         auStack_12f4);
                    local_2c = 4;
                }
                local_38 = local_38 + 1;
            }
            usleep(5000);
        }
        for (local_3c = 0; local_3c < local_28; local_3c = local_3c + 1) {
            for (local_34 = 0; local_34 < local_2bc; local_34 = local_34 + 1) {
                iVar2 = *(int *)(local_48 + local_34 * 4);
                local_2d8 = *(int *)(iVar2 + 0x184);
                uStack_2d4 = *(undefined4 *)(iVar2 + 0x188);
                uStack_2d0 = *(undefined4 *)(iVar2 + 0x18c);
                uStack_2cc = *(undefined4 *)(iVar2 + 400);
                local_2c8 = *(undefined4 *)(iVar2 + 0x194);
                uStack_2c4 = *(undefined4 *)(iVar2 + 0x198);
                uStack_2c0 = *(undefined4 *)(iVar2 + 0x19c);
                local_54 = local_2d8 + local_3c * 0x18;
                if (*(int *)((int)local_4c +
                             (local_28 * local_34 + local_3c) * 0xc + 4) !=
                    -0x40) {
                    if (*(int *)(local_54 + 0xc) == 0) {
                        puVar1 = auStack_1b8 + local_20;
                        local_20 = local_20 + 1;
                        *puVar1 =
                            *(undefined4 *)((int)local_4c +
                                            (local_28 * local_34 + local_3c) *
                                                0xc +
                                            4);
                        V_LOCK();
                        iVar2 =
                            *(int *)(*(int *)(local_48 + local_34 * 4) + 0xfc);
                        FUN_0004fc8c(&local_b8, &local_b8, iVar2,
                                     iVar2 >> 0x1f);
                        logfmt_raw(
                            auStack_12f4, 0x1000, 0, uStack_9c, local_b8,
                            uStack_b4, uStack_b0, uStack_ac, local_a8,
                            uStack_a4, uStack_a0, uStack_9c,
                            "chip temp min: %d",
                            *(undefined4 *)((int)local_4c +
                                            (local_28 * local_34 + local_3c) *
                                                0xc +
                                            4));
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/machine_runtime/"
                             "machine_runtime_base.c",
                             0xb0, "check_temperature_base", 0x16, 0x309, 0x14,
                             auStack_12f4);
                    } else if (*(int *)(local_54 + 0xc) == 1) {
                        puVar1 = auStack_2b8 + local_18;
                        local_18 = local_18 + 1;
                        *puVar1 =
                            *(undefined4 *)((int)local_4c +
                                            (local_28 * local_34 + local_3c) *
                                                0xc +
                                            4);
                        V_LOCK();
                        iVar2 =
                            *(int *)(*(int *)(local_48 + local_34 * 4) + 0xfc);
                        FUN_0004fc8c(&local_98, &local_98, iVar2,
                                     iVar2 >> 0x1f);
                        logfmt_raw(
                            auStack_12f4, 0x1000, 0, uStack_7c, local_98,
                            uStack_94, uStack_90, uStack_8c, local_88,
                            uStack_84, uStack_80, uStack_7c,
                            "chip temp max: %d",
                            *(undefined4 *)((int)local_4c +
                                            (local_28 * local_34 + local_3c) *
                                                0xc +
                                            4));
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/machine_runtime/"
                             "machine_runtime_base.c",
                             0xb0, "check_temperature_base", 0x16, 0x30c, 0x14,
                             auStack_12f4);
                    }
                }
            }
        }
        for (local_34 = 0; local_34 < local_2bc; local_34 = local_34 + 1) {
            iVar2 = *(int *)(local_48 + local_34 * 4);
            local_2f4 = *(int *)(iVar2 + 0x184);
            uStack_2f0 = *(undefined4 *)(iVar2 + 0x188);
            uStack_2ec = *(undefined4 *)(iVar2 + 0x18c);
            uStack_2e8 = *(undefined4 *)(iVar2 + 400);
            local_2e4 = *(undefined4 *)(iVar2 + 0x194);
            uStack_2e0 = *(undefined4 *)(iVar2 + 0x198);
            uStack_2dc = *(undefined4 *)(iVar2 + 0x19c);
            for (local_40 = 0; local_40 < local_28; local_40 = local_40 + 1) {
                if (*(int *)((int)local_4c +
                             (local_28 * local_34 + local_40) * 0xc + 4) ==
                    -0x40) {
                    V_LOCK();
                    iVar2 = *(int *)(*(int *)(local_48 + local_34 * 4) + 0xfc);
                    FUN_0004fc8c(&local_78, &local_78, iVar2, iVar2 >> 0x1f);
                    logfmt_raw(
                        auStack_12f4, 0x1000, 0, uStack_5c, local_78, uStack_74,
                        uStack_70, uStack_6c, local_68, uStack_64, uStack_60,
                        uStack_5c, "sensor_addr %02x, J0:6",
                        *(undefined4 *)(local_2f4 + local_40 * 0x18 + 0x14));
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "machine_runtime/machine_runtime_base.c",
                         0xb0, "check_temperature_base", 0x16, 0x317, 100,
                         auStack_12f4);
                } else {
                    local_50 = local_2f4 + local_40 * 0x18;
                    if (*(int *)(local_50 + 0xc) == 0) {
                        local_14 = local_14 + 1;
                        iVar2 = *(
                            int *)((int)local_4c +
                                   (local_28 * local_34 + local_40) * 0xc + 4);
                        if (iVar2 <= local_24) {
                            local_24 = iVar2;
                        }
                        iVar2 = *(
                            int *)((int)local_4c +
                                   (local_28 * local_34 + local_40) * 0xc + 4);
                        if (local_1c < iVar2) {
                            local_1c = iVar2;
                        }
                    } else if (*(int *)(local_50 + 0xc) == 1) {
                        local_30 = local_30 + 1;
                        iVar2 = *(
                            int *)((int)local_4c +
                                   (local_28 * local_34 + local_40) * 0xc + 4);
                        if (iVar2 <= local_24) {
                            local_24 = iVar2;
                        }
                        iVar2 = *(
                            int *)((int)local_4c +
                                   (local_28 * local_34 + local_40) * 0xc + 4);
                        if (local_1c < iVar2) {
                            local_1c = iVar2;
                        }
                    }
                }
            }
        }
        free(local_4c);
        *param_2 = local_24;
        *param_3 = local_1c;
    }
    return local_2c;
}

undefined4 rename_miner_by_eeprom_info_base(void)

{
    return 0;
}

undefined4 hot_cold_restart_base(int param_1)

{
    int iVar1;
    undefined1 auStack_1024[4096];
    int local_24;
    uint local_20;
    int local_1c;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    local_18 = 0;
    local_24 = 0;
    local_14 = get_all_created_runtime(&local_24);
    local_10 = 0;
    do {
        if (0xe < local_10) {
            V_LOCK();
            logfmt_raw(auStack_1024, 0x1000, 0, "----%s success----",
                       "hot_cold_restart_base");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/machine_runtime_base.c",
                 0xb0, "hot_cold_restart_base", 0x15, 0x373, 0x3c,
                 auStack_1024);
            power_on();
            for (local_c = 0; local_c < local_24; local_c = local_c + 1) {
                iVar1 = dev_ctrl();
                (**(code **)(iVar1 + 0x20))(
                    *(undefined4 *)(*(int *)(local_14 + local_c * 4) + 0xf8));
            }
            return 0;
        }
        power_on();
        V_LOCK();
        logfmt_raw(auStack_1024, 0x1000, 0, "----%s, No.%d begin----",
                   "hot_cold_restart_base", local_10 + 1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "hot_cold_restart_base", 0x15, 0x33f, 0x3c, auStack_1024);
        for (local_c = 0; local_c < local_24; local_c = local_c + 1) {
            iVar1 = dev_ctrl();
            (**(code **)(iVar1 + 0x20))(
                *(undefined4 *)(*(int *)(local_14 + local_c * 4) + 0xf8));
            sleep(5);
            for (local_1c = 0; local_1c < 3; local_1c = local_1c + 1) {
                iVar1 = dev_ctrl();
                (**(code **)(iVar1 + 0x18))(
                    *(undefined4 *)(*(int *)(local_14 + local_c * 4) + 0xf8),
                    *(undefined4 *)(*(int *)(local_14 + local_c * 4) + 0x454),
                    *(undefined4 *)(*(int *)(local_14 + local_c * 4) + 0x468));
                local_18 =
                    (**(code **)(*(int *)(local_14 + local_c * 4) + 0xdc))(
                        *(undefined4 *)(local_14 + local_c * 4));
                if (local_18 == 0)
                    break;
            }
            (**(code **)(*(int *)(local_14 + local_c * 4) + 0xe8))(
                *(undefined4 *)(local_14 + local_c * 4));
        }
        for (local_c = 0; local_c < local_24; local_c = local_c + 1) {
            if (*(int *)(*(int *)(local_14 + local_c * 4) + 0x1a8) !=
                *(int *)(*(int *)(local_14 + local_c * 4) + 0x150)) {
                V_LOCK();
                logfmt_raw(
                    auStack_1024, 0x1000, 0,
                    "chain %d check asic number error before increasing freq",
                    *(undefined4 *)(*(int *)(local_14 + local_c * 4) + 0xfc));
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "machine_runtime/machine_runtime_base.c",
                     0xb0, "hot_cold_restart_base", 0x15, 0x352, 100,
                     auStack_1024);
                goto LAB_000543b4;
            }
        }
        (**(code **)(param_1 + 0x44))(param_1);
        V_LOCK();
        logfmt_raw(auStack_1024, 0x1000, 0, "check bringup temperature %d C",
                   *(undefined4 *)(param_1 + 100));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "hot_cold_restart_base", 0x15, 0x357, 0x3c, auStack_1024);
        check_if_bringup_temp_valid(param_1);
        local_18 = (**(code **)(param_1 + 0x2c))(param_1);
        if (local_18 != 0) {
        LAB_000543b4:
            fan_pwm_set_max();
            power_off();
            V_LOCK();
            logfmt_raw(auStack_1024, 0x1000, 0, "----%s failed----",
                       "hot_cold_restart_base");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/machine_runtime_base.c",
                 0xb0, "hot_cold_restart_base", 0x15, 0x37d, 0x3c,
                 auStack_1024);
            do {
                sleep(1);
            } while (true);
        }
        for (local_c = 0; local_c < local_24; local_c = local_c + 1) {
            local_18 = (**(code **)(*(int *)(local_14 + local_c * 4) + 0xdc))(
                *(undefined4 *)(local_14 + local_c * 4));
            if (*(int *)(*(int *)(local_14 + local_c * 4) + 0x1a8) !=
                *(int *)(*(int *)(local_14 + local_c * 4) + 0x150)) {
                V_LOCK();
                logfmt_raw(
                    auStack_1024, 0x1000, 0,
                    "chain %d check asic number error after increasing freq",
                    *(undefined4 *)(*(int *)(local_14 + local_c * 4) + 0xfc));
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "machine_runtime/machine_runtime_base.c",
                     0xb0, "hot_cold_restart_base", 0x15, 0x362, 100,
                     auStack_1024);
                goto LAB_000543b4;
            }
        }
        V_LOCK();
        logfmt_raw(auStack_1024, 0x1000, 0, "----%s, No.%d end----",
                   "hot_cold_restart_base", local_10 + 1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "hot_cold_restart_base", 0x15, 0x366, 0x3c, auStack_1024);
        local_20 = 0x78;
        V_LOCK();
        logfmt_raw(auStack_1024, 0x1000, 0, "----cooling for %d seconds----",
                   local_20);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "hot_cold_restart_base", 0x15, 0x368, 0x3c, auStack_1024);
        power_off();
        fan_pwm_set_max();
        for (local_c = 0; local_c < local_24; local_c = local_c + 1) {
            iVar1 = dev_ctrl();
            (**(code **)(iVar1 + 0x20))(
                *(undefined4 *)(*(int *)(local_14 + local_c * 4) + 0xf8));
            iVar1 = dev_ctrl();
            (**(code **)(iVar1 + 0x28))(local_c);
        }
        sleep(local_20);
        local_10 = local_10 + 1;
    } while (true);
}

int start_mining_base(int param_1)

{
    int iVar1;
    undefined4 uVar2;
    code *pcVar3;
    undefined1 auStack_102c[4096];
    int local_2c;
    undefined4 local_28;
    undefined4 *local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;

    local_1c = 0;
    local_2c = 0;
    local_18 = get_all_created_runtime(&local_2c);
    for (local_14 = 0; local_14 < local_2c; local_14 = local_14 + 1) {
        if (*(int *)(local_18 + local_14 * 4) == 0) {
            printf("invalid pointer(%s)!\n", "be_runtimes[c]");
            return 3;
        }
        iVar1 = dev_ctrl();
        (**(code **)(iVar1 + 0x1c))(local_14);
    }
    V_LOCK();
    logfmt_raw(auStack_102c, 0x1000, 0,
               "all backend runtimes have been poweroff.");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "machine_runtime/machine_runtime_base.c",
        0xb0, "start_mining_base", 0x11, 0x392, 0x3c, auStack_102c);
    iVar1 = support_of_sleepmode(*(undefined4 *)(param_1 + 0x50));
    if ((iVar1 != 0) && (opt_custom_power_mode == '\x01')) {
        DAT_001523ec = 1;
        V_LOCK();
        logfmt_raw(auStack_102c, 0x1000, 0, "sleep on!");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "start_mining_base", 0x11, 0x398, 0x3c, auStack_102c);
    }
    iVar1 = power_init(DAT_001523ec, local_2c);
    if (iVar1 == 0) {
        V_LOCK();
        logfmt_raw(auStack_102c, 0x1000, 0, ">> power init success <<");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "start_mining_base", 0x11, 0x39f, 0x28, auStack_102c);
        iVar1 = start_heartbeat_thread();
        if (iVar1 == 0) {
            if (opt_algo == 9) {
                pcVar3 = *(code **)(param_1 + 0x1c);
                uVar2 = platfrom_get_check_asic_voltage();
                local_1c = (*pcVar3)(param_1, uVar2);
                if (local_1c != 0) {
                    return local_1c;
                }
            }
            (**(code **)(param_1 + 0x28))(param_1,
                                          *(undefined4 *)(param_1 + 0x58));
            for (local_14 = 0; local_14 < local_2c; local_14 = local_14 + 1) {
                iVar1 = (*(code *)**(undefined4 **)(local_18 + local_14 * 4))(
                    *(undefined4 *)(local_18 + local_14 * 4));
                if (iVar1 != 0) {
                    return iVar1;
                }
                local_1c = 0;
            }
            for (local_14 = 0; local_14 < local_2c; local_14 = local_14 + 1) {
                for (local_20 = 0; local_20 < 3; local_20 = local_20 + 1) {
                    iVar1 = dev_ctrl();
                    (**(code **)(iVar1 + 0x18))(
                        *(undefined4 *)(*(int *)(local_18 + local_14 * 4) +
                                        0xf8),
                        *(undefined4 *)(*(int *)(local_18 + local_14 * 4) +
                                        0x454),
                        *(undefined4 *)(*(int *)(local_18 + local_14 * 4) +
                                        0x468));
                    local_1c =
                        (**(code **)(*(int *)(local_18 + local_14 * 4) + 0xdc))(
                            *(undefined4 *)(local_18 + local_14 * 4));
                    if (local_1c == 0)
                        break;
                }
                (**(code **)(*(int *)(local_18 + local_14 * 4) + 0xe8))(
                    *(undefined4 *)(local_18 + local_14 * 4));
            }
            if (local_1c == 0) {
                check_and_destroy_abnormal_runtime();
                local_24 = (undefined4 *)get_all_created_runtime(&local_2c);
                if (local_2c < 1) {
                    V_LOCK();
                    logfmt_raw(auStack_102c, 0x1000, 0,
                               "there is no qualified device remain after "
                               "check abnormal runtime!");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "machine_runtime/machine_runtime_base.c",
                         0xb0, "start_mining_base", 0x11, 0x3c2, 100,
                         auStack_102c);
                    local_1c = 0x66;
                } else {
                    (**(code **)(param_1 + 0x44))(param_1);
                    V_LOCK();
                    logfmt_raw(auStack_102c, 0x1000, 0,
                               "check bringup temperature %d C",
                               *(undefined4 *)(param_1 + 100));
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "machine_runtime/machine_runtime_base.c",
                         0xb0, "start_mining_base", 0x11, 0x3d0, 0x3c,
                         auStack_102c);
                    check_if_bringup_temp_valid(param_1);
                    local_28 = (**(code **)(param_1 + 0x18))(
                        *(undefined4 *)(param_1 + 100));
                    fan_pwm_set(local_28);
                    for (local_14 = 0; local_14 < local_2c;
                         local_14 = local_14 + 1) {
                        redirect_nonce_output(*local_24, local_24[local_14]);
                        (**(code **)(local_24[local_14] + 0xf0))(
                            local_24[local_14]);
                    }
                    if (*(int *)(param_1 + 0x50) == 9) {
                        (**(code **)(param_1 + 0x44))(param_1);
                        V_LOCK();
                        logfmt_raw(auStack_102c, 0x1000, 0,
                                   "check bringup temperature %d C",
                                   *(undefined4 *)(param_1 + 100));
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/machine_runtime/"
                             "machine_runtime_base.c",
                             0xb0, "start_mining_base", 0x11, 0x3e0, 0x3c,
                             auStack_102c);
                    }
                    V_LOCK();
                    logfmt_raw(auStack_102c, 0x1000, 0,
                               "Initializing, please wait, this may take up 1 "
                               "minute...");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "machine_runtime/machine_runtime_base.c",
                         0xb0, "start_mining_base", 0x11, 999, 0x3c,
                         auStack_102c);
                    local_1c = (**(code **)(param_1 + 0x2c))(param_1);
                    if (local_1c == 0) {
                        for (local_14 = 0; local_14 < local_2c;
                             local_14 = local_14 + 1) {
                            (**(code **)(local_24[local_14] + 0x10))(
                                local_24[local_14]);
                        }
                    } else {
                        fan_pwm_set_max();
                    }
                }
            }
        } else {
            local_1c = start_heartbeat_thread();
        }
    } else {
        V_LOCK();
        logfmt_raw(auStack_102c, 0x1000, 0,
                   ">> power init error, check PSU please <<");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "start_mining_base", 0x11, 0x39b, 100, auStack_102c);
        V_LOCK();
        logfmt_raw(auStack_102c, 0x1000, 0, "Sweep error string = %s.",
                   &DAT_000ec7c8);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "start_mining_base", 0x11, 0x39c, 100, auStack_102c);
        local_1c = 300;
    }
    return local_1c;
}

int stop_mining_base(void)

{
    int iVar1;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    local_c = 0;
    local_18 = 0;
    local_14 = get_all_created_runtime(&local_18);
    local_10 = 0;
    while (true) {
        if (local_18 <= local_10) {
            iVar1 = dev_ctrl();
            (**(code **)(iVar1 + 0x10))(&WORD_0001c200);
            usleep(10000);
            return local_c;
        }
        if (*(int *)(local_14 + local_10 * 4) == 0)
            break;
        local_c = (**(code **)(*(int *)(local_14 + local_10 * 4) + 0x14))(
            *(undefined4 *)(local_14 + local_10 * 4));
        if (local_c != 0) {
            return local_c;
        }
        iVar1 = dev_ctrl();
        (**(code **)(iVar1 + 0x1c))(local_10);
        usleep(100000);
        local_10 = local_10 + 1;
    }
    printf("invalid pointer(%s)!\n", "be_runtimes[c]");
    return 3;
}

undefined4 reset_mining_base(void)

{
    return 0;
}

undefined4 FUN_00054f74(void)

{
    return 0;
}

undefined4 calc_freq_compensate_by_temp_base(void)

{
    return 0;
}

undefined4 machine_info_init(void)

{
    undefined4 uVar1;
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    V_LOCK();
    logfmt_raw(auStack_100c, 0x1000, 0, "platform_topol_init");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "machine_runtime/machine_runtime_base.c",
        0xb0, "machine_info_init", 0x11, 0x43b, 0x14, auStack_100c);
    local_c = platform_topol_init();
    if (local_c != 0) {
        /* WARNING: Subroutine does not return */
        exit(local_c);
    }
    V_LOCK();
    logfmt_raw(auStack_100c, 0x1000, 0, "check_machine_info");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "machine_runtime/machine_runtime_base.c",
        0xb0, "machine_info_init", 0x11, 0x43f, 0x14, auStack_100c);
    uVar1 = FUN_00054f74();
    return uVar1;
}

undefined4 FUN_00055114(char *param_1, undefined4 *param_2, undefined4 *param_3)

{
    char *pcVar1;
    undefined1 auStack_1018[4096];
    int local_18[2];
    int *local_10;
    int local_c;

    local_18[1] = 0;
    local_10 = local_18 + 1;
    *param_2 = 0;
    *param_3 = 0;
    local_18[0] = 0;
    get_chip_ft_correspond(local_10, local_18);
    local_c = 0;
    while (true) {
        if (local_18[0] <= local_c) {
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, "chip_ft %s not in lists",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/machine_runtime_base.c",
                 0xb0, "get_voltage_and_freq_by_chip_ft", 0x1f, 0x459, 100,
                 auStack_1018);
            return 0x12f;
        }
        if ((*(int *)(*local_10 + local_c * 0xc) != 0) &&
            (pcVar1 = strstr(*(char **)(*local_10 + local_c * 0xc), param_1),
             pcVar1 != (char *)0x0))
            break;
        local_c = local_c + 1;
    }
    *param_2 = *(undefined4 *)(*local_10 + local_c * 0xc + 4);
    *param_3 = *(undefined4 *)(*local_10 + local_c * 0xc + 8);
    return 0;
}

undefined4 set_voltage_and_freq_by_eeprom_chip_ft(int *param_1, int *param_2)

{
    int iVar1;
    undefined1 auStack_11a0[4096];
    char acStack_1a0[256];
    int aiStack_a0[16];
    int aiStack_60[16];
    int local_20;
    undefined4 local_1c;
    undefined4 local_18;
    undefined4 local_14;
    int local_10;
    int local_c;

    local_14 = 0;
    local_18 = 0;
    *param_1 = 0;
    *param_2 = 0xffff;
    local_1c = get_all_created_runtime(&local_20);
    local_c = 0;
    while (true) {
        if (local_20 <= local_c) {
            for (local_10 = 0; local_10 < local_20; local_10 = local_10 + 1) {
                iVar1 = aiStack_60[local_10];
                if (iVar1 < *param_1) {
                    iVar1 = *param_1;
                }
                *param_1 = iVar1;
                iVar1 = *param_2;
                if (aiStack_a0[local_10] <= iVar1) {
                    iVar1 = aiStack_a0[local_10];
                }
                *param_2 = iVar1;
            }
            V_LOCK();
            logfmt_raw(auStack_11a0, 0x1000, 0, "%s vol:%d,freq:%d",
                       "set_voltage_and_freq_by_eeprom_chip_ft", *param_1,
                       *param_2);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/machine_runtime_base.c",
                 0xb0, "set_voltage_and_freq_by_eeprom_chip_ft", 0x26, 0x482,
                 0x28, auStack_11a0);
            return 0;
        }
        local_14 = api_get_eeprom_chip_ft(local_c);
        local_18 = api_get_eeprom_chip_bin(local_c);
        snprintf(acStack_1a0, 0x100, "%s BIN%d", local_14, local_18);
        iVar1 = FUN_00055114(acStack_1a0, aiStack_60 + local_c,
                             aiStack_a0 + local_c);
        if (iVar1 != 0)
            break;
        local_c = local_c + 1;
    }
    return 0x12f;
}

undefined4 set_target_temp_by_eeprom_chip_ft(void)

{
    char *pcVar1;
    undefined1 auStack_1120[4096];
    char acStack_120[256];
    int local_20;
    undefined4 local_1c;
    undefined4 local_18;
    int local_14;
    int local_10;
    undefined4 local_c;

    local_c = 0;
    local_18 = 0;
    local_10 = 0;
    local_1c = get_all_created_runtime(&local_20);
    for (local_14 = 0; local_14 < local_20; local_14 = local_14 + 1) {
        local_c = api_get_eeprom_chip_ft(local_14);
        local_18 = api_get_eeprom_chip_bin(local_14);
        snprintf(acStack_120, 0x100, "%s BIN%d", local_c, local_18);
        pcVar1 = strstr(acStack_120, "C2 BIN2");
        if (((((pcVar1 != (char *)0x0) ||
               (pcVar1 = strstr(acStack_120, "C2 BIN3"),
                pcVar1 != (char *)0x0)) ||
              (pcVar1 = strstr(acStack_120, "C2 BIN4"),
               pcVar1 != (char *)0x0)) ||
             (pcVar1 = strstr(acStack_120, "C2 BIN5"),
              pcVar1 != (char *)0x0)) &&
            (-6 < local_10)) {
            local_10 = -5;
        }
    }
    opt_target_temp_bonus = local_10;
    V_LOCK();
    logfmt_raw(auStack_1120, 0x1000, 0, "opt_target_temp_bonus %d",
               opt_target_temp_bonus);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "machine_runtime/machine_runtime_base.c",
        0xb0, "set_target_temp_by_eeprom_chip_ft", 0x21, 0x4a6, 0x28,
        auStack_1120);
    return 0;
}

int hardware_init(undefined4 param_1)

{
    undefined1 uVar1;
    int iVar2;
    undefined4 uVar3;
    code *pcVar4;
    char local_106c[12];
    undefined2 local_1060;
    undefined2 local_6c;
    undefined1 local_6a;
    undefined4 local_68;
    undefined4 local_64;
    undefined4 uStack_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 local_54;
    undefined4 uStack_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 local_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 local_34;
    undefined4 local_30;
    int local_2c;
    int local_28;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    undefined4 local_14;

    local_18 = 0;
    local_24 = 0xffffffff;
    if (is_test_pool == '\x01') {
        V_LOCK();
        logfmt_raw(local_106c, 0x1000, 0, "Test pool is Ture");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "hardware_init", 0xd, 0x4ba, 0x28, local_106c);
    } else {
        V_LOCK();
        logfmt_raw(local_106c, 0x1000, 0, "Miner Bootsup");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_base.c",
             0xb0, "hardware_init", 0xd, 0x4b5, 0x28, local_106c);
        builtin_strncpy(local_106c, "Miner Bootsu", 0xc);
        local_1060 = 0x70;
        log_droa(local_106c, 0);
    }
    local_18 = machine_info_init();
    if (local_18 == 0) {
        platform_get_fan_control_info(&local_64);
        fan_control_info_init(local_64, uStack_60, uStack_5c, uStack_58,
                              local_54, uStack_50, uStack_4c, uStack_48,
                              local_44, uStack_40, uStack_3c, uStack_38,
                              local_34);
        iVar2 = platform_is_pic_mcu_en();
        if (iVar2 != 0) {
            uVar1 = platform_get_pic_device_high(0);
            set_pic_device_high(uVar1);
        }
        iVar2 = dev_ctrl();
        pcVar4 = *(code **)(iVar2 + 8);
        uVar3 = platform_get_chain_num();
        iVar2 = (*pcVar4)(uVar3);
        if (iVar2 == 0) {
            check_fan_valid();
            local_2c = query_device_num();
            if (local_2c < 1) {
                V_LOCK();
                logfmt_raw(local_106c, 0x1000, 0,
                           "query_device_num error code %d and then exit",
                           local_2c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "machine_runtime/machine_runtime_base.c",
                     0xb0, "hardware_init", 0xd, 0x4d5, 100, local_106c);
                local_18 = 0x12d;
            } else {
                for (local_28 = 0; local_28 < local_2c;
                     local_28 = local_28 + 1) {
                    iVar2 = dev_ctrl();
                    (**(code **)(iVar2 + 0x28))(local_28);
                    iVar2 = runtime_ctrl(param_1);
                    if (iVar2 == 0) {
                        V_LOCK();
                        logfmt_raw(local_106c, 0x1000, 0,
                                   "runtime ctrl error!");
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/machine_runtime/"
                             "machine_runtime_base.c",
                             0xb0, "hardware_init", 0xd, 0x4de, 0x50,
                             local_106c);
                        return 0x12d;
                    }
                }
                FUN_00050364(param_1);
                for (local_28 = 0; local_28 < local_2c;
                     local_28 = local_28 + 1) {
                    V_LOCK();
                    iVar2 = dev_ctrl();
                    uVar3 = (**(code **)(iVar2 + 0x30))(local_28);
                    logfmt_raw(local_106c, 0x1000, 0, "eeprom add device: %d",
                               uVar3);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "machine_runtime/machine_runtime_base.c",
                         0xb0, "hardware_init", 0xd, 0x4e7, 0x3c, local_106c);
                    iVar2 = dev_ctrl();
                    uVar3 = (**(code **)(iVar2 + 0x30))(local_28);
                    add_eeprom_device(uVar3);
                }
                local_24 = eeprom_load();
                if (local_24 == 0) {
                    local_20 = 0;
                    local_24 = 0;
                    for (local_1c = 0; local_1c < local_2c;
                         local_1c = local_1c + 1) {
                        local_68 = 0;
                        local_6c = 0;
                        local_6a = 0;
                        local_30 = 0;
                        local_18 = api_get_eeprom_chain_load_state(local_1c);
                        if (local_18 == -1) {
                            local_20 = local_20 + 1;
                            V_LOCK();
                            iVar2 = dev_ctrl();
                            uVar3 = (**(code **)(iVar2 + 0x30))(local_1c);
                            logfmt_raw(local_106c, 0x1000, 0,
                                       "g_eeprom_data is not ready, chain = %d",
                                       uVar3);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/"
                                 "machine_runtime/machine_runtime_base.c",
                                 0xb0, "hardware_init", 0xd, 0x51a, 100,
                                 local_106c);
                        } else if (local_18 == 0) {
                            local_20 = local_20 + 1;
                            V_LOCK();
                            iVar2 = dev_ctrl();
                            uVar3 = (**(code **)(iVar2 + 0x30))(local_1c);
                            logfmt_raw(local_106c, 0x1000, 0,
                                       "Chain%d load EEPROM error.", uVar3);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/"
                                 "machine_runtime/machine_runtime_base.c",
                                 0xb0, "hardware_init", 0xd, 0x51d, 100,
                                 local_106c);
                            V_LOCK();
                            iVar2 = dev_ctrl();
                            uVar3 = (**(code **)(iVar2 + 0x30))(local_1c);
                            logfmt_raw(local_106c, 0x1000, 0,
                                       "Sweep error string = J%d:4.", uVar3);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/"
                                 "machine_runtime/machine_runtime_base.c",
                                 0xb0, "hardware_init", 0xd, 0x51e, 100,
                                 local_106c);
                        }
                    }
                    if (local_20 == 0) {
                        local_18 = FUN_00050564(param_1);
                        if (local_18 == 0) {
                            local_14 = 0;
                            if (local_24 == 0) {
                                opt_custom_freq = eeprom_get_min_freq();
                                opt_custom_voltage = eeprom_get_max_voltage();
                                V_LOCK();
                                logfmt_raw(local_106c, 0x1000, 0,
                                           "MAX voltage: %d",
                                           opt_custom_voltage);
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/"
                                     "machine_runtime/machine_runtime_base.c",
                                     0xb0, "hardware_init", 0xd, 0x57a, 0x28,
                                     local_106c);
                                V_LOCK();
                                logfmt_raw(local_106c, 0x1000, 0,
                                           "MIN freq: %d", opt_custom_freq);
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/"
                                     "machine_runtime/machine_runtime_base.c",
                                     0xb0, "hardware_init", 0xd, 0x57b, 0x28,
                                     local_106c);
                            }
                            FUN_000501d8();
                        }
                    } else {
                        V_LOCK();
                        logfmt_raw(
                            local_106c, 0x1000, 0,
                            "Error! EEPROM data corrupted. pls check it");
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/machine_runtime/"
                             "machine_runtime_base.c",
                             0xb0, "hardware_init", 0xd, 0x538, 100,
                             local_106c);
                        V_LOCK();
                        logfmt_raw(local_106c, 0x1000, 0,
                                   "Sweep error string = %s.", "J255:4");
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/machine_runtime/"
                             "machine_runtime_base.c",
                             0xb0, "hardware_init", 0xd, 0x539, 100,
                             local_106c);
                        local_18 = 0x12e;
                    }
                } else {
                    V_LOCK();
                    logfmt_raw(local_106c, 0x1000, 0,
                               "EEPROM load error!, pls check it");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "machine_runtime/machine_runtime_base.c",
                         0xb0, "hardware_init", 0xd, 0x507, 100, local_106c);
                    V_LOCK();
                    logfmt_raw(local_106c, 0x1000, 0,
                               "Sweep error string = %s.", "J255:4");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "machine_runtime/machine_runtime_base.c",
                         0xb0, "hardware_init", 0xd, 0x508, 100, local_106c);
                    local_18 = 0x12e;
                }
            }
        } else {
            V_LOCK();
            logfmt_raw(local_106c, 0x1000, 0, "dev init failed!");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/machine_runtime_base.c",
                 0xb0, "hardware_init", 0xd, 0x4ca, 100, local_106c);
            local_18 = 0x12d;
        }
    }
    return local_18;
}

undefined4 check_if_bringup_temp_valid(int param_1)

{
    int iVar1;
    undefined1 auStack_101c[4096];
    int local_1c;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    local_c = 0x32;
    local_18 = get_all_created_runtime(&local_1c);
    local_14 = 0;
    while (true) {
        if (local_1c <= local_14) {
            return 0;
        }
        if (*(int *)(param_1 + 100) <
            *(int *)(*(int *)(local_18 + local_14 * 4) + 0x198))
            break;
        if (local_c <= *(int *)(param_1 + 100))
            break;
        local_14 = local_14 + 1;
    }
    V_LOCK();
    logfmt_raw(auStack_101c, 0x1000, 0,
               "bringup temperature unacceptable! refuse to start mining");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "machine_runtime/machine_runtime_base.c",
        0xb0, "check_if_bringup_temp_valid", 0x1b, 0x590, 100, auStack_101c);
    local_10 = 0;
    while (true) {
        if (local_14 <= local_10)
            break;
        (**(code **)(*(int *)(local_18 + local_10 * 4) + 0x14))(
            *(undefined4 *)(local_18 + local_10 * 4));
        iVar1 = dev_ctrl();
        (**(code **)(iVar1 + 0x1c))(
            *(undefined4 *)(*(int *)(local_18 + local_10 * 4) + 0xf8));
        local_10 = local_10 + 1;
    }
    power_off();
    do {
        sleep(1);
    } while (true);
}

/* WARNING: Type propagation algorithm not settling */

int thread_monitor_temperature_in_startup_stage(int param_1)

{
    int iVar1;
    undefined1 auStack_1028[4096];
    int local_28;
    int local_24[5];
    int *local_10;
    int local_c;

    local_24[1] = 0;
    local_10 = (int *)get_all_created_runtime(local_24 + 1);
    local_24[2] = 0;
    local_24[0] = -0x40;
    local_28 = 0xff;
    local_24[4] = 0;
    local_24[3] = 0;
    local_c = param_1;
    while (true) {
        local_24[2] = check_temperature_base(local_c, local_24, &local_28);
        if (local_24[2] == 0) {
            local_24[4] = 0;
        } else {
            local_24[4] = local_24[4] + 1;
            V_LOCK();
            logfmt_raw(auStack_1028, 0x1000, 0, "read temperature error");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/machine_runtime_base.c",
                 0xb0, "thread_monitor_temperature_in_startup_stage", 0x2b,
                 0x5b0, 100, auStack_1028);
        }
        iVar1 = local_28;
        if (local_28 < local_24[0]) {
            iVar1 = local_24[0];
        }
        if (*(int *)(*local_10 + 400) < iVar1) {
            local_24[3] = local_24[3] + 1;
            V_LOCK();
            logfmt_raw(auStack_1028, 0x1000, 0,
                       "read temperature exceed limit!");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/machine_runtime_base.c",
                 0xb0, "thread_monitor_temperature_in_startup_stage", 0x2b,
                 0x5b9, 100, auStack_1028);
        } else {
            local_24[3] = 0;
        }
        if ((1 < local_24[4]) || (1 < local_24[3])) {
            fan_pwm_set_max();
        }
        if (DAT_001523f4 == 0) {
            V_LOCK();
            logfmt_raw(auStack_1028, 0x1000, 0,
                       "warming up, min temp %d max temp %d", local_24[0],
                       local_28);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/machine_runtime_base.c",
                 0xb0, "thread_monitor_temperature_in_startup_stage", 0x2b,
                 0x5c3, 0x28, auStack_1028);
        }
        DAT_001523f4 = (DAT_001523f4 + 1) % 10;
        if (*(char *)(local_c + 0x80) != '\0')
            break;
        sleep(1);
    }
    *(undefined1 *)(local_c + 0x80) = 0;
    return local_c;
}

void FUN_000566f4(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_00056880(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

int machine_runtime_init(undefined4 param_1, int param_2)

{
    undefined1 auStack_1010[4096];
    int local_10;
    int local_c;

    local_c = 0;
    local_10 = 0;
    while ((local_10 == 0 && (param_2 != 8))) {
        local_10 = 1;
    }
    if (local_10 == 1) {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, "not support miner type: %d",
                   param_2);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_interface.c",
             0xb5, "machine_runtime_init", 0x14, 0x48, 100, auStack_1010,
             param_2, param_1);
    } else {
        local_c = machine_runtime_ctrl_ltc_1491();
        *(int *)(local_c + 0x50) = param_2;
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, "miner type: %d", param_2);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/"
             "machine_runtime_interface.c",
             0xb5, "machine_runtime_init", 0x14, 0x4e, 0x14, auStack_1010);
    }
    return local_c;
}

void machine_runtime_exit(void *param_1)

{
    if (param_1 != (void *)0x0) {
        free(param_1);
    }
    return;
}

undefined4 FUN_00056c30(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "chain", param_3, param_4);
    return param_1;
}

void FUN_00056c64(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_00056df0(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

undefined4 set_voltage_MP2973(int param_1)

{
    int iVar1;
    undefined1 auStack_106c[4096];
    int local_6c;
    undefined4 local_68;
    undefined4 uStack_64;
    undefined4 uStack_60;
    undefined4 uStack_5c;
    undefined4 local_58;
    undefined4 uStack_54;
    undefined4 uStack_50;
    undefined4 uStack_4c;
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    uint local_28;
    int local_24;
    int local_20;
    undefined4 local_1c;
    int local_18;
    uint local_14;

    local_1c = 0;
    local_18 = get_all_created_runtime(&local_6c);
    local_14 = param_1 + 0x96;
    V_LOCK();
    logfmt_raw(auStack_106c, 0x1000, 0, "set all chain target voltage is %d mV",
               local_14);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
        0xbb, "set_voltage_MP2973", 0x12, 0x23, 0x28, auStack_106c);
    if (local_14 < 0x673) {
        local_28 = local_14;
        if (local_14 < 0x546) {
            local_28 = 0x546;
        }
    } else {
        local_28 = 0x672;
    }
    if (local_14 != local_28) {
        V_LOCK();
        logfmt_raw(auStack_106c, 0x1000, 0,
                   "target voltage not in [%d %d], set to %d mV", 0x546, 0x672,
                   local_28);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/x7_2044/"
             "machine_runtime_x7_2044.c",
             0xbb, "set_voltage_MP2973", 0x12, 0x26, 0x50, auStack_106c);
    }
    local_20 = 0;
    do {
        if (local_6c <= local_20) {
            return local_1c;
        }
        for (local_24 = 0; local_24 < 3; local_24 = local_24 + 1) {
            iVar1 = set_chain_mps_voltage(
                *(undefined4 *)(*(int *)(local_18 + local_20 * 4) + 0xfc), 0,
                local_28 & 0xffff, local_28 & 0xffff);
            if (iVar1 == 0) {
                V_LOCK();
                FUN_00056c30(&local_48, &local_48, local_20, local_20 >> 0x1f);
                logfmt_raw(auStack_106c, 0x1000, 0, uStack_2c, local_48,
                           uStack_44, uStack_40, uStack_3c, local_38, uStack_34,
                           uStack_30, uStack_2c,
                           "set voltage to %d successfully", local_28);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
                     0xbb, "set_voltage_MP2973", 0x12, 0x31, 0x14,
                     auStack_106c);
                break;
            }
            V_LOCK();
            FUN_00056c30(&local_68, &local_68, local_20, local_20 >> 0x1f);
            logfmt_raw(auStack_106c, 0x1000, 0, uStack_4c, local_68, uStack_64,
                       uStack_60, uStack_5c, local_58, uStack_54, uStack_50,
                       uStack_4c, "set_chain_mps_voltage failed");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
                 0xbb, "set_voltage_MP2973", 0x12, 0x2e, 100, auStack_106c);
        }
        if (2 < local_24) {
            local_1c = 0x6d;
        }
        local_20 = local_20 + 1;
    } while (true);
}

undefined4 FUN_00057324(undefined4 param_1, int param_2)

{
    int iVar1;
    undefined4 local_18;
    undefined4 local_14;
    undefined4 local_10;
    undefined4 local_c;

    local_c = 0;
    local_10 = 10;
    local_18 = get_current_voltage();
    local_14 = param_2 - local_18;
    if (local_14 == 0) {
        local_c = 0;
    } else {
        if ((int)local_14 < 0) {
            local_10 = -10;
        }
        while (true) {
            iVar1 = local_10;
            if (local_10 < 0) {
                iVar1 = -local_10;
            }
            if ((int)((local_14 ^ (int)local_14 >> 0x1f) -
                      ((int)local_14 >> 0x1f)) <= iVar1)
                break;
            local_18 = local_18 + local_10;
            local_14 = local_14 - local_10;
            local_c = set_voltage_MP2973(local_18);
        }
        if (param_2 != local_18) {
            local_c = set_voltage_MP2973(param_2);
        }
        set_current_voltage(param_2);
    }
    return local_c;
}

/* WARNING: Restarted to delay deadcode elimination for space: stack */

int FUN_00057410(int param_1, int param_2)

{
    int iVar1;
    int local_54[16];
    int local_14;
    int local_10;
    int local_c;

    local_54[7] = 0x11;
    local_54[8] = 0xc;
    local_54[9] = 7;
    local_54[10] = 0xfffffffd;
    local_54[0xb] = 0xfffffff8;
    local_54[0xc] = 0xfffffff3;
    local_54[0xd] = 0xffffffee;
    local_54[0] = 0;
    local_54[1] = 0;
    local_54[2] = 0;
    local_54[3] = 0;
    local_54[4] = 0;
    local_54[5] = 0;
    local_54[6] = 0;
    local_c = 0;
    local_54[0xf] = param_2 - *(int *)(param_1 + 0x60);
    local_10 = 0;
    local_54[0xe] = 7;
    if (DAT_0014e900 <= param_2) {
        local_10 = 3;
    }
    iVar1 = DAT_001523f8;
    if (param_2 != DAT_0014e900) {
        for (local_14 = 0; local_14 < 6; local_14 = local_14 + 1) {
            if ((local_54[local_14 + 8] + local_10 < local_54[0xf]) &&
                (local_54[0xf] <= local_54[local_14 + 7] + local_10)) {
                local_c = local_54[local_14];
                break;
            }
        }
        if (local_10 + 0x11 < local_54[0xf]) {
            local_c = 0;
        }
        if (local_54[0xf] <= local_10 + -0x12) {
            local_c = 0;
        }
        if ((local_c < DAT_001523f8) && (param_2 <= DAT_0014e900)) {
            local_c = DAT_001523f8;
        }
        if ((DAT_001523f8 < local_c) && (DAT_0014e900 <= param_2)) {
            local_c = DAT_001523f8;
        }
        if (param_2 != DAT_0014e900) {
            DAT_0014e900 = param_2;
        }
        if (local_c != DAT_001523f8) {
            DAT_001523f8 = local_c;
        }
        if (local_c < 1) {
            iVar1 = 0;
        } else {
            iVar1 = local_c;
            if (0x77 < local_c) {
                iVar1 = 0x78;
            }
        }
    }
    return iVar1;
}

undefined4 set_frequency_with_voltage_x7_2044(void)

{
    return 0;
}

undefined4 check_asic_num_x7(int param_1)

{
    int iVar1;
    undefined1 auStack_10a0[4096];
    int aiStack_a0[32];
    int local_20;
    int local_1c;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    local_c = 0;
    local_20 = 0;
    local_1c = get_all_created_runtime(&local_20);
    for (local_18 = 0; local_18 < local_20; local_18 = local_18 + 1) {
        if (*(int *)(local_1c + local_18 * 4) == 0) {
            printf("invalid pointer(%s)!\n", "be_runtimes[c]");
            return 3;
        }
        iVar1 = dev_ctrl();
        (**(code **)(iVar1 + 0x1c))(local_18);
    }
    V_LOCK();
    logfmt_raw(auStack_10a0, 0x1000, 0,
               "all backend runtimes have been poweroff.");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
        0xbb, "check_asic_num_x7", 0x11, 0xc3, 0x3c, auStack_10a0);
    memset(aiStack_a0, 0, 0x80);
    V_LOCK();
    logfmt_raw(auStack_10a0, 0x1000, 0, "start to check asic num test loop");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
        0xbb, "check_asic_num_x7", 0x11, 200, 0x3c, auStack_10a0);
    local_14 = 1;
    do {
        if (1000 < local_14) {
            return 0;
        }
        for (local_18 = 0; local_18 < local_20; local_18 = local_18 + 1) {
            iVar1 = dev_ctrl();
            (**(code **)(iVar1 + 0x28))(local_18);
        }
        iVar1 = power_init(0, local_20);
        if (iVar1 != 0) {
            V_LOCK();
            logfmt_raw(auStack_10a0, 0x1000, 0, "power init error!");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
                 0xbb, "check_asic_num_x7", 0x11, 0xcf, 100, auStack_10a0);
            V_LOCK();
            logfmt_raw(auStack_10a0, 0x1000, 0, "Sweep error string = %s.",
                       &DAT_000f57c0);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
                 0xbb, "check_asic_num_x7", 0x11, 0xd0, 100, auStack_10a0);
            return 300;
        }
        (**(code **)(param_1 + 0x28))(param_1, *(undefined4 *)(param_1 + 0x58));
        for (local_18 = 0; local_18 < local_20; local_18 = local_18 + 1) {
            local_c = (*(code *)**(undefined4 **)(local_1c + local_18 * 4))(
                *(undefined4 *)(local_1c + local_18 * 4));
            if (local_c == 0) {
                iVar1 = dev_ctrl();
                (**(code **)(iVar1 + 0x18))(
                    *(undefined4 *)(*(int *)(local_1c + local_18 * 4) + 0xf8),
                    *(undefined4 *)(*(int *)(local_1c + local_18 * 4) + 0x454),
                    *(undefined4 *)(*(int *)(local_1c + local_18 * 4) + 0x468));
            }
        }
        for (local_18 = 0; local_18 < local_20; local_18 = local_18 + 1) {
            for (local_10 = 0; local_10 < 1; local_10 = local_10 + 1) {
                (**(code **)(*(int *)(local_1c + local_18 * 4) + 0xe8))(
                    *(undefined4 *)(local_1c + local_18 * 4));
                local_c =
                    (**(code **)(*(int *)(local_1c + local_18 * 4) + 0xdc))(
                        *(undefined4 *)(local_1c + local_18 * 4));
                if (local_c == 0)
                    break;
            }
            if (local_c != 0) {
                aiStack_a0[local_18 * 2] = aiStack_a0[local_18 * 2] + 1;
                sleep(10);
            }
            (**(code **)(*(int *)(local_1c + local_18 * 4) + 0x1c))(
                *(undefined4 *)(local_1c + local_18 * 4));
            V_LOCK();
            logfmt_raw(auStack_10a0, 0x1000, 0,
                       "chain[%d] check asic num test, loop:%d done, total "
                       "failed times:%d",
                       local_18, local_14, aiStack_a0[local_18 * 2]);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
                 0xbb, "check_asic_num_x7", 0x11, 0xea, 0x3c, auStack_10a0);
        }
        local_14 = local_14 + 1;
    } while (true);
}

/* WARNING: Globals starting with '_' overlap smaller symbols at the same
 * address */

int start_mining_x7(int param_1)

{
    int iVar1;
    undefined1 auStack_1024[4096];
    int local_24;
    undefined4 local_20;
    undefined4 *local_1c;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    local_c = 0;
    local_24 = 0;
    local_18 = get_all_created_runtime(&local_24);
    for (local_14 = 0; local_14 < local_24; local_14 = local_14 + 1) {
        if (*(int *)(local_18 + local_14 * 4) == 0) {
            printf("invalid pointer(%s)!\n", "be_runtimes[c]");
            return 3;
        }
        iVar1 = dev_ctrl();
        (**(code **)(iVar1 + 0x1c))(local_14);
    }
    V_LOCK();
    logfmt_raw(auStack_1024, 0x1000, 0,
               "all backend runtimes have been poweroff.");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
        0xbb, "start_mining_x7", 0xf, 0xfc, 0x3c, auStack_1024);
    iVar1 = power_init(0, local_24);
    if (iVar1 == 0) {
        iVar1 = start_heartbeat_thread();
        if (iVar1 == 0) {
            (**(code **)(param_1 + 0x28))(param_1,
                                          *(undefined4 *)(param_1 + 0x58));
            for (local_14 = 0; local_14 < local_24; local_14 = local_14 + 1) {
                local_c = (*(code *)**(undefined4 **)(local_18 + local_14 * 4))(
                    *(undefined4 *)(local_18 + local_14 * 4));
                if (local_c == 0) {
                    iVar1 = dev_ctrl();
                    (**(code **)(iVar1 + 0x18))(
                        *(undefined4 *)(*(int *)(local_18 + local_14 * 4) +
                                        0xf8),
                        *(undefined4 *)(*(int *)(local_18 + local_14 * 4) +
                                        0x454),
                        *(undefined4 *)(*(int *)(local_18 + local_14 * 4) +
                                        0x468));
                }
            }
            for (local_14 = 0; local_14 < local_24; local_14 = local_14 + 1) {
                for (local_10 = 0; local_10 < 1; local_10 = local_10 + 1) {
                    (**(code **)(*(int *)(local_18 + local_14 * 4) + 0xe8))(
                        *(undefined4 *)(local_18 + local_14 * 4));
                    local_c =
                        (**(code **)(*(int *)(local_18 + local_14 * 4) + 0xdc))(
                            *(undefined4 *)(local_18 + local_14 * 4));
                    if (local_c == 0)
                        break;
                }
                if (local_c != 0) {
                    sleep(10);
                }
            }
            check_and_destroy_abnormal_runtime();
            local_1c = (undefined4 *)get_all_created_runtime(&local_24);
            if (local_24 < 1) {
                V_LOCK();
                logfmt_raw(auStack_1024, 0x1000, 0,
                           "there is no qualified device remain after check "
                           "abnormal runtime!");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
                     0xbb, "start_mining_x7", 0xf, 0x122, 100, auStack_1024);
                local_c = 0x66;
            } else {
                local_c = (**(code **)(param_1 + 0x28))(
                    param_1, *(undefined4 *)(param_1 + 0x5c));
                if (local_c == 0) {
                    (**(code **)(param_1 + 0x44))(param_1);
                    V_LOCK();
                    logfmt_raw(auStack_1024, 0x1000, 0,
                               "first time check temperature %d C",
                               *(undefined4 *)(param_1 + 100));
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
                         0xbb, "start_mining_x7", 0xf, 300, 0x3c, auStack_1024);
                    local_20 = (**(code **)(param_1 + 0x18))(
                        *(undefined4 *)(param_1 + 100));
                    fan_pwm_set(local_20);
                    for (local_14 = 0; local_14 < local_24;
                         local_14 = local_14 + 1) {
                        redirect_nonce_output(*local_1c, local_1c[local_14]);
                        (**(code **)(local_1c[local_14] + 0xf0))(
                            local_1c[local_14]);
                    }
                    iVar1 =
                        support_of_sleepmode(*(undefined4 *)(param_1 + 0x50));
                    if (((iVar1 != 0) && (_opt_custom_power_mode == 1)) ||
                        (local_c = (**(code **)(param_1 + 0x2c))(param_1),
                         local_c == 0)) {
                        for (local_14 = 0; local_14 < local_24;
                             local_14 = local_14 + 1) {
                            (**(code **)(local_1c[local_14] + 4))(
                                local_1c[local_14]);
                            (**(code **)(local_1c[local_14] + 0x7c))(
                                local_1c[local_14],
                                *(undefined4 *)(param_1 + 0x54));
                            (**(code **)(local_1c[local_14] + 0x10))(
                                local_1c[local_14]);
                        }
                    }
                }
            }
        } else {
            local_c = start_heartbeat_thread();
        }
    } else {
        V_LOCK();
        logfmt_raw(auStack_1024, 0x1000, 0,
                   ">> power init error, check PSU please <<");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/x7_2044/"
             "machine_runtime_x7_2044.c",
             0xbb, "start_mining_x7", 0xf, 0x101, 100, auStack_1024);
        V_LOCK();
        logfmt_raw(auStack_1024, 0x1000, 0, "Sweep error string = %s.",
                   &DAT_000f57c0);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/x7_2044/"
             "machine_runtime_x7_2044.c",
             0xbb, "start_mining_x7", 0xf, 0x102, 100, auStack_1024);
        local_c = 300;
    }
    return local_c;
}

void *machine_runtime_ctrl_x7_2044(void)

{
    code *local_90;
    undefined1 *local_8c;
    code *local_88;
    code *local_84;
    code *local_7c;
    undefined1 *local_78;
    code *local_74;
    code *local_68;
    code *local_64;
    code *local_60;
    code *local_58;
    code *local_54;
    code *local_50;
    code *local_4c;
    undefined4 local_3c;
    word *local_38;
    word *local_34;
    undefined4 local_30;
    undefined4 local_28;
    undefined4 local_24;
    undefined4 local_20;
    undefined4 local_18;
    char *local_14;
    void *local_c;

    memset(&local_90, 0, 0x84);
    local_90 = FUN_00057410;
    local_8c = &LAB_000576d0;
    local_88 = get_working_voltage_base;
    local_84 = start_voltage_monitor_base;
    local_7c = stop_voltage_monitor_base;
    local_78 = &LAB_0005780c;
    local_74 = FUN_00057324;
    local_68 = set_baud_base;
    local_64 = set_frequency_with_voltage_x7_2044;
    local_60 = start_mining_x7;
    local_58 = stop_mining_base;
    local_54 = reset_mining_base;
    local_50 = check_asic_num_x7;
    local_4c = check_bringup_temperature_base;
    local_3c = 0x23;
    local_38 = &WORD_0001c200;
    local_34 = &WORD_0001c200;
    local_30 = 0x17;
    local_28 = 0x5dc;
    local_24 = 200000;
    local_20 = 0x44fa0000;
    local_18 = 0x3f800000;
    local_14 = "/config/sn";
    local_c = calloc(1, 0x84);
    if (local_c == (void *)0x0) {
        printf("invalid pointer(%s)!\n", "new_machine_runtime");
        local_c = (void *)0x0;
    } else {
        memcpy(local_c, &local_90, 0x84);
    }
    return local_c;
}

undefined4 FUN_00058818(int *param_1)

{
    undefined4 uVar1;

    uVar1 = chip_setting_send_update_cmd_x7(*param_1,
                                            *(undefined4 *)(*param_1 + 0x150),
                                            (char)param_1[2], param_1[3]);
    *(undefined4 *)param_1[4] = uVar1;
    return 0;
}

undefined4 FUN_0005887c(int *param_1)

{
    undefined4 uVar1;

    uVar1 = chip_setting_get_md5sum_x7(
        *param_1, *(undefined4 *)(*param_1 + 0x150), (char)param_1[2],
        param_1[3], param_1[4], param_1[5]);
    *(undefined4 *)param_1[6] = uVar1;
    return 0;
}

undefined4 FUN_00058904(undefined4 *param_1, undefined4 param_2,
                        undefined4 param_3, undefined1 param_4,
                        undefined4 param_5, undefined4 param_6)

{
    *param_1 = param_2;
    param_1[1] = param_3;
    *(undefined1 *)(param_1 + 2) = param_4;
    param_1[3] = param_5;
    param_1[4] = param_6;
    return 0;
}

undefined4 FUN_00058970(undefined4 *param_1, undefined4 param_2,
                        undefined4 param_3, undefined1 param_4,
                        undefined4 param_5, undefined4 param_6,
                        undefined4 param_7, undefined4 param_8)

{
    *param_1 = param_2;
    param_1[1] = param_3;
    *(undefined1 *)(param_1 + 2) = param_4;
    param_1[3] = param_5;
    param_1[4] = param_6;
    param_1[5] = param_7;
    param_1[6] = param_8;
    return 0;
}

undefined4 update_chip_x7(char param_1, float *param_2)

{
    int iVar1;
    void *pvVar2;
    undefined4 uVar3;
    float fVar4;
    undefined1 auStack_130c[4096];
    float local_30c;
    undefined4 uStack_308;
    undefined4 auStack_304[6];
    byte local_2ec[4];
    pthread_t apStack_2e8[6];
    uint local_2d0;
    int local_2cc;
    undefined8 local_2c8;
    undefined8 uStack_2c0;
    undefined8 local_2b8;
    undefined8 local_2b0;
    undefined8 local_2a8;
    undefined8 local_2a0;
    undefined8 local_298;
    undefined8 local_290;
    int local_288;
    uint local_284;
    undefined1 auStack_280[196];
    uint local_1bc;
    char local_1b8[24];
    undefined2 local_1a0;
    undefined1 auStack_19e[102];
    char local_138[128];
    undefined4 local_b8;
    undefined4 uStack_b4;
    undefined4 uStack_b0;
    undefined4 uStack_ac;
    undefined4 local_a8;
    undefined4 uStack_a4;
    undefined4 uStack_a0;
    undefined4 uStack_9c;
    undefined4 local_98;
    undefined4 uStack_94;
    undefined4 uStack_90;
    undefined4 uStack_8c;
    undefined4 local_88;
    undefined4 uStack_84;
    undefined4 uStack_80;
    undefined4 uStack_7c;
    undefined4 local_78;
    undefined4 uStack_74;
    undefined4 uStack_70;
    undefined4 uStack_6c;
    undefined4 local_68;
    undefined4 uStack_64;
    undefined4 uStack_60;
    undefined4 uStack_5c;
    pthread_t local_54;
    size_t local_50;
    uint local_4c;
    void *local_48;
    int local_44;
    int local_40;
    int local_3c;
    int local_38;
    int local_34;
    int local_30;
    char local_2b;
    undefined1 local_2a;
    undefined1 local_29;
    int local_28;
    float local_24;
    char *local_20;
    uint local_1c;
    uint local_18;
    FILE *local_14;

    builtin_strncpy(local_138, "/usr/bin/update_app.zip", 0x18);
    memset(local_138 + 0x18, 0, 0x68);
    builtin_strncpy(local_1b8, "/usr/bin/update_total.zi", 0x18);
    local_1a0 = 0x70;
    memset(auStack_19e, 0, 0x66);
    local_1bc = 0;
    memset(&local_284, 0, 200);
    local_2b = '\0';
    local_2c8 = 0;
    uStack_2c0 = 0;
    local_2b8 = 0;
    local_2b0 = 0;
    local_2a8 = 0;
    local_2a0 = 0;
    local_298 = 0;
    local_290 = 0;
    local_2a = 0;
    local_29 = 0;
    local_28 = get_all_created_runtime(&local_2cc);
    local_2ec[0] = 0;
    local_2ec[1] = 0;
    local_2ec[2] = 0;
    local_24 = *param_2;
    local_30c = 0.7;
    uStack_308 = 0x3e99999a;
    if (param_1 == '\0') {
        local_20 = local_1b8;
        local_1c = 0x4b0;
    } else {
        local_20 = local_138;
        local_1c = 300;
    }
    printf(" %s \n", local_20);
    local_14 = fopen(local_20, "r");
    if (local_14 == (FILE *)0x0) {
        V_LOCK();
        logfmt_raw(auStack_130c, 0x1000, 0, "open file %s failed", local_20);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/x7_2044/"
             "machine_runtime_x7_2044.c",
             0xbb, "update_chip_x7", 0xe, 0x1e1, 100, auStack_130c);
        uVar3 = 0x132;
    } else {
        fseek(local_14, 0, 2);
        local_18 = ftell(local_14);
        V_LOCK();
        logfmt_raw(auStack_130c, 0x1000, 0, "begin sending update_packets");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/x7_2044/"
             "machine_runtime_x7_2044.c",
             0xbb, "update_chip_x7", 0xe, 0x1e7, 0x28, auStack_130c);
        while (true) {
            while (true) {
                local_48 = malloc(0x20c);
                memset(local_48, 0, 0x20c);
                for (local_44 = 0; local_44 < local_2cc;
                     local_44 = local_44 + 1) {
                    local_54 = sync_unblocked_get_status_x7(
                        *(undefined4 *)(local_28 + local_44 * 4), 0x11, 1,
                        local_48, 0x14, &local_288);
                    if (local_54 != 0) {
                        V_LOCK();
                        logfmt_raw(auStack_130c, 0x1000, 0,
                                   "get update ack packet failed,err code:%d",
                                   local_54);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/machine_runtime/"
                             "x7_2044/machine_runtime_x7_2044.c",
                             0xbb, "update_chip_x7", 0xe, 0x1ff, 100,
                             auStack_130c);
                        free(local_48);
                        fclose(local_14);
                        return 0x6d;
                    }
                    if (local_288 != 0) {
                        local_2d0 = *(uint *)((int)local_48 + 0xc);
                        if (local_2d0 <= local_1bc) {
                            local_1bc = local_2d0;
                        }
                        V_LOCK();
                        logfmt_raw(auStack_130c, 0x1000, 0,
                                   "recv send_again packet, ack_packet_num %d",
                                   local_1bc);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/machine_runtime/"
                             "x7_2044/machine_runtime_x7_2044.c",
                             0xbb, "update_chip_x7", 0xe, 0x1f5, 0x14,
                             auStack_130c);
                    }
                }
                free(local_48);
                local_4c = local_1bc * 0xc4;
                if (local_18 <= local_4c) {
                    local_4c = local_18;
                }
                if (*param_2 <=
                    (((1.0 - local_24) * (float)local_4c) / (float)local_18) *
                            local_30c +
                        local_24) {
                    fVar4 = (((1.0 - local_24) * (float)local_4c) /
                             (float)local_18) *
                                local_30c +
                            local_24;
                } else {
                    fVar4 = *param_2;
                }
                *param_2 = fVar4;
                fseek(local_14, local_4c, 0);
                local_50 = fread(auStack_280, 1, 0xc4, local_14);
                if ((int)local_50 < 0) {
                    V_LOCK();
                    logfmt_raw(auStack_130c, 0x1000, 0,
                               "err occured while reading file %s ", local_20);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
                         0xbb, "update_chip_x7", 0xe, 0x20e, 100, auStack_130c);
                    fclose(local_14);
                    return 0x132;
                }
                if (local_50 == 0)
                    break;
                local_2b = '\0';
                local_284 = local_1bc;
                for (local_40 = 0; local_40 < local_2cc;
                     local_40 = local_40 + 1) {
                    chip_setting_send_update_single_packet(
                        *(undefined4 *)(local_28 + local_40 * 4), &local_284,
                        (local_50 & 0xff) + 4 & 0xff, param_1);
                }
                local_1bc = local_1bc + 1;
            }
            if (local_2b == '\x01')
                break;
            sleep(5);
            local_2b = '\x01';
        }
        V_LOCK();
        logfmt_raw(auStack_130c, 0x1000, 0,
                   "send packet complete, prepare checking md5 and update, "
                   "don\'t shutdown");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/machine_runtime/x7_2044/"
             "machine_runtime_x7_2044.c",
             0xbb, "update_chip_x7", 0xe, 0x225, 0x28, auStack_130c);
        iVar1 = CalcFileMD5(local_20, &local_2c8);
        if (iVar1 == 0) {
            for (local_3c = 0; local_3c < local_2cc; local_3c = local_3c + 1) {
                pvVar2 = malloc(0x1c);
                auStack_304[local_3c + 3] = pvVar2;
                FUN_00058970(
                    auStack_304[local_3c + 3],
                    *(undefined4 *)(local_28 + local_3c * 4),
                    *(undefined4 *)(*(int *)(local_28 + local_3c * 4) + 0x150),
                    param_1, &local_2c8, 0x20, local_2ec + local_3c,
                    apStack_2e8 + local_3c);
                pthread_create(apStack_2e8 + local_3c + 3,
                               (pthread_attr_t *)0x0, FUN_0005887c,
                               (void *)auStack_304[local_3c + 3]);
            }
            for (local_38 = 0; local_38 < local_2cc; local_38 = local_38 + 1) {
                pthread_join(apStack_2e8[local_38 + 3], (void **)0x0);
                free((void *)auStack_304[local_38 + 3]);
                local_54 = apStack_2e8[local_38];
                if (apStack_2e8[local_38] != 0) {
                    fclose(local_14);
                    return 0x132;
                }
                if ((uint)local_2ec[local_38] !=
                    *(uint *)(*(int *)(local_28 + local_38 * 4) + 0x150)) {
                    fclose(local_14);
                    return 0x66;
                }
            }
            V_LOCK();
            logfmt_raw(auStack_130c, 0x1000, 0, "updating...");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
                 0xbb, "update_chip_x7", 0xe, 0x243, 0x28, auStack_130c);
            for (local_34 = 0; local_34 < local_2cc; local_34 = local_34 + 1) {
                pvVar2 = malloc(0x14);
                auStack_304[local_34] = pvVar2;
                FUN_00058904(
                    auStack_304[local_34],
                    *(undefined4 *)(local_28 + local_34 * 4),
                    *(undefined4 *)(*(int *)(local_28 + local_34 * 4) + 0x150),
                    param_1, local_2ec + local_34, apStack_2e8 + local_34);
                pthread_create(apStack_2e8 + local_34 + 3,
                               (pthread_attr_t *)0x0, FUN_00058818,
                               (void *)auStack_304[local_34]);
            }
            for (local_30 = 0; local_30 < local_2cc; local_30 = local_30 + 1) {
                pthread_join(apStack_2e8[local_30 + 3], (void **)0x0);
                free((void *)auStack_304[local_30]);
                local_54 = apStack_2e8[local_30];
                if (apStack_2e8[local_30] != 0) {
                    V_LOCK();
                    iVar1 = *(int *)(*(int *)(local_28 + local_30 * 4) + 0xfc);
                    FUN_00056c30(&local_b8, &local_b8, iVar1, iVar1 >> 0x1f);
                    logfmt_raw(
                        auStack_130c, 0x1000, 0, uStack_9c, local_b8, uStack_b4,
                        uStack_b0, uStack_ac, local_a8, uStack_a4, uStack_a0,
                        uStack_9c,
                        "chip update err code %d, wait %ds and shutdown...",
                        local_54, local_1c);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
                         0xbb, "update_chip_x7", 0xe, 0x254, 100, auStack_130c);
                    sleep(local_1c);
                    fclose(local_14);
                    return 0x132;
                }
                if ((uint)local_2ec[local_30] !=
                    *(uint *)(*(int *)(local_28 + local_30 * 4) + 0x150)) {
                    V_LOCK();
                    iVar1 = *(int *)(*(int *)(local_28 + local_30 * 4) + 0xfc);
                    FUN_00056c30(&local_98, &local_98, iVar1, iVar1 >> 0x1f);
                    logfmt_raw(
                        auStack_130c, 0x1000, 0, uStack_7c, local_98, uStack_94,
                        uStack_90, uStack_8c, local_88, uStack_84, uStack_80,
                        uStack_7c,
                        "chip update err code %d, wait %ds and shutdown...",
                        local_54, local_1c);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
                         0xbb, "update_chip_x7", 0xe, 0x25b, 100, auStack_130c);
                    sleep(local_1c);
                    fclose(local_14);
                    return 0x66;
                }
                V_LOCK();
                iVar1 = *(int *)(*(int *)(local_28 + local_30 * 4) + 0xfc);
                FUN_00056c30(&local_78, &local_78, iVar1, iVar1 >> 0x1f);
                logfmt_raw(auStack_130c, 0x1000, 0, uStack_5c, local_78,
                           uStack_74, uStack_70, uStack_6c, local_68, uStack_64,
                           uStack_60, uStack_5c, "chip update complete");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
                     0xbb, "update_chip_x7", 0xe, 0x260, 0x28, auStack_130c);
                *param_2 = 1.0;
            }
            fclose(local_14);
            uVar3 = 0;
        } else {
            V_LOCK();
            logfmt_raw(auStack_130c, 0x1000, 0, "run cmd \"md5sum\" failed");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/"
                 "machine_runtime/x7_2044/machine_runtime_x7_2044.c",
                 0xbb, "update_chip_x7", 0xe, 0x228, 100, auStack_130c);
            fclose(local_14);
            uVar3 = 0x132;
        }
    }
    return uVar3;
}

void FUN_0005990c(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_00059a98(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

int chip_update_xmr_routine(int param_1)

{
    int iVar1;
    undefined1 auStack_1030[4096];
    undefined4 local_30;
    int local_2c;
    int local_28;
    int local_24;
    undefined4 local_20;
    int local_1c;
    undefined4 local_18;
    undefined4 local_14;
    undefined4 local_10;
    undefined4 local_c;

    local_10 = 0;
    local_14 = 0;
    local_c = 0;
    local_18 = 0;
    local_1c = 0;
    local_20 = 0;
    local_30 = 0;
    local_24 = get_miner_working_status_p();
    *(undefined1 *)(local_24 + 9) = 1;
    V_LOCK();
    logfmt_raw(auStack_1030, 0x1000, 0, "chip update mode");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/chip_update/chip_update.c",
         0xa3, "chip_update_xmr_routine", 0x17, 0x1c, 0x28, auStack_1030);
    start_api_thread();
    local_28 = dhash_content_init(opt_algo);
    if (local_28 == 0) {
        printf("invalid pointer(%s)!\n", "dhash_content");
        local_1c = 3;
    } else {
        set_frontend_runtime_type(local_28, opt_algo);
        local_1c = hardware_init(opt_algo);
        if (local_1c == 0) {
            local_2c = machine_runtime_init(opt_machine_type, opt_algo);
            if (local_2c == 0) {
                printf("invalid pointer(%s)!\n", "machine_runtime");
                local_1c = 3;
            } else {
                local_1c = (**(code **)(local_2c + 0x30))(local_2c);
                if (local_1c == 0) {
                    sleep(5);
                    (**(code **)(local_2c + 0xc))(local_2c);
                    local_20 = get_all_created_runtime(&local_30);
                    *(undefined1 *)(local_24 + 9) = 0;
                    dhash_content_exit(local_28);
                    iVar1 = update_chip_x7(param_1 != 0, local_24 + 0xc);
                    if (iVar1 == 0) {
                        local_1c = 0;
                    } else {
                        local_1c = -1;
                    }
                }
            }
        }
    }
    return local_1c;
}

undefined4 dhash_content_init(int param_1)

{
    undefined1 auStack_1010[4096];
    undefined4 local_10;
    uint local_c;

    local_10 = 0;
    for (local_c = 0;
         (local_c < 2 && (param_1 != *(int *)(&DAT_000fdfa4 + local_c * 0xc)));
         local_c = local_c + 1) {
    }
    if ((local_c == 2) || (*(int *)(&DAT_000fdfac + local_c * 0xc) == 0)) {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0,
                   "ALGO %d does not define dhash_content", param_1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/dhash_content/dhash_content.c",
             0xa7, "dhash_content_init", 0x12, 0x40, 100, auStack_1010);
    } else {
        local_10 = (**(code **)(&DAT_000fdfac + local_c * 0xc))();
    }
    return local_10;
}

void dhash_content_exit(void *param_1)

{
    if (param_1 != (void *)0x0) {
        free(param_1);
    }
    return;
}

void FUN_0005a03c(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_0005a1c8(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

uint FUN_0005a358(uint param_1)

{
    return param_1 << 0x18 | (param_1 >> 8 & 0xff) << 0x10 |
           (param_1 >> 0x10 & 0xff) << 8 | param_1 >> 0x18;
}

void FUN_0005a380(undefined4 param_1, undefined4 param_2, undefined4 param_3)

{
    undefined1 auStack_28[32];

    sha256(param_1, param_3, auStack_28);
    sha256(auStack_28, 0x20, param_2);
    return;
}

void FUN_0005a3cc(int param_1, int param_2)

{
    undefined4 uVar1;
    undefined4 local_14;

    for (local_14 = 0; local_14 < 8; local_14 = local_14 + 1) {
        uVar1 = FUN_0005a358(*(undefined4 *)(param_2 + local_14 * 4));
        *(undefined4 *)(param_1 + local_14 * 4) = uVar1;
    }
    return;
}

undefined4 FUN_0005a454(int *param_1, int *param_2, char param_3)

{
    undefined4 uVar1;
    int iVar2;
    undefined1 local_7c[32];
    undefined1 auStack_5c[32];
    int local_3c;
    int iStack_38;
    int iStack_34;
    int iStack_30;
    int local_2c;
    int iStack_28;
    int iStack_24;
    int iStack_20;
    int *local_1c;
    undefined1 *local_18;
    size_t local_14;
    uint *local_10;
    int local_c;

    local_10 = (uint *)param_1[0x11b];
    if (local_10 == (uint *)0x0) {
        printf("invalid pointer(%s)!\n", "private");
        uVar1 = 3;
    } else {
        local_14 = *local_10;
        if (7 < local_14) {
            local_14 = 8;
        }
        if ((param_3 != '\0') && ((char)param_2[0x6f] != '\0')) {
            DAT_00152400 = 0;
        }
        memset(local_10 + 1, 0, *local_10);
        if (local_14 != 0) {
            memcpy(local_10 + 1, &DAT_00152400, local_14);
            DAT_00152400 = CONCAT44(DAT_00152400._4_4_ +
                                        (uint)(0xfffffffe < (uint)DAT_00152400),
                                    (uint)DAT_00152400 + 1);
        }
        memcpy((void *)(param_2[0x4b] + param_2[0x16]), local_10 + 1,
               *local_10);
        FUN_0005a380(param_2[0x4b], &local_3c, param_2[0x4a]);
        for (local_c = 0; local_c < param_2[0x51]; local_c = local_c + 1) {
            memcpy(auStack_5c, *(void **)(param_2[0x52] + local_c * 4), 0x20);
            FUN_0005a380(local_7c, &local_3c, 0x40);
        }
        local_18 = local_7c;
        local_1c = &local_3c;
        FUN_0005a3cc(local_1c, local_18);
        memcpy(param_1 + 2, param_2 + 0x74, 0x50);
        param_1[0xb] = local_3c;
        param_1[0xc] = iStack_38;
        param_1[0xd] = iStack_34;
        param_1[0xe] = iStack_30;
        param_1[0xf] = local_2c;
        param_1[0x10] = iStack_28;
        param_1[0x11] = iStack_24;
        param_1[0x12] = iStack_20;
        memcpy(param_1 + 0x102, param_2 + 0x174, 0x20);
        param_1[0x113] = param_2[0x59];
        iVar2 = *param_2;
        *param_1 = iVar2;
        param_1[1] = iVar2 >> 0x1f;
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 FUN_0005a70c(int param_1, undefined4 *param_2)

{
    undefined4 uVar1;
    undefined4 local_e8;
    undefined4 uStack_e4;
    char acStack_e0[64];
    undefined1 auStack_a0[80];
    undefined4 local_50;
    undefined1 auStack_4c[32];
    undefined1 auStack_2c[16];
    size_t local_1c;
    undefined4 local_18;
    size_t *local_c;

    local_c = (size_t *)param_2[0x11b];
    if (local_c == (size_t *)0x0) {
        printf("invalid pointer(%s)!\n", "private");
        uVar1 = 3;
    } else {
        local_e8 = *param_2;
        uStack_e4 = param_2[1];
        strcpy(acStack_e0, (char *)param_2[0x119]);
        memcpy(auStack_a0, param_2 + 2, 0x50);
        local_50 = target_to_diff_ltc(param_2 + 0x102);
        memcpy(auStack_4c, param_2 + 0x102, 0x20);
        memcpy(auStack_2c, local_c + 1, *local_c);
        local_1c = *local_c;
        local_18 = param_2[0x113];
        (**(code **)(param_1 + 0x20))(param_1, &local_e8);
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 FUN_0005a840(int param_1, int param_2, int param_3)

{
    int iVar1;
    size_t *psVar2;
    undefined4 uVar3;
    uint uVar4;

    psVar2 = *(size_t **)(param_1 + 0x46c);
    if (psVar2 == (size_t *)0x0) {
        printf("invalid pointer(%s)!\n", "private");
        uVar3 = 3;
    } else if ((*(int *)(param_2 + 0x62c) == 0) ||
               (iVar1 = strcmp((char *)(param_3 + 0x10),
                               *(char **)(param_2 + 0x62c)),
                iVar1 == 0)) {
        if (*psVar2 == *(size_t *)(param_3 + 0x68)) {
            uVar4 = (uint) * (byte *)(param_3 + 0x50) << 0x18 |
                    (uint) * (byte *)(param_3 + 0x51) << 0x10 |
                    (uint) * (byte *)(param_3 + 0x52) << 8 |
                    (uint) * (byte *)(param_3 + 0x53);
            *(uint *)(param_1 + 0x430) = uVar4;
            *(int *)(param_1 + 0x434) = (int)uVar4 >> 0x1f;
            memcpy(psVar2 + 1, (void *)(param_3 + 0x56), *psVar2);
            *(undefined4 *)(param_1 + 0x44c) = *(undefined4 *)(param_3 + 0x6c);
            uVar3 = 0;
        } else {
            uVar3 = 1;
        }
    } else {
        uVar3 = 1;
    }
    return uVar3;
}

void *dhash_content_ltc_1491(void)

{
    undefined8 local_24;
    undefined8 local_1c;
    undefined8 local_14;
    void *local_c;

    local_24 = 0x5a70c0005a454;
    local_1c = 0x5a840;
    local_14 = 0x3c001062a8;
    local_c = calloc(1, 0x18);
    memcpy(local_c, &local_24, 0x18);
    return local_c;
}

undefined8 FUN_0005aa20(undefined4 param_1, undefined4 param_2)

{
    return CONCAT44(param_2, param_1);
}

void diff_to_target_ltc(void *param_1)

{
    undefined4 uVar1;
    undefined4 uVar2;
    double in_d0;
    double dVar3;
    undefined8 uVar4;
    double local_58;
    undefined8 local_44;
    undefined8 local_3c;
    undefined8 local_34;
    undefined8 local_2c;
    undefined8 *local_24;
    undefined8 local_20;
    undefined8 local_18;
    undefined8 local_10;

    local_58 = in_d0;
    if (in_d0 <= 0.0) {
        local_58 = 1.0;
    }
    local_10 = 1.7668201048317172e+72 / local_58;
    dVar3 = local_10 / 6.277101735386681e+57;
    local_18._0_4_ = SUB84(dVar3, 0);
    local_18._4_4_ = (undefined4)((ulonglong)dVar3 >> 0x20);
    uVar1 = local_18._4_4_;
    uVar2 = (undefined4)local_18;
    local_18 = dVar3;
    local_20 = FUN_000cce60(uVar2, uVar1);
    local_24 = &local_2c;
    uVar4 = FUN_0005aa20((int)local_20, (int)((ulonglong)local_20 >> 0x20));
    *local_24 = uVar4;
    local_18 = (double)FUN_000ccad4((undefined4)local_20, local_20._4_4_);
    local_10 = local_10 - local_18 * 6.277101735386681e+57;
    dVar3 = local_10 / 3.402823669209385e+38;
    local_18._0_4_ = SUB84(dVar3, 0);
    local_18._4_4_ = (undefined4)((ulonglong)dVar3 >> 0x20);
    uVar1 = local_18._4_4_;
    uVar2 = (undefined4)local_18;
    local_18 = dVar3;
    uVar4 = FUN_000cce60(uVar2, uVar1);
    local_24 = &local_34;
    local_20 = uVar4;
    uVar4 = FUN_0005aa20((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
    *local_24 = uVar4;
    local_18 = (double)FUN_000ccad4((undefined4)local_20, local_20._4_4_);
    local_10 = local_10 - local_18 * 3.402823669209385e+38;
    dVar3 = local_10 / 1.8446744073709552e+19;
    local_18._0_4_ = SUB84(dVar3, 0);
    local_18._4_4_ = (undefined4)((ulonglong)dVar3 >> 0x20);
    uVar1 = local_18._4_4_;
    uVar2 = (undefined4)local_18;
    local_18 = dVar3;
    uVar4 = FUN_000cce60(uVar2, uVar1);
    local_24 = &local_3c;
    local_20 = uVar4;
    uVar4 = FUN_0005aa20((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
    *local_24 = uVar4;
    local_18 = (double)FUN_000ccad4((undefined4)local_20, local_20._4_4_);
    local_18 = local_18 * 1.8446744073709552e+19;
    dVar3 = local_10 - local_18;
    local_10._0_4_ = SUB84(dVar3, 0);
    local_10._4_4_ = (undefined4)((ulonglong)dVar3 >> 0x20);
    uVar1 = local_10._4_4_;
    uVar2 = (undefined4)local_10;
    local_10 = dVar3;
    uVar4 = FUN_000cce60(uVar2, uVar1);
    local_24 = &local_44;
    local_20 = uVar4;
    uVar4 = FUN_0005aa20((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
    *local_24 = uVar4;
    memcpy(param_1, &local_44, 0x20);
    return;
}

char target_to_diff_ltc(int param_1)

{
    uint uVar1;
    uint local_1c;
    int local_18;
    char local_11;

    local_11 = '\0';
    local_18 = 0x18;
    do {
        if (local_18 < 0) {
            return local_11;
        }
        uVar1 = ((uint *)(param_1 + local_18))[1];
        for (local_1c = 0x3f; -1 < (int)local_1c; local_1c = local_1c - 1) {
            if (((*(uint *)(param_1 + local_18) >> (local_1c & 0xff) |
                  uVar1 << (0x20 - local_1c & 0xff) |
                  uVar1 >> (local_1c - 0x20 & 0xff)) &
                 1) != 0) {
                return local_11;
            }
            local_11 = local_11 + '\x01';
        }
        local_18 = local_18 + -8;
    } while (true);
}

undefined4 target_to_double_diff_ltc(undefined4 param_1)

{
    undefined4 uVar1;
    undefined4 extraout_s1;
    undefined8 local_10;

    uVar1 = le256todouble(param_1);
    local_10 = (double)CONCAT44(extraout_s1, uVar1);
    if (local_10 == 0.0) {
        local_10 = 1.0;
    }
    return SUB84(65536.0 / local_10, 0);
}

void FUN_0005ade0(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_0005af6c(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

undefined4 FUN_0005b0fc(int *param_1, int *param_2)

{
    undefined4 uVar1;
    int iVar2;

    if (param_1[0x11b] == 0) {
        printf("invalid pointer(%s)!\n", "private");
        uVar1 = 3;
    } else {
        memcpy(param_1 + 2, param_2 + 0x74, *(byte *)(param_2 + 0x74) + 1);
        iVar2 = *param_2;
        *param_1 = iVar2;
        param_1[1] = iVar2 >> 0x1f;
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 FUN_0005b1ac(int param_1, undefined4 *param_2)

{
    undefined4 uVar1;
    undefined4 local_198;
    undefined4 local_194;
    char acStack_190[64];
    undefined4 local_150;
    undefined4 uStack_14c;
    undefined4 uStack_148;
    undefined4 uStack_144;
    undefined4 local_140;
    undefined4 uStack_13c;
    undefined4 uStack_138;
    undefined4 uStack_134;
    undefined4 local_130;
    undefined4 local_12c;
    undefined4 local_128;
    undefined4 local_124;
    char acStack_120[64];
    undefined1 auStack_e0[198];
    byte local_1a;
    undefined4 local_19;
    char *local_c;

    local_c = (char *)param_2[0x11b];
    if (local_c == (char *)0x0) {
        printf("invalid pointer(%s)!\n", "private");
        uVar1 = 3;
    } else {
        local_198 = *param_2;
        local_194 = param_2[1];
        strcpy(acStack_190, local_c);
        local_150 = *(undefined4 *)(local_c + 0x40);
        uStack_14c = *(undefined4 *)(local_c + 0x44);
        uStack_148 = *(undefined4 *)(local_c + 0x48);
        uStack_144 = *(undefined4 *)(local_c + 0x4c);
        local_140 = *(undefined4 *)(local_c + 0x50);
        uStack_13c = *(undefined4 *)(local_c + 0x54);
        uStack_138 = *(undefined4 *)(local_c + 0x58);
        uStack_134 = *(undefined4 *)(local_c + 0x5c);
        local_130 = *(undefined4 *)(local_c + 0x60);
        local_12c = *(undefined4 *)(local_c + 100);
        local_128 = *(undefined4 *)(local_c + 0x68);
        local_124 = *(undefined4 *)(local_c + 0x6c);
        strcpy(acStack_120, (char *)param_2[0x119]);
        local_1a = *(byte *)(param_2 + 2);
        memcpy(auStack_e0, (void *)((int)param_2 + 9), (uint)local_1a);
        local_19 = param_2[0xc];
        (**(code **)(param_1 + 0x20))(param_1, &local_198);
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 FUN_0005b300(int param_1, int param_2, int param_3)

{
    int iVar1;
    undefined4 uVar2;
    uint uVar3;
    undefined1 auStack_1010[4096];
    char *local_10;
    int local_c;

    local_10 = *(char **)(param_1 + 0x46c);
    local_c = param_3;
    if (local_10 == (char *)0x0) {
        printf("invalid pointer(%s)!\n", "private");
        uVar2 = 3;
    } else if (*(int *)(param_2 + 0x634) == 0) {
        printf("invalid pointer(%s)!\n", "pool->work.private");
        uVar2 = 3;
    } else {
        iVar1 = strcmp((char *)(param_3 + 0x10), local_10);
        if ((((iVar1 == 0) &&
              (iVar1 = memcmp((void *)(local_c + 0x50), local_10 + 0x40, 0x20),
               iVar1 == 0)) &&
             (*(int *)(local_c + 0x74) == *(int *)(local_10 + 100) &&
              *(int *)(local_c + 0x70) == *(int *)(local_10 + 0x60))) &&
            ((*(int *)(local_c + 0x7c) == *(int *)(local_10 + 0x6c) &&
              *(int *)(local_c + 0x78) == *(int *)(local_10 + 0x68) &&
              ((*(int *)(param_2 + 0x62c) == 0 ||
                (iVar1 = strcmp((char *)(local_c + 0x80),
                                *(char **)(param_2 + 0x62c)),
                 iVar1 == 0)))))) {
            uVar3 = (uint) * (byte *)(local_c + 0xc0) << 0x18 |
                    (uint) * (byte *)(local_c + 0xc1) << 0x10 |
                    (uint) * (byte *)(local_c + 0xc2) << 8 |
                    (uint) * (byte *)(local_c + 0xc3);
            *(uint *)(param_1 + 0x430) = uVar3;
            *(int *)(param_1 + 0x434) = (int)uVar3 >> 0x1f;
            *(undefined4 *)(param_1 + 0x430) = *(undefined4 *)(local_c + 0xc0);
            memcpy(local_10 + 0x70, (void *)(local_c + 0xc4), 0x20);
            uVar2 = 0;
        } else {
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0,
                       "stale nonce, ans_id: %s ,pool_job_id: %s, chip_id %d, "
                       "core_id %d",
                       local_c + 0x80, *(undefined4 *)(param_2 + 0x62c),
                       *(undefined4 *)(local_c + 8),
                       *(undefined4 *)(local_c + 0xc));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/dhash_content/"
                 "x7/x7_2044/x7_2044_content.c",
                 0xb4, "nonce_pop_handler_x7_2044", 0x19, 0x37, 0x14,
                 auStack_1010);
            uVar2 = 1;
        }
    }
    return uVar2;
}

void *dhash_content_x7_2044(void)

{
    undefined8 local_24;
    undefined8 local_1c;
    undefined8 local_14;
    void *local_c;

    local_24 = 0x5b1ac0005b0fc;
    local_1c = 0x5b300;
    local_14 = 0x5a001166b0;
    local_c = calloc(1, 0x18);
    memcpy(local_c, &local_24, 0x18);
    return local_c;
}

undefined8 FUN_0005b660(uint param_1, uint param_2)

{
    return CONCAT44(param_1 << 0x18 | (param_1 >> 8 & 0xff) << 0x10 |
                        (param_1 >> 0x10 & 0xff) << 8 | param_1 >> 0x18,
                    param_2 << 0x18 | (param_2 >> 8 & 0xff) << 0x10 |
                        (param_2 >> 0x10 & 0xff) << 8 | param_2 >> 0x18);
}

undefined8 FUN_0005b6a4(undefined4 param_1, undefined4 param_2)

{
    return CONCAT44(param_2, param_1);
}

undefined4 le256todouble(undefined4 *param_1)

{
    double dVar1;
    double dVar2;
    double dVar3;
    double dVar4;
    undefined8 uVar5;
    undefined4 local_18;

    uVar5 = FUN_0005b6a4(param_1[6], param_1[7]);
    dVar1 = (double)FUN_000ccad4((int)uVar5, (int)((ulonglong)uVar5 >> 0x20));
    uVar5 = FUN_0005b6a4(param_1[4], param_1[5]);
    dVar2 = (double)FUN_000ccad4((int)uVar5, (int)((ulonglong)uVar5 >> 0x20));
    uVar5 = FUN_0005b6a4(param_1[2], param_1[3]);
    dVar3 = (double)FUN_000ccad4((int)uVar5, (int)((ulonglong)uVar5 >> 0x20));
    uVar5 = FUN_0005b6a4(*param_1, param_1[1]);
    dVar4 = (double)FUN_000ccad4((int)uVar5, (int)((ulonglong)uVar5 >> 0x20));
    local_18 =
        SUB84(dVar1 * 6.277101735386681e+57 + dVar2 * 3.402823669209385e+38 +
                  dVar3 * 1.8446744073709552e+19 + dVar4,
              0);
    return local_18;
}

undefined4 le256_target_to_double_diff_base(undefined4 param_1)

{
    undefined4 uVar1;
    double in_d0;
    undefined4 extraout_s1;
    undefined8 local_10;

    uVar1 = le256todouble(param_1);
    local_10 = (double)CONCAT44(extraout_s1, uVar1);
    if (local_10 == 0.0) {
        local_10 = 1.0;
    }
    return SUB84(in_d0 / local_10, 0);
}

void diff_to_le256_target_base(void *param_1)

{
    undefined4 uVar1;
    undefined4 uVar2;
    double in_d0;
    double in_d1;
    double dVar3;
    undefined8 uVar4;
    double local_1058;
    undefined1 auStack_1044[4096];
    undefined8 local_44;
    undefined8 local_3c;
    undefined8 local_34;
    undefined8 local_2c;
    undefined8 *local_24;
    undefined8 local_20;
    undefined8 local_18;
    undefined8 local_10;

    local_1058 = in_d0;
    if (in_d0 <= 0.0) {
        V_LOCK();
        logfmt_raw(auStack_1044, 0x1000, 0, "Diff zero passed to set_target");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/dhash_content/base_common.c",
             0xa5, "diff_to_le256_target_base", 0x19, 0x39, 0x14, auStack_1044);
        local_1058 = 1.0;
    }
    local_10 = in_d1 / local_1058;
    dVar3 = local_10 / 6.277101735386681e+57;
    local_18._0_4_ = SUB84(dVar3, 0);
    local_18._4_4_ = (undefined4)((ulonglong)dVar3 >> 0x20);
    uVar1 = local_18._4_4_;
    uVar2 = (undefined4)local_18;
    local_18 = dVar3;
    local_20 = FUN_000cce60(uVar2, uVar1);
    local_24 = &local_2c;
    uVar4 = FUN_0005b6a4((int)local_20, (int)((ulonglong)local_20 >> 0x20));
    *local_24 = uVar4;
    local_18 = (double)FUN_000ccad4((undefined4)local_20, local_20._4_4_);
    local_10 = local_10 - local_18 * 6.277101735386681e+57;
    dVar3 = local_10 / 3.402823669209385e+38;
    local_18._0_4_ = SUB84(dVar3, 0);
    local_18._4_4_ = (undefined4)((ulonglong)dVar3 >> 0x20);
    uVar1 = local_18._4_4_;
    uVar2 = (undefined4)local_18;
    local_18 = dVar3;
    uVar4 = FUN_000cce60(uVar2, uVar1);
    local_24 = &local_34;
    local_20 = uVar4;
    uVar4 = FUN_0005b6a4((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
    *local_24 = uVar4;
    local_18 = (double)FUN_000ccad4((undefined4)local_20, local_20._4_4_);
    local_10 = local_10 - local_18 * 3.402823669209385e+38;
    dVar3 = local_10 / 1.8446744073709552e+19;
    local_18._0_4_ = SUB84(dVar3, 0);
    local_18._4_4_ = (undefined4)((ulonglong)dVar3 >> 0x20);
    uVar1 = local_18._4_4_;
    uVar2 = (undefined4)local_18;
    local_18 = dVar3;
    uVar4 = FUN_000cce60(uVar2, uVar1);
    local_24 = &local_3c;
    local_20 = uVar4;
    uVar4 = FUN_0005b6a4((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
    *local_24 = uVar4;
    local_18 = (double)FUN_000ccad4((undefined4)local_20, local_20._4_4_);
    local_18 = local_18 * 1.8446744073709552e+19;
    dVar3 = local_10 - local_18;
    local_10._0_4_ = SUB84(dVar3, 0);
    local_10._4_4_ = (undefined4)((ulonglong)dVar3 >> 0x20);
    uVar1 = local_10._4_4_;
    uVar2 = (undefined4)local_10;
    local_10 = dVar3;
    uVar4 = FUN_000cce60(uVar2, uVar1);
    local_24 = &local_44;
    local_20 = uVar4;
    uVar4 = FUN_0005b6a4((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
    *local_24 = uVar4;
    memcpy(param_1, &local_44, 0x20);
    return;
}

char le256_target_to_diff_base(int param_1)

{
    uint local_14;
    int local_10;
    char local_9;

    local_9 = '\0';
    local_10 = 0x1f;
    do {
        if (local_10 < 0) {
            return local_9;
        }
        for (local_14 = 7; -1 < (int)local_14; local_14 = local_14 - 1) {
            if (((int)(uint) * (byte *)(param_1 + local_10) >>
                     (local_14 & 0xff) &
                 1U) != 0) {
                return local_9;
            }
            local_9 = local_9 + '\x01';
        }
        local_10 = local_10 + -1;
    } while (true);
}

undefined4 be256todouble(undefined4 *param_1)

{
    double dVar1;
    double dVar2;
    double dVar3;
    double dVar4;
    undefined8 uVar5;
    undefined4 local_18;

    uVar5 = FUN_0005b660(*param_1, param_1[1]);
    dVar1 = (double)FUN_000ccad4((int)uVar5, (int)((ulonglong)uVar5 >> 0x20));
    uVar5 = FUN_0005b660(param_1[2], param_1[3]);
    dVar2 = (double)FUN_000ccad4((int)uVar5, (int)((ulonglong)uVar5 >> 0x20));
    uVar5 = FUN_0005b660(param_1[4], param_1[5]);
    dVar3 = (double)FUN_000ccad4((int)uVar5, (int)((ulonglong)uVar5 >> 0x20));
    uVar5 = FUN_0005b660(param_1[6], param_1[7]);
    dVar4 = (double)FUN_000ccad4((int)uVar5, (int)((ulonglong)uVar5 >> 0x20));
    local_18 =
        SUB84(dVar1 * 6.277101735386681e+57 + dVar2 * 3.402823669209385e+38 +
                  dVar3 * 1.8446744073709552e+19 + dVar4,
              0);
    return local_18;
}

undefined4 be256_target_to_double_diff_base(undefined4 param_1)

{
    undefined4 uVar1;
    double in_d0;
    undefined4 extraout_s1;
    undefined8 local_10;

    uVar1 = be256todouble(param_1);
    local_10 = (double)CONCAT44(extraout_s1, uVar1);
    if (local_10 == 0.0) {
        local_10 = 1.0;
    }
    return SUB84(in_d0 / local_10, 0);
}

void diff_to_be256_target_base(void *param_1)

{
    undefined4 uVar1;
    undefined4 uVar2;
    double in_d0;
    double in_d1;
    double dVar3;
    undefined8 uVar4;
    double local_1058;
    undefined1 auStack_1044[4096];
    undefined8 local_44;
    undefined8 local_3c;
    undefined8 local_34;
    undefined8 local_2c;
    undefined8 *local_24;
    undefined8 local_20;
    undefined8 local_18;
    undefined8 local_10;

    local_1058 = in_d0;
    if (in_d0 <= 0.0) {
        V_LOCK();
        logfmt_raw(auStack_1044, 0x1000, 0, "Diff zero passed to set_target");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/dhash_content/base_common.c",
             0xa5, "diff_to_be256_target_base", 0x19, 0xa9, 0x14, auStack_1044);
        local_1058 = 1.0;
    }
    local_10 = in_d1 / local_1058;
    dVar3 = local_10 / 6.277101735386681e+57;
    local_18._0_4_ = SUB84(dVar3, 0);
    local_18._4_4_ = (undefined4)((ulonglong)dVar3 >> 0x20);
    uVar1 = local_18._4_4_;
    uVar2 = (undefined4)local_18;
    local_18 = dVar3;
    local_20 = FUN_000cce60(uVar2, uVar1);
    local_24 = &local_44;
    uVar4 = FUN_0005b660((int)local_20, (int)((ulonglong)local_20 >> 0x20));
    *local_24 = uVar4;
    local_18 = (double)FUN_000ccad4((undefined4)local_20, local_20._4_4_);
    local_10 = local_10 - local_18 * 6.277101735386681e+57;
    dVar3 = local_10 / 3.402823669209385e+38;
    local_18._0_4_ = SUB84(dVar3, 0);
    local_18._4_4_ = (undefined4)((ulonglong)dVar3 >> 0x20);
    uVar1 = local_18._4_4_;
    uVar2 = (undefined4)local_18;
    local_18 = dVar3;
    uVar4 = FUN_000cce60(uVar2, uVar1);
    local_24 = &local_3c;
    local_20 = uVar4;
    uVar4 = FUN_0005b660((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
    *local_24 = uVar4;
    local_18 = (double)FUN_000ccad4((undefined4)local_20, local_20._4_4_);
    local_10 = local_10 - local_18 * 3.402823669209385e+38;
    dVar3 = local_10 / 1.8446744073709552e+19;
    local_18._0_4_ = SUB84(dVar3, 0);
    local_18._4_4_ = (undefined4)((ulonglong)dVar3 >> 0x20);
    uVar1 = local_18._4_4_;
    uVar2 = (undefined4)local_18;
    local_18 = dVar3;
    uVar4 = FUN_000cce60(uVar2, uVar1);
    local_24 = &local_34;
    local_20 = uVar4;
    uVar4 = FUN_0005b660((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
    *local_24 = uVar4;
    local_18 = (double)FUN_000ccad4((undefined4)local_20, local_20._4_4_);
    local_18 = local_18 * 1.8446744073709552e+19;
    dVar3 = local_10 - local_18;
    local_10._0_4_ = SUB84(dVar3, 0);
    local_10._4_4_ = (undefined4)((ulonglong)dVar3 >> 0x20);
    uVar1 = local_10._4_4_;
    uVar2 = (undefined4)local_10;
    local_10 = dVar3;
    uVar4 = FUN_000cce60(uVar2, uVar1);
    local_24 = &local_2c;
    local_20 = uVar4;
    uVar4 = FUN_0005b660((int)uVar4, (int)((ulonglong)uVar4 >> 0x20));
    *local_24 = uVar4;
    memcpy(param_1, &local_44, 0x20);
    return;
}

char be256_target_to_diff_base(int param_1)

{
    uint local_14;
    int local_10;
    char local_9;

    local_9 = '\0';
    local_10 = 0;
    do {
        if (0x1f < local_10) {
            return local_9;
        }
        for (local_14 = 7; -1 < (int)local_14; local_14 = local_14 - 1) {
            if (((int)(uint) * (byte *)(param_1 + local_10) >>
                     (local_14 & 0xff) &
                 1U) != 0) {
                return local_9;
            }
            local_9 = local_9 + '\x01';
        }
        local_10 = local_10 + 1;
    } while (true);
}

undefined4 FUN_0005c1bc(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "fanid", param_3, param_4);
    return param_1;
}

undefined4 FUN_0005c1f0(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "fanspeed", param_3, param_4);
    return param_1;
}

void check_fan_valid(void)

{
    undefined4 uVar1;
    int iVar2;
    uint uVar3;
    undefined1 auStack_1070[4096];
    undefined4 local_70;
    undefined4 uStack_6c;
    undefined4 uStack_68;
    undefined4 uStack_64;
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    int local_30;
    uint local_2c;
    int local_28;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;

    local_20 = 0;
    if (fan_inited != '\x01') {
        fan_init();
        fan_inited = '\x01';
    }
    green_led_off();
    red_led_off();
    fan_pwm_set_max();
    V_LOCK();
    logfmt_raw(auStack_1070, 0x1000, 0, "Begain check_fan_valid");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/miner_util/check_fan.c",
         0xa0, "check_fan_valid", 0xf, 0x1f, 0x14, auStack_1070);
    local_28 = platform_get_fan_num();
    do {
        local_24 = 0;
        for (local_1c = 0; local_1c < local_28; local_1c = local_1c + 1) {
            local_30 = fan_get_realtime_speed(local_1c);
            if (local_30 != -1) {
                uVar1 = platform_get_fan_max_speed(local_1c);
                iVar2 = fan_get_check_fan_speed(uVar1);
                if (iVar2 <= local_30) {
                    local_24 = local_24 + 1;
                }
            }
        }
        usleep(500000);
        local_20 = local_20 + 1;
        if (local_20 % 0x14 == 0) {
            fan_pwm_set_max(local_20 * 0x66666667);
        }
        if (local_24 < local_28) {
            if (local_20 % 0x78 == 0) {
                red_led_on(local_20 * -0x77777777);
                for (local_18 = 0; local_18 < local_28;
                     local_18 = local_18 + 1) {
                    local_2c = fan_get_realtime_speed(local_18);
                    if (local_2c == 0xffffffff) {
                    LAB_0005c458:
                        V_LOCK();
                        FUN_0005c1bc(&local_70, &local_70, local_18,
                                     local_18 >> 0x1f);
                        uVar3 = local_2c & ~((int)local_2c >> 0x1f);
                        FUN_0005c1f0(&local_50, &local_50, uVar3,
                                     (int)uVar3 >> 0x1f);
                        logfmt_raw(
                            auStack_1070, 0x1000, 0, uStack_54, local_70,
                            uStack_6c, uStack_68, uStack_64, local_60,
                            uStack_5c, uStack_58, uStack_54, local_50,
                            uStack_4c, uStack_48, uStack_44, local_40,
                            uStack_3c, uStack_38, uStack_34,
                            "%2d(corresponding to FAN%s on control board PCB)",
                            local_18, *(undefined4 *)(fan_name + local_18 * 4));
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/miner_util/"
                             "check_fan.c",
                             0xa0, "check_fan_valid", 0xf, 0x34, 100,
                             auStack_1070);
                        set_miner_6060info_status_fan_err(local_18, 1);
                    } else {
                        uVar1 = platform_get_fan_max_speed(local_18);
                        iVar2 = fan_get_check_fan_speed(uVar1);
                        if ((int)local_2c < iVar2)
                            goto LAB_0005c458;
                    }
                }
            }
        }
        if (local_28 <= local_24) {
            local_14 = 0;
            while (true) {
                if (local_28 <= local_14)
                    break;
                set_miner_6060info_status_fan_err(local_14, 0);
                local_14 = local_14 + 1;
            }
            V_LOCK();
            logfmt_raw(auStack_1070, 0x1000, 0,
                       "check_fan_speed ok, fan_num = %d", local_24);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/miner_util/check_fan.c",
                0xa0, "check_fan_valid", 0xf, 0x3d, 0x3c, auStack_1070);
            return;
        }
    } while (true);
}

undefined4 FUN_0005c648(undefined4 param_1, undefined4 param_2)

{
    V_STR(param_1, "error", param_2);
    return param_1;
}

void FUN_0005c680(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_0005c80c(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

int FUN_0005c99c(void *param_1, __start_routine *param_2)

{
    int iVar1;

    pthread_attr_init((pthread_attr_t *)((int)param_1 + 8));
    iVar1 =
        pthread_create((pthread_t *)((int)param_1 + 4),
                       (pthread_attr_t *)((int)param_1 + 8), param_2, param_1);
    pthread_attr_destroy((pthread_attr_t *)((int)param_1 + 8));
    return iVar1;
}

void heartbeat_on_device(void)

{
    int iVar1;
    undefined1 auStack_103c[4096];
    int local_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    int local_18;
    int local_14;

    local_3c = 0;
    V_LOCK();
    logfmt_raw(auStack_103c, 0x1000, 0, "heartbeat_on_device");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/miner_util/check_heartbeat.c",
         0xa6, "heartbeat_on_device", 0x13, 0x36, 0x3c, auStack_103c);
    do {
        local_18 = get_all_created_runtime(&local_3c);
        for (local_14 = 0; local_14 < local_3c; local_14 = local_14 + 1) {
            iVar1 = dev_ctrl();
            iVar1 = (**(code **)(iVar1 + 0x50))(
                *(undefined4 *)(*(int *)(local_18 + local_14 * 4) + 0xf8));
            if (iVar1 == 0) {
                V_LOCK();
                FUN_0005c648(&local_38, "pic lost");
                logfmt_raw(auStack_103c, 0x1000, 0, uStack_1c, local_38,
                           uStack_34, uStack_30, uStack_2c, local_28, uStack_24,
                           uStack_20, uStack_1c, "heartbeat failed!");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/check_heartbeat.c",
                     0xa6, "heartbeat_on_device", 0x13, 0x3e, 100,
                     auStack_103c);
            }
            sleep(5);
        }
    } while (true);
}

int psu_watchdog(void)

{
    uint uVar1;
    int iVar2;
    int extraout_r3;
    undefined4 uVar3;
    undefined4 extraout_s1;
    undefined4 uVar4;
    undefined1 auStack_1020[4096];
    int local_20;
    int local_1c;
    double local_18;
    int local_10;
    int local_c;

    local_18 = -1.0;
    local_10 = 0;
    local_20 = 0;
    local_c = 0;
    local_1c = bitmain_set_watchdog(1);
    V_LOCK();
    logfmt_raw(auStack_1020, 0x1000, 0, "enable power watchdog: 0x%04x",
               local_1c);
    V_UNLOCK();
    uVar4 = 0x4d;
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/miner_util/check_heartbeat.c",
         0xa6, "psu_watchdog", 0xc, 0x4d, 0x3c, auStack_1020);
    if (local_1c == 1) {
        while (true) {
            pthread_setcancelstate(1, (int *)0x0);
            uVar3 = read_feedback_voltage(0);
            local_18 = (double)CONCAT44(extraout_s1, uVar3);
            local_10 = get_current_voltage();
            iVar2 = is_power_on();
            if (iVar2 != 0) {
                if (0.0 <= local_18) {
                    if (((double)(longlong)local_10 * 1.1 < local_18 * 100.0) ||
                        (local_18 * 100.0 < (double)(longlong)local_10 * 0.9)) {
                        V_LOCK();
                        if (local_18 * 100.0 - (double)(longlong)local_10 <=
                            0.0) {
                            uVar1 = 0x6e2c;
                        } else {
                            uVar1 = 0x6e24;
                        }
                        logfmt_raw(
                            auStack_1020, 0x1000, 0,
                            ">> chain avg vol %s from %d to %.2f, pls check <<",
                            uVar1 | 0x110000, local_10, local_18 * 100.0);
                        V_UNLOCK();
                        uVar4 = 0x5d;
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/miner_util/"
                             "check_heartbeat.c",
                             0xa6, "psu_watchdog", 0xc, 0x5d, 0x50,
                             auStack_1020);
                        local_c = local_c + 1;
                    } else {
                        local_c = 0;
                    }
                } else {
                    V_LOCK();
                    logfmt_raw(
                        auStack_1020, 0x1000, 0,
                        ">> read_feedback_voltage failed!, pls check <<");
                    V_UNLOCK();
                    uVar4 = 0x59;
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/check_heartbeat.c",
                         0xa6, "psu_watchdog", 0xc, 0x59, 100, auStack_1020);
                    local_c = local_c + 1;
                }
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0,
                           "cur_voltage = %d, avg_voltage = %.2f", local_10,
                           uVar4, local_18 * 100.0);
                V_UNLOCK();
                uVar4 = 99;
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/check_heartbeat.c",
                     0xa6, "psu_watchdog", 0xc, 99, 0x14, auStack_1020);
            }
            local_1c = bitmain_get_power_status();
            if (local_1c == 0) {
                local_20 = 0;
            } else {
                V_LOCK();
                local_20 = local_20 + 1;
                logfmt_raw(auStack_1020, 0x1000, 0,
                           ">> power status error, ret %d, err_times %d <<",
                           local_1c, local_20);
                V_UNLOCK();
                uVar4 = 0x6e;
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/check_heartbeat.c",
                     0xa6, "psu_watchdog", 0xc, 0x6e, 0x50, auStack_1020);
                if (local_c != 0) {
                    return local_c;
                }
                if (3 < local_20) {
                    return local_20;
                }
            }
            if (3 < local_c)
                break;
            pthread_setcancelstate(0, (int *)0x0);
            pthread_testcancel();
            sleep(10);
        }
        V_LOCK();
        logfmt_raw(auStack_1020, 0x1000, 0,
                   ">> feedback voltage: too many times error, pls check <<");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/check_heartbeat.c",
             0xa6, "psu_watchdog", 0xc, 0x75, 100, auStack_1020);
        iVar2 = extraout_r3;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1020, 0x1000, 0, "%s enable power watchdog failed!",
                   "psu_watchdog");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/check_heartbeat.c",
             0xa6, "psu_watchdog", 0xc, 0x4f, 100, auStack_1020);
        iVar2 = 0;
    }
    return iVar2;
}

undefined4 start_heartbeat_thread(void)

{
    int iVar1;
    undefined4 uVar2;
    undefined1 auStack_1010[4096];
    undefined4 *local_10;
    int local_c;

    local_10 = (undefined4 *)calloc(1, 0x30);
    *local_10 = 5;
    local_c = 0xffffffff;
    iVar1 = platform_is_pic_mcu_en();
    if (iVar1 == 0) {
        local_c = FUN_0005c99c(local_10, psu_watchdog);
    } else {
        local_c = FUN_0005c99c(local_10, heartbeat_on_device);
    }
    if (local_c == 0) {
        pthread_detach(local_10[1]);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, "start_heartbeat_thread");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/check_heartbeat.c",
             0xa6, "start_heartbeat_thread", 0x16, 0x8c, 0x3c, auStack_1010);
        uVar2 = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, "heartbeat thread create failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/check_heartbeat.c",
             0xa6, "start_heartbeat_thread", 0x16, 0x88, 100, auStack_1010);
        uVar2 = 5;
    }
    return uVar2;
}

void stop_heartbeat_thread(int param_1)

{
    /* WARNING: Subroutine does not return */
    pthread_exit((void *)(param_1 + 4));
}

undefined4 FUN_0005d2d8(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "poolno", param_3, param_4);
    return param_1;
}

undefined4 FUN_0005d30c(undefined4 param_1, undefined4 param_2)

{
    V_STR(param_1, &DAT_00116fa0, param_2);
    return param_1;
}

void FUN_0005d344(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_0005d4d0(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

int FUN_0005d660(void *param_1, __start_routine *param_2)

{
    int iVar1;

    pthread_attr_init((pthread_attr_t *)((int)param_1 + 8));
    iVar1 =
        pthread_create((pthread_t *)((int)param_1 + 4),
                       (pthread_attr_t *)((int)param_1 + 8), param_2, param_1);
    pthread_attr_destroy((pthread_attr_t *)((int)param_1 + 8));
    return iVar1;
}

void FUN_0005d6cc(void)

{
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = nice(10);
    if (local_c == 0) {
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0,
                   "Unable to set thread to low priority");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/check_pool.c",
             0xa1, "set_lowprio", 0xb, 0x12, 0x14, auStack_100c);
    }
    return;
}

void watchpool_thread(void)

{
    char cVar1;
    pthread_t __th;
    long lVar2;
    int iVar3;
    int iVar4;
    undefined1 auStack_1068[4096];
    int local_68[2];
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    int *local_20;
    int local_1c;
    char *local_18;
    int local_14;

    __th = pthread_self();
    pthread_detach(__th);
    pthread_setcanceltype(1, (int *)0x0);
    FUN_0005d6cc();
    local_18 = (char *)calloc(1, 0x40);
    snprintf(local_18, 0x40, "%.10s_%d", "watchpool_thread", 0);
    V_LOCK();
    lVar2 = syscall(0xe0);
    logfmt_raw(auStack_1068, 0x1000, 0, "%s on pid %ld", local_18, lVar2);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/miner_util/check_pool.c",
         0xa1, "watchpool_thread", 0x10, 0x1f, 0x28, auStack_1068);
    prctl(0xf, local_18);
    do {
        cgtime(local_68);
        local_14 = 0;
        while (true) {
            if (total_pools <= local_14)
                break;
            local_20 = *(int **)(pools + local_14 * 4);
            cVar1 = pool_tget(local_20, local_20 + 0x1dc);
            if ((cVar1 != '\x01') &&
                (iVar4 = local_20[1], iVar3 = get_current_pool(),
                 iVar4 < *(int *)(iVar3 + 4))) {
                if (0x78 < local_68[0] - local_20[0x1dd]) {
                    V_LOCK();
                    FUN_0005d2d8(&local_60, &local_60, *local_20,
                                 *local_20 >> 0x1f);
                    FUN_0005d30c(&local_40, local_20[3]);
                    logfmt_raw(auStack_1068, 0x1000, 0, uStack_44, local_60,
                               uStack_5c, uStack_58, uStack_54, local_50,
                               uStack_4c, uStack_48, uStack_44, local_40,
                               uStack_3c, uStack_38, uStack_34, local_30,
                               uStack_2c, uStack_28, uStack_24,
                               "stable for >%d seconds", 0x78);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/check_pool.c",
                         0xa1, "watchpool_thread", 0x10, 0x32, 0x50,
                         auStack_1068);
                    switch_pools(0);
                }
            }
            local_14 = local_14 + 1;
        }
        local_1c = get_current_pool();
        iVar3 = pool_tget(local_1c, local_1c + 0x770);
        if (iVar3 != 0) {
            switch_pools(0);
        }
        sleep(0x1e);
    } while (true);
}

undefined4 FUN_0005da64(int param_1)

{
    pthread_t __th;

    __th = pthread_self();
    pthread_detach(__th);
    pthread_setcanceltype(1, (int *)0x0);
    FUN_0005d6cc();
    api();
    *(undefined4 *)(param_1 + 4) = 0;
    return 0;
}

void FUN_0005dabc(void)

{
    int local_14;
    int local_10;
    int local_c;

    local_14 = 0;
    local_10 = get_all_created_runtime(&local_14);
    for (local_c = 0; local_c < local_14; local_c = local_c + 1) {
        (**(code **)(*(int *)(local_10 + local_c * 4) + 0x14))(
            *(undefined4 *)(local_10 + local_c * 4));
        (**(code **)(*(int *)(local_10 + local_c * 4) + 0x1c))(
            *(undefined4 *)(local_10 + local_c * 4));
    }
    if (local_14 != 0) {
        fan_pwm_set(0x14);
    }
    green_led_on();
    red_led_on();
    while (pools_active != '\x01') {
        sleep(1);
    }
    return;
}

void FUN_0005dbc0(void)

{
    return;
}

undefined4 start_watchpool_thread(void)

{
    undefined4 uVar1;
    undefined1 auStack_1010[4096];
    int local_10;
    undefined4 local_c;

    local_c = 0x161060;
    thr_info._96_4_ = 2;
    local_10 = FUN_0005d660(0x161060, watchpool_thread);
    if (local_10 == 0) {
        uVar1 = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, "watchpool thread create failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/check_pool.c",
             0xa1, "start_watchpool_thread", 0x16, 0x7f, 100, auStack_1010);
        uVar1 = 5;
    }
    return uVar1;
}

undefined4 start_api_thread(void)

{
    undefined4 uVar1;
    undefined1 auStack_1010[4096];
    int local_10;
    undefined4 local_c;

    local_c = 0x161090;
    thr_info._144_4_ = 3;
    local_10 = FUN_0005d660(0x161090, FUN_0005da64);
    if (local_10 == 0) {
        uVar1 = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, "api thread create failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/check_pool.c",
             0xa1, "start_api_thread", 0x10, 0x8b, 100, auStack_1010);
        uVar1 = 5;
    }
    return uVar1;
}

undefined4 create_pool_connect(void)

{
    int iVar1;
    char *pcVar2;
    undefined1 uVar3;
    undefined1 auStack_1018[4096];
    undefined4 *local_18;
    undefined4 local_14;
    int local_10;
    int local_c;

    local_14 = 0;
    FUN_0005dbc0();
    iVar1 = create_pool_stratum_threads();
    if (iVar1 == 0) {
        local_10 = 0;
        do {
            sleep(1);
            local_10 = local_10 + 1;
            if (pools_active == '\x01')
                break;
        } while (local_10 < 0x3c);
        if (pools_active != '\x01') {
            V_LOCK();
            logfmt_raw(
                auStack_1018, 0x1000, 0,
                "No servers were found that could be used to get work from.");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "check_pool.c",
                 0xa1, "create_pool_connect", 0x13, 0xa5, 100, auStack_1018);
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0,
                       "Please check the details from the list below of the "
                       "servers you have input.");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "check_pool.c",
                 0xa1, "create_pool_connect", 0x13, 0xa6, 100, auStack_1018);
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0,
                       "Most likely you have input the wrong URL, forgotten to "
                       "add a port, have not set up workers, or the network "
                       "was disconnected.");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "check_pool.c",
                 0xa1, "create_pool_connect", 0x13, 0xa7, 100, auStack_1018);
            for (local_c = 0; local_c < total_pools; local_c = local_c + 1) {
                local_18 = *(undefined4 **)(pools + local_c * 4);
                V_LOCK();
                logfmt_raw(auStack_1018, 0x1000, 0,
                           "Pool: %d  URL: %s\tUser: %s  Password: %s",
                           *local_18, local_18[3], local_18[4], local_18[5]);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/check_pool.c",
                     0xa1, "create_pool_connect", 0x13, 0xad, 0x50,
                     auStack_1018);
                if ((local_18[5] != 0) && (local_18[4] != 0)) {
                    pcVar2 = strstr((char *)local_18[5], "stats");
                    if ((pcVar2 == (char *)0x0) &&
                        (iVar1 = strcmp((char *)local_18[4], "benchmark"),
                         iVar1 != 0)) {
                        uVar3 = 0;
                    } else {
                        uVar3 = 1;
                    }
                    *(undefined1 *)(local_18 + 0x19c) = uVar3;
                }
            }
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, "No servers could be used!");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "check_pool.c",
                 0xa1, "create_pool_connect", 0x13, 0xb3, 100, auStack_1018);
            FUN_0005dabc();
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0,
                       "Pool is activing, exiting and restart.");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "check_pool.c",
                 0xa1, "create_pool_connect", 0x13, 0xb5, 0x50, auStack_1018);
            local_14 = 0;
        }
    } else {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, "stratum thread create failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/check_pool.c",
             0xa1, "create_pool_connect", 0x13, 0x99, 100, auStack_1018);
        local_14 = 1;
    }
    return local_14;
}

undefined4 check_pool_connect(void)

{
    int iVar1;
    char *pcVar2;
    undefined1 uVar3;
    undefined1 auStack_1018[4096];
    int local_18;
    int local_14;
    undefined4 local_10;
    int local_c;

    local_10 = 0;
    FUN_0005dbc0();
    iVar1 = check_pools_valid();
    if (iVar1 < 1) {
        V_LOCK();
        logfmt_raw(
            auStack_1018, 0x1000, 0,
            "No servers were found that could be used to get work from.");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/check_pool.c",
             0xa1, "check_pool_connect", 0x12, 0xca, 100, auStack_1018);
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0,
                   "Please check the details from the list below of the "
                   "servers you have input.");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/check_pool.c",
             0xa1, "check_pool_connect", 0x12, 0xcb, 100, auStack_1018);
        V_LOCK();
        logfmt_raw(
            auStack_1018, 0x1000, 0,
            "Most likely you have input the wrong URL, forgotten to add a "
            "port, have not set up workers, or the network was disconnected.");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/check_pool.c",
             0xa1, "check_pool_connect", 0x12, 0xcc, 100, auStack_1018);
        for (local_c = 0; local_c < total_pools; local_c = local_c + 1) {
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0,
                       "Pool: %d  URL: %s\tUser: %s  Password: %s",
                       **(undefined4 **)(pools + local_c * 4),
                       *(undefined4 *)(*(int *)(pools + local_c * 4) + 0xc),
                       *(undefined4 *)(*(int *)(pools + local_c * 4) + 0x10),
                       *(undefined4 *)(*(int *)(pools + local_c * 4) + 0x14));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "check_pool.c",
                 0xa1, "check_pool_connect", 0x12, 0xd0, 0x50, auStack_1018);
            if ((*(int *)(*(int *)(pools + local_c * 4) + 0x14) != 0) &&
                (*(int *)(*(int *)(pools + local_c * 4) + 0x10) != 0)) {
                pcVar2 = strstr(
                    *(char **)(*(int *)(pools + local_c * 4) + 0x14), "stats");
                if ((pcVar2 == (char *)0x0) &&
                    (iVar1 = strcmp(
                         *(char **)(*(int *)(pools + local_c * 4) + 0x10),
                         "benchmark"),
                     iVar1 != 0)) {
                    uVar3 = 0;
                } else {
                    uVar3 = 1;
                }
                *(undefined1 *)(*(int *)(pools + local_c * 4) + 0x670) = uVar3;
            }
        }
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, "No servers could be used!");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/check_pool.c",
             0xa1, "check_pool_connect", 0x12, 0xd4, 100, auStack_1018);
        local_18 = 1;
        while (pools_active != '\x01') {
            local_14 = 0;
            while ((pools_active != '\x01' &&
                    (local_14 + local_18 * -0x3c < 0 !=
                     SBORROW4(local_14, local_18 * 0x3c)))) {
                local_14 = local_14 + 1;
                sleep(1);
            }
            iVar1 = local_18 + 1;
            if (local_18 + -0x13 < 0 == SBORROW4(iVar1, 0x14)) {
                iVar1 = 0x14;
            }
            local_18 = iVar1;
            check_pools_valid();
        }
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, "Pool is activing.");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/check_pool.c",
             0xa1, "check_pool_connect", 0x12, 0xe1, 0x50, auStack_1018);
    }
    return local_10;
}

void FUN_0005e7ac(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_0005e938(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

undefined4 check_sn(char *param_1)

{
    size_t sVar1;
    undefined4 uVar2;
    undefined1 auStack_1024[4096];
    char local_24[20];
    char *local_10;
    FILE *local_c;

    local_24[0] = '\0';
    local_24[1] = '\0';
    local_24[2] = '\0';
    local_24[3] = '\0';
    local_24[4] = '\0';
    local_24[5] = '\0';
    local_24[6] = '\0';
    local_24[7] = '\0';
    local_24[8] = '\0';
    local_24[9] = '\0';
    local_24[10] = '\0';
    local_24[0xb] = '\0';
    local_24[0xc] = '\0';
    local_24[0xd] = '\0';
    local_24[0xe] = '\0';
    local_24[0xf] = '\0';
    local_24[0x10] = '\0';
    local_24[0x11] = '\0';
    local_c = (FILE *)0x0;
    g_miner_sn_file_path = param_1;
    if (param_1 == (char *)0x0) {
        g_miner_sn_file_path = "/config/sn";
    }
    local_c = fopen(g_miner_sn_file_path, "r");
    if (local_c == (FILE *)0x0) {
        V_LOCK();
        logfmt_raw(auStack_1024, 0x1000, 0, "miner has no sn!");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/check_sn.c",
             0x9f, "check_sn", 8, 0x17, 100, auStack_1024);
        uVar2 = 2;
    } else {
        sVar1 = fread(local_24, 0x11, 1, local_c);
        if (sVar1 == 0) {
            if (local_24[0] == '\0') {
                V_LOCK();
                logfmt_raw(auStack_1024, 0x1000, 0, "miner sn: is NULL");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/check_sn.c",
                     0x9f, "check_sn", 8, 0x39, 100, auStack_1024);
            } else {
                V_LOCK();
                sVar1 = strlen(local_24);
                logfmt_raw(auStack_1024, 0x1000, 0,
                           "miner sn: not support length %d:%s", sVar1,
                           local_24);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/check_sn.c",
                     0x9f, "check_sn", 8, 0x37, 100, auStack_1024);
            }
            uVar2 = 1;
        } else {
            local_10 = strstr(local_24, "\r\n");
            if (local_10 == (char *)0x0) {
                strcpy(g_miner_sn, local_24);
            } else {
                strncpy(g_miner_sn, local_24, (int)local_10 - (int)local_24);
            }
            sVar1 = strlen(g_miner_sn);
            if (*(char *)((int)&DAT_00152400 + sVar1 + 7) == '\n') {
                sVar1 = strlen(g_miner_sn);
                *(undefined1 *)((int)&DAT_00152400 + sVar1 + 7) = 0;
            }
            sVar1 = strlen(g_miner_sn);
            if (*(char *)((int)&DAT_00152400 + sVar1 + 7) == '\r') {
                sVar1 = strlen(g_miner_sn);
                *(undefined1 *)((int)&DAT_00152400 + sVar1 + 7) = 0;
            }
            V_LOCK();
            logfmt_raw(auStack_1024, 0x1000, 0, "droa miner sn: %s", local_24);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/miner_util/check_sn.c",
                0x9f, "check_sn", 8, 0x31, 0x3c, auStack_1024);
            fclose(local_c);
            uVar2 = 0;
        }
    }
    return uVar2;
}

int fan_get_check_fan_speed(int param_1)

{
    return (param_1 * 0x5a) / 0x6e;
}

undefined4 fan_pwm_get(void)

{
    undefined4 local_c;

    if (DAT_00152421 != '\x01') {
        DAT_00152424 = pwm_init(0, 1);
        DAT_00152421 = '\x01';
    }
    pwm_get(DAT_00152424, &local_c);
    return local_c;
}

void fan_pwm_set(uint param_1)

{
    uint uVar1;
    undefined4 local_c;

    if (DAT_00152421 != '\x01') {
        DAT_00152424 = pwm_init(0, 100);
        DAT_00152421 = '\x01';
    }
    local_c = param_1;
    if (100 < param_1) {
        local_c = 100;
    }
    uVar1 = fan_pwm_get();
    if (local_c != uVar1) {
        if (fan_pwm_fixed == '\0') {
            pwm_set(DAT_00152424, local_c);
        } else {
            pwm_set(DAT_00152424, fan_pwm);
        }
    }
    return;
}

void fan_pwm_set_max(void)

{
    int iVar1;

    if (DAT_00152421 != '\x01') {
        DAT_00152424 = pwm_init(0, 100);
        DAT_00152421 = '\x01';
    }
    iVar1 = fan_pwm_get();
    if (iVar1 != 100) {
        pwm_set(DAT_00152424, 100);
        return;
    }
    return;
}

undefined4 read_feedback_voltage(uint param_1)

{
    int iVar1;
    undefined1 auStack_1010[4096];
    undefined8 local_10;

    local_10 = 0;
    iVar1 = platform_is_pic_mcu_en();
    if (iVar1 == 0) {
        local_10._0_4_ = bitmain_get_sample_voltage();
    } else {
        local_10._0_4_ = pic1704_get_an_voltage1(param_1 & 0xff);
    }
    V_LOCK();
    logfmt_raw(auStack_1010, 0x1000, 0,
               "read_feedback_voltage chain = %d, voltage = %f", param_1);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/miner_util/power_api.c",
         0xa0, "read_feedback_voltage", 0x15, 0x39, 0x14, auStack_1010);
    return (undefined4)local_10;
}

undefined4 FUN_0005f1e8(void)

{
    int iVar1;
    undefined4 uVar2;
    undefined4 extraout_s1;
    undefined1 auStack_1020[4096];
    undefined8 local_20;
    undefined4 local_18;
    undefined4 uStack_14;
    int local_10;
    int local_c;

    local_18 = 0;
    uStack_14 = 0;
    local_c = query_device_num();
    local_10 = 0;
    while (true) {
        if (local_c <= local_10)
            break;
        iVar1 = dev_ctrl();
        uVar2 = (**(code **)(iVar1 + 0x30))(local_10);
        uVar2 = read_feedback_voltage(uVar2);
        local_20 = (double)CONCAT44(extraout_s1, uVar2);
        V_LOCK();
        iVar1 = dev_ctrl();
        uVar2 = (**(code **)(iVar1 + 0x30))(local_10);
        logfmt_raw(auStack_1020, 0x1000, 0, "chain %d feedback voltage = %.2f",
                   uVar2);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/power_api.c",
             0xa0, "get_minimal_feedback_voltage", 0x1c, 0x45, 0x28,
             auStack_1020);
        if (0.1 < local_20) {
            if ((local_20 < (double)CONCAT44(uStack_14, local_18)) ||
                ((double)CONCAT44(uStack_14, local_18) < 0.1)) {
                local_18 = (undefined4)local_20;
                uStack_14 = local_20._4_4_;
            }
        }
        local_10 = local_10 + 1;
    }
    V_LOCK();
    logfmt_raw(auStack_1020, 0x1000, 0, "the minimal voltage = %.2f", local_18,
               uStack_14);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/miner_util/power_api.c",
         0xa0, "get_minimal_feedback_voltage", 0x1c, 0x4a, 0x14, auStack_1020);
    return local_18;
}

undefined4 FUN_0005f3d0(void)

{
    int iVar1;
    undefined4 uVar2;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;
    undefined4 uVar3;
    undefined1 auStack_1020[4096];
    int local_20;
    int local_1c;
    undefined8 local_18;
    undefined8 local_10;

    local_20 = 3;
    local_1c = get_current_voltage();
    local_18 = ((double)(longlong)local_1c * 0.75) / 100.0;
    local_10 = 0.0;
    do {
        sleep(1);
        iVar1 = platform_is_pic_mcu_en();
        if (iVar1 == 0) {
            uVar2 = read_feedback_voltage(0);
            local_10 = (double)CONCAT44(extraout_s1_00, uVar2);
            V_LOCK();
            logfmt_raw(auStack_1020, 0x1000, 0, "read fb voltage %.2f",
                       (undefined4)local_10, local_10._4_4_);
            V_UNLOCK();
            uVar2 = 100;
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/miner_util/power_api.c",
                0xa0, "check_feedback_voltage", 0x16, 100, 0x14, auStack_1020);
            if (local_10 < 0.0) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0,
                           "read_feedback_voltage_from_psu failed!");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/power_api.c",
                     0xa0, "check_feedback_voltage", 0x16, 0x66, 0x50,
                     auStack_1020);
                break;
            }
            if ((local_10 * 100.0 <= (double)(longlong)local_1c * 1.1) &&
                ((double)(longlong)local_1c * 0.9 <= local_10 * 100.0))
                break;
            V_LOCK();
            logfmt_raw(auStack_1020, 0x1000, 0,
                       "power voltage qualified! centi_voltage %d fb_vol %f",
                       local_1c, uVar2, local_10 * 100.0);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/miner_util/power_api.c",
                0xa0, "check_feedback_voltage", 0x16, 0x6b, 100, auStack_1020);
        } else {
            uVar2 = FUN_0005f1e8();
            local_10 = (double)CONCAT44(extraout_s1, uVar2);
            if (local_18 <= local_10) {
                V_LOCK();
                uVar2 = (undefined4)local_18;
                uVar3 = local_18._4_4_;
                logfmt_raw(auStack_1020, 0x1000, 0,
                           "power voltage qualified! centi_voltage %d "
                           "feedback_voltage %f qualified_vol %f",
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/power_api.c",
                     0xa0, "check_feedback_voltage", 0x16, 0x5f, 0x50,
                     auStack_1020, uVar2, uVar3);
                break;
            }
            V_LOCK();
            uVar2 = (undefined4)local_18;
            uVar3 = local_18._4_4_;
            logfmt_raw(auStack_1020, 0x1000, 0,
                       "power voltage can not meet the target! centi_voltage "
                       "%d feedback_voltage %f qualified_vol %f",
                       local_1c);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/miner_util/power_api.c",
                0xa0, "check_feedback_voltage", 0x16, 0x5b, 0x50, auStack_1020,
                uVar2, uVar3);
        }
        local_20 = local_20 + -1;
    } while (local_20 != 0);
    if (local_20 == 0) {
        uVar2 = 0xffffffff;
    } else {
        uVar2 = 0;
    }
    return uVar2;
}

uint FUN_0005f7c0(uint param_1)

{
    param_1 = param_1 & ~((int)param_1 >> 0x1f);
    if (0xfe < (int)param_1) {
        param_1 = 0xff;
    }
    return param_1;
}

undefined4 FUN_0005f7fc(uint param_1, uint param_2)

{
    int iVar1;
    undefined4 uVar2;
    undefined4 uVar3;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;
    undefined4 extraout_s1_01;
    undefined4 extraout_s1_02;
    undefined4 uVar4;
    uint local_101c;
    undefined1 auStack_1014[4096];
    uint local_14;

    local_14 = param_1;
    V_LOCK();
    logfmt_raw(auStack_1014, 0x1000, 0, "step n from %d to %d", param_1,
               param_2);
    V_UNLOCK();
    uVar4 = 0x7f;
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/miner_util/power_api.c",
         0xa0, "stepN", 5, 0x7f, 0x28, auStack_1014);
    local_101c = param_1;
    while (true) {
        if (local_101c == param_2)
            break;
        uVar2 = bitmain_convert_N_to_V(param_2);
        uVar3 = bitmain_convert_N_to_V(local_101c);
        if (ABS((double)CONCAT44(extraout_s1_00, uVar2) -
                (double)CONCAT44(extraout_s1_01, uVar3)) <= 0.5)
            break;
        if (local_101c < param_2) {
            iVar1 = param_2 - local_101c;
            if (iVar1 < 0) {
                iVar1 = -iVar1;
            }
            iVar1 = iVar1 / 2;
        } else {
            iVar1 = param_2 - local_101c;
            if (iVar1 < 0) {
                iVar1 = -iVar1;
            }
            iVar1 = -(iVar1 / 2);
        }
        local_14 = local_14 + iVar1;
        V_LOCK();
        uVar2 = bitmain_convert_N_to_V(local_14);
        logfmt_raw(auStack_1014, 0x1000, 0, "set N to %d, voltage = %.2f",
                   local_14, uVar4, CONCAT44(extraout_s1, uVar2));
        V_UNLOCK();
        uVar4 = 0x83;
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/power_api.c",
             0xa0, "stepN", 5, 0x83, 0x28, auStack_1014);
        bitmain_set_voltage_by_n(local_14 & 0xff);
        local_101c = local_14;
    }
    if (local_101c != param_2) {
        V_LOCK();
        uVar2 = bitmain_convert_N_to_V(param_2);
        logfmt_raw(auStack_1014, 0x1000, 0, "final set N to %d, voltage = %.2f",
                   param_2, uVar4, CONCAT44(extraout_s1_02, uVar2));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/power_api.c",
             0xa0, "stepN", 5, 0x89, 0x28, auStack_1014);
        bitmain_set_voltage_by_n(param_2 & 0xff);
    }
    return 0;
}

undefined4 FUN_0005fb68(void)

{
    undefined4 uVar1;
    undefined4 extraout_s1;
    undefined1 auStack_1030[4096];
    double local_30;
    int local_24;
    undefined4 local_20;
    undefined4 uStack_1c;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    local_20 = 0;
    uStack_1c = 0;
    local_c = 0;
    local_14 = 100;
    local_18 = 0;
    local_24 = platform_get_chain_num();
    do {
        local_c = local_c + 1;
        if (local_14 <= local_c) {
            return 0;
        }
        for (local_10 = 0; local_10 < local_24; local_10 = local_10 + 1) {
            uVar1 = read_feedback_voltage(local_10);
            local_30 = (double)CONCAT44(extraout_s1, uVar1);
            if ((double)CONCAT44(uStack_1c, local_20) < local_30) {
                local_20 = uVar1;
                uStack_1c = extraout_s1;
            }
        }
        if ((double)CONCAT44(uStack_1c, local_20) <= 10.0) {
            if ((double)CONCAT44(uStack_1c, local_20) <= 4.0) {
                return 0;
            }
            if (2 < local_14) {
                local_c = 0;
            }
            local_14 = 2;
        } else {
            if (0x14 < local_14) {
                local_c = 0;
            }
            local_14 = 0x14;
        }
        local_18 = local_18 + 1;
        sleep(1);
    } while (local_18 < 0x15);
    V_LOCK();
    logfmt_raw(auStack_1030, 0x1000, 0,
               "APW discharge too slow OR pic adc wrong");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/miner_util/power_api.c",
         0xa0, "wait_for_psu_discharge", 0x16, 0xbb, 100, auStack_1030);
    return 0xffffffff;
}

undefined4 FUN_0005fd30(int param_1, int param_2)

{
    undefined4 uVar1;
    undefined1 auStack_1014[4096];
    int local_14;
    undefined8 local_10;

    local_10 = (double)(longlong)param_1 / 100.0;
    V_LOCK();
    logfmt_raw(auStack_1014, 0x1000, 0, "set voltage to %lf",
               (undefined4)local_10, local_10._4_4_);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/miner_util/power_api.c",
         0xa0, "set_voltage_without_feedback", 0x1c, 0xc5, 0x28, auStack_1014);
    local_14 = bitmain_set_voltage(SUB84(local_10, 0));
    if (local_14 < 0) {
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0,
                   "bitmain_set_voltage failed, return code:%x", local_14);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/power_api.c",
             0xa0, "set_voltage_without_feedback", 0x1c, 200, 100,
             auStack_1014);
        uVar1 = 0xffffffff;
    } else {
        usleep(500000);
        *(int *)(param_2 + 0x1c) = param_1;
        *(undefined4 *)(param_2 + 0x20) = *(undefined4 *)(param_2 + 0x1c);
        uVar1 = 0;
    }
    return uVar1;
}

int FUN_0005fef0(int param_1, int param_2)

{
    int iVar1;
    bool bVar2;
    undefined4 uVar3;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;
    undefined4 extraout_s1_01;
    undefined1 auStack_1038[4096];
    int local_38;
    int local_34;
    int local_30;
    int local_2c;
    undefined8 local_28;
    undefined8 local_20;
    int local_18;
    int local_14;
    undefined8 local_10;

    local_2c = 0;
    local_30 = 0xff;
    local_28 = (double)(longlong)param_1 / 100.0;
    local_20 = 0.0;
    local_10 = (double)(longlong) * (int *)(param_2 + 0x20) / 100.0;
    local_18 = bitmain_set_voltage(SUB84(local_28, 0));
    do {
        uVar3 = FUN_0005f1e8();
        local_20 = (double)CONCAT44(extraout_s1, uVar3);
        local_14 = bitmain_convert_V_to_N(uVar3);
        local_10 = local_20;
        if (*(int *)(param_2 + 0x20) != 0) {
            local_10 = (double)(longlong) * (int *)(param_2 + 0x20) / 100.0;
        }
        local_34 = bitmain_convert_V_to_N(SUB84(local_10, 0));
        local_38 = local_18 - local_14;
        if (local_20 < 0.1) {
            local_2c = -1;
            V_LOCK();
            logfmt_raw(auStack_1038, 0x1000, 0,
                       "minimal feedback voltage is zero");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/miner_util/power_api.c",
                0xa0, "set_voltage_with_feedback", 0x19, 0xe3, 0x50,
                auStack_1038);
        LAB_00060284:
            if (local_2c == 0) {
                V_LOCK();
                uVar3 = bitmain_convert_N_to_V(local_34);
                logfmt_raw(auStack_1038, 0x1000, 0,
                           "set to target voltage = %.2f, power real voltage = "
                           "%.2f, feed back voltage = %.2f",
                           (undefined4)local_28, local_28._4_4_,
                           CONCAT44(extraout_s1_01, uVar3),
                           (undefined4)local_20, local_20._4_4_);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/power_api.c",
                     0xa0, "set_voltage_with_feedback", 0x19, 0xf4, 0x28,
                     auStack_1038);
                *(int *)(param_2 + 0x1c) = param_1;
            } else {
                V_LOCK();
                logfmt_raw(
                    auStack_1038, 0x1000, 0,
                    "fail to set taget voltage = %.2f, feedback_vol = %.2f",
                    (undefined4)local_28, local_28._4_4_, SUB84(local_20, 0),
                    local_20._4_4_);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/power_api.c",
                     0xa0, "set_voltage_with_feedback", 0x19, 0xf7, 100,
                     auStack_1038);
            }
            return local_2c;
        }
        if (local_38 == 0)
            goto LAB_00060284;
        V_LOCK();
        logfmt_raw(auStack_1038, 0x1000, 0,
                   "board voltage = %.2f, target voltage = %.2f, power real "
                   "voltage = %.2f, steps = %d",
                   (undefined4)local_20, local_20._4_4_, SUB84(local_28, 0),
                   local_28._4_4_, (undefined4)local_10, local_10._4_4_,
                   local_38);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/power_api.c",
             0xa0, "set_voltage_with_feedback", 0x19, 0xe7, 0x28);
        if ((0xff < local_34 + local_38) || (local_34 + local_38 < 0)) {
            V_LOCK();
            logfmt_raw(auStack_1038, 0x1000, 0, "overflow to the N limitation");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/miner_util/power_api.c",
                0xa0, "set_voltage_with_feedback", 0x19, 0xea, 100,
                auStack_1038);
            local_2c = -2;
            goto LAB_00060284;
        }
        FUN_0005f7fc(local_34, local_34 + local_38);
        local_34 = local_34 + local_38;
        local_34 = FUN_0005f7c0(local_34);
        uVar3 = bitmain_convert_N_to_V(local_34);
        *(int *)(param_2 + 0x20) =
            (int)(longlong)((double)CONCAT44(extraout_s1_00, uVar3) * 100.0);
        if ((ABS(local_20 - local_28) <= 0.1) ||
            (iVar1 = local_30 + -1, bVar2 = local_30 == 0, local_30 = iVar1,
             bVar2))
            goto LAB_00060284;
    } while (true);
}

void power_on(void)

{
    bitmain_power_on();
    DAT_00152440 = 1;
    return;
}

void all_dev_poweroff(void)

{
    int iVar1;
    int local_14;
    int local_10;
    int local_c;

    local_14 = 0;
    local_10 = get_all_created_runtime(&local_14);
    local_c = 0;
    while (true) {
        if (local_14 <= local_c)
            break;
        (**(code **)(*(int *)(local_10 + local_c * 4) + 0x14))(
            *(undefined4 *)(local_10 + local_c * 4));
        iVar1 = dev_ctrl();
        (**(code **)(iVar1 + 0x1c))(
            *(undefined4 *)(*(int *)(local_10 + local_c * 4) + 0xf8));
        local_c = local_c + 1;
    }
    power_off();
    return;
}

void power_off(void)

{
    bitmain_power_off();
    DAT_00152440 = 0;
    sleep(1);
    return;
}

undefined4 power_info_init(undefined4 param_1, undefined4 param_2,
                           undefined4 param_3, undefined4 param_4,
                           undefined4 param_5)

{
    DAT_0015242c = param_1;
    DAT_00152430 = param_2;
    DAT_00152434 = param_3;
    DAT_00152438 = param_4;
    DAT_0015243c = param_5;
    return 0;
}

undefined4 set_power_init_status(undefined1 param_1)

{
    DAT_00152428 = param_1;
    return 0;
}

undefined1 is_power_init(void)

{
    return DAT_00152428;
}

undefined1 is_power_on(void)

{
    return DAT_00152440;
}

int power_init(char param_1, int param_2)

{
    char cVar1;
    int iVar2;
    int local_1028;
    char local_1021;
    undefined1 auStack_101c[4096];
    int local_1c;
    int local_18;
    int local_14;
    undefined4 local_10;
    short local_c;
    undefined2 local_a;

    local_14 = 0;
    local_1028 = param_2;
    local_1021 = param_1;
    local_10 = get_all_created_runtime(&local_1028);
    cVar1 = platform_is_adjustable_power();
    if (cVar1 == '\x01') {
        local_c = bitmain_power_version();
        iVar2 = platform_is_psu_supported(local_c);
        if (iVar2 == 0) {
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0,
                       "Not support power version, %04x", local_c);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/miner_util/power_api.c",
                0xa0, "power_init", 10, 0x13c, 100, auStack_101c);
            local_14 = -1;
        } else {
            cVar1 = platform_is_pic_mcu_en();
            if (cVar1 != '\x01') {
                local_c = bitmain_set_watchdog(0);
                if (local_c != 0) {
                    V_LOCK();
                    logfmt_raw(auStack_101c, 0x1000, 0,
                               "disable power watchdog: %04x", local_c);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/power_api.c",
                         0xa0, "power_init", 10, 0x143, 100, auStack_101c);
                    return local_14;
                }
                sleep(1);
            }
            power_off();
            if (local_1021 != '\0') {
                fan_pwm_set(0);
                do {
                    fan_pwm_set(0);
                    sleep(10);
                } while (true);
            }
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0,
                       "Initializing the power, please wait, this may take up "
                       "1 minute...");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/miner_util/power_api.c",
                0xa0, "power_init", 10, 0x152, 0x3c, auStack_101c);
            sleep(0x1e);
            cVar1 = platform_is_pic_mcu_en();
            if (cVar1 != '\x01') {
                FUN_0005fb68();
            }
            local_a = bitmain_power_fw_version();
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0,
                       "bitmain power fw version: %04x", local_a);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/miner_util/power_api.c",
                0xa0, "power_init", 10, 0x15b, 0x3c, auStack_101c);
            DAT_00152441 = 0;
            DAT_00152444 = 0;
            DAT_00152448 = 0;
            DAT_00152428 = 1;
            if ((opt_custom_voltage_swith != '\0') ||
                (iVar2 = is_eeprom_loaded(), iVar2 != 0)) {
                DAT_00152434 = opt_custom_voltage;
            }
            DAT_0015242c._0_1_ = platform_is_adjustable_power();
            DAT_00152438._0_1_ = platform_is_check_asic_voltage_enable();
            DAT_0015243c = platfrom_get_check_asic_voltage();
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0, "Power init:");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/miner_util/power_api.c",
                0xa0, "power_init", 10, 0x170, 0x14, auStack_101c);
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0, "current_voltage_raw\t\t= %d",
                       DAT_00152444);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/miner_util/power_api.c",
                0xa0, "power_init", 10, 0x171, 0x14, auStack_101c);
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0, "working_voltage_raw\t\t= %d",
                       DAT_00152434);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/miner_util/power_api.c",
                0xa0, "power_init", 10, 0x172, 0x14, auStack_101c);
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0,
                       "check_asic_voltage_enable\t= %d",
                       (undefined1)DAT_00152438);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/miner_util/power_api.c",
                0xa0, "power_init", 10, 0x173, 0x14, auStack_101c);
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0, "check_asic_voltage_raw\t= %d",
                       DAT_0015243c);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/miner_util/power_api.c",
                0xa0, "power_init", 10, 0x174, 0x14, auStack_101c);
            iVar2 = is_check_asic_voltage_enable();
            if (iVar2 == 0) {
                local_14 = set_working_voltage(0);
            } else {
                local_14 = set_check_asic_voltage(0);
            }
            if (local_14 == 0) {
                for (local_18 = 0; local_18 < 0x14; local_18 = local_18 + 1) {
                    if ((local_c == 0x71) || (local_c == 0x74)) {
                        local_14 = 0;
                        break;
                    }
                    local_14 = bitmain_get_power_status();
                    if (local_14 == 0) {
                        local_14 = 0;
                        break;
                    }
                    if ((local_18 + 1) % 5 == 0) {
                        V_LOCK();
                        logfmt_raw(auStack_101c, 0x1000, 0,
                                   ">> bitmain_get_power_status failed(%d) <<",
                                   local_14);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/miner_util/"
                             "power_api.c",
                             0xa0, "power_init", 10, 0x18a, 100, auStack_101c);
                    }
                    sleep(3);
                }
                V_LOCK();
                logfmt_raw(auStack_101c, 0x1000, 0,
                           "bitmain_get_power_status end!");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/power_api.c",
                     0xa0, "power_init", 10, 0x191, 0x14, auStack_101c);
                power_on();
                usleep(400000);
                for (local_1c = 0; local_1c < local_1028;
                     local_1c = local_1c + 1) {
                    iVar2 = dev_ctrl();
                    (**(code **)(iVar2 + 0x24))(local_1c);
                    sleep(1);
                    iVar2 = dev_ctrl();
                    (**(code **)(iVar2 + 0x28))(local_1c);
                    usleep(300000);
                    iVar2 = dev_ctrl();
                    (**(code **)(iVar2 + 0x24))(local_1c);
                    sleep(1);
                    iVar2 = dev_ctrl();
                    (**(code **)(iVar2 + 0x28))(local_1c);
                    usleep(300000);
                    iVar2 = dev_ctrl();
                    (**(code **)(iVar2 + 0x24))(local_1c);
                }
                iVar2 = FUN_0005f3d0();
                if (iVar2 == 0) {
                    V_LOCK();
                    logfmt_raw(auStack_101c, 0x1000, 0,
                               "check_feedback_voltage end!");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/power_api.c",
                         0xa0, "power_init", 10, 0x1a8, 0x28, auStack_101c);
                } else {
                    V_LOCK();
                    logfmt_raw(auStack_101c, 0x1000, 0,
                               "check_feedback_voltage error!");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/power_api.c",
                         0xa0, "power_init", 10, 0x1a3, 100, auStack_101c);
                    local_14 = -1;
                }
            } else {
                V_LOCK();
                logfmt_raw(auStack_101c, 0x1000, 0,
                           "set_voltage_by_steps error!");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/power_api.c",
                     0xa0, "power_init", 10, 0x17c, 100, auStack_101c);
                local_14 = -1;
            }
        }
    } else {
        V_LOCK();
        logfmt_raw(auStack_101c, 0x1000, 0,
                   "%s, current algo donot use adjustable power!",
                   "power_init");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/power_api.c",
             0xa0, "power_init", 10, 0x135, 100, auStack_101c);
        V_LOCK();
        logfmt_raw(auStack_101c, 0x1000, 0, "Sweep error string = %s.",
                   &DAT_00117e44);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/power_api.c",
             0xa0, "power_init", 10, 0x136, 100, auStack_101c);
        local_14 = -1;
    }
    return local_14;
}

undefined4 set_current_voltage(undefined4 param_1)

{
    DAT_00152444 = param_1;
    return 0;
}

undefined4 set_voltage(undefined4 param_1, char param_2)

{
    undefined4 uVar1;
    undefined1 auStack_1008[4096];

    if (param_2 == '\x01') {
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, "set_voltage to %d", param_1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/power_api.c",
             0xa0, "set_voltage", 0xb, 0x1ba, 0x28, auStack_1008);
        uVar1 = FUN_0005fd30(param_1, &DAT_00152428);
    } else {
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, "set_voltage power is not inited");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/power_api.c",
             0xa0, "set_voltage", 0xb, 0x1b6, 100, auStack_1008);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, "Sweep error string = %s.",
                   &DAT_00118030);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/power_api.c",
             0xa0, "set_voltage", 0xb, 0x1b7, 100, auStack_1008);
        uVar1 = 0xffffffff;
    }
    return uVar1;
}

undefined4 set_voltage_by_steps(int param_1, char param_2, uint param_3)

{
    uint uVar1;
    undefined8 uVar2;
    uint local_1024;
    undefined1 auStack_1018[4096];
    undefined4 local_18;
    int local_14;
    uint local_10;
    uint local_c;

    if (param_2 == '\x01') {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, "set_voltage_by_steps to %d",
                   param_1);
        V_UNLOCK();
        uVar2 = zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
            "build/rootfs/buildroot/tmp/release/build/"
            "godminer-origin_godminer-branch1/miner_util/power_api.c",
            0xa0, "set_voltage_by_steps", 0x14, 0x1c5, 0x28, auStack_1018);
        local_18 = 0;
        local_1024 = param_3;
        if (100 < param_3) {
            local_1024 = 100;
        }
        local_c = local_1024 / 10;
        local_14 =
            get_current_voltage((int)uVar2, (int)((ulonglong)uVar2 >> 0x20),
                                local_1024 * -0x33333333);
        local_10 = param_1 - local_14;
        if (local_10 == 0) {
            local_18 = 0;
        } else {
            if ((int)local_10 < 0) {
                local_c = -local_c;
            }
            while (true) {
                uVar1 = local_c;
                if ((int)local_c < 0) {
                    uVar1 = -local_c;
                }
                if ((int)((local_10 ^ (int)local_10 >> 0x1f) -
                          ((int)local_10 >> 0x1f)) <= (int)uVar1)
                    break;
                local_14 = local_14 + local_c;
                local_10 = local_10 - local_c;
                FUN_0005fd30(local_14, &DAT_00152428);
            }
            if (param_1 != local_14) {
                FUN_0005fd30(param_1, &DAT_00152428);
            }
        }
    } else {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, "Sweep error string = %s.",
                   &DAT_00118030);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/power_api.c",
             0xa0, "set_voltage_by_steps", 0x14, 0x1c1, 100, auStack_1018);
        local_18 = 0xffffffff;
    }
    return local_18;
}

undefined4 get_current_voltage(void)

{
    undefined4 uVar1;
    undefined1 auStack_1008[4096];

    uVar1 = DAT_00152444;
    if (DAT_00152428 != '\x01') {
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, "Sweep error string = %s.",
                   &DAT_00118030);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/power_api.c",
             0xa0, "get_current_voltage", 0x13, 0x1f0, 100, auStack_1008);
        uVar1 = 0xffffffff;
    }
    return uVar1;
}

undefined4 get_working_voltage(void)

{
    undefined4 uVar1;
    undefined1 auStack_1008[4096];

    uVar1 = DAT_00152434;
    if (DAT_00152428 != '\x01') {
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, "Sweep error string = %s.",
                   &DAT_00118030);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/power_api.c",
             0xa0, "get_working_voltage", 0x13, 0x1fa, 100, auStack_1008);
        uVar1 = 0xffffffff;
    }
    return uVar1;
}

undefined4 get_max_voltage(void)

{
    undefined4 uVar1;
    undefined4 extraout_s1;
    undefined1 auStack_1008[4096];

    if (DAT_00152428 == '\x01') {
        uVar1 = bitmain_convert_N_to_V(0);
        uVar1 = (undefined4)(longlong)((double)CONCAT44(extraout_s1, uVar1) *
                                       100.0);
    } else {
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, "Sweep error string = %s.",
                   &DAT_00118030);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/power_api.c",
             0xa0, "get_max_voltage", 0xf, 0x204, 100, auStack_1008);
        uVar1 = 0xffffffff;
    }
    return uVar1;
}

undefined4 set_working_voltage(char param_1)

{
    undefined4 uVar1;
    undefined1 auStack_100c[4098];
    short local_a;

    local_a = 0;
    if (param_1 == '\0') {
        local_a = set_voltage(DAT_00152434, DAT_00152428);
    } else {
        local_a = set_voltage_by_steps(DAT_00152434, DAT_00152428, 100);
    }
    if (local_a == 0) {
        uVar1 = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, "set_working_voltage error!");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/power_api.c",
             0xa0, "set_working_voltage", 0x13, 0x214, 100, auStack_100c);
        uVar1 = 0xffffffff;
    }
    return uVar1;
}

undefined4 is_check_asic_voltage_enable(void)

{
    undefined4 uVar1;

    if (((char)DAT_0015242c == '\0') || ((char)DAT_00152438 == '\0')) {
        uVar1 = 0;
    } else {
        uVar1 = 1;
    }
    return uVar1;
}

undefined4 set_check_asic_voltage(char param_1)

{
    undefined4 uVar1;
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    V_LOCK();
    logfmt_raw(auStack_100c, 0x1000, 0, "set_check_asic_voltage");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/miner_util/power_api.c",
         0xa0, "set_check_asic_voltage", 0x16, 0x224, 0x28, auStack_100c);
    if (param_1 == '\0') {
        local_c = set_voltage(DAT_0015243c, DAT_00152428);
    } else {
        local_c = set_voltage_by_steps(DAT_0015243c, DAT_00152428, 100);
    }
    if (local_c == 0) {
        uVar1 = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, "set_check_asic_voltage error!");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/power_api.c",
             0xa0, "set_check_asic_voltage", 0x16, 0x22c, 100, auStack_100c);
        uVar1 = 0xffffffff;
    }
    return uVar1;
}

void FUN_00061b68(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_00061cf4(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

int FUN_00061e84(void)

{
    int iVar1;
    undefined1 auStack_11f0[224];
    undefined1 auStack_1110[4096];
    undefined1 auStack_110[16];
    void *local_100;
    int local_f0;
    int local_2c;
    void *local_28;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;
    size_t local_10;
    int local_c;

    local_2c = 0;
    local_c = -0x80000000;
    local_24 = get_all_created_runtime(&local_2c);
    local_10 = 0;
    local_14 = 0;
    for (local_18 = 0; local_18 < local_2c; local_18 = local_18 + 1) {
        read_status_from_monitor(auStack_110,
                                 *(undefined4 *)(local_24 + local_18 * 4));
        local_10 = local_10 + local_f0;
    }
    local_28 = calloc(local_10, 4);
    if (local_28 == (void *)0x0) {
        printf("invalid pointer(%s)!\n", "temp_out_chip");
        local_c = DAT_0014f404;
    } else {
        for (local_1c = 0; local_1c < local_2c; local_1c = local_1c + 1) {
            read_status_from_monitor(auStack_11f0,
                                     *(undefined4 *)(local_24 + local_1c * 4));
            memcpy(auStack_110, auStack_11f0, 0xe0);
            memcpy((void *)((int)local_28 + local_14 * 4), local_100,
                   local_f0 << 2);
            local_14 = local_14 + local_f0;
        }
        for (local_20 = 0; local_20 < (int)local_10; local_20 = local_20 + 1) {
            iVar1 = *(int *)((int)local_28 + local_20 * 4);
            if (local_c < iVar1) {
                local_c = iVar1;
            }
        }
        free(local_28);
        DAT_0014f404 = local_c;
        V_LOCK();
        logfmt_raw(auStack_1110, 0x1000, 0, "max temp chip: %d", local_c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/set_pwm_by_temp.c",
             0xa6, "get_max_chip_temp", 0x11, 0x3b, 0x14, auStack_1110);
    }
    return local_c;
}

int FUN_00062104(void)

{
    int iVar1;
    undefined1 auStack_1e0[224];
    undefined1 auStack_100[8];
    int local_f8;
    int local_f0;
    int local_e4;
    int local_e0;
    int local_20;
    undefined4 *local_1c;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    local_20 = 0;
    local_c = 0x7fffffff;
    local_1c = (undefined4 *)get_all_created_runtime(&local_20);
    if (0 < local_20) {
        read_status_from_monitor(auStack_100, *local_1c);
        for (local_10 = 0; local_10 < local_20; local_10 = local_10 + 1) {
            read_status_from_monitor(auStack_1e0, local_1c[local_10]);
            memcpy(auStack_100, auStack_1e0, 0xe0);
            for (local_14 = 0; local_14 < local_e4; local_14 = local_14 + 1) {
                iVar1 = *(int *)(local_f8 + local_14 * 4);
                if (iVar1 <= local_c) {
                    local_c = iVar1;
                }
            }
            for (local_18 = 0; local_18 < local_e0; local_18 = local_18 + 1) {
                iVar1 = *(int *)(local_f0 + local_18 * 4);
                if (iVar1 <= local_c) {
                    local_c = iVar1;
                }
            }
        }
    }
    return local_c;
}

int FUN_00062264(void)

{
    int iVar1;
    undefined1 auStack_1e0[224];
    undefined1 auStack_100[4];
    int local_fc;
    int local_f4;
    int local_e4;
    int local_e0;
    int local_20;
    undefined4 *local_1c;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    local_20 = 0;
    local_c = -0x80000000;
    local_1c = (undefined4 *)get_all_created_runtime(&local_20);
    if (0 < local_20) {
        read_status_from_monitor(auStack_100, *local_1c);
        for (local_10 = 0; local_10 < local_20; local_10 = local_10 + 1) {
            read_status_from_monitor(auStack_1e0, local_1c[local_10]);
            memcpy(auStack_100, auStack_1e0, 0xe0);
            for (local_14 = 0; local_14 < local_e4; local_14 = local_14 + 1) {
                iVar1 = *(int *)(local_fc + local_14 * 4);
                if (local_c < iVar1) {
                    local_c = iVar1;
                }
            }
            for (local_18 = 0; local_18 < local_e0; local_18 = local_18 + 1) {
                iVar1 = *(int *)(local_f4 + local_18 * 4);
                if (local_c < iVar1) {
                    local_c = iVar1;
                }
            }
        }
    }
    return local_c;
}

int FUN_000623c4(void)

{
    int iVar1;
    uint uVar2;
    uint uVar3;
    undefined4 *local_118[56];
    size_t local_38[4];
    void *local_28;
    int *local_24;
    undefined4 local_20;
    undefined4 local_1c;
    undefined4 local_18;
    int local_14;
    int local_10;
    int local_c;

    local_38[0] = 0;
    local_c = -0x40;
    local_18 = 0xffffffc0;
    local_1c = 0;
    local_20 = 0;
    local_24 = (int *)get_all_created_runtime(local_38);
    local_28 = calloc(local_38[0], 4);
    if (local_28 == (void *)0x0) {
        printf("invalid pointer(%s)!\n", "temp_avg_chip_local");
        local_c = 0xff;
    } else {
        local_38[3] = 0;
        local_38[2] = 0;
        local_38[1] = 0;
        for (local_10 = 0; local_10 < (int)local_38[0];
             local_10 = local_10 + 1) {
            read_status_from_monitor(local_118, local_24[local_10]);
            *(undefined4 *)((int)local_28 + local_10 * 4) = *local_118[0];
        }
        for (local_14 = 0; local_14 < (int)local_38[0];
             local_14 = local_14 + 1) {
            iVar1 = *(int *)((int)local_28 + local_14 * 4);
            if (local_c < iVar1) {
                local_c = iVar1;
            }
        }
        local_38[2] = get_temp(2);
        if ((local_38[2] != -0x40) && (0 < (int)local_38[0])) {
            uVar2 = (DAT_0014f408 + local_38[2]) - *(int *)(*local_24 + 400);
            uVar3 = (DAT_0014f40c + local_38[2]) - *(int *)(*local_24 + 400);
            local_38[3] = (uVar3 & ~((int)uVar3 >> 0x1f)) * 2;
            local_c =
                local_c + (uVar2 & ~((int)uVar2 >> 0x1f)) * 2 + local_38[3];
        }
        free(local_28);
    }
    return local_c;
}

int FUN_000625d4(void)

{
    int iVar1;
    undefined1 auStack_11f0[224];
    undefined1 auStack_1110[4096];
    undefined1 auStack_110[4];
    void *local_10c;
    int local_f4;
    int local_2c;
    void *local_28;
    int local_24;
    int local_20;
    int local_1c;
    size_t local_18;
    int local_14;
    int local_10;
    int local_c;

    local_2c = 0;
    local_14 = 0x7fffffff;
    local_24 = get_all_created_runtime(&local_2c);
    local_18 = 0;
    local_1c = 0;
    for (local_20 = 0; local_20 < local_2c; local_20 = local_20 + 1) {
        read_status_from_monitor(auStack_110,
                                 *(undefined4 *)(local_24 + local_20 * 4));
        local_18 = local_18 + local_f4;
    }
    local_28 = calloc(local_18, 4);
    if (local_28 == (void *)0x0) {
        printf("invalid pointer(%s)!\n", "temp_in_pcb");
        local_14 = DAT_0014f410;
    } else {
        for (local_c = 0; local_c < local_2c; local_c = local_c + 1) {
            read_status_from_monitor(auStack_11f0,
                                     *(undefined4 *)(local_24 + local_c * 4));
            memcpy(auStack_110, auStack_11f0, 0xe0);
            memcpy((void *)((int)local_28 + local_1c * 4), local_10c,
                   local_f4 << 2);
            local_1c = local_1c + local_f4;
        }
        for (local_10 = 0; local_10 < (int)local_18; local_10 = local_10 + 1) {
            iVar1 = check_value_valid_with_stdd(
                local_28, local_18,
                *(undefined4 *)((int)local_28 + local_10 * 4));
            if (iVar1 == 0) {
                V_LOCK();
                logfmt_raw(auStack_1110, 0x1000, 0,
                           "%d C, most likely a bad sensor",
                           *(undefined4 *)((int)local_28 + local_10 * 4));
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/set_pwm_by_temp.c",
                     0xa6, "get_min_pcb_temp", 0x10, 0xa9, 0x14, auStack_1110);
            } else {
                iVar1 = *(int *)((int)local_28 + local_10 * 4);
                if (iVar1 <= local_14) {
                    local_14 = iVar1;
                }
            }
        }
        free(local_28);
        DAT_0014f410 = local_14;
        V_LOCK();
        logfmt_raw(auStack_1110, 0x1000, 0, "min temp pcb: %d", local_14);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/set_pwm_by_temp.c",
             0xa6, "get_min_pcb_temp", 0x10, 0xaf, 0x14, auStack_1110);
    }
    return local_14;
}

undefined4 get_temp(undefined4 param_1)

{
    undefined1 auStack_100c[4096];
    undefined4 local_c;

    switch (param_1) {
    case 0:
        local_c = FUN_00062264();
        break;
    case 1:
        local_c = FUN_000625d4();
        break;
    case 2:
        local_c = FUN_00061e84();
        break;
    case 3:
        local_c = FUN_00062104();
        break;
    case 4:
        local_c = FUN_000623c4();
        break;
    default:
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, "%s unknow temp type %d", param_1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/set_pwm_by_temp.c",
             0xa6, "get_temp", 8, 0xc9, 100, auStack_100c);
        local_c = 0x7fffffff;
    }
    return local_c;
}

int FUN_00062a34(void)

{
    int iVar1;
    int local_c;

    iVar1 = get_temp(1);
    if (iVar1 < 0x13) {
        local_c = 0x28;
    } else if ((iVar1 < 0x13) || (0x21 < iVar1)) {
        if ((iVar1 < 0x22) || (0x26 < iVar1)) {
            if ((iVar1 < 0x27) || (0x30 < iVar1)) {
                if ((iVar1 < 0x31) || (0x37 < iVar1)) {
                    local_c = 100;
                } else {
                    local_c =
                        (int)(longlong)((double)(longlong)(iVar1 + -0x30) *
                                            5.714285714285714 +
                                        60.0);
                }
            } else {
                local_c =
                    (int)(longlong)((double)(longlong)(iVar1 + -0x26) + 50.0);
            }
        } else {
            local_c = 0x32;
        }
    } else {
        local_c = (int)(longlong)((double)(longlong)(iVar1 + -0x12) *
                                      0.6666666666666666 +
                                  40.0);
    }
    iVar1 = get_temp(DAT_0014f3dc);
    if (DAT_0014f3e0 <= iVar1) {
        local_c = 100;
    }
    iVar1 = DAT_0014f3d4;
    if (DAT_0014f3d4 < local_c) {
        iVar1 = local_c;
    }
    if (DAT_0014f3d8 <= iVar1) {
        iVar1 = DAT_0014f3d8;
    }
    return iVar1;
}

int FUN_00062c30(void)

{
    int iVar1;
    int local_c;

    iVar1 = get_temp(1);
    if (iVar1 < 0xe) {
        local_c = 0x14;
    } else if ((iVar1 < 0xe) || (0x20 < iVar1)) {
        local_c = (int)(longlong)((double)(longlong)(iVar1 + -0x20) *
                                      1.4285714285714286 +
                                  60.0);
    } else {
        local_c = (int)(longlong)((double)(longlong)(iVar1 + -0xd) *
                                      2.1052631578947367 +
                                  20.0);
    }
    iVar1 = get_temp(DAT_0014f3dc);
    if (DAT_0014f3e0 <= iVar1) {
        local_c = 100;
    }
    iVar1 = DAT_0014f3d4;
    if (DAT_0014f3d4 < local_c) {
        iVar1 = local_c;
    }
    if (DAT_0014f3d8 <= iVar1) {
        iVar1 = DAT_0014f3d8;
    }
    return iVar1;
}

float FUN_00062d88(int param_1, char param_2)

{
    float fVar1;
    float fVar2;
    undefined4 local_c;

    *(float *)(param_1 + 0x20) =
        *(float *)(param_1 + 8) - *(float *)(param_1 + 0xc);
    fVar1 = *(float *)(param_1 + 0x20) - *(float *)(param_1 + 0x24);
    fVar2 = (*(float *)(param_1 + 0x20) -
             (*(float *)(param_1 + 0x24) + *(float *)(param_1 + 0x24))) +
            *(float *)(param_1 + 0x28);
    if (param_2 == '\0') {
        local_c = *(float *)(param_1 + 0x14) * fVar1 +
                  *(float *)(param_1 + 0x18) * *(float *)(param_1 + 0x20) +
                  *(float *)(param_1 + 0x1c) * fVar2;
    } else {
        local_c = *(float *)(param_1 + 0x10) * fVar1 +
                  *(float *)(param_1 + 0x18) * *(float *)(param_1 + 0x20) +
                  *(float *)(param_1 + 0x1c) * fVar2;
    }
    *(undefined4 *)(param_1 + 0x28) = *(undefined4 *)(param_1 + 0x24);
    *(undefined4 *)(param_1 + 0x24) = *(undefined4 *)(param_1 + 0x20);
    return local_c;
}

int FUN_00062ec8(char param_1)

{
    int iVar1;
    float fVar2;
    int local_10;
    int local_c;

    iVar1 = get_temp(DAT_0014f3e4);
    DAT_0015245c = (float)(longlong)iVar1;
    local_c = fan_pwm_get();
    fVar2 = (float)FUN_00062d88(&DAT_00152450, param_1);
    local_10 = (int)fVar2;
    if ((param_1 != '\0') && (local_10 + 0x14 < 0 != SCARRY4(local_10, 0x14))) {
        local_10 = -0x14;
    }
    local_c = local_c + local_10;
    iVar1 = get_temp(DAT_0014f3dc);
    if (DAT_0014f3e0 <= iVar1) {
        local_c = 100;
    }
    fVar2 = DAT_00152454;
    if (DAT_00152454 <= (float)(longlong)local_c) {
        fVar2 = (float)(longlong)local_c;
    }
    if (fVar2 <= DAT_00152450) {
        if (DAT_00152454 <= (float)(longlong)local_c) {
            iVar1 = (int)(float)(longlong)local_c;
        } else {
            iVar1 = (int)DAT_00152454;
        }
    } else {
        iVar1 = (int)DAT_00152450;
    }
    return iVar1;
}

void set_pwm_by_temp(void)

{
    int iVar1;
    uint uVar2;
    int iVar3;
    bool bVar4;
    uint uVar5;
    undefined8 uVar6;
    undefined4 local_14;

    if (DAT_0015247c == '\x01') {
        clock_gettime(1, (timespec *)&DAT_00152488);
        iVar3 = DAT_00152488 - DAT_00152480;
        uVar6 = VectorShiftLeft((longlong)iVar3, 5, 0x40, 0);
        uVar6 = VectorSub(uVar6, (longlong)iVar3, 8);
        uVar6 = VectorAdd(uVar6, uVar6, 8);
        uVar5 = (uint)uVar6;
        uVar6 = VectorAdd(CONCAT44((int)((ulonglong)uVar6 >> 0x20) * 2 +
                                       (uint)CARRY4(uVar5, uVar5),
                                   uVar5 * 2),
                          (longlong)iVar3, 8);
        uVar6 = VectorShiftLeft(uVar6, 3, 0x40, 0);
        uVar5 = (DAT_0015248c - DAT_00152484) / 1000000;
        uVar2 = uVar5 + (uint)uVar6;
        iVar3 = ((int)uVar5 >> 0x1f) + (int)((ulonglong)uVar6 >> 0x20) +
                (uint)CARRY4(uVar5, (uint)uVar6);
        if (((int)(uint)((uint)DAT_00152490 < 0x14) <= DAT_00152490._4_4_) ||
            (iVar1 = (int)DAT_0014f3ec >> 0x1f,
             (int)(iVar3 - (iVar1 + (uint)(uVar2 < DAT_0014f3ec))) < 0 !=
                 (SBORROW4(iVar3, iVar1) !=
                  SBORROW4(iVar3 - iVar1, (uint)(uVar2 < DAT_0014f3ec))))) {
            if (DAT_00152490._4_4_ < (int)(uint)((uint)DAT_00152490 < 0x14)) {
                return;
            }
            iVar1 = (int)DAT_0014f3f0 >> 0x1f;
            if ((int)(iVar3 - (iVar1 + (uint)(uVar2 < DAT_0014f3f0))) < 0 !=
                (SBORROW4(iVar3, iVar1) !=
                 SBORROW4(iVar3 - iVar1, (uint)(uVar2 < DAT_0014f3f0)))) {
                return;
            }
        }
        clock_gettime(1, (timespec *)&DAT_00152480);
        bVar4 = 0xfffffffe < (uint)DAT_00152490;
        DAT_00152490._0_4_ = (uint)DAT_00152490 + 1;
        DAT_00152490._4_4_ = DAT_00152490._4_4_ + (uint)bVar4;
    } else {
        clock_gettime(1, (timespec *)&DAT_00152480);
        DAT_00152490._0_4_ = 0;
        DAT_00152490._4_4_ = 0;
        DAT_0015247c = '\x01';
    }
    if (DAT_0014f3d0 == 1) {
        local_14 = FUN_00062c30();
    } else if (DAT_0014f3d0 == 0) {
        local_14 = FUN_00062a34();
    } else if (DAT_0014f3d0 == 2) {
        local_14 = FUN_00062ec8(DAT_00152490._4_4_ <
                                (int)(uint)((uint)DAT_00152490 < 0x15));
    } else {
        local_14 = 100;
    }
    fan_pwm_set(local_14);
    return;
}

undefined4
fan_control_info_init(int param_1, int param_2, int param_3, undefined4 param_4,
                      undefined4 param_5, undefined4 param_6, int param_7,
                      undefined4 param_8, undefined4 param_9, float param_10,
                      float param_11, float param_12, float param_13)

{
    undefined1 auStack_1018[4096];

    DAT_0014f3e0 = param_5;
    DAT_0014f3e4 = param_6;
    DAT_0014f3e8 = param_7;
    DAT_0014f3ec = param_8;
    DAT_0014f3f0 = param_9;
    DAT_0014f3f4 = param_10;
    DAT_0014f3f8 = param_11;
    DAT_0014f3fc = param_12;
    DAT_0014f400 = param_13;
    DAT_0014f3d0 = param_1;
    DAT_0014f3d4 = param_2;
    DAT_0014f3d8 = param_3;
    DAT_0014f3dc = param_4;
    memset(&DAT_00152450, 0, 0x2c);
    if (DAT_0014f3d0 == 2) {
        DAT_00152460 = DAT_0014f3f4;
        DAT_00152464 = DAT_0014f3f8;
        DAT_00152468 = DAT_0014f3fc;
        DAT_0015246c = DAT_0014f400;
        DAT_00152458 = (float)(longlong)DAT_0014f3e8;
        DAT_00152454 = (float)(longlong)DAT_0014f3d4;
        DAT_00152450 = (float)(longlong)DAT_0014f3d8;
    }
    V_LOCK();
    logfmt_raw(
        auStack_1018, 0x1000, 0,
        "startup P: %f, p: %f, i: %f, d: %f   target: %f, min %f, max %f",
        (double)DAT_00152460, (double)DAT_00152464, (double)DAT_00152468,
        (double)DAT_0015246c, (double)DAT_00152458, (double)DAT_00152454,
        (double)DAT_00152450);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/miner_util/set_pwm_by_temp.c",
         0xa6, "fan_control_info_init", 0x15, 0x177, 0x14, auStack_1018);
    return 0;
}

undefined4 FUN_00063518(undefined4 param_1, undefined4 param_2)

{
    V_STR(param_1, "error", param_2);
    return param_1;
}

undefined4 FUN_00063550(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "chain", param_3, param_4);
    return param_1;
}

undefined4 FUN_00063584(undefined4 param_1, undefined1 param_2)

{
    V_BOOL(param_1, "poweroff", param_2);
    return param_1;
}

void FUN_000635c0(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_0006374c(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

/* WARNING: Heritage AFTER dead removal. Example location: s0xfffffe18 :
 * 0x00063b24 */
/* WARNING: Restarted to delay deadcode elimination for space: stack */

undefined4 *FUN_000638dc(undefined4 *param_1, char param_2)

{
    int iVar1;
    undefined8 uVar2;
    undefined4 uVar3;
    undefined8 in_d17;
    undefined1 auStack_11ec[4096];
    int local_1ec;
    undefined4 local_1e8;
    undefined4 uStack_1e4;
    undefined4 uStack_1e0;
    undefined4 uStack_1dc;
    undefined1 local_1d8[32];
    undefined1 local_1b8[32];
    undefined1 local_198[32];
    undefined1 local_178[32];
    undefined1 local_158[32];
    undefined1 local_138[32];
    undefined1 local_118[32];
    undefined1 local_f8[32];
    undefined1 local_d8[32];
    undefined1 local_b8[36];
    undefined4 local_94;
    undefined4 *local_90;
    undefined4 local_8c;
    int local_88;
    undefined4 local_84;
    uint *local_80;
    undefined4 local_7c;
    undefined4 *local_78;
    undefined4 local_74;
    int local_70;
    undefined4 local_6c;
    uint *local_68;
    undefined4 local_64;
    undefined4 *local_60;
    undefined4 local_5c;
    int local_58;
    undefined4 local_54;
    uint *local_50;
    undefined4 local_4c;
    undefined4 *local_48;
    undefined4 local_44;
    int local_40;
    undefined4 local_3c;
    uint *local_38;
    undefined4 local_34;
    undefined4 *local_30;
    undefined4 local_2c;
    int local_28;
    undefined4 local_24;
    uint *local_20;
    int local_1c;
    int local_18;
    int local_14;

    local_1ec = 0;
    local_1c = get_all_created_runtime(&local_1ec);
    memset(&local_1e8, 0, 0x10);
    for (local_18 = 0; local_18 < local_1ec; local_18 = local_18 + 1) {
        local_14 =
            get_flag_from_monitor(*(undefined4 *)(local_1c + local_18 * 4));
        local_20 = (uint *)(local_14 + 0x10);
        local_24 = 0;
        /* WARNING: Ignoring partial resolution of indirect */
        uVar3 = 0;
        uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
        if (((uint)uVar2 & *local_20) != 0 ||
            ((uint)((ulonglong)uVar2 >> 0x20) & *(uint *)(local_14 + 0x14)) !=
                0) {
            local_28 = local_14 + 0x10;
            local_2c = 0;
            /* WARNING: Ignoring partial resolution of indirect */
            uVar3 = 0;
            uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
            *(uint *)(local_14 + 0x18) =
                (uint)uVar2 | *(uint *)(local_14 + 0x18);
            *(uint *)(local_14 + 0x1c) =
                (uint)((ulonglong)uVar2 >> 0x20) | *(uint *)(local_14 + 0x1c);
            if (param_2 != '\0') {
                V_LOCK();
                iVar1 = *(int *)(*(int *)(local_1c + local_18 * 4) + 0xfc);
                FUN_00063550(local_1d8, local_1d8, iVar1, iVar1 >> 0x1f);
                FUN_00063518(local_1b8, "temp lost");
                logfmt_raw(auStack_11ec, 0x1000, 0);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/miner_monitor/check_miner_status.c",
                     0xb7, "check_temp");
                local_30 = &local_1e8;
                local_34 = 0;
                /* WARNING: Ignoring partial resolution of indirect */
                uVar3 = 0;
                VectorShiftLeft(1, in_d17, 8, 1);
            }
        }
        local_38 = (uint *)(local_14 + 0x10);
        local_3c = 1;
        /* WARNING: Ignoring partial resolution of indirect */
        uVar3 = 1;
        uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
        if (((uint)uVar2 & *local_38) != 0 ||
            ((uint)((ulonglong)uVar2 >> 0x20) & *(uint *)(local_14 + 0x14)) !=
                0) {
            local_40 = local_14 + 0x10;
            local_44 = 1;
            /* WARNING: Ignoring partial resolution of indirect */
            uVar3 = 1;
            uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
            *(uint *)(local_14 + 0x18) =
                (uint)uVar2 | *(uint *)(local_14 + 0x18);
            *(uint *)(local_14 + 0x1c) =
                (uint)((ulonglong)uVar2 >> 0x20) | *(uint *)(local_14 + 0x1c);
            if (param_2 != '\0') {
                V_LOCK();
                iVar1 = *(int *)(*(int *)(local_1c + local_18 * 4) + 0xfc);
                FUN_00063550(local_198, local_198, iVar1, iVar1 >> 0x1f);
                FUN_00063518(local_178, "temp too high");
                logfmt_raw(auStack_11ec, 0x1000, 0);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/miner_monitor/check_miner_status.c",
                     0xb7, "check_temp");
                local_48 = &local_1e8;
                local_4c = 1;
                /* WARNING: Ignoring partial resolution of indirect */
                uVar3 = 1;
                VectorShiftLeft(1, in_d17, 8, 1);
            }
        }
        local_50 = (uint *)(local_14 + 0x10);
        local_54 = 2;
        /* WARNING: Ignoring partial resolution of indirect */
        uVar3 = 2;
        uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
        if (((uint)uVar2 & *local_50) != 0 ||
            ((uint)((ulonglong)uVar2 >> 0x20) & *(uint *)(local_14 + 0x14)) !=
                0) {
            local_58 = local_14 + 0x10;
            local_5c = 2;
            /* WARNING: Ignoring partial resolution of indirect */
            uVar3 = 2;
            uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
            *(uint *)(local_14 + 0x18) =
                (uint)uVar2 | *(uint *)(local_14 + 0x18);
            *(uint *)(local_14 + 0x1c) =
                (uint)((ulonglong)uVar2 >> 0x20) | *(uint *)(local_14 + 0x1c);
            if (param_2 != '\0') {
                V_LOCK();
                iVar1 = *(int *)(*(int *)(local_1c + local_18 * 4) + 0xfc);
                FUN_00063550(local_158, local_158, iVar1, iVar1 >> 0x1f);
                FUN_00063518(local_138, "temp too low");
                logfmt_raw(auStack_11ec, 0x1000, 0);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/miner_monitor/check_miner_status.c",
                     0xb7, "check_temp");
                local_60 = &local_1e8;
                local_64 = 2;
                /* WARNING: Ignoring partial resolution of indirect */
                uVar3 = 2;
                VectorShiftLeft(1, in_d17, 8, 1);
            }
        }
        local_68 = (uint *)(local_14 + 0x10);
        local_6c = 3;
        /* WARNING: Ignoring partial resolution of indirect */
        uVar3 = 3;
        uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
        if (((uint)uVar2 & *local_68) != 0 ||
            ((uint)((ulonglong)uVar2 >> 0x20) & *(uint *)(local_14 + 0x14)) !=
                0) {
            local_70 = local_14 + 0x10;
            local_74 = 3;
            /* WARNING: Ignoring partial resolution of indirect */
            uVar3 = 3;
            uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
            *(uint *)(local_14 + 0x18) =
                (uint)uVar2 | *(uint *)(local_14 + 0x18);
            *(uint *)(local_14 + 0x1c) =
                (uint)((ulonglong)uVar2 >> 0x20) | *(uint *)(local_14 + 0x1c);
            if (param_2 != '\0') {
                V_LOCK();
                iVar1 = *(int *)(*(int *)(local_1c + local_18 * 4) + 0xfc);
                FUN_00063550(local_118, local_118, iVar1, iVar1 >> 0x1f);
                FUN_00063518(local_f8, "read no temp");
                logfmt_raw(auStack_11ec, 0x1000, 0);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/miner_monitor/check_miner_status.c",
                     0xb7, "check_temp");
                local_78 = &local_1e8;
                local_7c = 3;
                /* WARNING: Ignoring partial resolution of indirect */
                uVar3 = 3;
                VectorShiftLeft(1, in_d17, 8, 1);
            }
        }
        local_80 = (uint *)(local_14 + 0x10);
        local_84 = 4;
        /* WARNING: Ignoring partial resolution of indirect */
        uVar3 = 4;
        uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
        if (((uint)uVar2 & *local_80) != 0 ||
            ((uint)((ulonglong)uVar2 >> 0x20) & *(uint *)(local_14 + 0x14)) !=
                0) {
            local_88 = local_14 + 0x10;
            local_8c = 4;
            /* WARNING: Ignoring partial resolution of indirect */
            uVar3 = 4;
            uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
            *(uint *)(local_14 + 0x18) =
                (uint)uVar2 | *(uint *)(local_14 + 0x18);
            *(uint *)(local_14 + 0x1c) =
                (uint)((ulonglong)uVar2 >> 0x20) | *(uint *)(local_14 + 0x1c);
            if (param_2 != '\0') {
                V_LOCK();
                iVar1 = *(int *)(*(int *)(local_1c + local_18 * 4) + 0xfc);
                FUN_00063550(local_d8, local_d8, iVar1, iVar1 >> 0x1f);
                FUN_00063518(local_b8, "uneffective temp exceed limit");
                logfmt_raw(auStack_11ec, 0x1000, 0);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/miner_monitor/check_miner_status.c",
                     0xb7, "check_temp");
                local_90 = &local_1e8;
                local_94 = 4;
                /* WARNING: Ignoring partial resolution of indirect */
                uVar3 = 4;
                VectorShiftLeft(1, in_d17, 8, 1);
            }
        }
    }
    *param_1 = local_1e8;
    param_1[1] = uStack_1e4;
    param_1[2] = uStack_1e0;
    param_1[3] = uStack_1dc;
    return param_1;
}

/* WARNING: Restarted to delay deadcode elimination for space: stack */

undefined4 FUN_00064390(char param_1)

{
    undefined8 uVar1;
    undefined4 uVar2;
    undefined8 in_d17;
    undefined1 auStack_104c[4096];
    undefined4 local_4c;
    undefined1 local_48[32];
    undefined4 local_28;
    int local_24;
    undefined4 local_20;
    uint *local_1c;
    int local_18;
    undefined4 *local_14;

    local_4c = 0;
    local_14 = (undefined4 *)get_all_created_runtime(&local_4c);
    local_18 = get_flag_from_monitor(*local_14);
    local_1c = (uint *)(local_18 + 0x20);
    local_20 = 2;
    /* WARNING: Ignoring partial resolution of indirect */
    uVar2 = 2;
    uVar1 = VectorShiftLeft(1, in_d17, 8, 1);
    if (((uint)uVar1 & *local_1c) != 0 ||
        ((uint)((ulonglong)uVar1 >> 0x20) & *(uint *)(local_18 + 0x24)) != 0) {
        local_24 = local_18 + 0x20;
        local_28 = 2;
        /* WARNING: Ignoring partial resolution of indirect */
        uVar2 = 2;
        uVar1 = VectorShiftLeft(1, in_d17, 8, 1);
        *(uint *)(local_18 + 0x28) = (uint)uVar1 | *(uint *)(local_18 + 0x28);
        *(uint *)(local_18 + 0x2c) =
            (uint)((ulonglong)uVar1 >> 0x20) | *(uint *)(local_18 + 0x2c);
        if (param_1 != '\0') {
            V_LOCK();
            FUN_00063518(local_48, "fan error exceed limit");
            logfmt_raw(auStack_104c, 0x1000, 0);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/check_miner_status.c",
                 0xb7, "check_fan_err");
            return 1;
        }
    }
    return 0;
}

/* WARNING: Restarted to delay deadcode elimination for space: stack */

undefined1 FUN_00064568(char param_1)

{
    undefined8 uVar1;
    undefined4 uVar2;
    undefined8 in_d17;
    int local_24[2];
    uint *local_1c;
    uint *local_18;
    int local_14;
    int local_10;
    undefined1 local_9;

    local_9 = 0;
    local_24[0] = 0;
    local_14 = get_all_created_runtime(local_24);
    for (local_10 = 0; local_10 < local_24[0]; local_10 = local_10 + 1) {
        local_1c = (uint *)get_flag_from_monitor(
            *(undefined4 *)(local_14 + local_10 * 4));
        local_24[1] = 0;
        /* WARNING: Ignoring partial resolution of indirect */
        uVar2 = 0;
        uVar1 = VectorShiftLeft(1, in_d17, 8, 1);
        if ((((uint)uVar1 & *local_1c) != 0 ||
             ((uint)((ulonglong)uVar1 >> 0x20) & local_1c[1]) != 0) &&
            (param_1 != '\0')) {
            local_9 = 1;
        }
        local_18 = local_1c;
    }
    return local_9;
}

undefined1 FUN_00064668(char param_1, undefined1 *param_2)

{
    char cVar1;
    int iVar2;
    int iVar3;
    int iVar4;
    uint uVar5;
    undefined8 uVar6;
    undefined1 auStack_1078[4096];
    undefined4 local_78;
    undefined4 uStack_74;
    undefined4 uStack_70;
    undefined4 uStack_6c;
    undefined4 local_68;
    undefined4 uStack_64;
    undefined4 uStack_60;
    undefined4 uStack_5c;
    undefined4 local_58;
    undefined4 uStack_54;
    undefined4 uStack_50;
    undefined4 uStack_4c;
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    int *local_34;
    undefined4 *local_30;
    undefined4 *local_2c;
    int local_28;
    uint local_24;
    char *local_20;
    int iStack_1c;
    undefined1 local_15;
    int local_14;

    local_15 = 0;
    if (DAT_001524c8 != '\x01') {
        local_2c = &DAT_001524cc;
        clock_gettime(1, (timespec *)&DAT_001524cc);
        DAT_001524c8 = '\x01';
    }
    for (local_14 = 0; local_14 < total_pools; local_14 = local_14 + 1) {
        local_28 = *(int *)(pools + local_14 * 4);
        cVar1 = pool_tget(local_28, local_28 + 0x770);
        if ((cVar1 != '\x01') && (pools_active != '\0')) {
            local_30 = &DAT_001524cc;
            clock_gettime(1, (timespec *)&DAT_001524cc);
            set_miner_6060info_network_lost_err(0);
        }
    }
    local_34 = &DAT_001524cc;
    clock_gettime(1, (timespec *)&DAT_001524d4);
    iVar4 = local_34[2] - *local_34;
    uVar6 = VectorShiftLeft((longlong)iVar4, 5, 0x40, 0);
    uVar6 = VectorSub(uVar6, (longlong)iVar4, 8);
    uVar6 = VectorAdd(uVar6, uVar6, 8);
    uVar5 = (uint)uVar6;
    uVar6 = VectorAdd(CONCAT44((int)((ulonglong)uVar6 >> 0x20) * 2 +
                                   (uint)CARRY4(uVar5, uVar5),
                               uVar5 * 2),
                      (longlong)iVar4, 8);
    uVar6 = VectorShiftLeft(uVar6, 3, 0x40, 0);
    uVar5 = (local_34[3] - local_34[1]) / 1000000;
    local_20 = (char *)(uVar5 + (uint)uVar6);
    iStack_1c = ((int)uVar5 >> 0x1f) + (int)((ulonglong)uVar6 >> 0x20) +
                (uint)CARRY4(uVar5, (uint)uVar6);
    if ((DAT_001524dc != '\0') &&
        (0 < (int)(iStack_1c + (uint)((char *)0xea5f < local_20)) ==
         SBORROW4(-iStack_1c, (uint)((char *)0xea5f < local_20)))) {
        iVar4 = rand();
        local_24 = iVar4 % 0x78 + 0x3c;
        V_LOCK(iVar4 * -0x77777777);
        logfmt_raw(auStack_1078, 0x1000, 0,
                   "The pool connection recovered after the system poweroff. "
                   "Exit and restart mining(%d)!",
                   local_24);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/miner_monitor/"
             "check_miner_status.c",
             0xb7, "check_lost_connection_to_pool", 0x1d, 0x89, 0x50,
             auStack_1078);
        sleep(local_24);
        /* WARNING: Subroutine does not return */
        exit(1);
    }
    if (param_1 != '\0') {
        if (0 < (int)(iStack_1c + (uint)((char *)0xea60 < local_20)) ==
            SBORROW4(-iStack_1c, (uint)((char *)0xea60 < local_20))) {
            DAT_001524e0 = 0;
        } else {
            iVar2 = DAT_001524e0 + 1;
            iVar4 = DAT_001524e0 * -0x77777777;
            iVar3 = DAT_001524e0 % 0x3c;
            DAT_001524e0 = iVar2;
            if (iVar3 == 0) {
                V_LOCK(iVar4);
                FUN_00063518(&local_78, "net lost");
                logfmt_raw(auStack_1078, 0x1000, 0, uStack_5c, local_78,
                           uStack_74, uStack_70, uStack_6c, local_68, uStack_64,
                           uStack_60, uStack_5c, "lost internet for %d seconds",
                           (int)local_20 / 1000);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/miner_monitor/check_miner_status.c",
                     0xb7, "check_lost_connection_to_pool", 0x1d, 0x91, 100,
                     auStack_1078);
                set_miner_6060info_network_lost_err(1);
            }
            local_15 = 1;
        }
        if ((0 < (int)(iStack_1c +
                       (uint)("ce/jenkins/jenkins/workspace/"
                              "Antminer_L9_CVCtrl_release/build/rootfs/"
                              "buildroot/tmp/release/build/"
                              "godminer-origin_godminer-branch1/backend/"
                              "backend_ltc_1491/chip_reg_io_ltc_1491.c" <
                              local_20)) !=
             SBORROW4(
                 -iStack_1c,
                 (uint)("ce/jenkins/jenkins/workspace/"
                        "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                        "release/build/godminer-origin_godminer-branch1/"
                        "backend/backend_ltc_1491/chip_reg_io_ltc_1491.c" <
                        local_20))) &&
            (DAT_001524dc != '\x01')) {
            V_LOCK();
            FUN_00063518(&local_58, "net lost");
            logfmt_raw(auStack_1078, 0x1000, 0, uStack_3c, local_58, uStack_54,
                       uStack_50, uStack_4c, local_48, uStack_44, uStack_40,
                       uStack_3c,
                       "lost internet %d seconds > 20 minutes, poweroff.",
                       (int)local_20 / 1000);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/check_miner_status.c",
                 0xb7, "check_lost_connection_to_pool", 0x1d, 0x9c, 0x78,
                 auStack_1078);
            *param_2 = 1;
            DAT_001524dc = '\x01';
        }
    }
    return local_15;
}

void FUN_00064bd0(char param_1)

{
    DAT_0014f510 = DAT_0014f510 == '\0';
    if (param_1 == '\0') {
        red_led_off();
        if (DAT_0014f510 == '\0') {
            green_led_off();
        } else {
            green_led_on();
        }
    } else {
        green_led_off();
        if (DAT_0014f510 == '\0') {
            red_led_off();
        } else {
            red_led_on();
        }
    }
    return;
}

void FUN_00064c80(void)

{
    DAT_00152498 = 0;
    DAT_00152499 = 0;
    DAT_0015249a = 0;
    DAT_0015249b = 0;
    DAT_0015249c = 0;
    DAT_0015249d = 0;
    DAT_0015249e = 0;
    DAT_0015249f = 0;
    DAT_001524a0._0_1_ = 0;
    return;
}

/* WARNING: Globals starting with '_' overlap smaller symbols at the same
 * address */

undefined4 *get_miner_working_status(undefined4 *param_1)

{
    undefined4 uVar1;
    undefined4 uVar2;
    undefined4 uVar3;

    if (DAT_001524ac != '\x01') {
        FUN_00064c80();
        DAT_001524ac = '\x01';
        if (pools_active == '\x01') {
            _DAT_0015249c = (uint3)_DAT_0015249c;
        } else {
            _DAT_0015249c = CONCAT12(1, _DAT_0015249c);
        }
    }
    uVar3 = DAT_001524a4;
    uVar2 = DAT_001524a0;
    uVar1 = _DAT_0015249c;
    *param_1 = _DAT_00152498;
    param_1[1] = uVar1;
    param_1[2] = uVar2;
    param_1[3] = uVar3;
    param_1[4] = DAT_001524a8;
    return param_1;
}

undefined1 *get_miner_working_status_p(void)

{
    return &DAT_00152498;
}

void update_miner_working_status(void)

{
    DAT_0015249e = pools_active != '\x01';
    return;
}

/* WARNING: Heritage AFTER dead removal. Example location: s0xffffff88 :
 * 0x00064f94 */
/* WARNING: Restarted to delay deadcode elimination for space: stack */

void task_check_miner_status(undefined4 param_1)

{
    uint uVar1;
    bool bVar2;
    undefined8 uVar3;
    undefined4 uVar4;
    undefined8 in_d17;
    uint local_1098;
    uint uStack_1094;
    undefined4 uStack_1090;
    undefined4 uStack_108c;
    undefined4 local_1084;
    undefined1 auStack_1080[4096];
    int local_80;
    char local_79;
    uint local_78;
    uint uStack_74;
    undefined4 uStack_70;
    undefined4 uStack_6c;
    undefined1 local_68[36];
    undefined4 local_44;
    uint *local_40;
    undefined4 local_3c;
    uint *local_38;
    undefined4 local_34;
    uint *local_30;
    undefined4 local_2c;
    uint *local_28;
    char local_23;
    char local_22;
    char local_21;
    int local_20;
    char local_19;
    char local_18;
    char local_17;
    byte local_16;
    char local_15;
    int local_14;

    local_79 = '\0';
    local_1084 = param_1;
    if (DAT_001524ac != '\x01') {
        FUN_00064c80();
        DAT_001524ac = '\x01';
    }
    pthread_mutex_lock((pthread_mutex_t *)&DAT_001524b0);
    local_16 = (char)DAT_001524a0 == '\0';
    FUN_000638dc(&local_1098, local_16);
    local_78 = local_1098;
    uStack_74 = uStack_1094;
    uStack_70 = uStack_1090;
    uStack_6c = uStack_108c;
    local_28 = &local_78;
    local_2c = 1;
    /* WARNING: Ignoring partial resolution of indirect */
    uVar4 = 1;
    uVar3 = VectorShiftLeft(1, in_d17, 8, 1);
    uVar1 = (uint)uVar3 & local_1098 |
            (uint)((ulonglong)uVar3 >> 0x20) & uStack_1094;
    bVar2 = uVar1 != 0;
    if (bVar2) {
        uVar1 = 1;
    }
    local_17 = (char)uVar1;
    if (!bVar2) {
        local_17 = '\0';
    }
    if (local_17 != '\0') {
        set_miner_6060info_status_high_temp_err(1);
    }
    local_30 = &local_78;
    local_34 = 2;
    /* WARNING: Ignoring partial resolution of indirect */
    uVar4 = 2;
    uVar3 = VectorShiftLeft(1, in_d17, 8, 1);
    uVar1 =
        (uint)uVar3 & local_78 | (uint)((ulonglong)uVar3 >> 0x20) & uStack_74;
    bVar2 = uVar1 != 0;
    if (bVar2) {
        uVar1 = 1;
    }
    local_18 = (char)uVar1;
    if (!bVar2) {
        local_18 = '\0';
    }
    if (local_18 != '\0') {
        set_miner_6060info_status_low_temp_err(1);
    }
    local_19 = FUN_00064390(local_16);
    local_80 = 0;
    local_20 = get_all_created_runtime(&local_80);
    for (local_14 = 0; local_14 < local_80; local_14 = local_14 + 1) {
        local_16 = (local_16 &
                    *(byte *)(*(int *)(local_20 + local_14 * 4) + 0x102)) != 0;
    }
    local_21 = FUN_00064568(local_16);
    local_22 = FUN_00064668(local_16, &local_79);
    local_40 = &local_78;
    local_44 = 3;
    /* WARNING: Ignoring partial resolution of indirect */
    uVar4 = 3;
    uVar3 = VectorShiftLeft(1, in_d17, 8, 1);
    uVar1 =
        (uint)uVar3 & local_78 | (uint)((ulonglong)uVar3 >> 0x20) & uStack_74;
    bVar2 = uVar1 != 0;
    if (bVar2) {
        uVar1 = 1;
    }
    local_23 = (char)uVar1;
    if (!bVar2) {
        local_23 = '\0';
    }
    local_38 = &local_78;
    local_3c = 4;
    /* WARNING: Ignoring partial resolution of indirect */
    uVar4 = 4;
    uVar3 = VectorShiftLeft(1, in_d17, 8, 1);
    if (((uint)uVar3 & local_78) == 0 &&
        ((uint)((ulonglong)uVar3 >> 0x20) & uStack_74) == 0) {
        local_15 = '\0';
    } else {
        local_15 = '\x01';
        set_miner_6060info_uneffective_temp_err(1);
    }
    if (((char)DAT_001524a0 != '\x01') &&
        ((((local_17 != '\0' || (local_18 != '\0')) || (local_19 != '\0')) ||
          (((local_23 != '\0' || (local_15 != '\0')) ||
            (local_79 != '\0')))))) {
        DAT_001524a0._0_1_ = '\x01';
        all_dev_poweroff();
        V_LOCK();
        FUN_00063584(local_68, 1);
        logfmt_raw(auStack_1080, 0x1000, 0);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/miner_monitor/"
             "check_miner_status.c",
             0xb7, "task_check_miner_status");
    }
    if (((local_17 == '\0') && (local_18 == '\0')) &&
        (((local_23 == '\0' && (((local_15 == '\0' && (local_19 == '\0')) &&
                                 (local_21 == '\0')))) &&
          ((local_22 == '\0' && ((char)DAT_001524a0 == '\0')))))) {
        DAT_0015249f = 0;
    } else {
        DAT_0015249f = 1;
    }
    if (local_16 != 0) {
        DAT_00152498 = local_17;
        DAT_00152499 = local_18;
        DAT_0015249c = local_19;
        if ((local_21 == '\0') && ((char)DAT_001524a0 == '\0')) {
            DAT_0015249d = 0;
        } else {
            DAT_0015249d = 1;
        }
        DAT_0015249e = local_22;
        DAT_0015249a = local_23;
        DAT_0015249b = local_15;
    }
    pthread_mutex_unlock((pthread_mutex_t *)&DAT_001524b0);
    FUN_00064bd0(DAT_0015249f);
    if ((((local_17 == '\0') && (local_23 == '\0')) && (local_15 == '\0')) &&
        (local_79 == '\0')) {
        set_pwm_by_temp();
    } else {
        fan_pwm_set_max();
    }
    return;
}

void FUN_0006545c(int param_1)

{
    bool bVar1;
    int iVar2;
    int *piVar3;

    if ((param_1 != 0) && (*(int *)(param_1 + 4) != -1)) {
        piVar3 = (int *)(param_1 + 4);
        DataMemoryBarrier(0xb);
        do {
            iVar2 = *piVar3;
            bVar1 = (bool)hasExclusiveAccess(piVar3);
        } while (!bVar1);
        *piVar3 = iVar2 + -1;
        if (iVar2 + -1 == 0) {
            json_delete(param_1);
        }
    }
    return;
}

/* WARNING: Globals starting with '_' overlap smaller symbols at the same
 * address */

undefined4 FUN_000654c4(void)

{
    undefined4 uVar1;
    int local_10;
    int local_c;

    if (DAT_0015251d == '\0') {
        for (local_c = 0; local_c < 8; local_c = local_c + 1) {
            *(undefined4 *)(&DAT_00152558 + local_c * 0x10) = 0x278d00;
            *(undefined4 *)(&DAT_0015255c + local_c * 0x10) = 0;
        }
        for (local_10 = 0; local_10 < 0x10; local_10 = local_10 + 1) {
            *(undefined4 *)(&DAT_001527d8 + local_10 * 0x10) = 0x278d00;
            *(undefined4 *)(&DAT_001527dc + local_10 * 0x10) = 0;
            *(undefined4 *)(&DAT_001525d8 + local_10 * 0x10) = 600;
            *(undefined4 *)(&DAT_001525dc + local_10 * 0x10) = 0;
            *(undefined4 *)(&DAT_001526d8 + local_10 * 0x10) = 600;
            *(undefined4 *)(&DAT_001526dc + local_10 * 0x10) = 0;
        }
        DAT_001528f8._0_4_ = 0x278d00;
        DAT_001528f8._4_4_ = 0;
        DAT_00152528._0_4_ = 0x278d00;
        DAT_00152528._4_4_ = 0;
        DAT_00152538._0_4_ = 0x278d00;
        DAT_00152538._4_4_ = 0;
        DAT_001528e8._0_4_ = 0x278d00;
        DAT_001528e8._4_4_ = 0;
        _DAT_001528d8 = 0x278d00;
        DAT_001528dc = 0;
        DAT_00152548._0_4_ = 0x278d00;
        DAT_00152548._4_4_ = 0;
        DAT_0015251d = '\x01';
        uVar1 = 0;
    } else {
        uVar1 = 0xffffffff;
    }
    return uVar1;
}

undefined1 *get_miner_6060info_status(void)

{
    return &DAT_00152520;
}

void set_miner_6060info_status_fan_err(int param_1, undefined1 param_2)

{
    double dVar1;
    uint uVar2;
    undefined8 uVar3;
    int local_109c;
    char acStack_1098[128];
    undefined1 auStack_1018[4096];
    timeval local_18;
    timeval local_10;

    local_109c = param_1;
    if (7 < param_1) {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0,
                   "check_fan_index_valid failed, fan_index >= FAN_MAX");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/miner_monitor/"
             "miner_6060info.c",
             0xb3, "set_miner_6060info_status_fan_err", 0x21, 0x5c, 0x28,
             auStack_1018);
        local_109c = 0;
    }
    pthread_mutex_lock((pthread_mutex_t *)miner_6060info_lock);
    (&DAT_00152520)[(local_109c + 3) * 0x10] = param_2;
    FUN_000654c4();
    local_10.tv_sec = 0;
    local_10.tv_usec = 0;
    gettimeofday(&local_10, (__timezone_ptr_t)0x0);
    if ((&DAT_00152520)[(local_109c + 3) * 0x10] != '\0') {
        dVar1 =
            difftime(local_10.tv_sec, (&DAT_00152524)[(local_109c + 3) * 4]);
        uVar3 = FUN_000cce38(SUB84(dVar1, 0), (int)((ulonglong)dVar1 >> 0x20));
        uVar2 = (uint) * (undefined8 *)(&DAT_00152558 + local_109c * 0x10);
        if ((int)(uint)((uint)uVar3 == uVar2) <=
            (int)((int)((ulonglong)uVar3 >> 0x20) -
                  ((int)((ulonglong) * (undefined8 *)(&DAT_00152558 +
                                                      local_109c * 0x10) >>
                         0x20) +
                   (uint)((uint)uVar3 < uVar2)))) {
            snprintf(acStack_1098, 0x80, "F%d:1", local_109c);
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, "Sweep error string = %s",
                       acStack_1098);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/miner_6060info.c",
                 0xb3, "set_miner_6060info_status_fan_err", 0x21, 0x5f, 100,
                 auStack_1018);
        }
    }
    local_18.tv_sec = 0;
    local_18.tv_usec = 0;
    if ((&DAT_00152520)[(local_109c + 3) * 0x10] == '\0') {
        (&DAT_00152524)[(local_109c + 3) * 4] = 0;
    } else {
        gettimeofday(&local_18, (__timezone_ptr_t)0x0);
        (&DAT_00152524)[(local_109c + 3) * 4] = local_18.tv_sec;
    }
    pthread_mutex_unlock((pthread_mutex_t *)miner_6060info_lock);
    return;
}

void set_miner_6060info_status_high_temp_err(char param_1)

{
    double dVar1;
    undefined8 uVar2;
    undefined4 local_1098[32];
    undefined1 auStack_1018[4096];
    timeval local_18;
    timeval local_10;

    pthread_mutex_lock((pthread_mutex_t *)miner_6060info_lock);
    DAT_00152520 = param_1;
    FUN_000654c4();
    local_10.tv_sec = 0;
    local_10.tv_usec = 0;
    gettimeofday(&local_10, (__timezone_ptr_t)0x0);
    if (DAT_00152520 != '\0') {
        dVar1 = difftime(local_10.tv_sec, DAT_00152524);
        uVar2 = FUN_000cce38(SUB84(dVar1, 0), (int)((ulonglong)dVar1 >> 0x20));
        if ((int)(uint)((uint)uVar2 == (uint)DAT_00152528) <=
            (int)((int)((ulonglong)uVar2 >> 0x20) -
                  ((int)((ulonglong)DAT_00152528 >> 0x20) +
                   (uint)((uint)uVar2 < (uint)DAT_00152528)))) {
            local_1098[0] = 0x313a50;
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, "Sweep error string = %s",
                       local_1098);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/miner_6060info.c",
                 0xb3, "set_miner_6060info_status_high_temp_err", 0x27, 0x67,
                 100, auStack_1018);
        }
    }
    local_18.tv_sec = 0;
    local_18.tv_usec = 0;
    if (DAT_00152520 != '\0') {
        gettimeofday(&local_18, (__timezone_ptr_t)0x0);
    }
    DAT_00152524 = local_18.tv_sec;
    pthread_mutex_unlock((pthread_mutex_t *)miner_6060info_lock);
    return;
}

void set_miner_6060info_uneffective_temp_err(char param_1)

{
    double dVar1;
    undefined8 uVar2;
    undefined4 local_1098[32];
    undefined1 auStack_1018[4096];
    timeval local_18;
    timeval local_10;

    pthread_mutex_lock((pthread_mutex_t *)miner_6060info_lock);
    DAT_00152540 = param_1;
    FUN_000654c4();
    local_10.tv_sec = 0;
    local_10.tv_usec = 0;
    gettimeofday(&local_10, (__timezone_ptr_t)0x0);
    if (DAT_00152540 != '\0') {
        dVar1 = difftime(local_10.tv_sec, DAT_00152544);
        uVar2 = FUN_000cce38(SUB84(dVar1, 0), (int)((ulonglong)dVar1 >> 0x20));
        if ((int)(uint)((uint)uVar2 == (uint)DAT_00152548) <=
            (int)((int)((ulonglong)uVar2 >> 0x20) -
                  ((int)((ulonglong)DAT_00152548 >> 0x20) +
                   (uint)((uint)uVar2 < (uint)DAT_00152548)))) {
            local_1098[0] = 0x363a4a;
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, "Sweep error string = %s",
                       local_1098);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/miner_6060info.c",
                 0xb3, "set_miner_6060info_uneffective_temp_err", 0x27, 0x6f,
                 100, auStack_1018);
        }
    }
    local_18.tv_sec = 0;
    local_18.tv_usec = 0;
    if (DAT_00152540 != '\0') {
        gettimeofday(&local_18, (__timezone_ptr_t)0x0);
    }
    DAT_00152544 = local_18.tv_sec;
    pthread_mutex_unlock((pthread_mutex_t *)miner_6060info_lock);
    return;
}

void set_miner_6060info_status_low_temp_err(char param_1)

{
    double dVar1;
    undefined8 uVar2;
    undefined4 local_1098[32];
    undefined1 auStack_1018[4096];
    timeval local_18;
    timeval local_10;

    pthread_mutex_lock((pthread_mutex_t *)miner_6060info_lock);
    DAT_00152530 = param_1;
    FUN_000654c4();
    local_10.tv_sec = 0;
    local_10.tv_usec = 0;
    gettimeofday(&local_10, (__timezone_ptr_t)0x0);
    if (DAT_00152530 != '\0') {
        dVar1 = difftime(local_10.tv_sec, DAT_00152534);
        uVar2 = FUN_000cce38(SUB84(dVar1, 0), (int)((ulonglong)dVar1 >> 0x20));
        if ((int)(uint)((uint)uVar2 == (uint)DAT_00152538) <=
            (int)((int)((ulonglong)uVar2 >> 0x20) -
                  ((int)((ulonglong)DAT_00152538 >> 0x20) +
                   (uint)((uint)uVar2 < (uint)DAT_00152538)))) {
            local_1098[0] = 0x323a50;
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, "Sweep error string = %s",
                       local_1098);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/miner_6060info.c",
                 0xb3, "set_miner_6060info_status_low_temp_err", 0x26, 0x77,
                 100, auStack_1018);
        }
    }
    local_18.tv_sec = 0;
    local_18.tv_usec = 0;
    if (DAT_00152530 != '\0') {
        gettimeofday(&local_18, (__timezone_ptr_t)0x0);
    }
    DAT_00152534 = local_18.tv_sec;
    pthread_mutex_unlock((pthread_mutex_t *)miner_6060info_lock);
    return;
}

void set_miner_6060info_low_hashrate_err(int param_1, undefined1 param_2)

{
    double dVar1;
    uint uVar2;
    undefined8 uVar3;
    int local_109c;
    char acStack_1098[128];
    undefined1 auStack_1018[4096];
    timeval local_18;
    timeval local_10;

    local_109c = param_1;
    if (0xf < param_1) {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0,
                   "check_chain_index_valid failed, chain_index >= "
                   "PLATFORM_MAX_CHAIN_NUM");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/miner_monitor/"
             "miner_6060info.c",
             0xb3, "set_miner_6060info_low_hashrate_err", 0x23, 0x7c, 0x28,
             auStack_1018);
        local_109c = 0;
    }
    pthread_mutex_lock((pthread_mutex_t *)miner_6060info_lock);
    (&DAT_00152520)[(local_109c + 0xb) * 0x10] = param_2;
    FUN_000654c4();
    local_10.tv_sec = 0;
    local_10.tv_usec = 0;
    gettimeofday(&local_10, (__timezone_ptr_t)0x0);
    if ((&DAT_00152520)[(local_109c + 0xb) * 0x10] != '\0') {
        dVar1 =
            difftime(local_10.tv_sec, (&DAT_00152524)[(local_109c + 0xb) * 4]);
        uVar3 = FUN_000cce38(SUB84(dVar1, 0), (int)((ulonglong)dVar1 >> 0x20));
        uVar2 = (uint) * (undefined8 *)(&DAT_001525d8 + local_109c * 0x10);
        if ((int)(uint)((uint)uVar3 == uVar2) <=
            (int)((int)((ulonglong)uVar3 >> 0x20) -
                  ((int)((ulonglong) * (undefined8 *)(&DAT_001525d8 +
                                                      local_109c * 0x10) >>
                         0x20) +
                   (uint)((uint)uVar3 < uVar2)))) {
            snprintf(acStack_1098, 0x80, "R%d:1", local_109c);
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, "Sweep error string = %s",
                       acStack_1098);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/miner_6060info.c",
                 0xb3, "set_miner_6060info_low_hashrate_err", 0x23, 0x7f, 100,
                 auStack_1018);
        }
    }
    local_18.tv_sec = 0;
    local_18.tv_usec = 0;
    if ((&DAT_00152520)[(local_109c + 0xb) * 0x10] == '\0') {
        (&DAT_00152524)[(local_109c + 0xb) * 4] = 0;
    } else {
        gettimeofday(&local_18, (__timezone_ptr_t)0x0);
        (&DAT_00152524)[(local_109c + 0xb) * 4] = local_18.tv_sec;
    }
    pthread_mutex_unlock((pthread_mutex_t *)miner_6060info_lock);
    return;
}

void set_miner_6060info_runtime_bad_asic_err(int param_1, undefined1 param_2)

{
    double dVar1;
    uint uVar2;
    undefined8 uVar3;
    int local_109c;
    char acStack_1098[128];
    undefined1 auStack_1018[4096];
    timeval local_18;
    timeval local_10;

    local_109c = param_1;
    if (0xf < param_1) {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0,
                   "check_chain_index_valid failed, chain_index >= "
                   "PLATFORM_MAX_CHAIN_NUM");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/miner_monitor/"
             "miner_6060info.c",
             0xb3, "set_miner_6060info_runtime_bad_asic_err", 0x27, 0x85, 0x28,
             auStack_1018);
        local_109c = 0;
    }
    pthread_mutex_lock((pthread_mutex_t *)miner_6060info_lock);
    (&DAT_00152520)[(local_109c + 0x1b) * 0x10] = param_2;
    FUN_000654c4();
    local_10.tv_sec = 0;
    local_10.tv_usec = 0;
    gettimeofday(&local_10, (__timezone_ptr_t)0x0);
    if ((&DAT_00152520)[(local_109c + 0x1b) * 0x10] != '\0') {
        dVar1 =
            difftime(local_10.tv_sec, (&DAT_00152524)[(local_109c + 0x1b) * 4]);
        uVar3 = FUN_000cce38(SUB84(dVar1, 0), (int)((ulonglong)dVar1 >> 0x20));
        uVar2 = (uint) * (undefined8 *)(&DAT_001526d8 + local_109c * 0x10);
        if ((int)(uint)((uint)uVar3 == uVar2) <=
            (int)((int)((ulonglong)uVar3 >> 0x20) -
                  ((int)((ulonglong) * (undefined8 *)(&DAT_001526d8 +
                                                      local_109c * 0x10) >>
                         0x20) +
                   (uint)((uint)uVar3 < uVar2)))) {
            snprintf(acStack_1098, 0x80, "J%d:1", local_109c);
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, "Sweep error string = %s",
                       acStack_1098);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/miner_6060info.c",
                 0xb3, "set_miner_6060info_runtime_bad_asic_err", 0x27, 0x88,
                 100, auStack_1018);
        }
    }
    local_18.tv_sec = 0;
    local_18.tv_usec = 0;
    if ((&DAT_00152520)[(local_109c + 0x1b) * 0x10] == '\0') {
        (&DAT_00152524)[(local_109c + 0x1b) * 4] = 0;
    } else {
        gettimeofday(&local_18, (__timezone_ptr_t)0x0);
        (&DAT_00152524)[(local_109c + 0x1b) * 4] = local_18.tv_sec;
    }
    pthread_mutex_unlock((pthread_mutex_t *)miner_6060info_lock);
    return;
}

/* WARNING: Globals starting with '_' overlap smaller symbols at the same
 * address */

void set_miner_6060info_network_lost_err(char param_1)

{
    double dVar1;
    undefined8 uVar2;
    undefined4 local_1098[32];
    undefined1 auStack_1018[4096];
    timeval local_18;
    timeval local_10;

    pthread_mutex_lock((pthread_mutex_t *)miner_6060info_lock);
    DAT_001528d0 = param_1;
    FUN_000654c4();
    local_10.tv_sec = 0;
    local_10.tv_usec = 0;
    gettimeofday(&local_10, (__timezone_ptr_t)0x0);
    if (DAT_001528d0 != '\0') {
        dVar1 = difftime(local_10.tv_sec, DAT_001528d4);
        uVar2 = FUN_000cce38(SUB84(dVar1, 0), (int)((ulonglong)dVar1 >> 0x20));
        if ((int)(uint)((uint)uVar2 == (uint)_DAT_001528d8) <=
            (int)((int)((ulonglong)uVar2 >> 0x20) -
                  ((int)((ulonglong)_DAT_001528d8 >> 0x20) +
                   (uint)((uint)uVar2 < (uint)_DAT_001528d8)))) {
            local_1098[0] = 0x343a4e;
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, "Sweep error string = %s",
                       local_1098);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/miner_6060info.c",
                 0xb3, "set_miner_6060info_network_lost_err", 0x23, 0x90, 100,
                 auStack_1018);
        }
    }
    local_18.tv_sec = 0;
    local_18.tv_usec = 0;
    if (DAT_001528d0 != '\0') {
        gettimeofday(&local_18, (__timezone_ptr_t)0x0);
    }
    DAT_001528d4 = local_18.tv_sec;
    pthread_mutex_unlock((pthread_mutex_t *)miner_6060info_lock);
    return;
}

void set_miner_6060info_asic_num_less_than_design_err(int param_1,
                                                      undefined1 param_2)

{
    double dVar1;
    uint uVar2;
    undefined8 uVar3;
    int local_109c;
    char acStack_1098[128];
    undefined1 auStack_1018[4096];
    timeval local_18;
    timeval local_10;

    local_109c = param_1;
    if (0xf < param_1) {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0,
                   "check_chain_index_valid failed, chain_index >= "
                   "PLATFORM_MAX_CHAIN_NUM");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/miner_monitor/"
             "miner_6060info.c",
             0xb3, "set_miner_6060info_asic_num_less_than_design_err", 0x30,
             0x96, 0x28, auStack_1018);
        local_109c = 0;
    }
    pthread_mutex_lock((pthread_mutex_t *)miner_6060info_lock);
    (&DAT_00152520)[(local_109c + 0x2b) * 0x10] = param_2;
    FUN_000654c4();
    local_10.tv_sec = 0;
    local_10.tv_usec = 0;
    gettimeofday(&local_10, (__timezone_ptr_t)0x0);
    if ((&DAT_00152520)[(local_109c + 0x2b) * 0x10] != '\0') {
        dVar1 =
            difftime(local_10.tv_sec, (&DAT_00152524)[(local_109c + 0x2b) * 4]);
        uVar3 = FUN_000cce38(SUB84(dVar1, 0), (int)((ulonglong)dVar1 >> 0x20));
        uVar2 = (uint) * (undefined8 *)(&DAT_001527d8 + local_109c * 0x10);
        if ((int)(uint)((uint)uVar3 == uVar2) <=
            (int)((int)((ulonglong)uVar3 >> 0x20) -
                  ((int)((ulonglong) * (undefined8 *)(&DAT_001527d8 +
                                                      local_109c * 0x10) >>
                         0x20) +
                   (uint)((uint)uVar3 < uVar2)))) {
            snprintf(acStack_1098, 0x80, "J%d:2", local_109c);
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, "Sweep error string = %s",
                       acStack_1098);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/miner_6060info.c",
                 0xb3, "set_miner_6060info_asic_num_less_than_design_err", 0x30,
                 0x99, 100, auStack_1018);
        }
    }
    local_18.tv_sec = 0;
    local_18.tv_usec = 0;
    if ((&DAT_00152520)[(local_109c + 0x2b) * 0x10] == '\0') {
        (&DAT_00152524)[(local_109c + 0x2b) * 4] = 0;
    } else {
        gettimeofday(&local_18, (__timezone_ptr_t)0x0);
        (&DAT_00152524)[(local_109c + 0x2b) * 4] = local_18.tv_sec;
    }
    pthread_mutex_unlock((pthread_mutex_t *)miner_6060info_lock);
    return;
}

void set_miner_6060info_malloc_failed_err(char param_1)

{
    double dVar1;
    undefined8 uVar2;
    undefined4 local_1098[32];
    undefined1 auStack_1018[4096];
    timeval local_18;
    timeval local_10;

    pthread_mutex_lock((pthread_mutex_t *)miner_6060info_lock);
    DAT_001528e0 = param_1;
    FUN_000654c4();
    local_10.tv_sec = 0;
    local_10.tv_usec = 0;
    gettimeofday(&local_10, (__timezone_ptr_t)0x0);
    if (DAT_001528e0 != '\0') {
        dVar1 = difftime(local_10.tv_sec, DAT_001528e4);
        uVar2 = FUN_000cce38(SUB84(dVar1, 0), (int)((ulonglong)dVar1 >> 0x20));
        if ((int)(uint)((uint)uVar2 == (uint)DAT_001528e8) <=
            (int)((int)((ulonglong)uVar2 >> 0x20) -
                  ((int)((ulonglong)DAT_001528e8 >> 0x20) +
                   (uint)((uint)uVar2 < (uint)DAT_001528e8)))) {
            local_1098[0] = 0x313a4d;
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, "Sweep error string = %s",
                       local_1098);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/miner_6060info.c",
                 0xb3, "set_miner_6060info_malloc_failed_err", 0x24, 0xa1, 100,
                 auStack_1018);
        }
    }
    local_18.tv_sec = 0;
    local_18.tv_usec = 0;
    if (DAT_001528e0 != '\0') {
        gettimeofday(&local_18, (__timezone_ptr_t)0x0);
    }
    DAT_001528e4 = local_18.tv_sec;
    pthread_mutex_unlock((pthread_mutex_t *)miner_6060info_lock);
    return;
}

void set_miner_6060info_board_num_less_than_design_err(char param_1)

{
    double dVar1;
    undefined8 uVar2;
    undefined4 local_1098[32];
    undefined1 auStack_1018[4096];
    timeval local_18;
    timeval local_10;

    pthread_mutex_lock((pthread_mutex_t *)miner_6060info_lock);
    DAT_001528f0 = param_1;
    FUN_000654c4();
    local_10.tv_sec = 0;
    local_10.tv_usec = 0;
    gettimeofday(&local_10, (__timezone_ptr_t)0x0);
    if (DAT_001528f0 != '\0') {
        dVar1 = difftime(local_10.tv_sec, DAT_001528f4);
        uVar2 = FUN_000cce38(SUB84(dVar1, 0), (int)((ulonglong)dVar1 >> 0x20));
        if ((int)(uint)((uint)uVar2 == (uint)DAT_001528f8) <=
            (int)((int)((ulonglong)uVar2 >> 0x20) -
                  ((int)((ulonglong)DAT_001528f8 >> 0x20) +
                   (uint)((uint)uVar2 < (uint)DAT_001528f8)))) {
            local_1098[0] = 0x383a4a;
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, "Sweep error string = %s",
                       local_1098);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/miner_6060info.c",
                 0xb3, "set_miner_6060info_board_num_less_than_design_err",
                 0x31, 0xa9, 100, auStack_1018);
        }
    }
    local_18.tv_sec = 0;
    local_18.tv_usec = 0;
    if (DAT_001528f0 != '\0') {
        gettimeofday(&local_18, (__timezone_ptr_t)0x0);
    }
    DAT_001528f4 = local_18.tv_sec;
    pthread_mutex_unlock((pthread_mutex_t *)miner_6060info_lock);
    return;
}

void reset_miner_6060info_status(void)

{
    pthread_mutex_lock((pthread_mutex_t *)miner_6060info_lock);
    memset(&DAT_00152520, 0, 0x3e0);
    pthread_mutex_unlock((pthread_mutex_t *)miner_6060info_lock);
    return;
}

undefined4 miner_6060info_errorcode_init(void)

{
    int iVar1;
    undefined4 uVar2;
    undefined1 auStack_1104[4096];
    undefined1 auStack_104[252];

    pthread_mutex_lock((pthread_mutex_t *)&DAT_00152504);
    if (DAT_0015251c == '\0') {
        iVar1 = access(PTR_s__etc_errorcode_json_0014f610, 0);
        if (iVar1 == 0) {
            DAT_00152500 = (int *)json_load_file(
                PTR_s__etc_errorcode_json_0014f610, 0, auStack_104);
            if ((DAT_00152500 == (int *)0x0) || (*DAT_00152500 != 0)) {
                V_LOCK();
                logfmt_raw(auStack_1104, 0x1000, 0, "%s, %d bad json format",
                           "/workspace/jenkins/jenkins/workspace/"
                           "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                           "tmp/release/build/godminer-origin_godminer-branch1/"
                           "miner_util/miner_monitor/miner_6060info.c",
                           0xc6);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/miner_monitor/miner_6060info.c",
                     0xb3, "miner_6060info_errorcode_init", 0x1d, 0xc6, 100,
                     auStack_1104);
                pthread_mutex_unlock((pthread_mutex_t *)&DAT_00152504);
                uVar2 = 0;
            } else {
                DAT_0015251c = '\x01';
                pthread_mutex_unlock((pthread_mutex_t *)&DAT_00152504);
                uVar2 = 1;
            }
        } else {
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_00152504);
            uVar2 = 0;
        }
    } else {
        pthread_mutex_unlock((pthread_mutex_t *)&DAT_00152504);
        uVar2 = 0;
    }
    return uVar2;
}

void miner_6060info_errorcode_uninit(void)

{
    pthread_mutex_lock((pthread_mutex_t *)&DAT_00152504);
    if (DAT_0015251c != '\x01') {
        pthread_mutex_unlock((pthread_mutex_t *)&DAT_00152504);
        return;
    }
    DAT_0015251c = 0;
    usleep(1000);
    FUN_0006545c(DAT_00152500);
    pthread_mutex_unlock((pthread_mutex_t *)&DAT_00152504);
    return;
}

undefined4 get_errstr_from_json_by_errorcode(char *param_1, char *param_2,
                                             size_t param_3)

{
    char cVar1;
    int iVar2;
    uint uVar3;
    undefined4 uVar4;
    undefined1 auStack_1030[4096];
    undefined4 local_30;
    undefined4 local_2c;
    undefined4 local_28;
    undefined4 local_24;
    char *local_20;
    undefined4 local_1c;
    char local_15;
    uint local_14;
    int *local_10;
    int *local_c;

    local_c = (int *)0x0;
    local_10 = (int *)0x0;
    if ((DAT_0015251c == '\x01') ||
        (cVar1 = miner_6060info_errorcode_init(), cVar1 == '\x01')) {
        local_c = (int *)json_object_get(DAT_00152500, "errorcode");
        if ((local_c == (int *)0x0) || (*local_c != 1)) {
            V_LOCK();
            logfmt_raw(auStack_1030, 0x1000, 0, "%s, %d bad errorcode format",
                       "/workspace/jenkins/jenkins/workspace/"
                       "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                       "release/build/godminer-origin_godminer-branch1/"
                       "miner_util/miner_monitor/miner_6060info.c",
                       0xea);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/miner_6060info.c",
                 0xb3, "get_errstr_from_json_by_errorcode", 0x21, 0xea, 100,
                 auStack_1030);
        }
        local_15 = '\0';
        local_14 = 0;
        while (uVar3 = json_array_size(local_c), local_14 < uVar3) {
            local_10 = (int *)json_array_get(local_c, local_14);
            if ((local_10 == (int *)0x0) || (*local_10 != 0)) {
                V_LOCK();
                logfmt_raw(auStack_1030, 0x1000, 0,
                           "%s, %d bad object in errorcode",
                           "/workspace/jenkins/jenkins/workspace/"
                           "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                           "tmp/release/build/godminer-origin_godminer-branch1/"
                           "miner_util/miner_monitor/miner_6060info.c",
                           0xf3);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/miner_monitor/miner_6060info.c",
                     0xb3, "get_errstr_from_json_by_errorcode", 0x21, 0xf3, 100,
                     auStack_1030);
                return 0;
            }
            local_1c = json_object_get(local_10, &DAT_00118d74);
            local_20 = (char *)json_string_value(local_1c);
            iVar2 = strcmp(param_1, local_20);
            if (iVar2 == 0) {
                local_24 = json_object_get(local_10, "reason");
                local_28 = json_string_value(local_24);
                local_2c = json_object_get(local_10, "suggestion");
                local_30 = json_string_value(local_2c);
                snprintf(param_2, param_3, "%s; %s; %s", local_20, local_28,
                         local_30);
                local_15 = '\x01';
                break;
            }
            local_14 = local_14 + 1;
        }
        if (local_15 == '\x01') {
            uVar4 = 1;
        } else {
            V_LOCK();
            logfmt_raw(auStack_1030, 0x1000, 0,
                       "error code %s does not exist in the file", param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/miner_6060info.c",
                 0xb3, "get_errstr_from_json_by_errorcode", 0x21, 0x106, 100,
                 auStack_1030);
            uVar4 = 0;
        }
    } else {
        uVar4 = 0;
    }
    return uVar4;
}

undefined4
get_reason_suggestion_from_json_by_errorcode(char *param_1, char *param_2,
                                             char *param_3, size_t param_4)

{
    char cVar1;
    int iVar2;
    uint uVar3;
    undefined4 uVar4;
    undefined1 auStack_1030[4096];
    char *local_30;
    undefined4 local_2c;
    char *local_28;
    undefined4 local_24;
    char *local_20;
    undefined4 local_1c;
    char local_15;
    uint local_14;
    int *local_10;
    int *local_c;

    local_c = (int *)0x0;
    local_10 = (int *)0x0;
    if ((DAT_0015251c == '\x01') ||
        (cVar1 = miner_6060info_errorcode_init(), cVar1 == '\x01')) {
        local_c = (int *)json_object_get(DAT_00152500, "errorcode");
        if ((local_c == (int *)0x0) || (*local_c != 1)) {
            V_LOCK();
            logfmt_raw(auStack_1030, 0x1000, 0, "%s, %d bad errorcode format",
                       "/workspace/jenkins/jenkins/workspace/"
                       "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                       "release/build/godminer-origin_godminer-branch1/"
                       "miner_util/miner_monitor/miner_6060info.c",
                       0x119);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/miner_6060info.c",
                 0xb3, "get_reason_suggestion_from_json_by_errorcode", 0x2c,
                 0x119, 100, auStack_1030);
        }
        local_15 = '\0';
        local_14 = 0;
        while (uVar3 = json_array_size(local_c), local_14 < uVar3) {
            local_10 = (int *)json_array_get(local_c, local_14);
            if ((local_10 == (int *)0x0) || (*local_10 != 0)) {
                V_LOCK();
                logfmt_raw(auStack_1030, 0x1000, 0,
                           "%s, %d bad object in errorcode",
                           "/workspace/jenkins/jenkins/workspace/"
                           "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                           "tmp/release/build/godminer-origin_godminer-branch1/"
                           "miner_util/miner_monitor/miner_6060info.c",
                           0x122);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/"
                     "miner_util/miner_monitor/miner_6060info.c",
                     0xb3, "get_reason_suggestion_from_json_by_errorcode", 0x2c,
                     0x122, 100, auStack_1030);
                return 0;
            }
            local_1c = json_object_get(local_10, &DAT_00118d74);
            local_20 = (char *)json_string_value(local_1c);
            iVar2 = strcmp(param_1, local_20);
            if (iVar2 == 0) {
                local_24 = json_object_get(local_10, "reason");
                local_28 = (char *)json_string_value(local_24);
                snprintf(param_2, param_4, local_28);
                local_2c = json_object_get(local_10, "suggestion");
                local_30 = (char *)json_string_value(local_2c);
                snprintf(param_3, param_4, local_30);
                local_15 = '\x01';
                break;
            }
            local_14 = local_14 + 1;
        }
        if (local_15 == '\x01') {
            uVar4 = 1;
        } else {
            V_LOCK();
            logfmt_raw(auStack_1030, 0x1000, 0,
                       "error code %s does not exist in the file", param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/miner_6060info.c",
                 0xb3, "get_reason_suggestion_from_json_by_errorcode", 0x2c,
                 0x137, 100, auStack_1030);
            uVar4 = 0;
        }
    } else {
        uVar4 = 0;
    }
    return uVar4;
}

void set_json_info_by_errorcode_and_time(undefined4 param_1, undefined4 param_2,
                                         time_t param_3)

{
    char cVar1;
    int iVar2;
    undefined4 uVar3;
    time_t local_34c;
    undefined4 local_348;
    undefined4 local_344;
    tm local_340;
    char acStack_314[256];
    undefined1 auStack_214[256];
    undefined1 auStack_114[256];
    undefined4 local_14;

    local_14 = 0;
    local_34c = param_3;
    local_348 = param_2;
    local_344 = param_1;
    if (((DAT_0015251c == '\x01') ||
         (cVar1 = miner_6060info_errorcode_init(), cVar1 == '\x01')) &&
        (iVar2 = get_reason_suggestion_from_json_by_errorcode(
             local_348, auStack_114, auStack_214, 0x100),
         iVar2 != 0)) {
        local_14 = json_object();
        uVar3 = json_string(local_348);
        json_object_set_new(local_14, &DAT_00118d74, uVar3);
        uVar3 = json_string(auStack_114);
        json_object_set_new(local_14, "cause", uVar3);
        uVar3 = json_string(auStack_214);
        json_object_set_new(local_14, "suggestion", uVar3);
        localtime_r(&local_34c, &local_340);
        snprintf(acStack_314, 0x100, "%d%02d%02d%02d%02d%02d",
                 local_340.tm_year + 0x76c, local_340.tm_mon + 1,
                 local_340.tm_mday, local_340.tm_hour, local_340.tm_min,
                 local_340.tm_sec);
        uVar3 = json_string(acStack_314);
        json_object_set_new(local_14, "timestamp", uVar3);
        json_array_append_new(local_344, local_14);
    }
    return;
}

void sweep_get_error_code(undefined4 param_1)

{
    char local_1ec[128];
    timeval local_16c;
    timeval local_164;
    timeval local_15c;
    timeval local_154;
    timeval local_14c;
    timeval local_144;
    timeval local_13c;
    timeval local_134;
    timeval local_12c;
    timeval local_124[33];
    undefined4 local_1c;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    local_1c = 0;
    FUN_000654c4();
    miner_6060info_errorcode_init();
    pthread_mutex_lock((pthread_mutex_t *)miner_6060info_lock);
    local_124[0].tv_sec = 0;
    local_124[0].tv_usec = 0;
    gettimeofday(local_124, (__timezone_ptr_t)0x0);
    if (DAT_00152520 != '\0') {
        builtin_strncpy(local_1ec, "P:1", 4);
        set_json_info_by_errorcode_and_time(param_1, local_1ec, DAT_00152524);
    }
    local_12c.tv_sec = 0;
    local_12c.tv_usec = 0;
    gettimeofday(&local_12c, (__timezone_ptr_t)0x0);
    if (DAT_00152530 != '\0') {
        builtin_strncpy(local_1ec, "P:2", 4);
        set_json_info_by_errorcode_and_time(param_1, local_1ec, DAT_00152534);
    }
    local_134.tv_sec = 0;
    local_134.tv_usec = 0;
    gettimeofday(&local_134, (__timezone_ptr_t)0x0);
    if (DAT_00152540 != '\0') {
        builtin_strncpy(local_1ec, "J:6", 4);
        set_json_info_by_errorcode_and_time(param_1, local_1ec, DAT_00152544);
    }
    for (local_c = 0; local_c < 8; local_c = local_c + 1) {
        local_13c.tv_sec = 0;
        local_13c.tv_usec = 0;
        gettimeofday(&local_13c, (__timezone_ptr_t)0x0);
        if ((&DAT_00152520)[(local_c + 3) * 0x10] != '\0') {
            snprintf(local_1ec, 0x80, "F%d:1", local_c);
            set_json_info_by_errorcode_and_time(
                param_1, local_1ec, (&DAT_00152524)[(local_c + 3) * 4]);
        }
    }
    for (local_10 = 0; local_10 < 0x10; local_10 = local_10 + 1) {
        local_144.tv_sec = 0;
        local_144.tv_usec = 0;
        gettimeofday(&local_144, (__timezone_ptr_t)0x0);
        if ((&DAT_00152520)[(local_10 + 0xb) * 0x10] != '\0') {
            snprintf(local_1ec, 0x80, "R%d:1", local_10);
            set_json_info_by_errorcode_and_time(
                param_1, local_1ec, (&DAT_00152524)[(local_10 + 0xb) * 4]);
        }
    }
    for (local_14 = 0; local_14 < 0x10; local_14 = local_14 + 1) {
        local_14c.tv_sec = 0;
        local_14c.tv_usec = 0;
        gettimeofday(&local_14c, (__timezone_ptr_t)0x0);
        if ((&DAT_00152520)[(local_14 + 0x1b) * 0x10] != '\0') {
            snprintf(local_1ec, 0x80, "J%d:1", local_14);
            set_json_info_by_errorcode_and_time(
                param_1, local_1ec, (&DAT_00152524)[(local_14 + 0x1b) * 4]);
        }
    }
    for (local_18 = 0; local_18 < 0x10; local_18 = local_18 + 1) {
        local_154.tv_sec = 0;
        local_154.tv_usec = 0;
        gettimeofday(&local_154, (__timezone_ptr_t)0x0);
        if ((&DAT_00152520)[(local_18 + 0x2b) * 0x10] != '\0') {
            snprintf(local_1ec, 0x80, "J%d:2", local_18);
            set_json_info_by_errorcode_and_time(
                param_1, local_1ec, (&DAT_00152524)[(local_18 + 0x2b) * 4]);
        }
    }
    local_15c.tv_sec = 0;
    local_15c.tv_usec = 0;
    gettimeofday(&local_15c, (__timezone_ptr_t)0x0);
    if (DAT_001528d0 != '\0') {
        builtin_strncpy(local_1ec, "N:4", 4);
        set_json_info_by_errorcode_and_time(param_1, local_1ec, DAT_001528d4);
    }
    local_164.tv_sec = 0;
    local_164.tv_usec = 0;
    gettimeofday(&local_164, (__timezone_ptr_t)0x0);
    if (DAT_001528e0 != '\0') {
        builtin_strncpy(local_1ec, "M:1", 4);
        set_json_info_by_errorcode_and_time(param_1, local_1ec, DAT_001528e4);
    }
    local_16c.tv_sec = 0;
    local_16c.tv_usec = 0;
    gettimeofday(&local_16c, (__timezone_ptr_t)0x0);
    if (DAT_001528f0 != '\0') {
        builtin_strncpy(local_1ec, "J:8", 4);
        set_json_info_by_errorcode_and_time(param_1, local_1ec, DAT_001528f4);
    }
    pthread_mutex_unlock((pthread_mutex_t *)miner_6060info_lock);
    return;
}

void FUN_00067e90(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_0006801c(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

void FUN_000681ac(void)

{
    int local_28;
    uint *local_24;
    uint *local_20;
    uint *local_1c;
    int local_18;
    int local_14;

    local_28 = 0;
    local_18 = get_all_created_runtime(&local_28);
    for (local_14 = 0; local_14 < local_28; local_14 = local_14 + 1) {
        local_20 = (uint *)update_temperature(
            *(undefined4 *)(local_18 + local_14 * 4),
            &DAT_00152900 +
                *(int *)(*(int *)(local_18 + local_14 * 4) + 0xf8) * 0xe0,
            *(int *)(*(int *)(local_18 + local_14 * 4) + 0xf8) * 0x50 +
                0x153700);
        local_1c = local_20;
        if (*local_20 != 0 || local_20[1] != 0) {
            subject_notify_all(DAT_00153c08,
                               *(undefined4 *)(local_18 + local_14 * 4));
            local_24 = local_1c;
            *local_1c = ~local_1c[2] & *local_1c;
            local_1c[1] = ~local_1c[3] & local_1c[1];
            local_1c[2] = 0;
            local_1c[3] = 0;
        }
    }
    return;
}

void FUN_00068310(void)

{
    int local_28;
    uint *local_24;
    uint *local_20;
    uint *local_1c;
    int local_18;
    int local_14;

    local_28 = 0;
    local_18 = get_all_created_runtime(&local_28);
    for (local_14 = 0; local_14 < local_28; local_14 = local_14 + 1) {
        local_20 = (uint *)update_hashrate(
            *(undefined4 *)(local_18 + local_14 * 4),
            &DAT_00152900 +
                *(int *)(*(int *)(local_18 + local_14 * 4) + 0xf8) * 0xe0,
            *(int *)(*(int *)(local_18 + local_14 * 4) + 0xf8) * 0x50 +
                0x153700);
        local_1c = local_20;
        if (*local_20 != 0 || local_20[1] != 0) {
            subject_notify_all(DAT_00153c0c,
                               *(undefined4 *)(local_18 + local_14 * 4));
            local_24 = local_1c;
            *local_1c = ~local_1c[2] & *local_1c;
            local_1c[1] = ~local_1c[3] & local_1c[1];
            local_1c[2] = 0;
            local_1c[3] = 0;
        }
    }
    return;
}

void FUN_00068474(void)

{
    int local_28;
    uint *local_24;
    uint *local_20;
    uint *local_1c;
    int local_18;
    int local_14;

    local_28 = 0;
    local_18 = get_all_created_runtime(&local_28);
    for (local_14 = 0; local_14 < local_28; local_14 = local_14 + 1) {
        local_20 = (uint *)update_chip_status(
            *(undefined4 *)(local_18 + local_14 * 4),
            &DAT_00152900 +
                *(int *)(*(int *)(local_18 + local_14 * 4) + 0xf8) * 0xe0,
            *(int *)(*(int *)(local_18 + local_14 * 4) + 0xf8) * 0x50 +
                0x153700);
        local_1c = local_20;
        if (*local_20 != 0 || local_20[1] != 0) {
            subject_notify_all(DAT_00153c10,
                               *(undefined4 *)(local_18 + local_14 * 4));
            local_24 = local_1c;
            *local_1c = ~local_1c[2] & *local_1c;
            local_1c[1] = ~local_1c[3] & local_1c[1];
            local_1c[2] = 0;
            local_1c[3] = 0;
        }
    }
    return;
}

void FUN_000685d8(void)

{
    int local_28;
    uint *local_24;
    uint *local_20;
    uint *local_1c;
    int local_18;
    int local_14;

    local_28 = 0;
    local_18 = get_all_created_runtime(&local_28);
    for (local_14 = 0; local_14 < local_28; local_14 = local_14 + 1) {
        local_20 = (uint *)update_fanspeed(
            *(undefined4 *)(local_18 + local_14 * 4),
            &DAT_00152900 +
                *(int *)(*(int *)(local_18 + local_14 * 4) + 0xf8) * 0xe0,
            *(int *)(*(int *)(local_18 + local_14 * 4) + 0xf8) * 0x50 +
                0x153700);
        local_1c = local_20;
        if (*local_20 != 0 || local_20[1] != 0) {
            subject_notify_all(DAT_00153c14,
                               *(undefined4 *)(local_18 + local_14 * 4));
            local_24 = local_1c;
            *local_1c = ~local_1c[2] & *local_1c;
            local_1c[1] = ~local_1c[3] & local_1c[1];
            local_1c[2] = 0;
            local_1c[3] = 0;
        }
    }
    return;
}

void FUN_0006873c(void)

{
    int iVar1;
    undefined4 uVar2;
    undefined4 uVar3;
    undefined4 uVar4;
    undefined4 uVar5;
    undefined4 uVar6;
    undefined4 *puVar7;
    undefined4 uVar8;
    undefined1 auStack_2198[4096];
    undefined1 auStack_1198[32];
    undefined1 auStack_1178[32];
    char acStack_1158[4096];
    undefined1 auStack_158[20];
    float fStack_144;
    float fStack_140;
    undefined4 local_128;
    undefined4 uStack_124;
    undefined1 auStack_120[44];
    float fStack_f4;
    float fStack_f0;
    undefined4 local_d8;
    undefined4 local_d4;
    undefined4 local_c8;
    undefined4 uStack_c4;
    int local_3c;
    int local_38;
    int local_34;
    int local_30;
    int local_2c;
    uint local_28;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;

    local_3c = 0;
    local_2c = frontend_runtime_instance();
    local_30 = get_all_created_runtime(&local_3c);
    local_14 = 0;
    read_system_status_from_monitor(auStack_158);
    format_hashrate_string(SUB84((double)fStack_140, 0),
                           *(undefined4 *)(*(int *)(local_2c + 0x48) + 0x10),
                           auStack_1178);
    format_hashrate_string(SUB84((double)fStack_144, 0),
                           *(undefined4 *)(*(int *)(local_2c + 0x48) + 0x10),
                           auStack_1198);
    V_LOCK();
    logfmt_raw(auStack_2198, 0x1000, 0,
               "total avg hashrate %s 2min avg hashrate %s hw %llu",
               auStack_1178, auStack_1198, local_128, uStack_124);
    V_UNLOCK();
    zlog(
        g_hash_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "miner_util/miner_monitor/miner_monitor.c",
        0xb2, "task_applog_printer", 0x13, 0x7d, 0x28, auStack_2198);
    for (local_18 = 0; local_18 < local_3c; local_18 = local_18 + 1) {
        read_status_from_monitor(auStack_120,
                                 *(undefined4 *)(local_30 + local_18 * 4));
        format_hashrate_string(
            SUB84((double)fStack_f0, 0),
            *(undefined4 *)(*(int *)(local_2c + 0x48) + 0x10), auStack_1178);
        format_hashrate_string(
            SUB84((double)fStack_f4, 0),
            *(undefined4 *)(*(int *)(local_2c + 0x48) + 0x10), auStack_1198);
        iVar1 = dev_ctrl();
        uVar2 = (**(code **)(iVar1 + 0x30))(
            *(undefined4 *)(*(int *)(local_30 + local_18 * 4) + 0xf8));
        uVar8 = uStack_c4;
        local_14 = snprintf(
            acStack_1158, 0x1000,
            "chain %d device %d alive chip count %d avg hashrate %s 30min avg "
            "hashrate %s hw %llu\n",
            uVar2, *(undefined4 *)(*(int *)(local_30 + local_18 * 4) + 0xf8),
            local_d8, auStack_1178, auStack_1198, local_c8, uStack_c4);
        iVar1 = *(int *)(local_30 + local_18 * 4);
        uVar5 = *(undefined4 *)(iVar1 + 0x1b8);
        uVar6 = *(undefined4 *)(iVar1 + 0x1bc);
        iVar1 = *(int *)(local_30 + local_18 * 4);
        uVar3 = *(undefined4 *)(iVar1 + 0x1c0);
        uVar4 = *(undefined4 *)(iVar1 + 0x1c4);
        uVar2 = local_d4;
        iVar1 = snprintf(acStack_1158 + local_14, 0x1000 - local_14,
                         "wc %llu nc %llu chip status str %s detail:\n", uVar6,
                         uVar5, uVar6, uVar3, uVar4, local_d4);
        local_14 = local_14 + iVar1;
        local_34 = *(int *)(*(int *)(local_30 + local_18 * 4) + 0x150);
        for (local_1c = 0; local_1c < local_34; local_1c = local_1c + 1) {
            local_38 = *(int *)(*(int *)(local_30 + local_18 * 4) + 0x1c8) +
                       local_1c * 0x30;
            iVar1 = snprintf(acStack_1158 + local_14, 0x1000 - local_14,
                             "%d:", local_1c + 1, uVar5, uVar6, uVar3, uVar4,
                             uVar2, uVar8);
            local_14 = local_14 + iVar1;
            for (local_20 = 0; local_20 < 6; local_20 = local_20 + 1) {
                puVar7 = (undefined4 *)(local_38 + local_20 * 8);
                uVar5 = *puVar7;
                uVar6 = puVar7[1];
                iVar1 =
                    snprintf(acStack_1158 + local_14, 0x1000 - local_14,
                             " %llu", uVar6, uVar5, uVar6, uVar3, uVar4, uVar2);
                local_14 = local_14 + iVar1;
            }
            iVar1 =
                snprintf(acStack_1158 + local_14, 0x1000U - local_14, " /",
                         0x1000U - local_14, uVar5, uVar6, uVar3, uVar4, uVar2);
            local_14 = local_14 + iVar1;
        }
        if (opt_algo == 0xd) {
            local_24 = 0;
            while (true) {
                if (local_34 <= local_24)
                    break;
                iVar1 = snprintf(acStack_1158 + local_14, 0x2000 - local_14,
                                 "\n------%d------", local_24 + 1, uVar5, uVar6,
                                 uVar3, uVar4, uVar2, uVar8);
                local_14 = local_14 + iVar1;
                for (local_28 = 0;
                     (int)local_28 <
                     *(int *)(*(int *)(local_30 + local_18 * 4) + 0x158);
                     local_28 = local_28 + 1) {
                    if ((local_28 & 7) == 0) {
                        iVar1 = snprintf(acStack_1158 + local_14,
                                         0x2000U - local_14, "\n",
                                         0x2000U - local_14, uVar5);
                        local_14 = local_14 + iVar1;
                    }
                    uVar5 =
                        *(undefined4 *)(*(int *)(*(int *)(local_30 +
                                                          local_18 * 4) +
                                                 0x1e4) +
                                        (local_24 *
                                             *(int *)(*(int *)(local_30 +
                                                               local_18 * 4) +
                                                      0x158) +
                                         local_28) *
                                            4);
                    iVar1 = snprintf(acStack_1158 + local_14, 0x2000 - local_14,
                                     " %d:%d ", local_28, uVar5);
                    local_14 = local_14 + iVar1;
                }
                local_24 = local_24 + 1;
            }
        }
        V_LOCK();
        logfmt_raw(auStack_2198, 0x1000, 0, &DAT_00119380, acStack_1158);
        V_UNLOCK();
        zlog(g_hash_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/miner_monitor/"
             "miner_monitor.c",
             0xb2, "task_applog_printer", 0x13, 0x9f, 0x28, auStack_2198);
    }
    return;
}

void FUN_00068df8(void)

{
    int iVar1;
    undefined1 auStack_108[44];
    float fStack_dc;
    double dStack_d0;
    undefined1 auStack_28[8];
    char local_20;
    int local_14;
    int local_10;
    int local_c;

    local_14 = 0;
    local_10 = get_all_created_runtime(&local_14);
    get_miner_working_status(auStack_28);
    if (local_20 != '\x01') {
        for (local_c = 0; local_c < local_14; local_c = local_c + 1) {
            read_status_from_monitor(auStack_108,
                                     *(undefined4 *)(local_10 + local_c * 4));
            if (((double)fStack_dc < dStack_d0 * 0.8) &&
                (iVar1 = strcmp(
                     (char *)(*(int *)(local_10 + local_c * 4) + 0x140), "ltc"),
                 iVar1 == 0)) {
                (**(code **)(*(int *)(local_10 + local_c * 4) + 0x18))(
                    *(undefined4 *)(local_10 + local_c * 4));
            }
        }
    }
    return;
}

void miner_monitor_init(void)

{
    undefined4 *puVar1;
    int iVar2;
    void *pvVar3;
    int local_10;
    int local_c;

    puVar1 = (undefined4 *)dev_ctrl();
    iVar2 = (*(code *)*puVar1)();
    local_c = 0;
    while (true) {
        if (iVar2 <= local_c)
            break;
        pvVar3 = calloc(0x100, 1);
        *(void **)(&DAT_0015294c + local_c * 0xe0) = pvVar3;
        **(undefined1 **)(&DAT_0015294c + local_c * 0xe0) = 0x3f;
        pvVar3 = calloc(0x10, 4);
        *(void **)(&DAT_00152968 + local_c * 0xe0) = pvVar3;
        pvVar3 = calloc(0x10, 4);
        *(void **)(&DAT_0015296c + local_c * 0xe0) = pvVar3;
        pvVar3 = calloc(0x10, 4);
        *(void **)(&DAT_00152908 + local_c * 0xe0) = pvVar3;
        pvVar3 = calloc(0x10, 4);
        *(void **)(&DAT_00152904 + local_c * 0xe0) = pvVar3;
        pvVar3 = calloc(0x10, 4);
        *(void **)(&DAT_00152900 + local_c * 0xe0) = pvVar3;
        pvVar3 = calloc(0x10, 4);
        *(void **)(&DAT_00152910 + local_c * 0xe0) = pvVar3;
        pvVar3 = calloc(0x10, 4);
        *(void **)(&DAT_0015290c + local_c * 0xe0) = pvVar3;
        *(undefined4 *)(&DAT_001529d0 + local_c * 0xe0) = 0;
        *(undefined8 *)(&DAT_001529d8 + local_c * 0xe0) = 0;
        for (local_10 = 0; local_10 < 0x10; local_10 = local_10 + 1) {
            *(undefined4 *)(*(int *)(&DAT_00152908 + local_c * 0xe0) +
                            local_10 * 4) = 0xffffffc0;
            *(undefined4 *)(*(int *)(&DAT_00152904 + local_c * 0xe0) +
                            local_10 * 4) = 0xffffffc0;
            *(undefined4 *)(*(int *)(&DAT_00152900 + local_c * 0xe0) +
                            local_10 * 4) = 0xffffffc0;
        }
        init_temp_senor_info(&DAT_00152900 + local_c * 0xe0);
        local_c = local_c + 1;
    }
    DAT_00153c08 = new_observable_subject();
    DAT_00153c0c = new_observable_subject();
    DAT_00153c10 = new_observable_subject();
    DAT_00153c14 = new_observable_subject();
    DAT_00153c04 = new_task_timer();
    add_new_task(DAT_00153c04, FUN_000681ac, 1000);
    add_new_task(DAT_00153c04, FUN_00068474, 120000);
    add_new_task(DAT_00153c04, FUN_0006873c, 60000);
    if (is_test_pool != '\x01') {
        add_new_task(DAT_00153c04, update_droa_log, 180000);
        add_new_task(DAT_00153c04, update_timestamp_file, 180000);
    }
    DAT_00153c00 = new_task_timer();
    add_new_task(DAT_00153c00, FUN_00068310, 5000);
    add_new_task(DAT_00153c00, FUN_000685d8, 1000);
    add_new_task(DAT_00153c00, task_check_miner_status, 1000);
    return;
}

void miner_monitor_deinit(void)

{
    undefined4 *puVar1;
    int iVar2;
    int local_c;

    destroy_task_timer(DAT_00153c00);
    destroy_task_timer(DAT_00153c04);
    destroy_observable_subject(DAT_00153c08);
    destroy_observable_subject(DAT_00153c0c);
    destroy_observable_subject(DAT_00153c10);
    destroy_observable_subject(DAT_00153c14);
    puVar1 = (undefined4 *)dev_ctrl();
    iVar2 = (*(code *)*puVar1)();
    for (local_c = 0; local_c < iVar2; local_c = local_c + 1) {
        free(*(void **)(&DAT_0015294c + local_c * 0xe0));
        free(*(void **)(&DAT_00152968 + local_c * 0xe0));
        free(*(void **)(&DAT_00152900 + local_c * 0xe0));
        free(*(void **)(&DAT_00152908 + local_c * 0xe0));
        free(*(void **)(&DAT_00152904 + local_c * 0xe0));
        free(*(void **)(&DAT_00152910 + local_c * 0xe0));
        free(*(void **)(&DAT_0015290c + local_c * 0xe0));
    }
    return;
}

undefined4 do_miner_monitor_start(void)

{
    undefined4 extraout_r3;
    int local_14;
    int local_10;
    int local_c;

    local_14 = 0;
    local_10 = get_all_created_runtime(&local_14);
    for (local_c = 0; local_c < local_14; local_c = local_c + 1) {
        while (*(char *)(*(int *)(local_10 + local_c * 4) + 0x102) != '\x01') {
            sleep(1);
        }
    }
    force_exec_all_task(DAT_00153c04);
    force_exec_all_task(DAT_00153c00);
    start_task_timer(DAT_00153c04);
    start_task_timer(DAT_00153c00);
    return extraout_r3;
}

void miner_monitor_start(void)

{
    pthread_t local_c;

    pthread_create(&local_c, (pthread_attr_t *)0x0, do_miner_monitor_start,
                   (void *)0x0);
    pthread_detach(local_c);
    return;
}

void miner_monitor_stop(void)

{
    stop_task_timer(DAT_00153c00);
    stop_task_timer(DAT_00153c04);
    return;
}

void *read_status_from_monitor(void *param_1, int param_2)

{
    memcpy(param_1, &DAT_00152900 + *(int *)(param_2 + 0xf8) * 0xe0, 0xe0);
    return param_1;
}

void add_temperature_observer(undefined4 param_1)

{
    subject_observe(DAT_00153c08, param_1);
    return;
}

void add_hashrate_observer(undefined4 param_1)

{
    subject_observe(DAT_00153c0c, param_1);
    return;
}

void add_chip_status_observer(undefined4 param_1)

{
    subject_observe(DAT_00153c10, param_1);
    return;
}

void add_fanspeed_observer(undefined4 param_1)

{
    subject_observe(DAT_00153c14, param_1);
    return;
}

int *read_system_status_from_monitor(int *param_1)

{
    int *piVar1;
    bool bVar2;
    uint uVar3;
    int local_4c[4];
    float fStack_3c;
    float local_38;
    float fStack_34;
    float local_30;
    int iStack_2c;
    undefined8 local_28;
    undefined8 local_20;
    uint local_18;
    int iStack_14;
    int local_c;

    local_4c[1] = 0;
    local_4c[2] = 0;
    local_4c[3] = 0;
    fStack_3c = 0.0;
    local_38 = 0.0;
    fStack_34 = 0.0;
    local_30 = 0.0;
    iStack_2c = 0;
    local_28 = 0.0;
    local_20 = 0.0;
    local_18 = 0;
    iStack_14 = 0;
    local_4c[0] = 0;
    piVar1 = (int *)get_all_created_runtime(local_4c);
    for (local_c = 0; local_c < local_4c[0]; local_c = local_c + 1) {
        fStack_3c =
            fStack_3c +
            *(float *)(&DAT_00152924 + *(int *)(piVar1[local_c] + 0xf8) * 0xe0);
        local_38 =
            local_38 +
            *(float *)(&DAT_00152928 + *(int *)(piVar1[local_c] + 0xf8) * 0xe0);
        fStack_34 =
            fStack_34 +
            *(float *)(&DAT_0015292c + *(int *)(piVar1[local_c] + 0xf8) * 0xe0);
        local_30 =
            local_30 +
            *(float *)(&DAT_00152930 + *(int *)(piVar1[local_c] + 0xf8) * 0xe0);
        uVar3 =
            (uint) * (undefined8 *)(&DAT_00152958 +
                                    *(int *)(piVar1[local_c] + 0xf8) * 0xe0);
        bVar2 = CARRY4(uVar3, local_18);
        local_18 = uVar3 + local_18;
        iStack_14 =
            (int)((ulonglong) *
                      (undefined8 *)(&DAT_00152958 +
                                     *(int *)(piVar1[local_c] + 0xf8) * 0xe0) >>
                  0x20) +
            iStack_14 + (uint)bVar2;
        local_28 =
            local_28 + *(double *)(&DAT_00152938 +
                                   *(int *)(piVar1[local_c] + 0xf8) * 0xe0);
        local_20 =
            local_20 + *(double *)(&DAT_00152940 +
                                   *(int *)(piVar1[local_c] + 0xf8) * 0xe0);
    }
    if (0 < local_4c[0]) {
        local_4c[2] = *(int *)(&DAT_00152964 + *(int *)(*piVar1 + 0xf8) * 0xe0);
        local_4c[3] = *(int *)(&DAT_00152968 + *(int *)(*piVar1 + 0xf8) * 0xe0);
    }
    *param_1 = local_4c[0];
    param_1[1] = local_4c[2];
    param_1[2] = local_4c[3];
    param_1[3] = (int)fStack_3c;
    param_1[4] = (int)local_38;
    param_1[5] = (int)fStack_34;
    param_1[6] = (int)local_30;
    param_1[7] = iStack_2c;
    param_1[8] = (int)local_28;
    param_1[9] = local_28._4_4_;
    param_1[10] = (int)local_20;
    param_1[0xb] = local_20._4_4_;
    param_1[0xc] = local_18;
    param_1[0xd] = iStack_14;
    return param_1;
}

int get_flag_from_monitor(int param_1)

{
    return *(int *)(param_1 + 0xf8) * 0x50 + 0x153700;
}

undefined4 FUN_00069b80(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "chain", param_3, param_4);
    return param_1;
}

undefined4 chip_speed_test(int param_1)

{
    uint uVar1;
    uint uVar2;
    undefined1 auStack_2440[4000];
    undefined1 auStack_14a0[4096];
    undefined1 auStack_4a0[6];
    char local_49a;
    char acStack_48c[1024];
    float local_8c;
    int aiStack_88[16];
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    int local_28;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    uint local_14;

    local_14 = 0;
    local_8c = 0.0;
    (**(code **)(param_1 + 0x94))(param_1, &local_8c);
    local_8c = local_8c * 120.0;
    V_LOCK();
    logfmt_raw(auStack_14a0, 0x1000, 0, "qualify nonce count %f",
               (double)local_8c);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "miner_util/miner_monitor/update_miner_status/update_chip_status.c",
        0xcb, "chip_speed_test", 0xf, 0x25, 0x14, auStack_14a0);
    get_miner_working_status(auStack_4a0);
    if (local_49a == '\0') {
        for (local_20 = 0;
             uVar2 = local_14, local_20 < *(int *)(param_1 + 0x150);
             local_20 = local_20 + 1) {
            if (*(uint *)(*(int *)(param_1 + 0x1e0) + local_20 * 4) <
                (uint)(0.0 < local_8c) * (int)local_8c) {
                if (*(int *)(*(int *)(param_1 + 0x1e0) + local_20 * 4) == 0) {
                    local_14 = local_14 + 1;
                    uVar1 = uVar2 & 0xf;
                    if ((int)uVar2 < 1) {
                        uVar1 = -(-uVar2 & 0xf);
                    }
                    aiStack_88[uVar1] = local_20;
                    *(undefined4 *)(*(int *)(param_1 + 0x210) +
                                    local_20 * 0x2c + 0x10) = 2;
                } else {
                    local_14 = local_14 + 1;
                    uVar1 = uVar2 & 0xf;
                    if ((int)uVar2 < 1) {
                        uVar1 = -(-uVar2 & 0xf);
                    }
                    aiStack_88[uVar1] = local_20;
                    *(undefined4 *)(*(int *)(param_1 + 0x210) +
                                    local_20 * 0x2c + 0x10) = 3;
                }
            } else {
                *(undefined4 *)(*(int *)(param_1 + 0x210) + local_20 * 0x2c +
                                0x10) = 0;
            }
            *(undefined4 *)(*(int *)(param_1 + 0x1e0) + local_20 * 4) = 0;
        }
        if (*(int *)(param_1 + 0x20c) < (int)local_14) {
            local_24 = 0;
            local_28 = snprintf(acStack_48c, 0x400, "bad asic id:");
            local_24 = local_24 + local_28;
            local_18 = 0;
            while (true) {
                uVar2 = local_14;
                if (0xf < (int)local_14) {
                    uVar2 = 0x10;
                }
                if ((int)uVar2 <= local_18)
                    break;
                local_28 = snprintf(acStack_48c + local_24, 0x400 - local_24,
                                    "%03d ", aiStack_88[local_18]);
                local_24 = local_24 + local_28;
                local_18 = local_18 + 1;
            }
            V_LOCK();
            logfmt_raw(auStack_14a0, 0x1000, 0, &DAT_001195f0, acStack_48c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/update_miner_status/update_chip_status.c",
                 0xcb, "chip_speed_test", 0xf, 0x56, 0x28, auStack_14a0);
            (**(code **)(param_1 + 0xd0))(param_1, auStack_2440, 4000);
            V_LOCK();
            FUN_00069b80(&local_48, &local_48, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(auStack_14a0, 0x1000, 0, uStack_2c, local_48, uStack_44,
                       uStack_40, uStack_3c, local_38, uStack_34, uStack_30,
                       uStack_2c, &DAT_001195f0, auStack_2440);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/update_miner_status/update_chip_status.c",
                 0xcb, "chip_speed_test", 0xf, 0x59, 0x3c, auStack_14a0);
        } else {
            local_1c = 0;
            while (true) {
                uVar2 = local_14;
                if (0xf < (int)local_14) {
                    uVar2 = 0x10;
                }
                if ((int)uVar2 <= local_1c)
                    break;
                *(undefined4 *)(*(int *)(param_1 + 0x210) +
                                aiStack_88[local_1c] * 0x2c + 0x10) = 0;
                local_1c = local_1c + 1;
            }
        }
    } else {
        V_LOCK();
        logfmt_raw(
            auStack_14a0, 0x1000, 0,
            "check lost connection to pool, keep the state of all chips!");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/miner_monitor/"
             "update_miner_status/update_chip_status.c",
             0xcb, "chip_speed_test", 0xf, 0x2d, 0x14, auStack_14a0);
    }
    return 0;
}

/* WARNING: Restarted to delay deadcode elimination for space: stack */

void update_str_and_flag(int param_1, int param_2, uint *param_3)

{
    undefined1 *puVar1;
    undefined8 uVar2;
    undefined4 uVar3;
    undefined8 in_d17;
    uint local_10;
    undefined1 *local_c;

    *(undefined4 *)(param_2 + 0x48) = 0;
    local_c = *(undefined1 **)(param_2 + 0x4c);
    for (local_10 = 0;
         puVar1 = local_c, (int)local_10 < *(int *)(param_1 + 0x150);
         local_10 = local_10 + 1) {
        switch (*(undefined4 *)(*(int *)(param_1 + 0x210) + local_10 * 0x2c +
                                0x10)) {
        case 0:
            *(int *)(param_2 + 0x48) = *(int *)(param_2 + 0x48) + 1;
            *local_c = 0x6f;
            break;
        case 1:
            *local_c = 0x23;
            /* WARNING: Ignoring partial resolution of indirect */
            uVar3 = 0;
            uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
            *param_3 = (uint)uVar2 | *param_3;
            param_3[1] = (uint)((ulonglong)uVar2 >> 0x20) | param_3[1];
            break;
        case 2:
            *local_c = 0x58;
            /* WARNING: Ignoring partial resolution of indirect */
            uVar3 = 1;
            uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
            *param_3 = (uint)uVar2 | *param_3;
            param_3[1] = (uint)((ulonglong)uVar2 >> 0x20) | param_3[1];
            break;
        case 3:
            *local_c = 0x78;
            /* WARNING: Ignoring partial resolution of indirect */
            uVar3 = 2;
            uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
            *param_3 = (uint)uVar2 | *param_3;
            param_3[1] = (uint)((ulonglong)uVar2 >> 0x20) | param_3[1];
            break;
        default:
            *local_c = 0x2a;
        }
        local_c = local_c + 1;
        if ((local_10 != 0) && ((local_10 & 7) == 0)) {
            *local_c = 0x20;
            local_c = puVar1 + 2;
        }
    }
    *local_c = 0;
    return;
}

void FUN_0006a418(int param_1)

{
    undefined4 local_c;

    for (local_c = 0; local_c < *(int *)(param_1 + 0x150);
         local_c = local_c + 1) {
        *(undefined4 *)(*(int *)(param_1 + 0x210) + local_c * 0x2c + 0x10) = 0;
    }
    return;
}

int update_chip_status(int param_1, int param_2, int param_3)

{
    if ((&DAT_00153c1c)[*(int *)(param_1 + 0xf8)] == '\x01') {
        if (*(char *)(param_1 + 0x102) == '\x01') {
            *(undefined4 *)(param_2 + 0x50) = *(undefined4 *)(param_1 + 0x1d0);
            chip_speed_test(param_1);
            update_str_and_flag(param_1, param_2, param_3 + 0x30);
        }
    } else {
        FUN_0006a418(param_1);
        *(undefined4 *)(param_2 + 0x50) = *(undefined4 *)(param_1 + 0x1d0);
        update_str_and_flag(param_1, param_2, param_3 + 0x30);
        *(undefined4 *)(param_2 + 0x48) = *(undefined4 *)(param_1 + 0x1a8);
        (&DAT_00153c1c)[*(int *)(param_1 + 0xf8)] = 1;
    }
    return param_3 + 0x30;
}

undefined4 FUN_0006a588(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "fanid", param_3, param_4);
    return param_1;
}

undefined4 FUN_0006a5bc(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "fanspeed", param_3, param_4);
    return param_1;
}

/* WARNING: Restarted to delay deadcode elimination for space: stack */

int update_fanspeed(int param_1, int param_2, int param_3)

{
    int iVar1;
    int iVar2;
    uint uVar3;
    int iVar4;
    undefined8 uVar5;
    undefined4 uVar6;
    undefined8 in_d17;
    undefined1 auStack_11a4[4096];
    char local_1a4[8];
    undefined4 local_19c;
    undefined1 local_198[32];
    undefined1 local_178[32];
    undefined1 local_158[32];
    undefined1 local_138[32];
    undefined1 local_118[32];
    undefined1 local_f8[32];
    undefined1 local_d8[32];
    undefined1 local_b8[32];
    undefined1 local_98[32];
    undefined1 local_78[32];
    undefined4 local_58;
    uint *local_54;
    undefined4 local_50;
    uint *local_4c;
    undefined4 local_48;
    uint *local_44;
    undefined4 local_40;
    uint *local_3c;
    undefined4 local_38;
    uint *local_34;
    uint local_30;
    uint local_2c;
    int local_28;
    int *local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;

    local_19c = 0;
    local_24 = (int *)get_all_created_runtime(&local_19c);
    if (param_1 == *local_24) {
        if (fan_inited != '\x01') {
            fan_init();
            fan_inited = '\x01';
        }
        local_28 = platform_get_fan_num();
        local_20 = 0;
        local_1a4[0] = '\0';
        local_1a4[1] = '\0';
        local_1a4[2] = '\0';
        local_1a4[3] = '\0';
        local_1a4[4] = '\0';
        local_1a4[5] = '\0';
        local_1a4[6] = '\0';
        local_1a4[7] = '\0';
        for (local_1c = 0; local_1c < local_28; local_1c = local_1c + 1) {
            local_30 = fan_get_realtime_speed(local_1c);
            V_LOCK();
            FUN_0006a588(local_198, local_198, local_1c, local_1c >> 0x1f);
            FUN_0006a5bc(local_178, local_178, local_30, (int)local_30 >> 0x1f);
            logfmt_raw(auStack_11a4, 0x1000, 0);
            V_UNLOCK();
            zlog(g_fan_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/miner_util/"
                 "miner_monitor/update_miner_status/update_fanspeed.c",
                 200, "update_fanspeed");
            if (local_30 == 0xffffffff) {
                V_LOCK();
                FUN_0006a588(local_118, local_118, local_1c, local_1c >> 0x1f);
                uVar3 = local_30 & ~((int)local_30 >> 0x1f);
                FUN_0006a5bc(local_f8, local_f8, uVar3, (int)uVar3 >> 0x1f);
                logfmt_raw(auStack_11a4, 0x1000, 0);
                V_UNLOCK();
                zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/"
                    "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                    "release/build/godminer-origin_godminer-branch1/miner_util/"
                    "miner_monitor/update_miner_status/update_fanspeed.c",
                    200, "update_fanspeed");
                local_1a4[local_1c] = '\x01';
            } else {
                V_LOCK();
                FUN_0006a588(local_158, local_158, local_1c, local_1c >> 0x1f);
                FUN_0006a5bc(local_138, local_138, local_30,
                             (int)local_30 >> 0x1f);
                logfmt_raw(auStack_11a4, 0x1000, 0);
                V_UNLOCK();
                zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/"
                    "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                    "release/build/godminer-origin_godminer-branch1/miner_util/"
                    "miner_monitor/update_miner_status/update_fanspeed.c",
                    200, "update_fanspeed");
                iVar1 = local_20;
                *(int *)(*(int *)(param_2 + 0x6c) + local_20 * 4) = local_1c;
                local_20 = local_20 + 1;
                *(uint *)(*(int *)(param_2 + 0x68) + iVar1 * 4) = local_30;
            }
        }
        *(int *)(param_2 + 100) = local_20;
        if (*(int *)(param_2 + 100) < local_28) {
            local_34 = (uint *)(param_3 + 0x20);
            local_38 = 1;
            /* WARNING: Ignoring partial resolution of indirect */
            uVar6 = 1;
            uVar5 = VectorShiftLeft(1, in_d17, 8, 1);
            *local_34 = (uint)uVar5 | *local_34;
            *(uint *)(param_3 + 0x24) =
                (uint)((ulonglong)uVar5 >> 0x20) | *(uint *)(param_3 + 0x24);
        }
        for (local_18 = 0; local_18 < *(int *)(param_2 + 100);
             local_18 = local_18 + 1) {
            if (*(int *)(*(int *)(param_2 + 0x68) + local_18 * 4) == 0) {
            LAB_0006ab3c:
                local_3c = (uint *)(param_3 + 0x20);
                local_40 = 0;
                /* WARNING: Ignoring partial resolution of indirect */
                uVar6 = 0;
                uVar5 = VectorShiftLeft(1, in_d17, 8, 1);
                *local_3c = (uint)uVar5 | *local_3c;
                *(uint *)(param_3 + 0x24) = (uint)((ulonglong)uVar5 >> 0x20) |
                                            *(uint *)(param_3 + 0x24);
                local_1a4[local_18] = '\x01';
            } else {
                iVar4 = *(int *)(*(int *)(param_2 + 0x68) + local_18 * 4);
                iVar1 = platform_get_fan_max_speed(local_18);
                iVar2 = fan_pwm_get();
                if (iVar4 < (iVar2 * iVar1) / 0x96)
                    goto LAB_0006ab3c;
            }
        }
        local_44 = (uint *)(param_3 + 0x20);
        local_48 = 1;
        /* WARNING: Ignoring partial resolution of indirect */
        uVar6 = 1;
        uVar5 = VectorShiftLeft(1, in_d17, 8, 1);
        if (((uint)uVar5 & *local_44) == 0 &&
            ((uint)((ulonglong)uVar5 >> 0x20) & *(uint *)(param_3 + 0x24)) ==
                0) {
            local_4c = (uint *)(param_3 + 0x20);
            local_50 = 0;
            /* WARNING: Ignoring partial resolution of indirect */
            uVar6 = 0;
            uVar5 = VectorShiftLeft(1, in_d17, 8, 1);
            if (((uint)uVar5 & *local_4c) == 0 &&
                ((uint)((ulonglong)uVar5 >> 0x20) &
                 *(uint *)(param_3 + 0x24)) == 0) {
                DAT_00153c30 = 0;
                goto LAB_0006b068;
            }
        }
        DAT_00153c30 = DAT_00153c30 + 1;
        if (DAT_0014f908 < DAT_00153c30) {
            V_LOCK();
            logfmt_raw(auStack_11a4, 0x1000, 0, "fan_error_num: %d fan_num %d");
            V_UNLOCK();
            if (*(char *)(param_1 + 0x102) == '\0') {
                zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/"
                    "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                    "release/build/godminer-origin_godminer-branch1/miner_util/"
                    "miner_monitor/update_miner_status/update_fanspeed.c",
                    200, "update_fanspeed");
            }
            if (DAT_0014f908 + 1 == DAT_00153c30) {
                local_54 = (uint *)(param_3 + 0x20);
                local_58 = 2;
                /* WARNING: Ignoring partial resolution of indirect */
                uVar6 = 2;
                uVar5 = VectorShiftLeft(1, in_d17, 8, 1);
                *local_54 = (uint)uVar5 | *local_54;
                *(uint *)(param_3 + 0x24) = (uint)((ulonglong)uVar5 >> 0x20) |
                                            *(uint *)(param_3 + 0x24);
                for (local_14 = 0; local_14 < local_28;
                     local_14 = local_14 + 1) {
                    local_2c = fan_get_realtime_speed(local_14);
                    V_LOCK();
                    FUN_0006a588(local_d8, local_d8, local_14,
                                 local_14 >> 0x1f);
                    FUN_0006a5bc(local_b8, local_b8, local_2c,
                                 (int)local_2c >> 0x1f);
                    logfmt_raw(auStack_11a4, 0x1000, 0);
                    V_UNLOCK();
                    zlog(g_fan_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_fanspeed.c",
                         200, "update_fanspeed");
                    V_LOCK();
                    FUN_0006a588(local_98, local_98, local_14,
                                 local_14 >> 0x1f);
                    uVar3 = local_2c & ~((int)local_2c >> 0x1f);
                    FUN_0006a5bc(local_78, local_78, uVar3, (int)uVar3 >> 0x1f);
                    logfmt_raw(auStack_11a4, 0x1000, 0);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_fanspeed.c",
                         200, "update_fanspeed");
                    if (local_1a4[local_14] != '\0') {
                        set_miner_6060info_status_fan_err(local_14, 1);
                    }
                }
            }
        }
    }
LAB_0006b068:
    return param_3 + 0x20;
}

undefined4 FUN_0006b078(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "chain", param_3, param_4);
    return param_1;
}

uint FUN_0006b0ac(float param_1, int param_2)

{
    int iVar1;
    bool bVar2;
    uint uVar3;
    undefined4 local_18;
    undefined4 local_10;
    undefined4 local_c;

    uVar3 = (uint)(0.0 < param_1 / 5.0) * (int)(param_1 / 5.0);
    local_10 = *(int *)(param_2 + 0xb40);
    get_miner_elapsed_time();
    iVar1 = *(int *)(param_2 + 0xb4c);
    bVar2 = iVar1 == 0;
    if (iVar1 == 0) {
        bVar2 = *(uint *)(param_2 + 0xb48) <= uVar3;
    }
    local_c = uVar3;
    if (bVar2 && (iVar1 != 0 || uVar3 != *(uint *)(param_2 + 0xb48))) {
        local_c = *(uint *)(param_2 + 0xb48);
    }
    for (local_18 = 0; local_18 < local_c; local_18 = local_18 + 1) {
        uVar3 = (local_10 + 0x2cf) * -0x49f49f49;
        local_10 = (local_10 + 0x2cf) % 0x2d0;
    }
    return uVar3;
}

/* WARNING: Restarted to delay deadcode elimination for space: stack */

uint *update_hashrate(int param_1, int param_2, uint *param_3)

{
    float fVar1;
    uint uVar2;
    int iVar3;
    uint *puVar4;
    bool bVar5;
    undefined4 uVar6;
    float fVar7;
    undefined8 uVar8;
    ulonglong uVar9;
    double dVar10;
    undefined1 auStack_11f0[228];
    undefined1 auStack_110c[4096];
    undefined1 auStack_10c[6];
    char local_106;
    char local_104;
    char local_f8[6];
    char local_f2;
    undefined1 auStack_e4[4];
    double dStack_e0;
    undefined4 local_d8;
    undefined4 uStack_d4;
    undefined4 local_d0;
    undefined4 uStack_cc;
    undefined1 local_c8[32];
    timespec *local_a8;
    undefined4 local_a4;
    uint *local_a0;
    undefined4 local_9c;
    uint *local_98;
    timespec *local_94;
    timespec *local_90;
    timespec *local_8c;
    timespec *local_88;
    timespec *local_84;
    timespec *local_80;
    timespec *local_7c;
    timespec *local_78;
    timespec *local_74;
    undefined4 local_70;
    undefined4 uStack_6c;
    float local_64;
    float fStack_60;
    float fStack_5c;
    int local_58;
    int iStack_54;
    uint local_50;
    int iStack_4c;
    int local_44;
    float fStack_40;
    float local_3c;
    uint local_38;
    int iStack_34;
    int local_30;
    int local_2c;
    timespec *local_28;
    timespec *local_24;
    timespec *local_20;
    int local_1c;

    (**(code **)(param_1 + 0x88))(param_1, &local_d0);
    (**(code **)(param_1 + 0x90))(param_1, &local_d8);
    (**(code **)(param_1 + 0x8c))(param_1, &dStack_e0, auStack_e4);
    *(undefined4 *)(param_2 + 0x38) = local_d0;
    *(undefined4 *)(param_2 + 0x3c) = uStack_cc;
    *(undefined4 *)(param_2 + 0x40) = local_d8;
    *(undefined4 *)(param_2 + 0x44) = uStack_d4;
    local_1c = *(int *)(param_1 + 0xf8);
    if (local_1c < 0x11) {
        local_20 = (timespec *)(&DAT_00153c38 + local_1c * 0x10);
        local_24 = (timespec *)(&DAT_00153d38 + local_1c * 0x10);
        local_28 = (timespec *)(local_1c * 0x10 + 0x153e38);
        if ((&DAT_00153f38)[local_1c] != '\x01') {
            local_7c = local_20;
            clock_gettime(1, local_20);
            local_78 = local_24;
            clock_gettime(1, local_24);
            local_74 = local_28;
            clock_gettime(1, local_28);
            *(undefined8 *)(&DAT_00153f48 + local_1c * 8) = 0;
            (&DAT_00153f38)[local_1c] = 1;
        }
        if ((*(int *)(param_1 + 0x1c0) == 0 &&
             *(int *)(param_1 + 0x1c4) == 0) &&
            (DAT_0015f4c8 != '\x01')) {
            local_88 = local_20;
            clock_gettime(1, local_20);
            local_84 = local_24;
            clock_gettime(1, local_24);
            local_80 = local_28;
            clock_gettime(1, local_28);
            *(undefined8 *)(&DAT_00153f48 + local_1c * 8) = 0;
        } else {
            if (DAT_0015f4c8 != '\x01') {
                DAT_0015f4c8 = '\x01';
            }
            local_8c = local_20;
            clock_gettime(1, local_20 + 1);
            iVar3 = local_8c[1].tv_sec - local_8c->tv_sec;
            uVar8 = VectorShiftLeft((longlong)iVar3, 5, 0x40, 0);
            uVar8 = VectorSub(uVar8, (longlong)iVar3, 8);
            uVar8 = VectorAdd(uVar8, uVar8, 8);
            uVar2 = (uint)uVar8;
            uVar9 = (ulonglong)iVar3;
            uVar8 = VectorAdd(CONCAT44((int)((ulonglong)uVar8 >> 0x20) * 2 +
                                           (uint)CARRY4(uVar2, uVar2),
                                       uVar2 * 2),
                              uVar9, 8);
            uVar8 = VectorShiftLeft(uVar8, 3, 0x40, 0);
            uVar2 = (local_8c[1].tv_nsec - local_8c->tv_nsec) / 1000000;
            fStack_40 = (float)FUN_000ccce0(
                uVar2 + (uint)uVar8, ((int)uVar2 >> 0x1f) +
                                         (int)((ulonglong)uVar8 >> 0x20) +
                                         (uint)CARRY4(uVar2, (uint)uVar8));
            fStack_40 = fStack_40 / 1000.0;
            local_44 = local_1c * 0xb50 + 0x153fc8;
            if (5.0 <= fStack_40) {
                local_50 = *(uint *)(param_1 + 0x1c0);
                iStack_4c = *(int *)(param_1 + 0x1c4);
                local_58 = local_50 - *(uint *)(&DAT_00153f48 + local_1c * 8);
                iStack_54 = iStack_4c -
                            (*(int *)(&DAT_00153f4c + local_1c * 8) +
                             (uint)(local_50 <
                                    *(uint *)(&DAT_00153f48 + local_1c * 8)));
                local_3c = 0.0;
                get_miner_working_status(local_f8);
                if ((local_f2 != '\x01') && (local_f8[0] != '\x01')) {
                    fVar1 = (float)FUN_000cccd0(local_58, iStack_54);
                    fVar1 = fVar1 / fStack_40;
                    uVar8 = VectorShiftLeft(
                        1,
                        uVar9 & 0xffffffffffff0000 |
                            (ulonglong) * (uint *)(param_1 + 0x1b0) & 0xffff,
                        8, 1);
                    local_3c = (float)FUN_000cccd0(
                        (int)uVar8, (int)((ulonglong)uVar8 >> 0x20));
                    local_3c = fVar1 * local_3c;
                }
                V_LOCK();
                logfmt_raw(auStack_110c, 0x1000, 0,
                           "[HashRate] time_passed_sec: %.2f, nc %llu, new "
                           "%llu, %.2f H/s");
                V_UNLOCK();
                zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/"
                    "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                    "release/build/godminer-origin_godminer-branch1/miner_util/"
                    "miner_monitor/update_miner_status/update_hashrate.c",
                    200, "update_hashrate");
                local_90 = local_20;
                clock_gettime(1, local_20);
                *(float *)(local_44 + *(int *)(local_44 + 0xb40) * 4) =
                    local_3c;
                *(int *)(local_44 + 0xb40) = *(int *)(local_44 + 0xb40) + 1;
                *(int *)(local_44 + 0xb40) = *(int *)(local_44 + 0xb40) % 0x2d0;
                *(uint *)(&DAT_00153f48 + local_1c * 8) = local_50;
                *(int *)(&DAT_00153f4c + local_1c * 8) = iStack_4c;
                fVar7 = *(float *)(param_2 + 0x30);
                fVar1 = (float)FUN_000cccd0(*(undefined4 *)(local_44 + 0xb48),
                                            *(undefined4 *)(local_44 + 0xb4c));
                fStack_5c = local_3c + fVar7 * fVar1;
                fVar1 = (float)FUN_000cccd0(
                    *(uint *)(local_44 + 0xb48) + 1,
                    *(int *)(local_44 + 0xb4c) +
                        (uint)(0xfffffffe < *(uint *)(local_44 + 0xb48)));
                *(float *)(param_2 + 0x30) = fStack_5c / fVar1;
                uVar2 = *(uint *)(local_44 + 0xb48);
                *(uint *)(local_44 + 0xb48) = uVar2 + 1;
                *(uint *)(local_44 + 0xb4c) =
                    *(int *)(local_44 + 0xb4c) + (uint)(0xfffffffe < uVar2);
            }
            uVar6 = FUN_0006b0ac(0x40a00000, local_44);
            *(undefined4 *)(param_2 + 0x24) = uVar6;
            uVar6 = FUN_0006b0ac(0x42700000, local_44);
            *(undefined4 *)(param_2 + 0x28) = uVar6;
            uVar6 = FUN_0006b0ac(0x44e10000, local_44);
            *(undefined4 *)(param_2 + 0x2c) = uVar6;
            local_38 = 0;
            iStack_34 = 0;
            for (local_30 = 0; local_30 < *(int *)(param_1 + 0x150);
                 local_30 = local_30 + 1) {
                for (local_2c = 2; local_2c < 6; local_2c = local_2c + 1) {
                    puVar4 = (uint *)(*(int *)(param_1 + 0x1c8) +
                                      local_30 * 0x30 + local_2c * 8);
                    uVar2 = *puVar4;
                    bVar5 = CARRY4(uVar2, local_38);
                    local_38 = uVar2 + local_38;
                    iStack_34 = puVar4[1] + iStack_34 + (uint)bVar5;
                }
            }
            *(uint *)(param_2 + 0x58) = local_38;
            *(int *)(param_2 + 0x5c) = iStack_34;
            local_94 = local_24;
            clock_gettime(1, local_24 + 1);
            iVar3 = local_94[1].tv_sec - local_94->tv_sec;
            uVar8 = VectorShiftLeft((longlong)iVar3, 5, 0x40, 0);
            uVar8 = VectorSub(uVar8, (longlong)iVar3, 8);
            uVar8 = VectorAdd(uVar8, uVar8, 8);
            uVar2 = (uint)uVar8;
            uVar8 = VectorAdd(CONCAT44((int)((ulonglong)uVar8 >> 0x20) * 2 +
                                           (uint)CARRY4(uVar2, uVar2),
                                       uVar2 * 2),
                              (longlong)iVar3, 8);
            uVar8 = VectorShiftLeft(uVar8, 3, 0x40, 0);
            uVar2 = (local_94[1].tv_nsec - local_94->tv_nsec) / 1000000;
            fVar1 = (float)FUN_000ccce0(uVar2 + (uint)uVar8,
                                        ((int)uVar2 >> 0x1f) +
                                            (int)((ulonglong)uVar8 >> 0x20) +
                                            (uint)CARRY4(uVar2, (uint)uVar8));
            fStack_60 = fVar1 / 1000.0;
            if (900.0 <= fVar1 / 1000.0) {
                local_64 = (float)FUN_0006b0ac(0x44610000, local_44);
                if (*(int *)(param_2 + 0xd0) < 0x18) {
                    *(float *)(param_2 + (*(int *)(param_2 + 0xd0) + 0x1c) *
                                             4) = local_64;
                } else {
                    memcpy((void *)(param_2 + 0x70), (void *)(param_2 + 0x74),
                           0x5c);
                    *(float *)(param_2 + 0xcc) = local_64;
                }
                *(int *)(param_2 + 0xd0) = *(int *)(param_2 + 0xd0) + 1;
                uVar2 = *(uint *)(param_2 + 0xd8);
                *(uint *)(param_2 + 0xd8) = uVar2 + 1;
                *(uint *)(param_2 + 0xdc) =
                    *(int *)(param_2 + 0xdc) + (uint)(0xfffffffe < uVar2);
                dVar10 = (double)local_64;
                if (dStack_e0 * 0.97 < dVar10) {
                    local_a4 = 0;
                    /* WARNING: Ignoring partial resolution of indirect */
                    uVar6 = 0;
                    uVar8 = VectorShiftLeft(1, dVar10, 8, 1);
                    param_3[2] = (uint)uVar8 | param_3[2];
                    param_3[3] = (uint)((ulonglong)uVar8 >> 0x20) | param_3[3];
                    local_a0 = param_3;
                    set_miner_6060info_low_hashrate_err(
                        *(undefined4 *)(param_1 + 0xfc), 0);
                } else {
                    local_9c = 0;
                    /* WARNING: Ignoring partial resolution of indirect */
                    uVar6 = 0;
                    uVar8 = VectorShiftLeft(1, dVar10, 8, 1);
                    *param_3 = (uint)uVar8 | *param_3;
                    param_3[1] = (uint)((ulonglong)uVar8 >> 0x20) | param_3[1];
                    local_98 = param_3;
                    get_miner_working_status(auStack_10c);
                    if ((local_104 != '\x01') && (local_106 != '\x01')) {
                        V_LOCK();
                        FUN_0006b078(local_c8, local_c8,
                                     *(int *)(param_1 + 0xfc),
                                     *(int *)(param_1 + 0xfc) >> 0x1f);
                        /* WARNING: Ignoring partial resolution of indirect */
                        /* WARNING: Ignoring partial resolution of indirect */
                        logfmt_raw(auStack_110c, 0x1000, 0);
                        V_UNLOCK();
                        /* WARNING: Ignoring partial resolution of indirect */
                        /* WARNING: Ignoring partial resolution of indirect */
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/miner_util/"
                             "miner_monitor/update_miner_status/"
                             "update_hashrate.c",
                             200, "update_hashrate");
                        read_status_from_monitor(auStack_11f0, param_1);
                        local_70 = 0;
                        uStack_6c = 0x41cdcd65;
                        V_LOCK();
                        logfmt_raw(auStack_110c, 0x1000, 0,
                                   "no ratio hashrate last_5s: %f");
                        V_UNLOCK();
                        /* WARNING: Ignoring partial resolution of indirect */
                        /* WARNING: Ignoring partial resolution of indirect */
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/miner_util/"
                             "miner_monitor/update_miner_status/"
                             "update_hashrate.c",
                             200, "update_hashrate");
                        V_LOCK();
                        logfmt_raw(auStack_110c, 0x1000, 0,
                                   "no ratio hashrate last_30min: %f");
                        V_UNLOCK();
                        /* WARNING: Ignoring partial resolution of indirect */
                        /* WARNING: Ignoring partial resolution of indirect */
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/miner_util/"
                             "miner_monitor/update_miner_status/"
                             "update_hashrate.c",
                             200, "update_hashrate");
                        V_LOCK();
                        logfmt_raw(auStack_110c, 0x1000, 0,
                                   "no ratio hashrate lifetime: %f");
                        V_UNLOCK();
                        /* WARNING: Ignoring partial resolution of indirect */
                        /* WARNING: Ignoring partial resolution of indirect */
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/miner_util/"
                             "miner_monitor/update_miner_status/"
                             "update_hashrate.c",
                             200, "update_hashrate");
                        set_miner_6060info_low_hashrate_err(
                            *(undefined4 *)(param_1 + 0xfc), 1);
                    }
                }
                local_a8 = local_24;
                clock_gettime(1, local_24);
            }
        }
    }
    return param_3;
}

undefined4 FUN_0006bf10(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "chain", param_3, param_4);
    return param_1;
}

undefined4 FUN_0006bf44(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "sensor", param_3, param_4);
    return param_1;
}

undefined4 FUN_0006bf78(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "pcbtemp", param_3, param_4);
    return param_1;
}

undefined4 FUN_0006bfac(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "chiptemp", param_3, param_4);
    return param_1;
}

undefined4 FUN_0006bfe0(int param_1, int *param_2, int *param_3, int *param_4,
                        int *param_5, int *param_6, size_t *param_7,
                        size_t *param_8, int *param_9)

{
    int iVar1;
    undefined4 uVar2;
    bool bVar3;
    undefined4 local_11a8;
    undefined4 uStack_11a4;
    undefined4 uStack_11a0;
    undefined4 uStack_119c;
    undefined4 local_1198;
    undefined4 uStack_1194;
    undefined4 uStack_1190;
    undefined4 uStack_118c;
    int *local_1188;
    int *local_1184;
    int *local_1180;
    int local_117c;
    undefined1 auStack_1174[4096];
    int local_174;
    undefined4 uStack_170;
    size_t local_16c;
    undefined4 uStack_168;
    undefined4 local_164;
    undefined4 uStack_160;
    undefined4 uStack_15c;
    undefined4 local_158;
    undefined4 uStack_154;
    undefined4 uStack_150;
    undefined4 uStack_14c;
    undefined4 local_148;
    undefined4 uStack_144;
    undefined4 uStack_140;
    undefined4 uStack_13c;
    undefined4 local_138;
    undefined4 uStack_134;
    undefined4 uStack_130;
    undefined4 uStack_12c;
    undefined4 local_128;
    undefined4 uStack_124;
    undefined4 uStack_120;
    undefined4 uStack_11c;
    undefined4 local_118;
    undefined4 uStack_114;
    undefined4 uStack_110;
    undefined4 uStack_10c;
    undefined4 local_108;
    undefined4 uStack_104;
    undefined4 uStack_100;
    undefined4 uStack_fc;
    undefined4 local_f8;
    undefined4 uStack_f4;
    undefined4 uStack_f0;
    undefined4 uStack_ec;
    undefined4 local_e8;
    undefined4 uStack_e4;
    undefined4 uStack_e0;
    undefined4 uStack_dc;
    undefined4 local_d8;
    undefined4 uStack_d4;
    undefined4 uStack_d0;
    undefined4 uStack_cc;
    undefined4 local_c8;
    undefined4 uStack_c4;
    undefined4 uStack_c0;
    undefined4 uStack_bc;
    undefined4 local_b8;
    undefined4 uStack_b4;
    undefined4 uStack_b0;
    undefined4 uStack_ac;
    undefined4 local_a8;
    undefined4 uStack_a4;
    undefined4 uStack_a0;
    undefined4 uStack_9c;
    undefined4 local_98;
    undefined4 uStack_94;
    undefined4 uStack_90;
    undefined4 uStack_8c;
    undefined4 local_88;
    undefined4 uStack_84;
    undefined4 uStack_80;
    undefined4 uStack_7c;
    undefined4 local_78;
    undefined4 uStack_74;
    undefined4 uStack_70;
    undefined4 uStack_6c;
    undefined4 local_68;
    undefined4 uStack_64;
    undefined4 uStack_60;
    undefined4 uStack_5c;
    undefined4 local_58;
    undefined4 uStack_54;
    undefined4 uStack_50;
    undefined4 uStack_4c;
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    int local_34;
    void *local_30;
    undefined4 local_2c;
    int local_28;
    uint local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;

    local_2c = 0xffffffc0;
    local_28 = 0;
    local_14 = 0;
    local_174 = *(int *)(param_1 + 0x184);
    uStack_170 = *(undefined4 *)(param_1 + 0x188);
    local_16c = *(size_t *)(param_1 + 0x18c);
    uStack_168 = *(undefined4 *)(param_1 + 400);
    local_164 = *(undefined4 *)(param_1 + 0x194);
    uStack_160 = *(undefined4 *)(param_1 + 0x198);
    uStack_15c = *(undefined4 *)(param_1 + 0x19c);
    local_1188 = param_4;
    local_1184 = param_3;
    local_1180 = param_2;
    local_117c = param_1;
    local_30 = calloc(local_16c, 0xc);
    *local_1184 = -0x96;
    *local_1188 = 0x96;
    *param_5 = -0x96;
    *param_6 = 0x96;
    (**(code **)(local_117c + 0xe4))(local_117c, local_30);
    for (local_18 = 0; local_18 < (int)local_16c; local_18 = local_18 + 1) {
        V_LOCK();
        FUN_0006bf10(&local_158, &local_158, *(int *)(local_117c + 0xfc),
                     *(int *)(local_117c + 0xfc) >> 0x1f);
        logfmt_raw(auStack_1174, 0x1000, 0, uStack_13c, local_158, uStack_154,
                   uStack_150, uStack_14c, local_148, uStack_144, uStack_140,
                   uStack_13c, "check_temperature, local:%d, remote:%d",
                   *(undefined4 *)((int)local_30 + local_18 * 0xc),
                   *(undefined4 *)((int)local_30 + local_18 * 0xc + 4));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/miner_monitor/"
             "update_miner_status/update_temperature.c",
             0xcb, "check_temperature", 0x11, 0x23, 0x14, auStack_1174);
        local_1c = 0;
        if (*(int *)((int)local_30 + local_18 * 0xc) == -0x40) {
            *param_9 = *param_9 + 1;
        } else {
            local_1c = 1;
            *param_7 = *param_7 + 1;
            if (*local_1184 < *(int *)((int)local_30 + local_18 * 0xc)) {
                *local_1184 = *(int *)((int)local_30 + local_18 * 0xc);
            }
            if (*(int *)((int)local_30 + local_18 * 0xc) < *local_1188) {
                *local_1188 = *(int *)((int)local_30 + local_18 * 0xc);
            }
        }
        local_20 = 0;
        if (*(int *)((int)local_30 + local_18 * 0xc + 4) == -0x40) {
            *param_9 = *param_9 + 1;
        } else {
            local_20 = 1;
            *param_8 = *param_8 + 1;
            if (*param_5 < *(int *)((int)local_30 + local_18 * 0xc + 4)) {
                *param_5 = *(int *)((int)local_30 + local_18 * 0xc + 4);
            }
            if (*(int *)((int)local_30 + local_18 * 0xc + 4) < *param_6) {
                *param_6 = *(int *)((int)local_30 + local_18 * 0xc + 4);
            }
        }
        bVar3 = *(int *)((int)local_30 + local_18 * 0xc + 8) != -0x40;
        if (!bVar3) {
            *param_9 = *param_9 + 1;
        }
        local_24 = (uint)bVar3;
        local_34 = local_174 + local_18 * 0x18;
        if (local_1180 != (int *)0x0) {
            if (*(int *)(local_34 + 0xc) == 0) {
                if (local_1c != 0) {
                    *(undefined4 *)(local_1180[1] + local_28 * 4) =
                        *(undefined4 *)((int)local_30 + local_18 * 0xc);
                }
                if (local_20 != 0) {
                    *(undefined4 *)(local_1180[2] + local_28 * 4) =
                        *(undefined4 *)((int)local_30 + local_18 * 0xc + 4);
                }
                if (local_24 != 0) {
                    *(undefined4 *)(*local_1180 + local_28 * 4) =
                        *(undefined4 *)((int)local_30 + local_18 * 0xc + 8);
                }
                local_28 = local_28 + 1;
            } else if (*(int *)(local_34 + 0xc) == 1) {
                if (local_1c != 0) {
                    *(undefined4 *)(local_1180[3] + local_14 * 4) =
                        *(undefined4 *)((int)local_30 + local_18 * 0xc);
                }
                if (local_20 != 0) {
                    *(undefined4 *)(local_1180[4] + local_14 * 4) =
                        *(undefined4 *)((int)local_30 + local_18 * 0xc + 4);
                }
                local_14 = local_14 + 1;
            }
        }
        V_LOCK();
        FUN_0006bf10(&local_138, &local_138, *(int *)(local_117c + 0xfc),
                     *(int *)(local_117c + 0xfc) >> 0x1f);
        FUN_0006bf44(&local_118, &local_118, *(int *)(local_34 + 0x14),
                     *(int *)(local_34 + 0x14) >> 0x1f);
        if (local_1c == 0) {
            FUN_0006bf78(&local_11a8, &local_11a8, 0xffffff00, 0xffffffff);
            local_f8 = local_11a8;
            uStack_f4 = uStack_11a4;
            uStack_f0 = uStack_11a0;
            uStack_ec = uStack_119c;
            local_e8 = local_1198;
            uStack_e4 = uStack_1194;
            uStack_e0 = uStack_1190;
            uStack_dc = uStack_118c;
        } else {
            iVar1 = *(int *)((int)local_30 + local_18 * 0xc);
            FUN_0006bf78(&local_f8, &local_f8, iVar1, iVar1 >> 0x1f);
        }
        if (local_20 == 0) {
            FUN_0006bfac(&local_11a8, &local_11a8, 0xffffff00, 0xffffffff);
            local_d8 = local_11a8;
            uStack_d4 = uStack_11a4;
            uStack_d0 = uStack_11a0;
            uStack_cc = uStack_119c;
            local_c8 = local_1198;
            uStack_c4 = uStack_1194;
            uStack_c0 = uStack_1190;
            uStack_bc = uStack_118c;
        } else {
            iVar1 = *(int *)((int)local_30 + local_18 * 0xc + 4);
            FUN_0006bfac(&local_d8, &local_d8, iVar1, iVar1 >> 0x1f);
        }
        logfmt_raw(auStack_1174, 0x1000, 0, uStack_11c, local_138, uStack_134,
                   uStack_130, uStack_12c, local_128, uStack_124, uStack_120,
                   uStack_11c, local_118, uStack_114, uStack_110, uStack_10c,
                   local_108, uStack_104, uStack_100, uStack_fc, local_f8,
                   uStack_f4, uStack_f0, uStack_ec, local_e8, uStack_e4,
                   uStack_e0, uStack_dc, local_d8, uStack_d4, uStack_d0,
                   uStack_cc, local_c8, uStack_c4, uStack_c0, uStack_bc,
                   &DAT_00119cf0, "check_temperature");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/miner_monitor/"
             "update_miner_status/update_temperature.c",
             0xcb, "check_temperature", 0x11, 0x67, 0x14, auStack_1174);
        V_LOCK();
        FUN_0006bf10(&local_b8, &local_b8, *(int *)(local_117c + 0xfc),
                     *(int *)(local_117c + 0xfc) >> 0x1f);
        FUN_0006bf44(&local_98, &local_98, *(int *)(local_34 + 0x14),
                     *(int *)(local_34 + 0x14) >> 0x1f);
        if (local_1c == 0) {
            FUN_0006bf78(&local_11a8, &local_11a8, 0xffffff00, 0xffffffff);
            local_78 = local_11a8;
            uStack_74 = uStack_11a4;
            uStack_70 = uStack_11a0;
            uStack_6c = uStack_119c;
            local_68 = local_1198;
            uStack_64 = uStack_1194;
            uStack_60 = uStack_1190;
            uStack_5c = uStack_118c;
        } else {
            iVar1 = *(int *)((int)local_30 + local_18 * 0xc);
            FUN_0006bf78(&local_78, &local_78, iVar1, iVar1 >> 0x1f);
        }
        if (local_20 == 0) {
            FUN_0006bfac(&local_11a8, &local_11a8, 0xffffff00, 0xffffffff);
            local_58 = local_11a8;
            uStack_54 = uStack_11a4;
            uStack_50 = uStack_11a0;
            uStack_4c = uStack_119c;
            local_48 = local_1198;
            uStack_44 = uStack_1194;
            uStack_40 = uStack_1190;
            uStack_3c = uStack_118c;
        } else {
            iVar1 = *(int *)((int)local_30 + local_18 * 0xc + 4);
            FUN_0006bfac(&local_58, &local_58, iVar1, iVar1 >> 0x1f);
        }
        logfmt_raw(auStack_1174, 0x1000, 0, uStack_9c, local_b8, uStack_b4,
                   uStack_b0, uStack_ac, local_a8, uStack_a4, uStack_a0,
                   uStack_9c, local_98, uStack_94, uStack_90, uStack_8c,
                   local_88, uStack_84, uStack_80, uStack_7c, local_78,
                   uStack_74, uStack_70, uStack_6c, local_68, uStack_64,
                   uStack_60, uStack_5c, local_58, uStack_54, uStack_50,
                   uStack_4c, local_48, uStack_44, uStack_40, uStack_3c,
                   &DAT_00119cf0, "check_temperature");
        V_UNLOCK();
        zlog(g_temp_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/miner_util/miner_monitor/"
             "update_miner_status/update_temperature.c",
             0xcb, "check_temperature", 0x11, 0x69, 0x28, auStack_1174);
    }
    free(local_30);
    if ((*param_7 == local_16c) && (*param_8 == local_16c)) {
        uVar2 = 0;
    } else {
        uVar2 = 0xffffffff;
    }
    return uVar2;
}

void init_temp_senor_info(int param_1)

{
    int *piVar1;
    int iVar2;
    int iVar3;
    int iVar4;
    int local_18[3];
    int local_c;

    piVar1 = (int *)get_all_created_runtime(local_18);
    *(undefined4 *)(param_1 + 0x1c) = 0;
    *(undefined4 *)(param_1 + 0x20) = 0;
    if (0 < local_18[0]) {
        iVar2 = *(int *)(*piVar1 + 0x184);
        iVar3 = *(int *)(*piVar1 + 0x18c);
        for (local_c = 0; local_c < iVar3; local_c = local_c + 1) {
            iVar4 = iVar2 + local_c * 0x18;
            if (*(int *)(iVar4 + 0xc) == 0) {
                *(int *)(param_1 + 0x1c) = *(int *)(param_1 + 0x1c) + 1;
            } else if (*(int *)(iVar4 + 0xc) == 1) {
                *(int *)(param_1 + 0x20) = *(int *)(param_1 + 0x20) + 1;
            }
        }
    }
    return;
}

/* WARNING: Restarted to delay deadcode elimination for space: stack */

int update_temperature(int param_1, int param_2, int param_3)

{
    int iVar1;
    undefined8 uVar2;
    undefined4 uVar3;
    undefined8 in_d17;
    undefined1 auStack_2124[4000];
    undefined1 auStack_1184[4096];
    uint local_184;
    int local_180;
    int local_17c;
    undefined4 local_178;
    undefined4 local_174;
    undefined4 local_170;
    undefined4 local_16c;
    undefined1 local_168[32];
    undefined1 local_148[32];
    undefined1 local_128[32];
    undefined1 local_108[32];
    undefined1 local_e8[32];
    undefined1 local_c8[32];
    undefined1 local_a8[32];
    undefined1 local_88[32];
    undefined1 local_68[44];
    undefined4 local_3c;
    uint *local_38;
    undefined4 local_34;
    uint *local_30;
    undefined4 local_2c;
    uint *local_28;
    undefined4 local_24;
    uint *local_20;
    undefined4 local_1c;
    uint *local_18;
    int local_14;

    local_17c = 0;
    local_180 = 0;
    local_184 = 0;
    if (*(char *)(param_1 + 0x102) == '\0') {
        local_14 = 5;
    } else {
        local_14 = 0;
    }
    if (*(char *)(param_1 + 0x102) == '\x01') {
        iVar1 = FUN_0006bfe0(param_1, param_2, &local_16c, &local_170);
        if ((iVar1 != 0) && (*(char *)(param_1 + 0x448) != '\x01')) {
            if (local_14 != 0) {
                V_LOCK();
                FUN_0006bf10(local_168, local_168, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(auStack_1184, 0x1000, 0);
                V_UNLOCK();
                if (local_14 == 5) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 4) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 3) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 2) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 1) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 0) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                }
                V_LOCK();
                logfmt_raw(auStack_1184, 0x1000, 0, "Sweep error string = %s.");
                V_UNLOCK();
                zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/"
                    "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                    "release/build/godminer-origin_godminer-branch1/miner_util/"
                    "miner_monitor/update_miner_status/update_temperature.c",
                    0xcb, "update_temperature");
            }
            local_18 = (uint *)(param_3 + 0x10);
            local_1c = 0;
            /* WARNING: Ignoring partial resolution of indirect */
            uVar3 = 0;
            uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
            *local_18 = (uint)uVar2 | *local_18;
            *(uint *)(param_3 + 0x14) =
                (uint)((ulonglong)uVar2 >> 0x20) | *(uint *)(param_3 + 0x14);
        }
        if (local_17c == 0) {
            *(int *)(&DAT_0015f518 + *(int *)(param_1 + 0xf8) * 4) =
                *(int *)(&DAT_0015f518 + *(int *)(param_1 + 0xf8) * 4) + 1;
            if (2 < *(int *)(&DAT_0015f518 + *(int *)(param_1 + 0xf8) * 4)) {
                V_LOCK();
                FUN_0006bf10(local_148, local_148, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(auStack_1184, 0x1000, 0);
                V_UNLOCK();
                if (local_14 == 5) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 4) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 3) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 2) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 1) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 0) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                }
                local_20 = (uint *)(param_3 + 0x10);
                local_24 = 3;
                /* WARNING: Ignoring partial resolution of indirect */
                uVar3 = 3;
                uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
                *local_20 = (uint)uVar2 | *local_20;
                *(uint *)(param_3 + 0x14) = (uint)((ulonglong)uVar2 >> 0x20) |
                                            *(uint *)(param_3 + 0x14);
            }
        } else {
            *(undefined4 *)(&DAT_0015f4d8 + *(int *)(param_1 + 0xf8) * 4) =
                local_16c;
            *(undefined4 *)(param_2 + 0x18) = local_170;
            *(undefined4 *)(&DAT_0015f518 + *(int *)(param_1 + 0xf8) * 4) = 0;
        }
        if (local_180 == 0) {
            *(int *)(&DAT_0015f598 + *(int *)(param_1 + 0xf8) * 4) =
                *(int *)(&DAT_0015f598 + *(int *)(param_1 + 0xf8) * 4) + 1;
            if (2 < *(int *)(&DAT_0015f598 + *(int *)(param_1 + 0xf8) * 4)) {
                V_LOCK();
                FUN_0006bf10(local_128, local_128, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(auStack_1184, 0x1000, 0);
                V_UNLOCK();
                if (local_14 == 5) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 4) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 3) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 2) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 1) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 0) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                }
                local_28 = (uint *)(param_3 + 0x10);
                local_2c = 3;
                /* WARNING: Ignoring partial resolution of indirect */
                uVar3 = 3;
                uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
                *local_28 = (uint)uVar2 | *local_28;
                *(uint *)(param_3 + 0x14) = (uint)((ulonglong)uVar2 >> 0x20) |
                                            *(uint *)(param_3 + 0x14);
            }
        } else {
            *(undefined4 *)(param_2 + 0x14) = local_174;
            *(undefined4 *)(&DAT_0015f558 + *(int *)(param_1 + 0xf8) * 4) =
                local_178;
            *(undefined4 *)(&DAT_0015f598 + *(int *)(param_1 + 0xf8) * 4) = 0;
        }
        if (*(uint *)(param_1 + 0x19c) < local_184) {
            *(int *)(&DAT_0015f5d8 + *(int *)(param_1 + 0xf8) * 4) =
                *(int *)(&DAT_0015f5d8 + *(int *)(param_1 + 0xf8) * 4) + 1;
            if (2 < *(int *)(&DAT_0015f5d8 + *(int *)(param_1 + 0xf8) * 4)) {
                V_LOCK();
                FUN_0006bf10(local_108, local_108, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(auStack_1184, 0x1000, 0);
                V_UNLOCK();
                if (local_14 == 5) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 4) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 3) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 2) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 1) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 0) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                }
                (**(code **)(param_1 + 0xd0))(param_1, auStack_2124, 4000);
                V_LOCK();
                FUN_0006bf10(local_e8, local_e8, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(auStack_1184, 0x1000, 0);
                V_UNLOCK();
                zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/"
                    "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                    "release/build/godminer-origin_godminer-branch1/miner_util/"
                    "miner_monitor/update_miner_status/update_temperature.c",
                    0xcb, "update_temperature");
                local_30 = (uint *)(param_3 + 0x10);
                local_34 = 4;
                /* WARNING: Ignoring partial resolution of indirect */
                uVar3 = 4;
                uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
                *local_30 = (uint)uVar2 | *local_30;
                *(uint *)(param_3 + 0x14) = (uint)((ulonglong)uVar2 >> 0x20) |
                                            *(uint *)(param_3 + 0x14);
            }
        } else {
            *(undefined4 *)(&DAT_0015f5d8 + *(int *)(param_1 + 0xf8) * 4) = 0;
        }
        if ((*(int *)(param_1 + 400) < *(int *)(param_2 + 0x14)) ||
            (*(int *)(param_1 + 0x194) <
             *(int *)(&DAT_0015f4d8 + *(int *)(param_1 + 0xf8) * 4))) {
            *(int *)(&DAT_0015f618 + *(int *)(param_1 + 0xf8) * 4) =
                *(int *)(&DAT_0015f618 + *(int *)(param_1 + 0xf8) * 4) + 1;
            if (2 < *(int *)(&DAT_0015f618 + *(int *)(param_1 + 0xf8) * 4)) {
                V_LOCK();
                FUN_0006bf10(local_c8, local_c8, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(auStack_1184, 0x1000, 0);
                V_UNLOCK();
                if (local_14 == 5) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 4) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 3) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 2) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 1) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 0) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                }
                V_LOCK();
                logfmt_raw(auStack_1184, 0x1000, 0, "Sweep error string = %s.");
                V_UNLOCK();
                zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/"
                    "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                    "release/build/godminer-origin_godminer-branch1/miner_util/"
                    "miner_monitor/update_miner_status/update_temperature.c",
                    0xcb, "update_temperature");
                (**(code **)(param_1 + 0xd0))(param_1, auStack_2124, 4000);
                V_LOCK();
                FUN_0006bf10(local_a8, local_a8, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(auStack_1184, 0x1000, 0);
                V_UNLOCK();
                zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/"
                    "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                    "release/build/godminer-origin_godminer-branch1/miner_util/"
                    "miner_monitor/update_miner_status/update_temperature.c",
                    0xcb, "update_temperature");
                local_38 = (uint *)(param_3 + 0x10);
                local_3c = 1;
                /* WARNING: Ignoring partial resolution of indirect */
                uVar3 = 1;
                uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
                *local_38 = (uint)uVar2 | *local_38;
                *(uint *)(param_3 + 0x14) = (uint)((ulonglong)uVar2 >> 0x20) |
                                            *(uint *)(param_3 + 0x14);
            }
        } else {
            *(undefined4 *)(&DAT_0015f618 + *(int *)(param_1 + 0xf8) * 4) = 0;
        }
        if (*(int *)(param_1 + 0x198) < *(int *)(param_2 + 0x18)) {
            *(undefined4 *)(&DAT_0015f658 + *(int *)(param_1 + 0xf8) * 4) = 0;
        } else {
            *(int *)(&DAT_0015f658 + *(int *)(param_1 + 0xf8) * 4) =
                *(int *)(&DAT_0015f658 + *(int *)(param_1 + 0xf8) * 4) + 1;
            if (2 < *(int *)(&DAT_0015f658 + *(int *)(param_1 + 0xf8) * 4)) {
                V_LOCK();
                FUN_0006bf10(local_88, local_88, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(auStack_1184, 0x1000, 0);
                V_UNLOCK();
                if (local_14 == 5) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 4) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 3) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 2) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 1) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                } else if (local_14 == 0) {
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "miner_util/miner_monitor/update_miner_status/"
                         "update_temperature.c",
                         0xcb, "update_temperature");
                }
                (**(code **)(param_1 + 0xd0))(param_1, auStack_2124, 4000);
                V_LOCK();
                FUN_0006bf10(local_68, local_68, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(auStack_1184, 0x1000, 0);
                V_UNLOCK();
                zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/"
                    "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                    "release/build/godminer-origin_godminer-branch1/miner_util/"
                    "miner_monitor/update_miner_status/update_temperature.c",
                    0xcb, "update_temperature");
                /* WARNING: Ignoring partial resolution of indirect */
                uVar3 = 2;
                uVar2 = VectorShiftLeft(1, in_d17, 8, 1);
                *(uint *)(param_3 + 0x10) =
                    (uint)uVar2 | *(uint *)(param_3 + 0x10);
                *(uint *)(param_3 + 0x14) = (uint)((ulonglong)uVar2 >> 0x20) |
                                            *(uint *)(param_3 + 0x14);
            }
        }
    }
    return param_3 + 0x10;
}

int runtime_ctrl(int param_1)

{
    undefined1 auStack_1010[4096];
    int local_10;
    uint local_c;

    local_10 = 0;
    for (local_c = 0;
         (local_c < 2 && (param_1 != *(int *)(&DAT_00119fa0 + local_c * 0xc)));
         local_c = local_c + 1) {
    }
    if ((local_c == 2) || (*(int *)(&DAT_00119fa8 + local_c * 0xc) == 0)) {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, "not support miner type: %d",
                   param_1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_interface.c",
             0xa5, "runtime_ctrl", 0xc, 0x45, 100, auStack_1010);
    } else {
        local_10 = (**(code **)(&DAT_00119fa8 + local_c * 0xc))();
        if (local_10 != 0) {
            pthread_mutex_lock((pthread_mutex_t *)&DAT_0015f79c);
            *(int *)(&DAT_0015f698 + DAT_0015f798 * 4) = local_10;
            *(int *)(local_10 + 0xf8) = DAT_0015f798;
            DAT_0015f798 = DAT_0015f798 + 1;
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_0015f79c);
        }
    }
    return local_10;
}

undefined4 query_device_num(void)

{
    undefined4 *puVar1;
    undefined4 uVar2;

    puVar1 = (undefined4 *)dev_ctrl();
    uVar2 = (*(code *)*puVar1)();
    return uVar2;
}

void redirect_nonce_output(int param_1, int param_2)

{
    while ((param_1 != *(int *)(param_1 + 0x3ec) &&
            (*(int *)(param_1 + 0x3ec) != 0))) {
        *(int *)(param_1 + 0x3ec) = param_1;
    }
    *(int *)(param_2 + 0x3ec) = param_1;
    return;
}

undefined *get_all_created_runtime(undefined4 *param_1)

{
    pthread_mutex_lock((pthread_mutex_t *)&DAT_0015f79c);
    *param_1 = DAT_0015f798;
    pthread_mutex_unlock((pthread_mutex_t *)&DAT_0015f79c);
    return &DAT_0015f698;
}

void check_and_destroy_abnormal_runtime(void)

{
    undefined1 auStack_1410[4096];
    undefined4 auStack_410[256];
    int local_10;
    int local_c;

    local_10 = 0;
    memset(auStack_410, 0, 0x400);
    local_c = 0;
    pthread_mutex_lock((pthread_mutex_t *)&DAT_0015f79c);
    for (local_10 = 0; local_10 < DAT_0015f798; local_10 = local_10 + 1) {
        if (*(int *)(*(int *)(&DAT_0015f698 + local_10 * 4) + 0x1a8) ==
            *(int *)(*(int *)(&DAT_0015f698 + local_10 * 4) + 0x150)) {
            auStack_410[local_c] =
                *(undefined4 *)(&DAT_0015f698 + local_10 * 4);
            local_c = local_c + 1;
        } else {
            V_LOCK();
            logfmt_raw(
                auStack_1410, 0x1000, 0,
                "chain %d runtime check asic number error, destroy it!",
                *(undefined4 *)(*(int *)(&DAT_0015f698 + local_10 * 4) + 0xfc));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "backend_interface.c",
                 0xa5, "check_and_destroy_abnormal_runtime", 0x22, 0x7c, 0x50,
                 auStack_1410);
            set_miner_6060info_asic_num_less_than_design_err(
                *(undefined4 *)(*(int *)(&DAT_0015f698 + local_10 * 4) + 0xfc),
                1);
            (**(code **)(*(int *)(&DAT_0015f698 + local_10 * 4) + 0x14))(
                *(undefined4 *)(&DAT_0015f698 + local_10 * 4));
            (**(code **)(*(int *)(&DAT_0015f698 + local_10 * 4) + 0x1c))(
                *(undefined4 *)(&DAT_0015f698 + local_10 * 4));
            free(*(void **)(&DAT_0015f698 + local_10 * 4));
            *(undefined4 *)(&DAT_0015f698 + local_10 * 4) = 0;
        }
    }
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(undefined4 *)(&DAT_0015f698 + local_10 * 4) = auStack_410[local_10];
    }
    DAT_0015f798 = local_c;
    pthread_mutex_unlock((pthread_mutex_t *)&DAT_0015f79c);
    return;
}

undefined4 FUN_0006ebcc(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "chain", param_3, param_4);
    return param_1;
}

void FUN_0006ec00(int param_1)

{
    uint uVar1;
    uint uVar2;
    int iVar3;
    undefined8 uVar4;

    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x2c));
    clock_gettime(1, (timespec *)(param_1 + 0x18));
    iVar3 = *(int *)(param_1 + 0x18) - *(int *)(param_1 + 0x10);
    uVar4 = VectorShiftLeft((longlong)iVar3, 5, 0x40, 0);
    uVar4 = VectorSub(uVar4, (longlong)iVar3, 8);
    uVar4 = VectorAdd(uVar4, uVar4, 8);
    uVar1 = (uint)uVar4;
    uVar4 = VectorAdd(CONCAT44((int)((ulonglong)uVar4 >> 0x20) * 2 +
                                   (uint)CARRY4(uVar1, uVar1),
                               uVar1 * 2),
                      (longlong)iVar3, 8);
    uVar4 = VectorShiftLeft(uVar4, 3, 0x40, 0);
    uVar1 = (*(int *)(param_1 + 0x1c) - *(int *)(param_1 + 0x14)) / 1000000;
    uVar2 = uVar1 + (uint)uVar4;
    iVar3 = ((int)uVar1 >> 0x1f) + (int)((ulonglong)uVar4 >> 0x20) +
            (uint)CARRY4(uVar1, (uint)uVar4);
    clock_gettime(1, (timespec *)(param_1 + 0x10));
    uVar1 = *(uint *)(param_1 + 8);
    if (iVar3 < 0) {
        uVar2 = 0;
        iVar3 = 0;
    }
    *(uint *)(param_1 + 8) = uVar1 - uVar2;
    *(uint *)(param_1 + 0xc) =
        *(int *)(param_1 + 0xc) - (iVar3 + (uint)(uVar1 < uVar2));
    if (*(int *)(param_1 + 0xc) < 0) {
        *(undefined8 *)(param_1 + 8) = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x2c));
    return;
}

bool FUN_0006ed60(char *param_1)

{
    int iVar1;
    int iVar2;
    bool bVar3;

    if (param_1[0x28] == '\x01') {
        FUN_0006ec00(param_1);
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x2c));
        if (((*param_1 == '\x01') || ((int)(uint)(*(int *)(param_1 + 8) == 0) <=
                                      *(int *)(param_1 + 0xc))) ||
            ((int)(uint)(*(int *)(param_1 + 0x20) == 0) <=
             *(int *)(param_1 + 0x24))) {
            param_1[0x28] = '\x01';
        } else {
            param_1[0x28] = '\0';
        }
        iVar1 = *(int *)(param_1 + 0x20) + -1;
        iVar2 =
            *(int *)(param_1 + 0x24) - (uint)(*(int *)(param_1 + 0x20) == 0);
        if (iVar2 < 0) {
            iVar1 = 0;
            iVar2 = 0;
        }
        *(int *)(param_1 + 0x20) = iVar1;
        *(int *)(param_1 + 0x24) = iVar2;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x2c));
        bVar3 = param_1[0x28] == '\x01';
    } else {
        bVar3 = false;
    }
    return bVar3;
}

void set_remain_debug_print_time(int param_1, undefined4 param_2, int param_3,
                                 int param_4)

{
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x2c));
    *(int *)(param_1 + 8) = param_3;
    *(int *)(param_1 + 0xc) = param_4;
    clock_gettime(1, (timespec *)(param_1 + 0x10));
    if ((int)(uint)(param_3 == 0) <= param_4) {
        *(undefined1 *)(param_1 + 0x28) = 1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x2c));
    return;
}

void set_remain_debug_print_lines(int param_1, undefined4 param_2, int param_3,
                                  int param_4)

{
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x2c));
    *(int *)(param_1 + 0x20) = param_3;
    *(int *)(param_1 + 0x24) = param_4;
    if ((int)(uint)(param_3 == 0) <= param_4) {
        *(undefined1 *)(param_1 + 0x28) = 1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x2c));
    return;
}

void set_debug_always_print(char *param_1, char param_2)

{
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x2c));
    *param_1 = param_2;
    if (param_2 != '\0') {
        param_1[0x28] = '\x01';
    }
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x2c));
    return;
}

void check_and_print_uart_debug_log(undefined4 param_1, int param_2,
                                    byte *param_3, int param_4, char param_5)

{
    byte bVar1;
    int iVar2;
    char acStack_1460[1024];
    undefined1 auStack_1060[4096];
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    int local_1c;
    byte *local_18;
    int local_14;

    if ((param_2 != 0) && (iVar2 = FUN_0006ed60(param_1), iVar2 != 0)) {
        local_14 = 0;
        local_18 = param_3;
        for (local_1c = 0; local_1c < param_2; local_1c = local_1c + 1) {
            bVar1 = *local_18;
            local_18 = local_18 + 1;
            iVar2 = snprintf(acStack_1460 + local_14, 0x400 - local_14, "%02x ",
                             (uint)bVar1);
            local_14 = local_14 + iVar2;
        }
        if (param_5 == '\0') {
            V_LOCK();
            FUN_0006ebcc(&local_40, &local_40, param_4, param_4 >> 0x1f);
            logfmt_raw(auStack_1060, 0x1000, 0, uStack_24, local_40, uStack_3c,
                       uStack_38, uStack_34, local_30, uStack_2c, uStack_28,
                       uStack_24, "Rx: %s", acStack_1460);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "uart_debug_logger.c",
                 0xa5, "check_and_print_uart_debug_log", 0x1e, 0x55, 0x28,
                 auStack_1060);
        } else {
            V_LOCK();
            FUN_0006ebcc(&local_60, &local_60, param_4, param_4 >> 0x1f);
            logfmt_raw(auStack_1060, 0x1000, 0, uStack_44, local_60, uStack_5c,
                       uStack_58, uStack_54, local_50, uStack_4c, uStack_48,
                       uStack_44, "Tx: %s", acStack_1460);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "uart_debug_logger.c",
                 0xa5, "check_and_print_uart_debug_log", 0x1e, 0x53, 0x28,
                 auStack_1060);
        }
    }
    return;
}

void FUN_0006f280(int param_1)

{
    bool bVar1;
    int iVar2;
    int *piVar3;

    if ((param_1 != 0) && (*(int *)(param_1 + 4) != -1)) {
        piVar3 = (int *)(param_1 + 4);
        DataMemoryBarrier(0xb);
        do {
            iVar2 = *piVar3;
            bVar1 = (bool)hasExclusiveAccess(piVar3);
        } while (!bVar1);
        *piVar3 = iVar2 + -1;
        if (iVar2 + -1 == 0) {
            json_delete(param_1);
        }
    }
    return;
}

uint FUN_0006f2e8(char *param_1)

{
    int iVar1;
    uint local_c;

    local_c = 0;
    while (true) {
        if (2 < local_c) {
            return 3;
        }
        iVar1 = strcmp(param_1, (&PTR_s_TMP451_0014fc40)[local_c]);
        if (iVar1 == 0)
            break;
        local_c = local_c + 1;
    }
    return local_c;
}

int FUN_0006f35c(char *param_1)

{
    int iVar1;
    int local_c;

    local_c = 0;
    while (iVar1 = strcmp(param_1, (&PTR_s_air_in_0014fc80)[local_c]),
           iVar1 != 0) {
        local_c = local_c + 1;
    }
    return local_c;
}

int FUN_0006f3c0(char *param_1)

{
    int iVar1;
    int local_c;

    local_c = 0;
    while (iVar1 = strcmp(param_1, (&PTR_DAT_0014fca0)[local_c]), iVar1 != 0) {
        local_c = local_c + 1;
    }
    return local_c;
}

int FUN_0006f424(char *param_1)

{
    int iVar1;
    int local_c;

    local_c = 0;
    while (iVar1 = strcmp(param_1, (&PTR_s_AT24C02D_0014fc00)[local_c]),
           iVar1 != 0) {
        local_c = local_c + 1;
    }
    return local_c;
}

undefined4 FUN_0006f4e0(void)

{
    undefined4 uVar1;
    undefined1 auStack_100c[4096];
    size_t local_c;

    local_c = topol_machine._4_4_;
    V_LOCK();
    logfmt_raw(auStack_100c, 0x1000, 0, "chain_num %d", local_c);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/backend/topol/topol.c",
         0x9f, "_alloc_chain", 0xc, 0x51, 0x14, auStack_100c);
    topol_machine._36_4_ = calloc(local_c, 0x78);
    if ((void *)topol_machine._36_4_ == (void *)0x0) {
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, "malloc %d chain_t failed",
                   local_c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_alloc_chain", 0xc, 0x56, 100, auStack_100c);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, "Sweep error string = %s.",
                   &DAT_0011a3b0);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_alloc_chain", 0xc, 0x57, 100, auStack_100c);
        uVar1 = 0xffffffff;
    } else {
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 FUN_0006f6c8(void)

{
    void *pvVar1;
    undefined4 uVar2;
    undefined1 auStack_1014[4096];
    size_t local_14;

    uVar2 = topol_machine._36_4_;
    local_14 = *(size_t *)(topol_machine._36_4_ + 0x5c);
    pvVar1 = calloc(local_14, 0x18);
    *(void **)(uVar2 + 0x54) = pvVar1;
    if (*(int *)(topol_machine._36_4_ + 0x54) == 0) {
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, "calloc sensor failed!");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_alloc_sensor", 0xd, 0x62, 100, auStack_1014);
        uVar2 = 0xffffffff;
    } else {
        uVar2 = 0;
    }
    return uVar2;
}

void FUN_0006f7b4(void)

{
    undefined4 uVar1;
    undefined4 local_c;

    uVar1 = topol_machine._4_4_;
    for (local_c = 1; local_c < (int)uVar1; local_c = local_c + 1) {
        memcpy((void *)(topol_machine._36_4_ + local_c * 0x78),
               (void *)topol_machine._36_4_, 0x78);
    }
    return;
}

undefined4 FUN_0006f850(undefined4 param_1)

{
    size_t sVar1;
    undefined4 uVar2;
    undefined1 auStack_1010[4096];
    char *local_10;
    int *local_c;

    local_c = (int *)json_object_get(param_1, "machine");
    if ((local_c == (int *)0x0) || (*local_c != 2)) {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, "get machine failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_machine", 0xe, 0x8c, 100, auStack_1010);
        uVar2 = 0xffffffff;
    } else {
        V_LOCK();
        uVar2 = json_string_value(local_c);
        logfmt_raw(auStack_1010, 0x1000, 0, "load machine %s conf", uVar2);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_machine", 0xe, 0x8f, 0x14, auStack_1010);
        local_10 = (char *)json_string_value(local_c);
        sVar1 = strlen(local_10);
        topol_machine._0_4_ = calloc(sVar1 + 1, 1);
        if ((char *)topol_machine._0_4_ == (char *)0x0) {
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0,
                       "get machine failed, Cannot allocate space");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_machine", 0xe, 0x95, 100, auStack_1010);
            uVar2 = 0xffffffff;
        } else {
            strcpy((char *)topol_machine._0_4_, local_10);
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0, "machine : %s ",
                       topol_machine._0_4_);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_machine", 0xe, 0x9a, 0x14, auStack_1010);
            local_c = (int *)json_object_get(param_1, "hw_version");
            if ((local_c == (int *)0x0) || (*local_c != 2)) {
                V_LOCK();
                logfmt_raw(auStack_1010, 0x1000, 0, "get hw_version failed");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_machine", 0xe, 0x9f, 100, auStack_1010);
                uVar2 = 0xffffffff;
            } else {
                V_LOCK();
                uVar2 = json_string_value(local_c);
                logfmt_raw(auStack_1010, 0x1000, 0, "hw_version: %s", uVar2);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_machine", 0xe, 0xa2, 0x14, auStack_1010);
                local_c = (int *)json_object_get(param_1, "sw_version");
                if ((local_c == (int *)0x0) || (*local_c != 2)) {
                    V_LOCK();
                    logfmt_raw(auStack_1010, 0x1000, 0,
                               "get sw_version failed");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/topol/topol.c",
                         0x9f, "_parse_machine", 0xe, 0xa7, 100, auStack_1010);
                    uVar2 = 0xffffffff;
                } else {
                    V_LOCK();
                    uVar2 = json_string_value(local_c);
                    logfmt_raw(auStack_1010, 0x1000, 0, "sw_version: %s",
                               uVar2);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/topol/topol.c",
                         0x9f, "_parse_machine", 0xe, 0xaa, 0x14, auStack_1010);
                    uVar2 = 0;
                }
            }
        }
    }
    return uVar2;
}

undefined4 FUN_0006fd8c(undefined4 param_1)

{
    undefined4 uVar1;
    undefined1 auStack_1010[4096];
    int *local_10;
    int *local_c;

    local_10 = (int *)json_object_get(param_1, "processor");
    if ((local_10 == (int *)0x0) || (*local_10 != 0)) {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, "get processor failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_processor", 0x10, 0xb6, 100, auStack_1010);
        uVar1 = 0xffffffff;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, "processor:");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_processor", 0x10, 0xb9, 0x14, auStack_1010);
        local_c = (int *)json_object_get(local_10, &DAT_0011a4d4);
        if ((local_c == (int *)0x0) || (*local_c != 2)) {
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0, "get type failed");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_processor", 0x10, 0xbe, 100, auStack_1010);
            uVar1 = 0xffffffff;
        } else {
            V_LOCK();
            uVar1 = json_string_value(local_c);
            logfmt_raw(auStack_1010, 0x1000, 0, "type: %s", uVar1);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_processor", 0x10, 0xc1, 0x14, auStack_1010);
            uVar1 = 0;
        }
    }
    return uVar1;
}

undefined4 FUN_00070010(undefined4 param_1)

{
    uint uVar1;
    undefined2 uVar2;
    undefined4 uVar3;
    undefined1 auStack_1014[4096];
    int *local_14;
    int local_10;
    int *local_c;

    local_14 = (int *)json_object_get(param_1, "power");
    if ((local_14 == (int *)0x0) || (*local_14 != 0)) {
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, "get power failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_power", 0xc, 0xcd, 100, auStack_1014);
        uVar3 = 0xffffffff;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, "power:");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_power", 0xc, 0xd0, 0x14, auStack_1014);
        local_c = (int *)json_object_get(local_14, &DAT_0011a4d4);
        if ((local_c == (int *)0x0) || (*local_c != 2)) {
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0, "get type failed");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_power", 0xc, 0xd5, 100, auStack_1014);
            uVar3 = 0xffffffff;
        } else {
            V_LOCK();
            uVar3 = json_string_value(local_c);
            logfmt_raw(auStack_1014, 0x1000, 0, "type: %s", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_power", 0xc, 0xd8, 0x14, auStack_1014);
            local_c = (int *)json_object_get(local_14, "version");
            if ((local_c == (int *)0x0) || (*local_c != 1)) {
                V_LOCK();
                logfmt_raw(auStack_1014, 0x1000, 0, "get version array failed");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_power", 0xc, 0xdd, 100, auStack_1014);
                uVar3 = 0xffffffff;
            } else {
                topol_machine._96_4_ = json_array_size(local_c);
                topol_machine._120_4_ = calloc(topol_machine._96_4_, 2);
                local_10 = 0;
                while (true) {
                    if ((int)topol_machine._96_4_ <= local_10)
                        break;
                    uVar3 = json_array_get(local_c, local_10);
                    uVar2 = json_integer_value(uVar3);
                    *(undefined2 *)(topol_machine._120_4_ + local_10 * 2) =
                        uVar2;
                    V_LOCK();
                    logfmt_raw(
                        auStack_1014, 0x1000, 0, "psu version = 0x%x",
                        *(undefined2 *)(topol_machine._120_4_ + local_10 * 2));
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/topol/topol.c",
                         0x9f, "_parse_power", 0xc, 0xe4, 0x14, auStack_1014);
                    local_10 = local_10 + 1;
                }
                local_c =
                    (int *)json_object_get(local_14, "is_adjustable_power");
                if (((local_c == (int *)0x0) || (*local_c != 5)) &&
                    ((local_c == (int *)0x0 || (*local_c != 6)))) {
                    V_LOCK();
                    logfmt_raw(auStack_1014, 0x1000, 0,
                               "get is_adjustable_power failed!");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/topol/topol.c",
                         0x9f, "_parse_power", 0xc, 0xea, 100, auStack_1014);
                    uVar3 = 0xffffffff;
                } else {
                    V_LOCK();
                    if ((local_c == (int *)0x0) || (*local_c != 5)) {
                        uVar1 = 0xa590;
                    } else {
                        uVar1 = 0xa588;
                    }
                    logfmt_raw(auStack_1014, 0x1000, 0,
                               "is_adjustable_power: %s", uVar1 | 0x110000);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/topol/topol.c",
                         0x9f, "_parse_power", 0xc, 0xed, 0x14, auStack_1014);
                    if ((local_c == (int *)0x0) || (*local_c != 5)) {
                        topol_machine[100] = 0;
                    } else {
                        topol_machine[100] = 1;
                    }
                    local_c = (int *)json_object_get(
                        local_14, "check_asic_voltage_enable");
                    if (((local_c == (int *)0x0) || (*local_c != 5)) &&
                        ((local_c == (int *)0x0 || (*local_c != 6)))) {
                        V_LOCK();
                        logfmt_raw(auStack_1014, 0x1000, 0,
                                   "get check_asic_voltage_enable failed!");
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/topol/"
                             "topol.c",
                             0x9f, "_parse_power", 0xc, 0xf3, 100,
                             auStack_1014);
                        uVar3 = 0xffffffff;
                    } else {
                        V_LOCK();
                        if ((local_c == (int *)0x0) || (*local_c != 5)) {
                            uVar1 = 0xa590;
                        } else {
                            uVar1 = 0xa588;
                        }
                        logfmt_raw(auStack_1014, 0x1000, 0,
                                   "check_asic_voltage_enable: %s",
                                   uVar1 | 0x110000);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/topol/"
                             "topol.c",
                             0x9f, "_parse_power", 0xc, 0xf6, 0x14,
                             auStack_1014);
                        if ((local_c == (int *)0x0) || (*local_c != 5)) {
                            topol_machine[0x65] = 0;
                        } else {
                            topol_machine[0x65] = 1;
                        }
                        local_c = (int *)json_object_get(local_14,
                                                         "check_asic_voltage");
                        if ((local_c == (int *)0x0) || (*local_c != 3)) {
                            V_LOCK();
                            logfmt_raw(auStack_1014, 0x1000, 0,
                                       "get check_asic_voltage failed!");
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/backend/"
                                 "topol/topol.c",
                                 0x9f, "_parse_power", 0xc, 0xfc, 100,
                                 auStack_1014);
                            uVar3 = 0xffffffff;
                        } else {
                            V_LOCK();
                            uVar3 = json_integer_value(local_c);
                            logfmt_raw(auStack_1014, 0x1000, 0,
                                       "check_asic_voltage: %d", uVar3);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/backend/"
                                 "topol/topol.c",
                                 0x9f, "_parse_power", 0xc, 0xff, 0x14,
                                 auStack_1014);
                            topol_machine._104_4_ = json_integer_value(local_c);
                            local_c =
                                (int *)json_object_get(local_14, "i2c_addr");
                            if ((local_c == (int *)0x0) || (*local_c != 3)) {
                                V_LOCK();
                                logfmt_raw(auStack_1014, 0x1000, 0,
                                           "get i2c_addr failed");
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/backend/"
                                     "topol/topol.c",
                                     0x9f, "_parse_power", 0xc, 0x105, 100,
                                     auStack_1014);
                                uVar3 = 0xffffffff;
                            } else {
                                V_LOCK();
                                uVar3 = json_integer_value(local_c);
                                logfmt_raw(auStack_1014, 0x1000, 0,
                                           "i2c_addr: %d", uVar3);
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/backend/"
                                     "topol/topol.c",
                                     0x9f, "_parse_power", 0xc, 0x108, 0x14,
                                     auStack_1014);
                                topol_machine._108_4_ =
                                    json_integer_value(local_c);
                                local_c = (int *)json_object_get(local_14,
                                                                 &DAT_0011a690);
                                if ((local_c == (int *)0x0) ||
                                    (*local_c != 3)) {
                                    V_LOCK();
                                    logfmt_raw(auStack_1014, 0x1000, 0,
                                               "get gpio failed");
                                    V_UNLOCK();
                                    zlog(g_zc,
                                         "/workspace/jenkins/jenkins/workspace/"
                                         "Antminer_L9_CVCtrl_release/build/"
                                         "rootfs/buildroot/tmp/release/build/"
                                         "godminer-origin_godminer-branch1/"
                                         "backend/topol/topol.c",
                                         0x9f, "_parse_power", 0xc, 0x10e, 100,
                                         auStack_1014);
                                    uVar3 = 0xffffffff;
                                } else {
                                    V_LOCK();
                                    uVar3 = json_integer_value(local_c);
                                    logfmt_raw(auStack_1014, 0x1000, 0,
                                               "gpio: %d", uVar3);
                                    V_UNLOCK();
                                    zlog(g_zc,
                                         "/workspace/jenkins/jenkins/workspace/"
                                         "Antminer_L9_CVCtrl_release/build/"
                                         "rootfs/buildroot/tmp/release/build/"
                                         "godminer-origin_godminer-branch1/"
                                         "backend/topol/topol.c",
                                         0x9f, "_parse_power", 0xc, 0x111, 0x14,
                                         auStack_1014);
                                    topol_machine._112_4_ =
                                        json_integer_value(local_c);
                                    uVar3 = 0;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return uVar3;
}

undefined4 FUN_00070bdc(undefined4 param_1)

{
    uint uVar1;
    undefined4 uVar2;
    double dVar3;
    undefined8 uVar4;
    undefined1 auStack_102c[4096];
    undefined4 local_2c;
    undefined4 local_28;
    int *local_24;
    size_t local_20;
    uint local_1c;
    int *local_18;
    int *local_14;

    local_2c = 0;
    local_28 = 0;
    local_18 = (int *)json_object_get(param_1, &DAT_0011a6b4);
    if ((local_18 == (int *)0x0) || (*local_18 != 0)) {
        V_LOCK();
        logfmt_raw(auStack_102c, 0x1000, 0, "get fan failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_fan", 10, 0x120, 100, auStack_102c);
        uVar2 = 0xffffffff;
    } else {
        local_14 = (int *)json_object_get(local_18, "fan_control_mode");
        if ((local_14 == (int *)0x0) || (*local_14 != 3)) {
            V_LOCK();
            logfmt_raw(auStack_102c, 0x1000, 0, "get fan_control_mode failed!");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_fan", 10, 0x127, 100, auStack_102c);
            uVar2 = 0xffffffff;
        } else {
            V_LOCK();
            uVar2 = json_integer_value(local_14);
            logfmt_raw(auStack_102c, 0x1000, 0, "fan_control_mode: %d", uVar2);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_fan", 10, 0x12a, 0x14, auStack_102c);
            topol_machine._40_4_ = json_integer_value(local_14);
            local_14 = (int *)json_object_get(local_18, "pwm_percent_min");
            if ((local_14 == (int *)0x0) || (*local_14 != 3)) {
                V_LOCK();
                logfmt_raw(auStack_102c, 0x1000, 0,
                           "get pwm_percent_min failed!");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_fan", 10, 0x130, 100, auStack_102c);
                uVar2 = 0xffffffff;
            } else {
                V_LOCK();
                uVar2 = json_integer_value(local_14);
                logfmt_raw(auStack_102c, 0x1000, 0, "pwm_percent_min: %d",
                           uVar2);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_fan", 10, 0x133, 0x14, auStack_102c);
                topol_machine._44_4_ = json_integer_value(local_14);
                local_14 = (int *)json_object_get(local_18, "pwm_percent_max");
                if ((local_14 == (int *)0x0) || (*local_14 != 3)) {
                    V_LOCK();
                    logfmt_raw(auStack_102c, 0x1000, 0,
                               "get pwm_percent_max failed!");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/topol/topol.c",
                         0x9f, "_parse_fan", 10, 0x139, 100, auStack_102c);
                    uVar2 = 0xffffffff;
                } else {
                    V_LOCK();
                    uVar2 = json_integer_value(local_14);
                    logfmt_raw(auStack_102c, 0x1000, 0, "pwm_percent_max: %d",
                               uVar2);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/topol/topol.c",
                         0x9f, "_parse_fan", 10, 0x13c, 0x14, auStack_102c);
                    topol_machine._48_4_ = json_integer_value(local_14);
                    local_14 = (int *)json_object_get(local_18,
                                                      "full_speed_temp_type");
                    if ((local_14 == (int *)0x0) || (*local_14 != 3)) {
                        V_LOCK();
                        logfmt_raw(auStack_102c, 0x1000, 0,
                                   "get full_speed_temp_type failed!");
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/topol/"
                             "topol.c",
                             0x9f, "_parse_fan", 10, 0x142, 100, auStack_102c);
                        uVar2 = 0xffffffff;
                    } else {
                        V_LOCK();
                        uVar2 = json_integer_value(local_14);
                        logfmt_raw(auStack_102c, 0x1000, 0,
                                   "full_speed_temp_type: %d", uVar2);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/topol/"
                             "topol.c",
                             0x9f, "_parse_fan", 10, 0x145, 0x14, auStack_102c);
                        topol_machine._52_4_ = json_integer_value(local_14);
                        local_14 =
                            (int *)json_object_get(local_18, "full_speed_temp");
                        if ((local_14 == (int *)0x0) || (*local_14 != 3)) {
                            V_LOCK();
                            logfmt_raw(auStack_102c, 0x1000, 0,
                                       "get full_speed_temp failed!");
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/backend/"
                                 "topol/topol.c",
                                 0x9f, "_parse_fan", 10, 0x14b, 100,
                                 auStack_102c);
                            uVar2 = 0xffffffff;
                        } else {
                            V_LOCK();
                            uVar2 = json_integer_value(local_14);
                            logfmt_raw(auStack_102c, 0x1000, 0,
                                       "full_speed_temp: %d", uVar2);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/backend/"
                                 "topol/topol.c",
                                 0x9f, "_parse_fan", 10, 0x14e, 0x14,
                                 auStack_102c);
                            topol_machine._56_4_ = json_integer_value(local_14);
                            local_14 = (int *)json_object_get(
                                local_18, "target_temp_type");
                            if ((local_14 == (int *)0x0) || (*local_14 != 3)) {
                                V_LOCK();
                                logfmt_raw(auStack_102c, 0x1000, 0,
                                           "get target_temp_type failed!");
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/backend/"
                                     "topol/topol.c",
                                     0x9f, "_parse_fan", 10, 0x154, 100,
                                     auStack_102c);
                                uVar2 = 0xffffffff;
                            } else {
                                V_LOCK();
                                uVar2 = json_integer_value(local_14);
                                logfmt_raw(auStack_102c, 0x1000, 0,
                                           "target_temp_type: %d", uVar2);
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/backend/"
                                     "topol/topol.c",
                                     0x9f, "_parse_fan", 10, 0x157, 0x14,
                                     auStack_102c);
                                topol_machine._60_4_ =
                                    json_integer_value(local_14);
                                local_14 = (int *)json_object_get(
                                    local_18, "target_temp");
                                if ((local_14 == (int *)0x0) ||
                                    (*local_14 != 3)) {
                                    V_LOCK();
                                    logfmt_raw(auStack_102c, 0x1000, 0,
                                               "get target_temp failed!");
                                    V_UNLOCK();
                                    zlog(g_zc,
                                         "/workspace/jenkins/jenkins/workspace/"
                                         "Antminer_L9_CVCtrl_release/build/"
                                         "rootfs/buildroot/tmp/release/build/"
                                         "godminer-origin_godminer-branch1/"
                                         "backend/topol/topol.c",
                                         0x9f, "_parse_fan", 10, 0x15d, 100,
                                         auStack_102c);
                                    uVar2 = 0xffffffff;
                                } else {
                                    V_LOCK();
                                    uVar2 = json_integer_value(local_14);
                                    logfmt_raw(auStack_102c, 0x1000, 0,
                                               "target_temp: %d", uVar2);
                                    V_UNLOCK();
                                    zlog(g_zc,
                                         "/workspace/jenkins/jenkins/workspace/"
                                         "Antminer_L9_CVCtrl_release/build/"
                                         "rootfs/buildroot/tmp/release/build/"
                                         "godminer-origin_godminer-branch1/"
                                         "backend/topol/topol.c",
                                         0x9f, "_parse_fan", 10, 0x160, 0x14,
                                         auStack_102c);
                                    topol_machine._64_4_ =
                                        json_integer_value(local_14);
                                    local_14 = (int *)json_object_get(
                                        local_18, "initial_interval");
                                    if ((local_14 == (int *)0x0) ||
                                        (*local_14 != 3)) {
                                        V_LOCK();
                                        logfmt_raw(
                                            auStack_102c, 0x1000, 0,
                                            "get initial_interval failed!");
                                        V_UNLOCK();
                                        zlog(g_zc,
                                             "/workspace/jenkins/jenkins/"
                                             "workspace/"
                                             "Antminer_L9_CVCtrl_release/build/"
                                             "rootfs/buildroot/tmp/release/"
                                             "build/"
                                             "godminer-origin_godminer-branch1/"
                                             "backend/topol/topol.c",
                                             0x9f, "_parse_fan", 10, 0x166, 100,
                                             auStack_102c);
                                        uVar2 = 0xffffffff;
                                    } else {
                                        V_LOCK();
                                        uVar2 = json_integer_value(local_14);
                                        logfmt_raw(auStack_102c, 0x1000, 0,
                                                   "initial_interval: %d",
                                                   uVar2);
                                        V_UNLOCK();
                                        zlog(g_zc,
                                             "/workspace/jenkins/jenkins/"
                                             "workspace/"
                                             "Antminer_L9_CVCtrl_release/build/"
                                             "rootfs/buildroot/tmp/release/"
                                             "build/"
                                             "godminer-origin_godminer-branch1/"
                                             "backend/topol/topol.c",
                                             0x9f, "_parse_fan", 10, 0x169,
                                             0x14, auStack_102c);
                                        topol_machine._68_4_ =
                                            json_integer_value(local_14);
                                        local_14 = (int *)json_object_get(
                                            local_18, "interval");
                                        if ((local_14 == (int *)0x0) ||
                                            (*local_14 != 3)) {
                                            V_LOCK();
                                            logfmt_raw(auStack_102c, 0x1000, 0,
                                                       "get interval failed!");
                                            V_UNLOCK();
                                            zlog(
                                                g_zc,
                                                "/workspace/jenkins/jenkins/"
                                                "workspace/"
                                                "Antminer_L9_CVCtrl_release/"
                                                "build/rootfs/buildroot/tmp/"
                                                "release/build/"
                                                "godminer-origin_godminer-"
                                                "branch1/backend/topol/topol.c",
                                                0x9f, "_parse_fan", 10, 0x16f,
                                                100, auStack_102c);
                                            uVar2 = 0xffffffff;
                                        } else {
                                            V_LOCK();
                                            uVar2 =
                                                json_integer_value(local_14);
                                            logfmt_raw(auStack_102c, 0x1000, 0,
                                                       "interval: %d", uVar2);
                                            V_UNLOCK();
                                            zlog(
                                                g_zc,
                                                "/workspace/jenkins/jenkins/"
                                                "workspace/"
                                                "Antminer_L9_CVCtrl_release/"
                                                "build/rootfs/buildroot/tmp/"
                                                "release/build/"
                                                "godminer-origin_godminer-"
                                                "branch1/backend/topol/topol.c",
                                                0x9f, "_parse_fan", 10, 0x172,
                                                0x14, auStack_102c);
                                            topol_machine._72_4_ =
                                                json_integer_value(local_14);
                                            local_14 = (int *)json_object_get(
                                                local_18, "startup_Kp");
                                            if ((local_14 == (int *)0x0) ||
                                                (*local_14 != 3)) {
                                                V_LOCK();
                                                logfmt_raw(
                                                    auStack_102c, 0x1000, 0,
                                                    "get startup_Kp failed!");
                                                V_UNLOCK();
                                                zlog(g_zc,
                                                     "/workspace/jenkins/"
                                                     "jenkins/workspace/"
                                                     "Antminer_L9_CVCtrl_"
                                                     "release/build/rootfs/"
                                                     "buildroot/tmp/release/"
                                                     "build/"
                                                     "godminer-origin_godminer-"
                                                     "branch1/backend/topol/"
                                                     "topol.c",
                                                     0x9f, "_parse_fan", 10,
                                                     0x178, 100, auStack_102c);
                                                uVar2 = 0xffffffff;
                                            } else {
                                                V_LOCK();
                                                uVar2 = json_integer_value(
                                                    local_14);
                                                logfmt_raw(auStack_102c, 0x1000,
                                                           0, "startup_Kp: %d",
                                                           uVar2);
                                                V_UNLOCK();
                                                zlog(g_zc,
                                                     "/workspace/jenkins/"
                                                     "jenkins/workspace/"
                                                     "Antminer_L9_CVCtrl_"
                                                     "release/build/rootfs/"
                                                     "buildroot/tmp/release/"
                                                     "build/"
                                                     "godminer-origin_godminer-"
                                                     "branch1/backend/topol/"
                                                     "topol.c",
                                                     0x9f, "_parse_fan", 10,
                                                     0x17b, 0x14, auStack_102c);
                                                uVar4 = json_integer_value(
                                                    local_14);
                                                dVar3 = (double)FUN_000ccae4(
                                                    (int)uVar4,
                                                    (int)((ulonglong)uVar4 >>
                                                          0x20));
                                                topol_machine._76_4_ =
                                                    (undefined4)(dVar3 / 100.0);
                                                local_14 =
                                                    (int *)json_object_get(
                                                        local_18,
                                                        &DAT_0011a960);
                                                if ((local_14 == (int *)0x0) ||
                                                    (*local_14 != 3)) {
                                                    V_LOCK();
                                                    logfmt_raw(
                                                        auStack_102c, 0x1000, 0,
                                                        "get Kp failed!");
                                                    V_UNLOCK();
                                                    zlog(
                                                        g_zc,
                                                        "/workspace/jenkins/"
                                                        "jenkins/workspace/"
                                                        "Antminer_L9_CVCtrl_"
                                                        "release/build/rootfs/"
                                                        "buildroot/tmp/release/"
                                                        "build/"
                                                        "godminer-origin_"
                                                        "godminer-branch1/"
                                                        "backend/topol/topol.c",
                                                        0x9f, "_parse_fan", 10,
                                                        0x181, 100,
                                                        auStack_102c);
                                                    uVar2 = 0xffffffff;
                                                } else {
                                                    V_LOCK();
                                                    uVar2 = json_integer_value(
                                                        local_14);
                                                    logfmt_raw(auStack_102c,
                                                               0x1000, 0,
                                                               "Kp: %d", uVar2);
                                                    V_UNLOCK();
                                                    zlog(
                                                        g_zc,
                                                        "/workspace/jenkins/"
                                                        "jenkins/workspace/"
                                                        "Antminer_L9_CVCtrl_"
                                                        "release/build/rootfs/"
                                                        "buildroot/tmp/release/"
                                                        "build/"
                                                        "godminer-origin_"
                                                        "godminer-branch1/"
                                                        "backend/topol/topol.c",
                                                        0x9f, "_parse_fan", 10,
                                                        0x184, 0x14,
                                                        auStack_102c);
                                                    uVar4 = json_integer_value(
                                                        local_14);
                                                    dVar3 =
                                                        (double)FUN_000ccae4(
                                                            (int)uVar4,
                                                            (int)((ulonglong)
                                                                      uVar4 >>
                                                                  0x20));
                                                    topol_machine._80_4_ =
                                                        (undefined4)(dVar3 /
                                                                     100.0);
                                                    local_14 =
                                                        (int *)json_object_get(
                                                            local_18,
                                                            &DAT_0011a97c);
                                                    if ((local_14 ==
                                                         (int *)0x0) ||
                                                        (*local_14 != 3)) {
                                                        V_LOCK();
                                                        logfmt_raw(
                                                            auStack_102c,
                                                            0x1000, 0,
                                                            "get Ki failed!");
                                                        V_UNLOCK();
                                                        zlog(g_zc,
                                                             "/workspace/"
                                                             "jenkins/jenkins/"
                                                             "workspace/"
                                                             "Antminer_L9_"
                                                             "CVCtrl_release/"
                                                             "build/rootfs/"
                                                             "buildroot/tmp/"
                                                             "release/build/"
                                                             "godminer-origin_"
                                                             "godminer-branch1/"
                                                             "backend/topol/"
                                                             "topol.c",
                                                             0x9f, "_parse_fan",
                                                             10, 0x18a, 100,
                                                             auStack_102c);
                                                        uVar2 = 0xffffffff;
                                                    } else {
                                                        V_LOCK();
                                                        uVar2 =
                                                            json_integer_value(
                                                                local_14);
                                                        logfmt_raw(auStack_102c,
                                                                   0x1000, 0,
                                                                   "Ki: %d",
                                                                   uVar2);
                                                        V_UNLOCK();
                                                        zlog(g_zc,
                                                             "/workspace/"
                                                             "jenkins/jenkins/"
                                                             "workspace/"
                                                             "Antminer_L9_"
                                                             "CVCtrl_release/"
                                                             "build/rootfs/"
                                                             "buildroot/tmp/"
                                                             "release/build/"
                                                             "godminer-origin_"
                                                             "godminer-branch1/"
                                                             "backend/topol/"
                                                             "topol.c",
                                                             0x9f, "_parse_fan",
                                                             10, 0x18d, 0x14,
                                                             auStack_102c);
                                                        uVar4 =
                                                            json_integer_value(
                                                                local_14);
                                                        dVar3 = (double)
                                                            FUN_000ccae4(
                                                                (int)uVar4,
                                                                (int)((ulonglong)
                                                                          uVar4 >>
                                                                      0x20));
                                                        topol_machine._84_4_ =
                                                            (undefined4)(dVar3 /
                                                                         100.0);
                                                        local_14 = (int *)
                                                            json_object_get(
                                                                local_18,
                                                                &DAT_0011a998);
                                                        if ((local_14 ==
                                                             (int *)0x0) ||
                                                            (*local_14 != 3)) {
                                                            V_LOCK();
                                                            logfmt_raw(
                                                                auStack_102c,
                                                                0x1000, 0,
                                                                "get Kd "
                                                                "failed!");
                                                            V_UNLOCK();
                                                            zlog(
                                                                g_zc,
                                                                "/workspace/"
                                                                "jenkins/"
                                                                "jenkins/"
                                                                "workspace/"
                                                                "Antminer_L9_"
                                                                "CVCtrl_"
                                                                "release/build/"
                                                                "rootfs/"
                                                                "buildroot/tmp/"
                                                                "release/build/"
                                                                "godminer-"
                                                                "origin_"
                                                                "godminer-"
                                                                "branch1/"
                                                                "backend/topol/"
                                                                "topol.c",
                                                                0x9f,
                                                                "_parse_fan",
                                                                10, 0x193, 100,
                                                                auStack_102c);
                                                            uVar2 = 0xffffffff;
                                                        } else {
                                                            V_LOCK();
                                                            uVar2 =
                                                                json_integer_value(
                                                                    local_14);
                                                            logfmt_raw(
                                                                auStack_102c,
                                                                0x1000, 0,
                                                                "Kd: %d",
                                                                uVar2);
                                                            V_UNLOCK();
                                                            zlog(
                                                                g_zc,
                                                                "/workspace/"
                                                                "jenkins/"
                                                                "jenkins/"
                                                                "workspace/"
                                                                "Antminer_L9_"
                                                                "CVCtrl_"
                                                                "release/build/"
                                                                "rootfs/"
                                                                "buildroot/tmp/"
                                                                "release/build/"
                                                                "godminer-"
                                                                "origin_"
                                                                "godminer-"
                                                                "branch1/"
                                                                "backend/topol/"
                                                                "topol.c",
                                                                0x9f,
                                                                "_parse_fan",
                                                                10, 0x196, 0x14,
                                                                auStack_102c);
                                                            uVar4 =
                                                                json_integer_value(
                                                                    local_14);
                                                            dVar3 = (double)FUN_000ccae4(
                                                                (int)uVar4,
                                                                (int)((ulonglong)
                                                                          uVar4 >>
                                                                      0x20));
                                                            topol_machine
                                                                ._88_4_ =
                                                                (undefined4)(dVar3 /
                                                                             100.0);
                                                            local_24 = (int *)
                                                                json_object_get(
                                                                    local_18,
                                                                    "speed_"
                                                                    "info");
                                                            if ((local_24 ==
                                                                 (int *)0x0) ||
                                                                (*local_24 !=
                                                                 1)) {
                                                                V_LOCK();
                                                                logfmt_raw(
                                                                    auStack_102c,
                                                                    0x1000, 0,
                                                                    "get fan "
                                                                    "speed_"
                                                                    "info "
                                                                    "failed");
                                                                V_UNLOCK();
                                                                zlog(
                                                                    g_zc,
                                                                    "/workspace"
                                                                    "/jenkins/"
                                                                    "jenkins/"
                                                                    "workspace/"
                                                                    "Antminer_"
                                                                    "L9_CVCtrl_"
                                                                    "release/"
                                                                    "build/"
                                                                    "rootfs/"
                                                                    "buildroot/"
                                                                    "tmp/"
                                                                    "release/"
                                                                    "build/"
                                                                    "godminer-"
                                                                    "origin_"
                                                                    "godminer-"
                                                                    "branch1/"
                                                                    "backend/"
                                                                    "topol/"
                                                                    "topol.c",
                                                                    0x9f,
                                                                    "_parse_"
                                                                    "fan",
                                                                    10, 0x19c,
                                                                    100,
                                                                    auStack_102c);
                                                                uVar2 =
                                                                    0xffffffff;
                                                            } else {
                                                                V_LOCK();
                                                                logfmt_raw(
                                                                    auStack_102c,
                                                                    0x1000, 0,
                                                                    "fan "
                                                                    "speed_"
                                                                    "info "
                                                                    "info:");
                                                                V_UNLOCK();
                                                                zlog(
                                                                    g_zc,
                                                                    "/workspace"
                                                                    "/jenkins/"
                                                                    "jenkins/"
                                                                    "workspace/"
                                                                    "Antminer_"
                                                                    "L9_CVCtrl_"
                                                                    "release/"
                                                                    "build/"
                                                                    "rootfs/"
                                                                    "buildroot/"
                                                                    "tmp/"
                                                                    "release/"
                                                                    "build/"
                                                                    "godminer-"
                                                                    "origin_"
                                                                    "godminer-"
                                                                    "branch1/"
                                                                    "backend/"
                                                                    "topol/"
                                                                    "topol.c",
                                                                    0x9f,
                                                                    "_parse_"
                                                                    "fan",
                                                                    10, 0x19f,
                                                                    0x14,
                                                                    auStack_102c);
                                                                local_20 =
                                                                    json_array_size(
                                                                        local_24);
                                                                topol_machine
                                                                    ._92_4_ =
                                                                    calloc(
                                                                        local_20,
                                                                        0xc);
                                                                if ((void
                                                                         *)topol_machine
                                                                        ._92_4_ ==
                                                                    (void
                                                                         *)0x0) {
                                                                    V_LOCK();
                                                                    logfmt_raw(
                                                                        auStack_102c,
                                                                        0x1000,
                                                                        0,
                                                                        "calloc"
                                                                        " topol"
                                                                        "_machi"
                                                                        "ne."
                                                                        "fan_"
                                                                        "info."
                                                                        "speeds"
                                                                        " faile"
                                                                        "d!");
                                                                    V_UNLOCK();
                                                                    zlog(
                                                                        g_zc,
                                                                        "/works"
                                                                        "pace/"
                                                                        "jenkin"
                                                                        "s/"
                                                                        "jenkin"
                                                                        "s/"
                                                                        "worksp"
                                                                        "ace/"
                                                                        "Antmin"
                                                                        "er_L9_"
                                                                        "CVCtrl"
                                                                        "_relea"
                                                                        "se/"
                                                                        "build/"
                                                                        "rootfs"
                                                                        "/build"
                                                                        "root/"
                                                                        "tmp/"
                                                                        "releas"
                                                                        "e/"
                                                                        "build/"
                                                                        "godmin"
                                                                        "er-"
                                                                        "origin"
                                                                        "_godmi"
                                                                        "ner-"
                                                                        "branch"
                                                                        "1/"
                                                                        "backen"
                                                                        "d/"
                                                                        "topol/"
                                                                        "topol."
                                                                        "c",
                                                                        0x9f,
                                                                        "_parse"
                                                                        "_fan",
                                                                        10,
                                                                        0x1a4,
                                                                        100,
                                                                        auStack_102c);
                                                                    uVar2 =
                                                                        0xffffffff;
                                                                } else {
                                                                    local_1c =
                                                                        0;
                                                                    while (
                                                                        uVar1 = json_array_size(
                                                                            local_24),
                                                                        local_1c <
                                                                            uVar1) {
                                                                        local_18 =
                                                                            (int *)json_array_get(
                                                                                local_24,
                                                                                local_1c);
                                                                        if ((local_18 ==
                                                                             (int *)0x0) ||
                                                                            (*local_18 !=
                                                                             0)) {
                                                                            V_LOCK();
                                                                            logfmt_raw(
                                                                                auStack_102c,
                                                                                0x1000,
                                                                                0,
                                                                                "get array %d failed",
                                                                                local_1c);
                                                                            V_UNLOCK();
                                                                            zlog(
                                                                                g_zc,
                                                                                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                                                                0x9f,
                                                                                "_parse_fan",
                                                                                10,
                                                                                0x1ad,
                                                                                100,
                                                                                auStack_102c);
                                                                            return 0xffffffff;
                                                                        }
                                                                        local_14 =
                                                                            (int *)json_object_get(
                                                                                local_18,
                                                                                &DAT_0011aa38);
                                                                        if ((local_14 ==
                                                                             (int *)0x0) ||
                                                                            (*local_14 !=
                                                                             3)) {
                                                                            V_LOCK();
                                                                            logfmt_raw(
                                                                                auStack_102c,
                                                                                0x1000,
                                                                                0,
                                                                                "get array %d id failed",
                                                                                local_1c);
                                                                            V_UNLOCK();
                                                                            zlog(
                                                                                g_zc,
                                                                                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                                                                0x9f,
                                                                                "_parse_fan",
                                                                                10,
                                                                                0x1b4,
                                                                                100,
                                                                                auStack_102c);
                                                                            return 0xffffffff;
                                                                        }
                                                                        V_LOCK();
                                                                        uVar2 = json_integer_value(
                                                                            local_14);
                                                                        logfmt_raw(
                                                                            auStack_102c,
                                                                            0x1000,
                                                                            0,
                                                                            "id"
                                                                            ": "
                                                                            "%"
                                                                            "d",
                                                                            uVar2);
                                                                        V_UNLOCK();
                                                                        zlog(
                                                                            g_zc,
                                                                            "/w"
                                                                            "or"
                                                                            "ks"
                                                                            "pa"
                                                                            "ce"
                                                                            "/j"
                                                                            "en"
                                                                            "ki"
                                                                            "ns"
                                                                            "/j"
                                                                            "en"
                                                                            "ki"
                                                                            "ns"
                                                                            "/w"
                                                                            "or"
                                                                            "ks"
                                                                            "pa"
                                                                            "ce"
                                                                            "/A"
                                                                            "nt"
                                                                            "mi"
                                                                            "ne"
                                                                            "r_"
                                                                            "L9"
                                                                            "_C"
                                                                            "VC"
                                                                            "tr"
                                                                            "l_"
                                                                            "re"
                                                                            "le"
                                                                            "as"
                                                                            "e/"
                                                                            "bu"
                                                                            "il"
                                                                            "d/"
                                                                            "ro"
                                                                            "ot"
                                                                            "fs"
                                                                            "/b"
                                                                            "ui"
                                                                            "ld"
                                                                            "ro"
                                                                            "ot"
                                                                            "/t"
                                                                            "mp"
                                                                            "/r"
                                                                            "el"
                                                                            "ea"
                                                                            "se"
                                                                            "/b"
                                                                            "ui"
                                                                            "ld"
                                                                            "/g"
                                                                            "od"
                                                                            "mi"
                                                                            "ne"
                                                                            "r-"
                                                                            "or"
                                                                            "ig"
                                                                            "in"
                                                                            "_g"
                                                                            "od"
                                                                            "mi"
                                                                            "ne"
                                                                            "r-"
                                                                            "br"
                                                                            "an"
                                                                            "ch"
                                                                            "1/"
                                                                            "ba"
                                                                            "ck"
                                                                            "en"
                                                                            "d/"
                                                                            "to"
                                                                            "po"
                                                                            "l/"
                                                                            "to"
                                                                            "po"
                                                                            "l."
                                                                            "c",
                                                                            0x9f,
                                                                            "_p"
                                                                            "ar"
                                                                            "se"
                                                                            "_f"
                                                                            "a"
                                                                            "n",
                                                                            10,
                                                                            0x1b7,
                                                                            0x14,
                                                                            auStack_102c);
                                                                        uVar2 = json_integer_value(
                                                                            local_14);
                                                                        *(undefined4
                                                                              *)(topol_machine
                                                                                     ._92_4_ +
                                                                                 local_1c *
                                                                                     0xc) =
                                                                            uVar2;
                                                                        local_14 = (int *)json_object_get(
                                                                            local_18,
                                                                            "ma"
                                                                            "x_"
                                                                            "sp"
                                                                            "ee"
                                                                            "d");
                                                                        if ((local_14 ==
                                                                             (int *)0x0) ||
                                                                            (*local_14 !=
                                                                             3)) {
                                                                            V_LOCK();
                                                                            logfmt_raw(
                                                                                auStack_102c,
                                                                                0x1000,
                                                                                0,
                                                                                "get array %d max_speed failed",
                                                                                local_1c);
                                                                            V_UNLOCK();
                                                                            zlog(
                                                                                g_zc,
                                                                                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                                                                0x9f,
                                                                                "_parse_fan",
                                                                                10,
                                                                                0x1bd,
                                                                                100,
                                                                                auStack_102c);
                                                                            return 0xffffffff;
                                                                        }
                                                                        V_LOCK();
                                                                        uVar2 = json_integer_value(
                                                                            local_14);
                                                                        logfmt_raw(
                                                                            auStack_102c,
                                                                            0x1000,
                                                                            0,
                                                                            "ma"
                                                                            "x_"
                                                                            "sp"
                                                                            "ee"
                                                                            "d:"
                                                                            " %"
                                                                            "d",
                                                                            uVar2);
                                                                        V_UNLOCK();
                                                                        zlog(
                                                                            g_zc,
                                                                            "/w"
                                                                            "or"
                                                                            "ks"
                                                                            "pa"
                                                                            "ce"
                                                                            "/j"
                                                                            "en"
                                                                            "ki"
                                                                            "ns"
                                                                            "/j"
                                                                            "en"
                                                                            "ki"
                                                                            "ns"
                                                                            "/w"
                                                                            "or"
                                                                            "ks"
                                                                            "pa"
                                                                            "ce"
                                                                            "/A"
                                                                            "nt"
                                                                            "mi"
                                                                            "ne"
                                                                            "r_"
                                                                            "L9"
                                                                            "_C"
                                                                            "VC"
                                                                            "tr"
                                                                            "l_"
                                                                            "re"
                                                                            "le"
                                                                            "as"
                                                                            "e/"
                                                                            "bu"
                                                                            "il"
                                                                            "d/"
                                                                            "ro"
                                                                            "ot"
                                                                            "fs"
                                                                            "/b"
                                                                            "ui"
                                                                            "ld"
                                                                            "ro"
                                                                            "ot"
                                                                            "/t"
                                                                            "mp"
                                                                            "/r"
                                                                            "el"
                                                                            "ea"
                                                                            "se"
                                                                            "/b"
                                                                            "ui"
                                                                            "ld"
                                                                            "/g"
                                                                            "od"
                                                                            "mi"
                                                                            "ne"
                                                                            "r-"
                                                                            "or"
                                                                            "ig"
                                                                            "in"
                                                                            "_g"
                                                                            "od"
                                                                            "mi"
                                                                            "ne"
                                                                            "r-"
                                                                            "br"
                                                                            "an"
                                                                            "ch"
                                                                            "1/"
                                                                            "ba"
                                                                            "ck"
                                                                            "en"
                                                                            "d/"
                                                                            "to"
                                                                            "po"
                                                                            "l/"
                                                                            "to"
                                                                            "po"
                                                                            "l."
                                                                            "c",
                                                                            0x9f,
                                                                            "_p"
                                                                            "ar"
                                                                            "se"
                                                                            "_f"
                                                                            "a"
                                                                            "n",
                                                                            10,
                                                                            0x1c0,
                                                                            0x14,
                                                                            auStack_102c);
                                                                        uVar2 = json_integer_value(
                                                                            local_14);
                                                                        *(undefined4
                                                                              *)(topol_machine
                                                                                     ._92_4_ +
                                                                                 local_1c *
                                                                                     0xc +
                                                                                 8) =
                                                                            uVar2;
                                                                        local_14 = (int *)json_object_get(
                                                                            local_18,
                                                                            "mi"
                                                                            "n_"
                                                                            "sp"
                                                                            "ee"
                                                                            "d");
                                                                        if ((local_14 ==
                                                                             (int *)0x0) ||
                                                                            (*local_14 !=
                                                                             3)) {
                                                                            V_LOCK();
                                                                            logfmt_raw(
                                                                                auStack_102c,
                                                                                0x1000,
                                                                                0,
                                                                                "get array %d min_speed failed",
                                                                                local_1c);
                                                                            V_UNLOCK();
                                                                            zlog(
                                                                                g_zc,
                                                                                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                                                                0x9f,
                                                                                "_parse_fan",
                                                                                10,
                                                                                0x1c6,
                                                                                100,
                                                                                auStack_102c);
                                                                            return 0xffffffff;
                                                                        }
                                                                        V_LOCK();
                                                                        uVar2 = json_integer_value(
                                                                            local_14);
                                                                        logfmt_raw(
                                                                            auStack_102c,
                                                                            0x1000,
                                                                            0,
                                                                            "mi"
                                                                            "n_"
                                                                            "sp"
                                                                            "ee"
                                                                            "d:"
                                                                            " %"
                                                                            "d",
                                                                            uVar2);
                                                                        V_UNLOCK();
                                                                        zlog(
                                                                            g_zc,
                                                                            "/w"
                                                                            "or"
                                                                            "ks"
                                                                            "pa"
                                                                            "ce"
                                                                            "/j"
                                                                            "en"
                                                                            "ki"
                                                                            "ns"
                                                                            "/j"
                                                                            "en"
                                                                            "ki"
                                                                            "ns"
                                                                            "/w"
                                                                            "or"
                                                                            "ks"
                                                                            "pa"
                                                                            "ce"
                                                                            "/A"
                                                                            "nt"
                                                                            "mi"
                                                                            "ne"
                                                                            "r_"
                                                                            "L9"
                                                                            "_C"
                                                                            "VC"
                                                                            "tr"
                                                                            "l_"
                                                                            "re"
                                                                            "le"
                                                                            "as"
                                                                            "e/"
                                                                            "bu"
                                                                            "il"
                                                                            "d/"
                                                                            "ro"
                                                                            "ot"
                                                                            "fs"
                                                                            "/b"
                                                                            "ui"
                                                                            "ld"
                                                                            "ro"
                                                                            "ot"
                                                                            "/t"
                                                                            "mp"
                                                                            "/r"
                                                                            "el"
                                                                            "ea"
                                                                            "se"
                                                                            "/b"
                                                                            "ui"
                                                                            "ld"
                                                                            "/g"
                                                                            "od"
                                                                            "mi"
                                                                            "ne"
                                                                            "r-"
                                                                            "or"
                                                                            "ig"
                                                                            "in"
                                                                            "_g"
                                                                            "od"
                                                                            "mi"
                                                                            "ne"
                                                                            "r-"
                                                                            "br"
                                                                            "an"
                                                                            "ch"
                                                                            "1/"
                                                                            "ba"
                                                                            "ck"
                                                                            "en"
                                                                            "d/"
                                                                            "to"
                                                                            "po"
                                                                            "l/"
                                                                            "to"
                                                                            "po"
                                                                            "l."
                                                                            "c",
                                                                            0x9f,
                                                                            "_p"
                                                                            "ar"
                                                                            "se"
                                                                            "_f"
                                                                            "a"
                                                                            "n",
                                                                            10,
                                                                            0x1c9,
                                                                            0x14,
                                                                            auStack_102c);
                                                                        uVar2 = json_integer_value(
                                                                            local_14);
                                                                        *(undefined4
                                                                              *)(topol_machine
                                                                                     ._92_4_ +
                                                                                 local_1c *
                                                                                     0xc +
                                                                                 4) =
                                                                            uVar2;
                                                                        topol_machine
                                                                            ._32_4_ =
                                                                            topol_machine
                                                                                ._32_4_ +
                                                                            1;
                                                                        local_1c =
                                                                            local_1c +
                                                                            1;
                                                                    }
                                                                    uVar2 = 0;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return uVar2;
}

undefined4 FUN_000725cc(undefined4 param_1)

{
    char *__nptr;
    long lVar1;
    undefined4 uVar2;
    undefined1 auStack_1018[4096];
    int *local_18;
    int *local_14;

    local_18 = (int *)json_object_get(param_1, &DAT_0011aad4);
    if ((local_18 == (int *)0x0) || (*local_18 != 0)) {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, "get asic failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_asic", 0xb, 0x1d9, 100, auStack_1018);
        uVar2 = 0xffffffff;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, "asic:");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_asic", 0xb, 0x1dc, 0x14, auStack_1018);
        local_14 = (int *)json_object_get(local_18, "asic_id");
        if ((local_14 == (int *)0x0) || (*local_14 != 2)) {
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, "get asic_id failed");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_asic", 0xb, 0x1e1, 100, auStack_1018);
            uVar2 = 0xffffffff;
        } else {
            V_LOCK();
            uVar2 = json_string_value(local_14);
            logfmt_raw(auStack_1018, 0x1000, 0, "asic_id: %s", uVar2);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_asic", 0xb, 0x1e4, 0x14, auStack_1018);
            local_14 = (int *)json_object_get(local_18, "chip_type");
            if ((local_14 == (int *)0x0) || (*local_14 != 2)) {
                V_LOCK();
                logfmt_raw(auStack_1018, 0x1000, 0, "get chip_type failed");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_asic", 0xb, 0x1e9, 100, auStack_1018);
                uVar2 = 0xffffffff;
            } else {
                V_LOCK();
                uVar2 = json_string_value(local_14);
                logfmt_raw(auStack_1018, 0x1000, 0, "chip_type : %s", uVar2);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_asic", 0xb, 0x1ec, 0x14, auStack_1018);
                __nptr = (char *)json_string_value(local_14);
                uVar2 = topol_machine._36_4_;
                lVar1 = strtol(__nptr, (char **)0x0, 0);
                *(long *)(uVar2 + 0x18) = lVar1;
                if (*(int *)(topol_machine._36_4_ + 0x18) == 0) {
                    V_LOCK();
                    logfmt_raw(auStack_1018, 0x1000, 0,
                               "convert chip_type failed");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/topol/topol.c",
                         0x9f, "_parse_asic", 0xb, 0x1f1, 100, auStack_1018);
                    uVar2 = 0xffffffff;
                } else {
                    V_LOCK();
                    logfmt_raw(auStack_1018, 0x1000, 0, "chip_type 0x%x",
                               *(undefined4 *)(topol_machine._36_4_ + 0x18));
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/topol/topol.c",
                         0x9f, "_parse_asic", 0xb, 500, 0x14, auStack_1018);
                    local_14 = (int *)json_object_get(local_18, "cycle_cnt");
                    if ((local_14 == (int *)0x0) || (*local_14 != 3)) {
                        V_LOCK();
                        logfmt_raw(auStack_1018, 0x1000, 0,
                                   "get cycle_cnt failed");
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/topol/"
                             "topol.c",
                             0x9f, "_parse_asic", 0xb, 0x1f9, 100,
                             auStack_1018);
                        uVar2 = 0xffffffff;
                    } else {
                        V_LOCK();
                        uVar2 = json_integer_value(local_14);
                        logfmt_raw(auStack_1018, 0x1000, 0, "cycle_cnt : %d",
                                   uVar2);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/topol/"
                             "topol.c",
                             0x9f, "_parse_asic", 0xb, 0x1fc, 0x14,
                             auStack_1018);
                        uVar2 = json_integer_value(local_14);
                        *(undefined4 *)(topol_machine._36_4_ + 0x1c) = uVar2;
                        local_14 = (int *)json_object_get(local_18,
                                                          "asic_big_core_num");
                        if ((local_14 == (int *)0x0) || (*local_14 != 3)) {
                            V_LOCK();
                            logfmt_raw(auStack_1018, 0x1000, 0,
                                       "get asic_big_core_num failed");
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/backend/"
                                 "topol/topol.c",
                                 0x9f, "_parse_asic", 0xb, 0x202, 100,
                                 auStack_1018);
                            uVar2 = 0xffffffff;
                        } else {
                            V_LOCK();
                            uVar2 = json_integer_value(local_14);
                            logfmt_raw(auStack_1018, 0x1000, 0,
                                       "asic_big_core_num: %d", uVar2);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/backend/"
                                 "topol/topol.c",
                                 0x9f, "_parse_asic", 0xb, 0x205, 0x14,
                                 auStack_1018);
                            uVar2 = json_integer_value(local_14);
                            *(undefined4 *)(topol_machine._36_4_ + 0x24) =
                                uVar2;
                            local_14 = (int *)json_object_get(
                                local_18, "asic_little_core_num");
                            if ((local_14 == (int *)0x0) || (*local_14 != 3)) {
                                V_LOCK();
                                logfmt_raw(auStack_1018, 0x1000, 0,
                                           "get asic_little_core_num failed");
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/backend/"
                                     "topol/topol.c",
                                     0x9f, "_parse_asic", 0xb, 0x20b, 100,
                                     auStack_1018);
                                uVar2 = 0xffffffff;
                            } else {
                                V_LOCK();
                                uVar2 = json_integer_value(local_14);
                                logfmt_raw(auStack_1018, 0x1000, 0,
                                           "asic_little_core_num %d", uVar2);
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/backend/"
                                     "topol/topol.c",
                                     0x9f, "_parse_asic", 0xb, 0x20e, 0x14,
                                     auStack_1018);
                                uVar2 = json_integer_value(local_14);
                                *(undefined4 *)(topol_machine._36_4_ + 0x28) =
                                    uVar2;
                                local_14 = (int *)json_object_get(
                                    local_18, "core_little_core_num");
                                if ((local_14 == (int *)0x0) ||
                                    (*local_14 != 3)) {
                                    V_LOCK();
                                    logfmt_raw(
                                        auStack_1018, 0x1000, 0,
                                        "get core_little_core_num failed");
                                    V_UNLOCK();
                                    zlog(g_zc,
                                         "/workspace/jenkins/jenkins/workspace/"
                                         "Antminer_L9_CVCtrl_release/build/"
                                         "rootfs/buildroot/tmp/release/build/"
                                         "godminer-origin_godminer-branch1/"
                                         "backend/topol/topol.c",
                                         0x9f, "_parse_asic", 0xb, 0x214, 100,
                                         auStack_1018);
                                    uVar2 = 0xffffffff;
                                } else {
                                    V_LOCK();
                                    uVar2 = json_integer_value(local_14);
                                    logfmt_raw(auStack_1018, 0x1000, 0,
                                               "core_little_core_num: %d",
                                               uVar2);
                                    V_UNLOCK();
                                    zlog(g_zc,
                                         "/workspace/jenkins/jenkins/workspace/"
                                         "Antminer_L9_CVCtrl_release/build/"
                                         "rootfs/buildroot/tmp/release/build/"
                                         "godminer-origin_godminer-branch1/"
                                         "backend/topol/topol.c",
                                         0x9f, "_parse_asic", 0xb, 0x217, 0x14,
                                         auStack_1018);
                                    uVar2 = json_integer_value(local_14);
                                    *(undefined4 *)(topol_machine._36_4_ +
                                                    0x2c) = uVar2;
                                    local_14 = (int *)json_object_get(
                                        local_18, "asic_domain_num");
                                    if ((local_14 == (int *)0x0) ||
                                        (*local_14 != 3)) {
                                        V_LOCK();
                                        logfmt_raw(
                                            auStack_1018, 0x1000, 0,
                                            "get asic_domain_num failed");
                                        V_UNLOCK();
                                        zlog(g_zc,
                                             "/workspace/jenkins/jenkins/"
                                             "workspace/"
                                             "Antminer_L9_CVCtrl_release/build/"
                                             "rootfs/buildroot/tmp/release/"
                                             "build/"
                                             "godminer-origin_godminer-branch1/"
                                             "backend/topol/topol.c",
                                             0x9f, "_parse_asic", 0xb, 0x21d,
                                             100, auStack_1018);
                                        uVar2 = 0xffffffff;
                                    } else {
                                        V_LOCK();
                                        uVar2 = json_integer_value(local_14);
                                        logfmt_raw(auStack_1018, 0x1000, 0,
                                                   "asic_domain_num : %d",
                                                   uVar2);
                                        V_UNLOCK();
                                        zlog(g_zc,
                                             "/workspace/jenkins/jenkins/"
                                             "workspace/"
                                             "Antminer_L9_CVCtrl_release/build/"
                                             "rootfs/buildroot/tmp/release/"
                                             "build/"
                                             "godminer-origin_godminer-branch1/"
                                             "backend/topol/topol.c",
                                             0x9f, "_parse_asic", 0xb, 0x220,
                                             0x14, auStack_1018);
                                        uVar2 = json_integer_value(local_14);
                                        *(undefined4 *)(topol_machine._36_4_ +
                                                        0x30) = uVar2;
                                        local_14 = (int *)json_object_get(
                                            local_18, "asic_addr_interval");
                                        if ((local_14 == (int *)0x0) ||
                                            (*local_14 != 3)) {
                                            V_LOCK();
                                            logfmt_raw(auStack_1018, 0x1000, 0,
                                                       "get asic_addr_interval "
                                                       "failed");
                                            V_UNLOCK();
                                            zlog(
                                                g_zc,
                                                "/workspace/jenkins/jenkins/"
                                                "workspace/"
                                                "Antminer_L9_CVCtrl_release/"
                                                "build/rootfs/buildroot/tmp/"
                                                "release/build/"
                                                "godminer-origin_godminer-"
                                                "branch1/backend/topol/topol.c",
                                                0x9f, "_parse_asic", 0xb, 0x226,
                                                100, auStack_1018);
                                            uVar2 = 0xffffffff;
                                        } else {
                                            V_LOCK();
                                            uVar2 =
                                                json_integer_value(local_14);
                                            logfmt_raw(
                                                auStack_1018, 0x1000, 0,
                                                "asic_addr_interval : %d",
                                                uVar2);
                                            V_UNLOCK();
                                            zlog(
                                                g_zc,
                                                "/workspace/jenkins/jenkins/"
                                                "workspace/"
                                                "Antminer_L9_CVCtrl_release/"
                                                "build/rootfs/buildroot/tmp/"
                                                "release/build/"
                                                "godminer-origin_godminer-"
                                                "branch1/backend/topol/topol.c",
                                                0x9f, "_parse_asic", 0xb, 0x229,
                                                0x14, auStack_1018);
                                            uVar2 =
                                                json_integer_value(local_14);
                                            *(undefined4 *)(topol_machine
                                                                ._36_4_ +
                                                            0x34) = uVar2;
                                            uVar2 = 0;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return uVar2;
}

undefined4 FUN_000732bc(undefined4 param_1)

{
    int iVar1;
    uint uVar2;
    undefined4 uVar3;
    undefined1 auStack_1020[4096];
    int *local_20;
    uint local_1c;
    int *local_18;
    int local_14;
    int *local_10;
    int *local_c;

    local_20 = (int *)json_object_get(param_1, "pic_sensor");
    if ((local_20 == (int *)0x0) || (*local_20 != 1)) {
        V_LOCK();
        logfmt_raw(auStack_1020, 0x1000, 0, "get pic sensor failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_chain_pic_sensor", 0x17, 0x237, 100, auStack_1020);
        uVar3 = 0xffffffff;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1020, 0x1000, 0, "pic sensor:");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_chain_pic_sensor", 0x17, 0x23a, 0x14, auStack_1020);
        local_1c = 0;
        while (uVar2 = json_array_size(local_20), local_1c < uVar2) {
            local_18 = (int *)json_array_get(local_20, local_1c);
            if ((local_18 == (int *)0x0) || (*local_18 != 0)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0, "get array %d failed",
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_pic_sensor", 0x17, 0x241, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            local_c = (int *)json_object_get(local_18, "index");
            if ((local_c == (int *)0x0) || (*local_c != 3)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0, "get array %d index failed",
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_pic_sensor", 0x17, 0x248, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            V_LOCK();
            uVar3 = json_integer_value(local_c);
            logfmt_raw(auStack_1020, 0x1000, 0, "index: %d", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_pic_sensor", 0x17, 0x24b, 0x14,
                auStack_1020);
            local_14 = json_integer_value(local_c);
            local_10 = (int *)(*(int *)(topol_machine._36_4_ + 0x54) +
                               local_14 * 0x18);
            *local_10 = local_14;
            local_10[2] = 0;
            local_c = (int *)json_object_get(local_18, &DAT_0011a4d4);
            if ((local_c == (int *)0x0) || (*local_c != 2)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0, "get array %d type failed",
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_pic_sensor", 0x17, 0x254, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            V_LOCK();
            uVar3 = json_string_value(local_c);
            logfmt_raw(auStack_1020, 0x1000, 0, "type: %s", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_pic_sensor", 0x17, 599, 0x14, auStack_1020);
            uVar3 = json_string_value(local_c);
            iVar1 = FUN_0006f2e8(uVar3);
            local_10[1] = iVar1;
            local_c = (int *)json_object_get(local_18, &DAT_0011adac);
            if ((local_c == (int *)0x0) || (*local_c != 3)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0,
                           "get array %d bind_asic failed", local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_pic_sensor", 0x17, 0x25d, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            V_LOCK();
            uVar3 = json_integer_value(local_c);
            logfmt_raw(auStack_1020, 0x1000, 0, "iic: %d", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_pic_sensor", 0x17, 0x260, 0x14,
                auStack_1020);
            iVar1 = json_integer_value(local_c);
            local_10[5] = iVar1;
            local_c = (int *)json_object_get(local_18, &DAT_0011add8);
            if ((local_c == (int *)0x0) || (*local_c != 2)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0, "get array %d x failed",
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_pic_sensor", 0x17, 0x266, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            V_LOCK();
            uVar3 = json_string_value(local_c);
            logfmt_raw(auStack_1020, 0x1000, 0, "x: %s", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_pic_sensor", 0x17, 0x269, 0x14,
                auStack_1020);
            uVar3 = json_string_value(local_c);
            iVar1 = FUN_0006f35c(uVar3);
            local_10[3] = iVar1;
            local_c = (int *)json_object_get(local_18, &DAT_0011adfc);
            if ((local_c == (int *)0x0) || (*local_c != 2)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0, "get array %d y failed",
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_pic_sensor", 0x17, 0x26f, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            V_LOCK();
            uVar3 = json_string_value(local_c);
            logfmt_raw(auStack_1020, 0x1000, 0, "y: %s", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_pic_sensor", 0x17, 0x272, 0x14,
                auStack_1020);
            uVar3 = json_string_value(local_c);
            iVar1 = FUN_0006f3c0(uVar3);
            local_10[4] = iVar1;
            local_1c = local_1c + 1;
        }
        uVar3 = 0;
    }
    return uVar3;
}

undefined4 FUN_00073be8(undefined4 param_1)

{
    int iVar1;
    uint uVar2;
    undefined4 uVar3;
    undefined1 auStack_1020[4096];
    int *local_20;
    uint local_1c;
    int *local_18;
    int local_14;
    int *local_10;
    int *local_c;

    local_20 = (int *)json_object_get(param_1, "ctrlboard_sensor");
    if ((local_20 == (int *)0x0) || (*local_20 != 1)) {
        V_LOCK();
        logfmt_raw(auStack_1020, 0x1000, 0,
                   "get ctrlboard_sensor sensor failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_chain_ctrlboard_sensor", 0x1d, 0x281, 100,
             auStack_1020);
        uVar3 = 0xffffffff;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1020, 0x1000, 0, "ctrlboard_sensor:");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_chain_ctrlboard_sensor", 0x1d, 0x284, 0x14,
             auStack_1020);
        local_1c = 0;
        while (uVar2 = json_array_size(local_20), local_1c < uVar2) {
            local_18 = (int *)json_array_get(local_20, local_1c);
            if ((local_18 == (int *)0x0) || (*local_18 != 0)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0, "get array %d failed",
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_ctrlboard_sensor", 0x1d, 0x28b, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            local_c = (int *)json_object_get(local_18, "index");
            if ((local_c == (int *)0x0) || (*local_c != 3)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0, "get array %d index failed",
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_ctrlboard_sensor", 0x1d, 0x292, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            V_LOCK();
            uVar3 = json_integer_value(local_c);
            logfmt_raw(auStack_1020, 0x1000, 0, "index: %d", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_ctrlboard_sensor", 0x1d, 0x295, 0x14,
                auStack_1020);
            local_14 = json_integer_value(local_c);
            local_10 = (int *)(*(int *)(topol_machine._36_4_ + 0x54) +
                               local_14 * 0x18);
            *local_10 = local_14;
            local_10[2] = 2;
            local_c = (int *)json_object_get(local_18, &DAT_0011a4d4);
            if ((local_c == (int *)0x0) || (*local_c != 2)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0, "get array %d type failed",
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_ctrlboard_sensor", 0x1d, 0x29e, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            V_LOCK();
            uVar3 = json_string_value(local_c);
            logfmt_raw(auStack_1020, 0x1000, 0, "type: %s", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_ctrlboard_sensor", 0x1d, 0x2a1, 0x14,
                auStack_1020);
            uVar3 = json_string_value(local_c);
            iVar1 = FUN_0006f2e8(uVar3);
            local_10[1] = iVar1;
            local_c = (int *)json_object_get(local_18, &DAT_0011adac);
            if ((local_c == (int *)0x0) || (*local_c != 3)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0,
                           "get array %d bind_asic failed", local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_ctrlboard_sensor", 0x1d, 0x2a7, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            V_LOCK();
            uVar3 = json_integer_value(local_c);
            logfmt_raw(auStack_1020, 0x1000, 0, "iic: %d", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_ctrlboard_sensor", 0x1d, 0x2aa, 0x14,
                auStack_1020);
            iVar1 = json_integer_value(local_c);
            local_10[5] = iVar1;
            local_c = (int *)json_object_get(local_18, &DAT_0011add8);
            if ((local_c == (int *)0x0) || (*local_c != 2)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0, "get array %d x failed",
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_ctrlboard_sensor", 0x1d, 0x2b0, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            V_LOCK();
            uVar3 = json_string_value(local_c);
            logfmt_raw(auStack_1020, 0x1000, 0, "x: %s", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_ctrlboard_sensor", 0x1d, 0x2b3, 0x14,
                auStack_1020);
            uVar3 = json_string_value(local_c);
            iVar1 = FUN_0006f35c(uVar3);
            local_10[3] = iVar1;
            local_c = (int *)json_object_get(local_18, &DAT_0011adfc);
            if ((local_c == (int *)0x0) || (*local_c != 2)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0, "get array %d y failed",
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_ctrlboard_sensor", 0x1d, 0x2b9, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            V_LOCK();
            uVar3 = json_string_value(local_c);
            logfmt_raw(auStack_1020, 0x1000, 0, "y: %s", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_ctrlboard_sensor", 0x1d, 700, 0x14,
                auStack_1020);
            uVar3 = json_string_value(local_c);
            iVar1 = FUN_0006f3c0(uVar3);
            local_10[4] = iVar1;
            local_1c = local_1c + 1;
        }
        uVar3 = 0;
    }
    return uVar3;
}

undefined4 FUN_00074514(undefined4 param_1)

{
    undefined4 uVar1;
    undefined1 auStack_1014[4096];
    undefined4 local_14;
    int *local_10;
    int *local_c;

    local_14 = 0;
    local_10 = (int *)json_object_get(param_1, &DAT_0011ae6c);
    if ((local_10 == (int *)0x0) || (*local_10 != 0)) {
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, "get pic failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_chain_pic", 0x10, 0x2cb, 100, auStack_1014);
        local_14 = 0xffffffff;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, &DAT_0011ae80);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_chain_pic", 0x10, 0x2ce, 0x14, auStack_1014);
        local_c = (int *)json_object_get(local_10, &DAT_0011a4d4);
        if ((local_c == (int *)0x0) || (*local_c != 2)) {
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0, "get type failed");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_pic", 0x10, 0x2d3, 100, auStack_1014);
            local_14 = 0xffffffff;
        } else {
            V_LOCK();
            uVar1 = json_string_value(local_c);
            logfmt_raw(auStack_1014, 0x1000, 0, "type: %s", uVar1);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_pic", 0x10, 0x2d6, 0x14, auStack_1014);
            local_c = (int *)json_object_get(local_10, "i2c_addr");
            if ((local_c == (int *)0x0) || (*local_c != 3)) {
                V_LOCK();
                logfmt_raw(auStack_1014, 0x1000, 0, "get i2c_addr failed");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_pic", 0x10, 0x2db, 100, auStack_1014);
                local_14 = 0xffffffff;
            } else {
                V_LOCK();
                uVar1 = json_integer_value(local_c);
                logfmt_raw(auStack_1014, 0x1000, 0, "i2c_addr: %d", uVar1);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_pic", 0x10, 0x2de, 0x14, auStack_1014);
                local_c = (int *)json_object_get(local_10, "device_high");
                if ((local_c == (int *)0x0) || (*local_c != 3)) {
                    V_LOCK();
                    logfmt_raw(auStack_1014, 0x1000, 0,
                               "get device_high failed");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/topol/topol.c",
                         0x9f, "_parse_chain_pic", 0x10, 0x2e3, 100,
                         auStack_1014);
                    local_14 = 0xffffffff;
                } else {
                    V_LOCK();
                    uVar1 = json_integer_value(local_c);
                    logfmt_raw(auStack_1014, 0x1000, 0, "device_high: %d",
                               uVar1);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/topol/topol.c",
                         0x9f, "_parse_chain_pic", 0x10, 0x2e6, 0x14,
                         auStack_1014);
                    uVar1 = json_integer_value(local_c);
                    *(undefined4 *)(topol_machine._36_4_ + 0x40) = uVar1;
                    if ((*(int *)(topol_machine._36_4_ + 0x58) == 1) ||
                        (*(int *)(topol_machine._36_4_ + 0x58) == 2)) {
                        local_14 = FUN_000732bc(local_10);
                    }
                }
            }
        }
    }
    return local_14;
}

undefined4 FUN_00074a68(undefined4 param_1)

{
    undefined4 uVar1;
    undefined1 auStack_1024[4096];
    int local_24;
    int local_20;
    int *local_1c;
    int local_18;
    int *local_14;

    local_20 = topol_machine._4_4_;
    local_1c = (int *)json_object_get(param_1, "eeprom");
    if ((local_1c == (int *)0x0) || (*local_1c != 0)) {
        V_LOCK();
        logfmt_raw(auStack_1024, 0x1000, 0, "get eeprom failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_chain_eeprom", 0x13, 0x2f9, 100, auStack_1024);
        uVar1 = 0xffffffff;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1024, 0x1000, 0, "eeprom:");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_chain_eeprom", 0x13, 0x2fc, 0x14, auStack_1024);
        local_14 = (int *)json_object_get(local_1c, &DAT_0011a4d4);
        if ((local_14 == (int *)0x0) || (*local_14 != 2)) {
            V_LOCK();
            logfmt_raw(auStack_1024, 0x1000, 0, "get type failed");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_eeprom", 0x13, 0x301, 100, auStack_1024);
            uVar1 = 0xffffffff;
        } else {
            V_LOCK();
            uVar1 = json_string_value(local_14);
            logfmt_raw(auStack_1024, 0x1000, 0, "type: %s", uVar1);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_eeprom", 0x13, 0x304, 0x14, auStack_1024);
            local_18 = 0;
            while (true) {
                if (local_20 <= local_18)
                    break;
                uVar1 = json_string_value(local_14);
                uVar1 = FUN_0006f424(uVar1);
                *(undefined4 *)(topol_machine._36_4_ + local_18 * 0x78 + 0x70) =
                    uVar1;
                local_18 = local_18 + 1;
            }
            local_14 = (int *)json_object_get(local_1c, "i2c_addr");
            if ((local_14 == (int *)0x0) || (*local_14 != 3)) {
                V_LOCK();
                logfmt_raw(auStack_1024, 0x1000, 0, "get i2c_addr failed");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_eeprom", 0x13, 0x30d, 100,
                     auStack_1024);
                uVar1 = 0xffffffff;
            } else {
                V_LOCK();
                uVar1 = json_integer_value(local_14);
                logfmt_raw(auStack_1024, 0x1000, 0, "i2c_addr: %d", uVar1);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_eeprom", 0x13, 0x310, 0x14,
                     auStack_1024);
                local_24 = 0;
                while (true) {
                    if (local_20 <= local_24)
                        break;
                    uVar1 = json_integer_value(local_14);
                    *(undefined4 *)(topol_machine._36_4_ + local_24 * 0x78 +
                                    0x74) = uVar1;
                    local_24 = local_24 + 1;
                }
                uVar1 = 0;
            }
        }
    }
    return uVar1;
}

undefined4 FUN_00074ef0(undefined4 param_1)

{
    int iVar1;
    uint uVar2;
    undefined4 uVar3;
    undefined1 auStack_1020[4096];
    int *local_20;
    uint local_1c;
    int *local_18;
    int local_14;
    int *local_10;
    int *local_c;

    local_20 = (int *)json_object_get(param_1, "asic_sensor");
    if ((local_20 == (int *)0x0) || (*local_20 != 1)) {
        V_LOCK();
        logfmt_raw(auStack_1020, 0x1000, 0, "get sensor failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_chain_sensor", 0x13, 800, 100, auStack_1020);
        uVar3 = 0xffffffff;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1020, 0x1000, 0, "asic_sensor:");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_chain_sensor", 0x13, 0x323, 0x14, auStack_1020);
        local_1c = 0;
        while (uVar2 = json_array_size(local_20), local_1c < uVar2) {
            local_18 = (int *)json_array_get(local_20, local_1c);
            if ((local_18 == (int *)0x0) || (*local_18 != 0)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0, "get array %d failed",
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_sensor", 0x13, 0x32b, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            local_c = (int *)json_object_get(local_18, "index");
            if ((local_c == (int *)0x0) || (*local_c != 3)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0, "get array %d index failed",
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_sensor", 0x13, 0x332, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            V_LOCK();
            uVar3 = json_integer_value(local_c);
            logfmt_raw(auStack_1020, 0x1000, 0, "index: %d", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_sensor", 0x13, 0x335, 0x14, auStack_1020);
            local_14 = json_integer_value(local_c);
            local_10 = (int *)(*(int *)(topol_machine._36_4_ + 0x54) +
                               local_14 * 0x18);
            *local_10 = local_14;
            local_10[2] = 1;
            local_c = (int *)json_object_get(local_18, &DAT_0011a4d4);
            if ((local_c == (int *)0x0) || (*local_c != 2)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0, "get array %d type failed",
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_sensor", 0x13, 0x33e, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            V_LOCK();
            uVar3 = json_string_value(local_c);
            logfmt_raw(auStack_1020, 0x1000, 0, "type: %s", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_sensor", 0x13, 0x341, 0x14, auStack_1020);
            uVar3 = json_string_value(local_c);
            iVar1 = FUN_0006f2e8(uVar3);
            local_10[1] = iVar1;
            local_c = (int *)json_object_get(local_18, "bind_asic");
            if ((local_c == (int *)0x0) || (*local_c != 3)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0,
                           "get array %d bind_asic failed", local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_sensor", 0x13, 0x347, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            V_LOCK();
            uVar3 = json_integer_value(local_c);
            logfmt_raw(auStack_1020, 0x1000, 0, "bind_asic: %d", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_sensor", 0x13, 0x34a, 0x14, auStack_1020);
            iVar1 = json_integer_value(local_c);
            local_10[5] = iVar1;
            local_c = (int *)json_object_get(local_18, &DAT_0011add8);
            if ((local_c == (int *)0x0) || (*local_c != 2)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0, "get array %d x failed",
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_sensor", 0x13, 0x350, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            V_LOCK();
            uVar3 = json_string_value(local_c);
            logfmt_raw(auStack_1020, 0x1000, 0, "x: %s", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_sensor", 0x13, 0x353, 0x14, auStack_1020);
            uVar3 = json_string_value(local_c);
            iVar1 = FUN_0006f35c(uVar3);
            local_10[3] = iVar1;
            local_c = (int *)json_object_get(local_18, &DAT_0011adfc);
            if ((local_c == (int *)0x0) || (*local_c != 2)) {
                V_LOCK();
                logfmt_raw(auStack_1020, 0x1000, 0, "get array %d y failed",
                           local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_sensor", 0x13, 0x359, 100,
                     auStack_1020);
                return 0xffffffff;
            }
            V_LOCK();
            uVar3 = json_string_value(local_c);
            logfmt_raw(auStack_1020, 0x1000, 0, "y: %s", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_sensor", 0x13, 0x35c, 0x14, auStack_1020);
            uVar3 = json_string_value(local_c);
            iVar1 = FUN_0006f3c0(uVar3);
            local_10[4] = iVar1;
            local_1c = local_1c + 1;
        }
        uVar3 = 0;
    }
    return uVar3;
}

undefined4 FUN_0007581c(undefined4 param_1)

{
    uint uVar1;
    undefined4 uVar2;
    undefined1 auStack_1018[4096];
    int *local_18;
    uint local_14;
    int *local_10;
    int *local_c;

    local_18 = (int *)json_object_get(param_1, "domain");
    if ((local_18 == (int *)0x0) || (*local_18 != 1)) {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, "get domain failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_chain_domain", 0x13, 0x36b, 100, auStack_1018);
        uVar2 = 0xffffffff;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, "domain:");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_chain_domain", 0x13, 0x36e, 0x14, auStack_1018);
        local_14 = 0;
        while (uVar1 = json_array_size(local_18), local_14 < uVar1) {
            local_c = (int *)json_array_get(local_18, local_14);
            if ((local_c == (int *)0x0) || (*local_c != 0)) {
                V_LOCK();
                logfmt_raw(auStack_1018, 0x1000, 0, "get array %d failed",
                           local_14);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_domain", 0x13, 0x375, 100,
                     auStack_1018);
                return 0xffffffff;
            }
            local_10 = (int *)json_object_get(local_c, "index");
            if ((local_10 == (int *)0x0) || (*local_10 != 3)) {
                V_LOCK();
                logfmt_raw(auStack_1018, 0x1000, 0, "get array %d index failed",
                           local_14);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "_parse_chain_domain", 0x13, 0x37c, 100,
                     auStack_1018);
                return 0xffffffff;
            }
            V_LOCK();
            uVar2 = json_integer_value(local_10);
            logfmt_raw(auStack_1018, 0x1000, 0, "index: %d", uVar2);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain_domain", 0x13, 0x37f, 0x14, auStack_1018);
            local_14 = local_14 + 1;
        }
        uVar2 = 0;
    }
    return uVar2;
}

int FUN_00075b94(undefined4 param_1)

{
    uint uVar1;
    int iVar2;
    undefined4 uVar3;
    undefined1 auStack_1014[4096];
    int *local_14;
    int *local_10;
    int local_c;

    local_14 = (int *)json_object_get(param_1, "chain");
    if ((local_14 == (int *)0x0) || (*local_14 != 0)) {
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, "get chain failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_chain", 0xc, 0x38d, 100, auStack_1014);
        local_c = -1;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, "chain:");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "_parse_chain", 0xc, 0x390, 0x14, auStack_1014);
        local_10 = (int *)json_object_get(local_14, "chain_num");
        if ((local_10 == (int *)0x0) || (*local_10 != 3)) {
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0, "get chain_num failed");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain", 0xc, 0x395, 100, auStack_1014);
            local_c = -1;
        } else {
            V_LOCK();
            uVar3 = json_integer_value(local_10);
            logfmt_raw(auStack_1014, 0x1000, 0, "chain_num : %d", uVar3);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "_parse_chain", 0xc, 0x398, 0x14, auStack_1014);
            topol_machine._4_4_ = json_integer_value(local_10);
            local_c = FUN_0006f4e0();
            if (local_c == 0) {
                local_10 = (int *)json_object_get(local_14, "chain_row");
                if ((local_10 == (int *)0x0) || (*local_10 != 3)) {
                    V_LOCK();
                    logfmt_raw(auStack_1014, 0x1000, 0, "get chain_row failed");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/topol/topol.c",
                         0x9f, "_parse_chain", 0xc, 0x3a0, 100, auStack_1014);
                    local_c = -1;
                } else {
                    V_LOCK();
                    uVar3 = json_integer_value(local_10);
                    logfmt_raw(auStack_1014, 0x1000, 0, "chain_row: %d", uVar3);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/topol/topol.c",
                         0x9f, "_parse_chain", 0xc, 0x3a3, 0x14, auStack_1014);
                    topol_machine._8_4_ = json_integer_value(local_10);
                    local_10 = (int *)json_object_get(local_14, "chain_column");
                    if ((local_10 == (int *)0x0) || (*local_10 != 3)) {
                        V_LOCK();
                        logfmt_raw(auStack_1014, 0x1000, 0,
                                   "get chain_column failed");
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/topol/"
                             "topol.c",
                             0x9f, "_parse_chain", 0xc, 0x3a9, 100,
                             auStack_1014);
                        local_c = -1;
                    } else {
                        V_LOCK();
                        uVar3 = json_integer_value(local_10);
                        logfmt_raw(auStack_1014, 0x1000, 0, "chain_column: %d",
                                   uVar3);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/topol/"
                             "topol.c",
                             0x9f, "_parse_chain", 0xc, 0x3ac, 0x14,
                             auStack_1014);
                        topol_machine._12_4_ = json_integer_value(local_10);
                        local_10 = (int *)json_object_get(local_14,
                                                          "chain_domain_num");
                        if ((local_10 == (int *)0x0) || (*local_10 != 3)) {
                            V_LOCK();
                            logfmt_raw(auStack_1014, 0x1000, 0,
                                       "get chain_domain_num failed");
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/backend/"
                                 "topol/topol.c",
                                 0x9f, "_parse_chain", 0xc, 0x3b2, 100,
                                 auStack_1014);
                            local_c = -1;
                        } else {
                            V_LOCK();
                            uVar3 = json_integer_value(local_10);
                            logfmt_raw(auStack_1014, 0x1000, 0,
                                       "chain_domain_num : %d", uVar3);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/backend/"
                                 "topol/topol.c",
                                 0x9f, "_parse_chain", 0xc, 0x3b5, 0x14,
                                 auStack_1014);
                            topol_machine._16_4_ = json_integer_value(local_10);
                            local_10 = (int *)json_object_get(local_14,
                                                              "chain_asic_num");
                            if ((local_10 == (int *)0x0) || (*local_10 != 3)) {
                                V_LOCK();
                                logfmt_raw(auStack_1014, 0x1000, 0,
                                           "get chain_asic_num failed");
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/backend/"
                                     "topol/topol.c",
                                     0x9f, "_parse_chain", 0xc, 0x3bb, 100,
                                     auStack_1014);
                                local_c = -1;
                            } else {
                                V_LOCK();
                                uVar3 = json_integer_value(local_10);
                                logfmt_raw(auStack_1014, 0x1000, 0,
                                           "chain_asic_num : %d", uVar3);
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/backend/"
                                     "topol/topol.c",
                                     0x9f, "_parse_chain", 0xc, 0x3be, 0x14,
                                     auStack_1014);
                                topol_machine._20_4_ =
                                    json_integer_value(local_10);
                                local_10 = (int *)json_object_get(
                                    local_14, "domain_asic_num");
                                if ((local_10 == (int *)0x0) ||
                                    (*local_10 != 3)) {
                                    V_LOCK();
                                    logfmt_raw(auStack_1014, 0x1000, 0,
                                               "get domain_asic_num failed");
                                    V_UNLOCK();
                                    zlog(g_zc,
                                         "/workspace/jenkins/jenkins/workspace/"
                                         "Antminer_L9_CVCtrl_release/build/"
                                         "rootfs/buildroot/tmp/release/build/"
                                         "godminer-origin_godminer-branch1/"
                                         "backend/topol/topol.c",
                                         0x9f, "_parse_chain", 0xc, 0x3c4, 100,
                                         auStack_1014);
                                    local_c = -1;
                                } else {
                                    V_LOCK();
                                    uVar3 = json_integer_value(local_10);
                                    logfmt_raw(auStack_1014, 0x1000, 0,
                                               "domain_asic_num : %d", uVar3);
                                    V_UNLOCK();
                                    zlog(g_zc,
                                         "/workspace/jenkins/jenkins/workspace/"
                                         "Antminer_L9_CVCtrl_release/build/"
                                         "rootfs/buildroot/tmp/release/build/"
                                         "godminer-origin_godminer-branch1/"
                                         "backend/topol/topol.c",
                                         0x9f, "_parse_chain", 0xc, 0x3c7, 0x14,
                                         auStack_1014);
                                    topol_machine._24_4_ =
                                        json_integer_value(local_10);
                                    local_10 = (int *)json_object_get(
                                        local_14, "pic_mcu_en");
                                    if (((local_10 == (int *)0x0) ||
                                         (*local_10 != 5)) &&
                                        ((local_10 == (int *)0x0 ||
                                          (*local_10 != 6)))) {
                                        V_LOCK();
                                        logfmt_raw(auStack_1014, 0x1000, 0,
                                                   "get pic_mcu_en failed!");
                                        V_UNLOCK();
                                        zlog(g_zc,
                                             "/workspace/jenkins/jenkins/"
                                             "workspace/"
                                             "Antminer_L9_CVCtrl_release/build/"
                                             "rootfs/buildroot/tmp/release/"
                                             "build/"
                                             "godminer-origin_godminer-branch1/"
                                             "backend/topol/topol.c",
                                             0x9f, "_parse_chain", 0xc, 0x3cd,
                                             100, auStack_1014);
                                        local_c = -1;
                                    } else {
                                        V_LOCK();
                                        if ((local_10 == (int *)0x0) ||
                                            (*local_10 != 5)) {
                                            uVar1 = 0xa590;
                                        } else {
                                            uVar1 = 0xa588;
                                        }
                                        logfmt_raw(auStack_1014, 0x1000, 0,
                                                   "pic_mcu_en: %s",
                                                   uVar1 | 0x110000);
                                        V_UNLOCK();
                                        zlog(g_zc,
                                             "/workspace/jenkins/jenkins/"
                                             "workspace/"
                                             "Antminer_L9_CVCtrl_release/build/"
                                             "rootfs/buildroot/tmp/release/"
                                             "build/"
                                             "godminer-origin_godminer-branch1/"
                                             "backend/topol/topol.c",
                                             0x9f, "_parse_chain", 0xc, 0x3d0,
                                             0x14, auStack_1014);
                                        if ((local_10 == (int *)0x0) ||
                                            (*local_10 != 5)) {
                                            topol_machine[0x1c] = '\0';
                                        } else {
                                            topol_machine[0x1c] = '\x01';
                                        }
                                        local_10 = (int *)json_object_get(
                                            local_14, "sensor_mode");
                                        if ((local_10 == (int *)0x0) ||
                                            (*local_10 != 3)) {
                                            V_LOCK();
                                            logfmt_raw(
                                                auStack_1014, 0x1000, 0,
                                                "get sensor_mode failed");
                                            V_UNLOCK();
                                            zlog(
                                                g_zc,
                                                "/workspace/jenkins/jenkins/"
                                                "workspace/"
                                                "Antminer_L9_CVCtrl_release/"
                                                "build/rootfs/buildroot/tmp/"
                                                "release/build/"
                                                "godminer-origin_godminer-"
                                                "branch1/backend/topol/topol.c",
                                                0x9f, "_parse_chain", 0xc,
                                                0x3d6, 100, auStack_1014);
                                            local_c = -1;
                                        } else {
                                            V_LOCK();
                                            uVar3 =
                                                json_integer_value(local_10);
                                            logfmt_raw(auStack_1014, 0x1000, 0,
                                                       "sensor mode : %d",
                                                       uVar3);
                                            V_UNLOCK();
                                            zlog(
                                                g_zc,
                                                "/workspace/jenkins/jenkins/"
                                                "workspace/"
                                                "Antminer_L9_CVCtrl_release/"
                                                "build/rootfs/buildroot/tmp/"
                                                "release/build/"
                                                "godminer-origin_godminer-"
                                                "branch1/backend/topol/topol.c",
                                                0x9f, "_parse_chain", 0xc,
                                                0x3d9, 0x14, auStack_1014);
                                            uVar3 =
                                                json_integer_value(local_10);
                                            *(undefined4 *)(topol_machine
                                                                ._36_4_ +
                                                            0x58) = uVar3;
                                            local_10 = (int *)json_object_get(
                                                local_14, "sensor_num");
                                            if ((local_10 == (int *)0x0) ||
                                                (*local_10 != 3)) {
                                                V_LOCK();
                                                logfmt_raw(
                                                    auStack_1014, 0x1000, 0,
                                                    "get sensor num failed");
                                                V_UNLOCK();
                                                zlog(g_zc,
                                                     "/workspace/jenkins/"
                                                     "jenkins/workspace/"
                                                     "Antminer_L9_CVCtrl_"
                                                     "release/build/rootfs/"
                                                     "buildroot/tmp/release/"
                                                     "build/"
                                                     "godminer-origin_godminer-"
                                                     "branch1/backend/topol/"
                                                     "topol.c",
                                                     0x9f, "_parse_chain", 0xc,
                                                     0x3df, 100, auStack_1014);
                                                local_c = -1;
                                            } else {
                                                V_LOCK();
                                                uVar3 = json_integer_value(
                                                    local_10);
                                                logfmt_raw(auStack_1014, 0x1000,
                                                           0, "sensor num : %d",
                                                           uVar3);
                                                V_UNLOCK();
                                                zlog(g_zc,
                                                     "/workspace/jenkins/"
                                                     "jenkins/workspace/"
                                                     "Antminer_L9_CVCtrl_"
                                                     "release/build/rootfs/"
                                                     "buildroot/tmp/release/"
                                                     "build/"
                                                     "godminer-origin_godminer-"
                                                     "branch1/backend/topol/"
                                                     "topol.c",
                                                     0x9f, "_parse_chain", 0xc,
                                                     0x3e2, 0x14, auStack_1014);
                                                uVar3 = json_integer_value(
                                                    local_10);
                                                *(undefined4 *)(topol_machine
                                                                    ._36_4_ +
                                                                0x5c) = uVar3;
                                                local_c = FUN_0006f6c8();
                                                if (local_c == 0) {
                                                    local_10 =
                                                        (int *)json_object_get(
                                                            local_14,
                                                            "max_chip_temp");
                                                    if ((local_10 ==
                                                         (int *)0x0) ||
                                                        (*local_10 != 3)) {
                                                        V_LOCK();
                                                        logfmt_raw(
                                                            auStack_1014,
                                                            0x1000, 0,
                                                            "get max_chip_temp "
                                                            "failed");
                                                        V_UNLOCK();
                                                        zlog(g_zc,
                                                             "/workspace/"
                                                             "jenkins/jenkins/"
                                                             "workspace/"
                                                             "Antminer_L9_"
                                                             "CVCtrl_release/"
                                                             "build/rootfs/"
                                                             "buildroot/tmp/"
                                                             "release/build/"
                                                             "godminer-origin_"
                                                             "godminer-branch1/"
                                                             "backend/topol/"
                                                             "topol.c",
                                                             0x9f,
                                                             "_parse_chain",
                                                             0xc, 0x3ea, 100,
                                                             auStack_1014);
                                                        local_c = -1;
                                                    } else {
                                                        V_LOCK();
                                                        uVar3 =
                                                            json_integer_value(
                                                                local_10);
                                                        logfmt_raw(auStack_1014,
                                                                   0x1000, 0,
                                                                   "max_chip_"
                                                                   "temp : %d",
                                                                   uVar3);
                                                        V_UNLOCK();
                                                        zlog(g_zc,
                                                             "/workspace/"
                                                             "jenkins/jenkins/"
                                                             "workspace/"
                                                             "Antminer_L9_"
                                                             "CVCtrl_release/"
                                                             "build/rootfs/"
                                                             "buildroot/tmp/"
                                                             "release/build/"
                                                             "godminer-origin_"
                                                             "godminer-branch1/"
                                                             "backend/topol/"
                                                             "topol.c",
                                                             0x9f,
                                                             "_parse_chain",
                                                             0xc, 0x3ed, 0x14,
                                                             auStack_1014);
                                                        uVar3 =
                                                            json_integer_value(
                                                                local_10);
                                                        *(undefined4
                                                              *)(topol_machine
                                                                     ._36_4_ +
                                                                 0x60) = uVar3;
                                                        local_10 = (int *)
                                                            json_object_get(
                                                                local_14,
                                                                "max_pcb_temp");
                                                        if ((local_10 ==
                                                             (int *)0x0) ||
                                                            (*local_10 != 3)) {
                                                            V_LOCK();
                                                            logfmt_raw(
                                                                auStack_1014,
                                                                0x1000, 0,
                                                                "get "
                                                                "max_pcb_temp "
                                                                "failed");
                                                            V_UNLOCK();
                                                            zlog(
                                                                g_zc,
                                                                "/workspace/"
                                                                "jenkins/"
                                                                "jenkins/"
                                                                "workspace/"
                                                                "Antminer_L9_"
                                                                "CVCtrl_"
                                                                "release/build/"
                                                                "rootfs/"
                                                                "buildroot/tmp/"
                                                                "release/build/"
                                                                "godminer-"
                                                                "origin_"
                                                                "godminer-"
                                                                "branch1/"
                                                                "backend/topol/"
                                                                "topol.c",
                                                                0x9f,
                                                                "_parse_chain",
                                                                0xc, 0x3f3, 100,
                                                                auStack_1014);
                                                            local_c = -1;
                                                        } else {
                                                            V_LOCK();
                                                            uVar3 =
                                                                json_integer_value(
                                                                    local_10);
                                                            logfmt_raw(
                                                                auStack_1014,
                                                                0x1000, 0,
                                                                "max_pcb_temp "
                                                                ": %d",
                                                                uVar3);
                                                            V_UNLOCK();
                                                            zlog(
                                                                g_zc,
                                                                "/workspace/"
                                                                "jenkins/"
                                                                "jenkins/"
                                                                "workspace/"
                                                                "Antminer_L9_"
                                                                "CVCtrl_"
                                                                "release/build/"
                                                                "rootfs/"
                                                                "buildroot/tmp/"
                                                                "release/build/"
                                                                "godminer-"
                                                                "origin_"
                                                                "godminer-"
                                                                "branch1/"
                                                                "backend/topol/"
                                                                "topol.c",
                                                                0x9f,
                                                                "_parse_chain",
                                                                0xc, 0x3f6,
                                                                0x14,
                                                                auStack_1014);
                                                            uVar3 =
                                                                json_integer_value(
                                                                    local_10);
                                                            *(undefined4
                                                                  *)(topol_machine
                                                                         ._36_4_ +
                                                                     100) =
                                                                uVar3;
                                                            local_10 = (int *)
                                                                json_object_get(
                                                                    local_14,
                                                                    "min_pcb_"
                                                                    "temp");
                                                            if ((local_10 ==
                                                                 (int *)0x0) ||
                                                                (*local_10 !=
                                                                 3)) {
                                                                V_LOCK();
                                                                logfmt_raw(
                                                                    auStack_1014,
                                                                    0x1000, 0,
                                                                    "get "
                                                                    "min_pcb_"
                                                                    "temp "
                                                                    "failed");
                                                                V_UNLOCK();
                                                                zlog(
                                                                    g_zc,
                                                                    "/workspace"
                                                                    "/jenkins/"
                                                                    "jenkins/"
                                                                    "workspace/"
                                                                    "Antminer_"
                                                                    "L9_CVCtrl_"
                                                                    "release/"
                                                                    "build/"
                                                                    "rootfs/"
                                                                    "buildroot/"
                                                                    "tmp/"
                                                                    "release/"
                                                                    "build/"
                                                                    "godminer-"
                                                                    "origin_"
                                                                    "godminer-"
                                                                    "branch1/"
                                                                    "backend/"
                                                                    "topol/"
                                                                    "topol.c",
                                                                    0x9f,
                                                                    "_parse_"
                                                                    "chain",
                                                                    0xc, 0x3fc,
                                                                    100,
                                                                    auStack_1014);
                                                                local_c = -1;
                                                            } else {
                                                                V_LOCK();
                                                                uVar3 =
                                                                    json_integer_value(
                                                                        local_10);
                                                                logfmt_raw(
                                                                    auStack_1014,
                                                                    0x1000, 0,
                                                                    "min_pcb_"
                                                                    "temp : %d",
                                                                    uVar3);
                                                                V_UNLOCK();
                                                                zlog(
                                                                    g_zc,
                                                                    "/workspace"
                                                                    "/jenkins/"
                                                                    "jenkins/"
                                                                    "workspace/"
                                                                    "Antminer_"
                                                                    "L9_CVCtrl_"
                                                                    "release/"
                                                                    "build/"
                                                                    "rootfs/"
                                                                    "buildroot/"
                                                                    "tmp/"
                                                                    "release/"
                                                                    "build/"
                                                                    "godminer-"
                                                                    "origin_"
                                                                    "godminer-"
                                                                    "branch1/"
                                                                    "backend/"
                                                                    "topol/"
                                                                    "topol.c",
                                                                    0x9f,
                                                                    "_parse_"
                                                                    "chain",
                                                                    0xc, 0x3ff,
                                                                    0x14,
                                                                    auStack_1014);
                                                                uVar3 =
                                                                    json_integer_value(
                                                                        local_10);
                                                                *(undefined4
                                                                      *)(topol_machine
                                                                             ._36_4_ +
                                                                         0x68) =
                                                                    uVar3;
                                                                local_10 = (int *)
                                                                    json_object_get(
                                                                        local_14,
                                                                        "max_"
                                                                        "uneffe"
                                                                        "ctive_"
                                                                        "coun"
                                                                        "t");
                                                                if ((local_10 ==
                                                                     (int *)0x0) ||
                                                                    (*local_10 !=
                                                                     3)) {
                                                                    V_LOCK();
                                                                    logfmt_raw(
                                                                        auStack_1014,
                                                                        0x1000,
                                                                        0,
                                                                        "get "
                                                                        "max_"
                                                                        "uneffe"
                                                                        "ctive_"
                                                                        "count "
                                                                        "faile"
                                                                        "d");
                                                                    V_UNLOCK();
                                                                    zlog(
                                                                        g_zc,
                                                                        "/works"
                                                                        "pace/"
                                                                        "jenkin"
                                                                        "s/"
                                                                        "jenkin"
                                                                        "s/"
                                                                        "worksp"
                                                                        "ace/"
                                                                        "Antmin"
                                                                        "er_L9_"
                                                                        "CVCtrl"
                                                                        "_relea"
                                                                        "se/"
                                                                        "build/"
                                                                        "rootfs"
                                                                        "/build"
                                                                        "root/"
                                                                        "tmp/"
                                                                        "releas"
                                                                        "e/"
                                                                        "build/"
                                                                        "godmin"
                                                                        "er-"
                                                                        "origin"
                                                                        "_godmi"
                                                                        "ner-"
                                                                        "branch"
                                                                        "1/"
                                                                        "backen"
                                                                        "d/"
                                                                        "topol/"
                                                                        "topol."
                                                                        "c",
                                                                        0x9f,
                                                                        "_parse"
                                                                        "_chai"
                                                                        "n",
                                                                        0xc,
                                                                        0x405,
                                                                        100,
                                                                        auStack_1014);
                                                                    local_c =
                                                                        -1;
                                                                } else {
                                                                    V_LOCK();
                                                                    uVar3 = json_integer_value(
                                                                        local_10);
                                                                    logfmt_raw(
                                                                        auStack_1014,
                                                                        0x1000,
                                                                        0,
                                                                        "max_"
                                                                        "uneffe"
                                                                        "ctive_"
                                                                        "count "
                                                                        ": %d",
                                                                        uVar3);
                                                                    V_UNLOCK();
                                                                    zlog(
                                                                        g_zc,
                                                                        "/works"
                                                                        "pace/"
                                                                        "jenkin"
                                                                        "s/"
                                                                        "jenkin"
                                                                        "s/"
                                                                        "worksp"
                                                                        "ace/"
                                                                        "Antmin"
                                                                        "er_L9_"
                                                                        "CVCtrl"
                                                                        "_relea"
                                                                        "se/"
                                                                        "build/"
                                                                        "rootfs"
                                                                        "/build"
                                                                        "root/"
                                                                        "tmp/"
                                                                        "releas"
                                                                        "e/"
                                                                        "build/"
                                                                        "godmin"
                                                                        "er-"
                                                                        "origin"
                                                                        "_godmi"
                                                                        "ner-"
                                                                        "branch"
                                                                        "1/"
                                                                        "backen"
                                                                        "d/"
                                                                        "topol/"
                                                                        "topol."
                                                                        "c",
                                                                        0x9f,
                                                                        "_parse"
                                                                        "_chai"
                                                                        "n",
                                                                        0xc,
                                                                        0x408,
                                                                        0x14,
                                                                        auStack_1014);
                                                                    uVar3 = json_integer_value(
                                                                        local_10);
                                                                    *(undefined4
                                                                          *)(topol_machine
                                                                                 ._36_4_ +
                                                                             0x6c) =
                                                                        uVar3;
                                                                    local_c = FUN_000725cc(
                                                                        local_14);
                                                                    if (local_c ==
                                                                        0) {
                                                                        iVar2 =
                                                                            0;
                                                                        if ((topol_machine
                                                                                 [0x1c] ==
                                                                             '\0') ||
                                                                            (local_c = FUN_00074514(
                                                                                 local_14),
                                                                             iVar2 =
                                                                                 local_c,
                                                                             local_c ==
                                                                                 0)) {
                                                                            local_c =
                                                                                iVar2;
                                                                            if ((*(int *)(topol_machine
                                                                                              ._36_4_ +
                                                                                          0x58) ==
                                                                                 3) &&
                                                                                (local_c = FUN_00073be8(
                                                                                     local_14),
                                                                                 local_c !=
                                                                                     0)) {
                                                                                V_LOCK();
                                                                                logfmt_raw(
                                                                                    auStack_1014,
                                                                                    0x1000,
                                                                                    0,
                                                                                    "parse chain ctrlboard failed");
                                                                                V_UNLOCK();
                                                                                zlog(
                                                                                    g_zc,
                                                                                    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                                                                    0x9f,
                                                                                    "_parse_chain",
                                                                                    0xc,
                                                                                    0x41f,
                                                                                    100,
                                                                                    auStack_1014);
                                                                                local_c =
                                                                                    -1;
                                                                            } else if (
                                                                                ((*(int *)(topol_machine
                                                                                               ._36_4_ +
                                                                                           0x58) ==
                                                                                  0) ||
                                                                                 (*(int *)(topol_machine
                                                                                               ._36_4_ +
                                                                                           0x58) ==
                                                                                  2)) &&
                                                                                (local_c = FUN_00074ef0(
                                                                                     local_14),
                                                                                 local_c !=
                                                                                     0)) {
                                                                                V_LOCK();
                                                                                logfmt_raw(
                                                                                    auStack_1014,
                                                                                    0x1000,
                                                                                    0,
                                                                                    "parse chain sensor failed");
                                                                                V_UNLOCK();
                                                                                zlog(
                                                                                    g_zc,
                                                                                    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                                                                    0x9f,
                                                                                    "_parse_chain",
                                                                                    0xc,
                                                                                    0x429,
                                                                                    100,
                                                                                    auStack_1014);
                                                                                local_c =
                                                                                    -1;
                                                                            } else {
                                                                                local_c = FUN_00074a68(
                                                                                    local_14);
                                                                                if (local_c ==
                                                                                    0) {
                                                                                    FUN_0006f7b4();
                                                                                    local_c =
                                                                                        0;
                                                                                } else {
                                                                                    V_LOCK();
                                                                                    logfmt_raw(
                                                                                        auStack_1014,
                                                                                        0x1000,
                                                                                        0,
                                                                                        "parse chain eeprom failed");
                                                                                    V_UNLOCK();
                                                                                    zlog(
                                                                                        g_zc,
                                                                                        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                                                                        0x9f,
                                                                                        "_parse_chain",
                                                                                        0xc,
                                                                                        0x431,
                                                                                        100,
                                                                                        auStack_1014);
                                                                                    local_c =
                                                                                        -1;
                                                                                }
                                                                            }
                                                                        } else {
                                                                            V_LOCK();
                                                                            logfmt_raw(
                                                                                auStack_1014,
                                                                                0x1000,
                                                                                0,
                                                                                "parse chain pic failed");
                                                                            V_UNLOCK();
                                                                            zlog(
                                                                                g_zc,
                                                                                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                                                                0x9f,
                                                                                "_parse_chain",
                                                                                0xc,
                                                                                0x416,
                                                                                100,
                                                                                auStack_1014);
                                                                            local_c =
                                                                                -1;
                                                                        }
                                                                    } else {
                                                                        V_LOCK();
                                                                        logfmt_raw(
                                                                            auStack_1014,
                                                                            0x1000,
                                                                            0,
                                                                            "pa"
                                                                            "rs"
                                                                            "e "
                                                                            "as"
                                                                            "ic"
                                                                            " f"
                                                                            "ai"
                                                                            "le"
                                                                            "d");
                                                                        V_UNLOCK();
                                                                        zlog(
                                                                            g_zc,
                                                                            "/w"
                                                                            "or"
                                                                            "ks"
                                                                            "pa"
                                                                            "ce"
                                                                            "/j"
                                                                            "en"
                                                                            "ki"
                                                                            "ns"
                                                                            "/j"
                                                                            "en"
                                                                            "ki"
                                                                            "ns"
                                                                            "/w"
                                                                            "or"
                                                                            "ks"
                                                                            "pa"
                                                                            "ce"
                                                                            "/A"
                                                                            "nt"
                                                                            "mi"
                                                                            "ne"
                                                                            "r_"
                                                                            "L9"
                                                                            "_C"
                                                                            "VC"
                                                                            "tr"
                                                                            "l_"
                                                                            "re"
                                                                            "le"
                                                                            "as"
                                                                            "e/"
                                                                            "bu"
                                                                            "il"
                                                                            "d/"
                                                                            "ro"
                                                                            "ot"
                                                                            "fs"
                                                                            "/b"
                                                                            "ui"
                                                                            "ld"
                                                                            "ro"
                                                                            "ot"
                                                                            "/t"
                                                                            "mp"
                                                                            "/r"
                                                                            "el"
                                                                            "ea"
                                                                            "se"
                                                                            "/b"
                                                                            "ui"
                                                                            "ld"
                                                                            "/g"
                                                                            "od"
                                                                            "mi"
                                                                            "ne"
                                                                            "r-"
                                                                            "or"
                                                                            "ig"
                                                                            "in"
                                                                            "_g"
                                                                            "od"
                                                                            "mi"
                                                                            "ne"
                                                                            "r-"
                                                                            "br"
                                                                            "an"
                                                                            "ch"
                                                                            "1/"
                                                                            "ba"
                                                                            "ck"
                                                                            "en"
                                                                            "d/"
                                                                            "to"
                                                                            "po"
                                                                            "l/"
                                                                            "to"
                                                                            "po"
                                                                            "l."
                                                                            "c",
                                                                            0x9f,
                                                                            "_p"
                                                                            "ar"
                                                                            "se"
                                                                            "_c"
                                                                            "ha"
                                                                            "i"
                                                                            "n",
                                                                            0xc,
                                                                            0x40e,
                                                                            100,
                                                                            auStack_1014);
                                                                        local_c =
                                                                            -1;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return local_c;
}

undefined1 platform_is_adjustable_power(void)

{
    return topol_machine[100];
}

undefined1 platform_is_check_asic_voltage_enable(void)

{
    return topol_machine[0x65];
}

undefined4 platfrom_get_check_asic_voltage(void)

{
    return topol_machine._104_4_;
}

undefined4 platform_get_machine_name(void)

{
    return topol_machine._0_4_;
}

undefined4 platform_get_chain_num(void)

{
    return topol_machine._4_4_;
}

undefined4 platform_get_chain_domain_num(void)

{
    return topol_machine._16_4_;
}

undefined4 platform_get_chain_asic_num(void)

{
    return topol_machine._20_4_;
}

undefined4 platform_get_domain_asic_num(void)

{
    return topol_machine._24_4_;
}

undefined4 platform_get_chip_type(int param_1)

{
    return *(undefined4 *)(topol_machine._36_4_ + param_1 * 0x78 + 0x18);
}

undefined4 platform_get_asic_big_core_num(int param_1)

{
    return *(undefined4 *)(topol_machine._36_4_ + param_1 * 0x78 + 0x24);
}

undefined4 platform_get_asic_little_core_num(int param_1)

{
    return *(undefined4 *)(topol_machine._36_4_ + param_1 * 0x78 + 0x28);
}

undefined4 platform_get_core_little_core_num(int param_1)

{
    return *(undefined4 *)(topol_machine._36_4_ + param_1 * 0x78 + 0x2c);
}

undefined4 platform_get_asic_domain_num(int param_1)

{
    return *(undefined4 *)(topol_machine._36_4_ + param_1 * 0x78 + 0x30);
}

undefined1 platform_is_pic_mcu_en(void)

{
    return topol_machine[0x1c];
}

undefined4 platform_get_asic_addr_interval(int param_1)

{
    return *(undefined4 *)(topol_machine._36_4_ + param_1 * 0x78 + 0x34);
}

undefined4 platform_get_chain_sensor_mode(int param_1)

{
    return *(undefined4 *)(topol_machine._36_4_ + param_1 * 0x78 + 0x58);
}

undefined4 platform_get_chain_sensor_num(int param_1)

{
    return *(undefined4 *)(topol_machine._36_4_ + param_1 * 0x78 + 0x5c);
}

undefined4 platform_get_sensor_addr(int param_1, int param_2)

{
    return *(
        undefined4 *)(*(int *)(topol_machine._36_4_ + param_1 * 0x78 + 0x54) +
                      param_2 * 0x18 + 0x14);
}

undefined4 platform_is_asic_sensor_air_in(void)

{
    return 0;
}

undefined4 platform_get_sensor_max_chip_temp(int param_1)

{
    return *(undefined4 *)(topol_machine._36_4_ + param_1 * 0x78 + 0x60);
}

undefined4 platform_get_sensor_max_pcb_temp(int param_1)

{
    return *(undefined4 *)(topol_machine._36_4_ + param_1 * 0x78 + 100);
}

undefined4 platform_get_sensor_min_pcb_temp(int param_1)

{
    return *(undefined4 *)(topol_machine._36_4_ + param_1 * 0x78 + 0x68);
}

undefined4 platform_get_sensor_max_uneffective_count(int param_1)

{
    return *(undefined4 *)(topol_machine._36_4_ + param_1 * 0x78 + 0x6c);
}

undefined4 platform_get_fan_num(void)

{
    return topol_machine._32_4_;
}

undefined4 platform_get_fan_max_speed(int param_1)

{
    return *(undefined4 *)(topol_machine._92_4_ + param_1 * 0xc + 8);
}

undefined4 platform_get_fan_min_speed(int param_1)

{
    return *(undefined4 *)(topol_machine._92_4_ + param_1 * 0xc + 4);
}

undefined4 *platform_get_fan_control_info(undefined4 *param_1)

{
    undefined4 uVar1;
    undefined4 uVar2;
    undefined4 uVar3;

    uVar3 = topol_machine._52_4_;
    uVar2 = topol_machine._48_4_;
    uVar1 = topol_machine._44_4_;
    *param_1 = topol_machine._40_4_;
    param_1[1] = uVar1;
    param_1[2] = uVar2;
    param_1[3] = uVar3;
    uVar3 = topol_machine._68_4_;
    uVar2 = topol_machine._64_4_;
    uVar1 = topol_machine._60_4_;
    param_1[4] = topol_machine._56_4_;
    param_1[5] = uVar1;
    param_1[6] = uVar2;
    param_1[7] = uVar3;
    uVar3 = topol_machine._84_4_;
    uVar2 = topol_machine._80_4_;
    uVar1 = topol_machine._76_4_;
    param_1[8] = topol_machine._72_4_;
    param_1[9] = uVar1;
    param_1[10] = uVar2;
    param_1[0xb] = uVar3;
    param_1[0xc] = topol_machine._88_4_;
    return param_1;
}

undefined4 platform_get_pic_device_high(int param_1)

{
    return *(undefined4 *)(topol_machine._36_4_ + param_1 * 0x78 + 0x40);
}

undefined4 platform_get_psu_gpio_port(void)

{
    return topol_machine._112_4_;
}

undefined4 platform_is_psu_supported(short param_1)

{
    int local_c;

    local_c = 0;
    while (true) {
        if ((int)topol_machine._96_4_ <= local_c) {
            return 0;
        }
        if (param_1 == *(short *)(topol_machine._120_4_ + local_c * 2))
            break;
        local_c = local_c + 1;
    }
    return 1;
}

undefined4 FUN_000778a0(void)

{
    undefined4 in_r3;

    return in_r3;
}

undefined4 platform_topol_init(void)

{
    undefined4 uVar1;
    undefined1 auStack_110c[4096];
    undefined1 auStack_10c[252];
    int *local_10;
    int local_c;

    local_c = 0;
    local_10 = (int *)json_load_file("/etc/topol.conf", 0, auStack_10c);
    if ((local_10 == (int *)0x0) || (*local_10 != 0)) {
        V_LOCK();
        logfmt_raw(auStack_110c, 0x1000, 0, "load topol config file %s failed",
                   "/etc/topol.conf");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/topol/topol.c",
             0x9f, "platform_topol_init", 0x13, 0x5e8, 0x14, auStack_110c);
        uVar1 = 0xffffffff;
    } else {
        local_c = FUN_0006f850(local_10);
        if (local_c == 0) {
            local_c = FUN_0006fd8c(local_10);
            if (local_c == 0) {
                local_c = FUN_00070010(local_10);
                if (local_c == 0) {
                    local_c = FUN_00070bdc(local_10);
                    if (local_c == 0) {
                        local_c = FUN_00075b94(local_10);
                        if (local_c != 0) {
                            V_LOCK();
                            logfmt_raw(auStack_110c, 0x1000, 0,
                                       "parse chain failed");
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/backend/"
                                 "topol/topol.c",
                                 0x9f, "platform_topol_init", 0x13, 0x60c, 0x14,
                                 auStack_110c);
                        }
                    } else {
                        V_LOCK();
                        logfmt_raw(auStack_110c, 0x1000, 0, "parse fan failed");
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/topol/"
                             "topol.c",
                             0x9f, "platform_topol_init", 0x13, 0x604, 0x14,
                             auStack_110c);
                    }
                } else {
                    V_LOCK();
                    logfmt_raw(auStack_110c, 0x1000, 0, "parse power failed");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/topol/topol.c",
                         0x9f, "platform_topol_init", 0x13, 0x5fd, 0x14,
                         auStack_110c);
                }
            } else {
                V_LOCK();
                logfmt_raw(auStack_110c, 0x1000, 0, "parse processor failed");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "topol/topol.c",
                     0x9f, "platform_topol_init", 0x13, 0x5f6, 0x14,
                     auStack_110c);
            }
        } else {
            V_LOCK();
            logfmt_raw(auStack_110c, 0x1000, 0, "parse machine failed");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                0x9f, "platform_topol_init", 0x13, 0x5ef, 0x14, auStack_110c);
        }
        FUN_0006f280(local_10);
        FUN_000778a0();
        if (local_c == 0) {
            uVar1 = 0;
        } else {
            uVar1 = 0x130;
        }
    }
    return uVar1;
}

undefined4 dev_ctrl(void)

{
    undefined4 uVar1;

    uVar1 = dev_ctrl_hal();
    return uVar1;
}

undefined4 FUN_00077cb0(undefined4 param_1, undefined4 param_2)

{
    V_STR(param_1, "error", param_2);
    return param_1;
}

undefined4 FUN_00077ce8(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "chain", param_3, param_4);
    return param_1;
}

void FUN_00077d1c(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_00077ea8(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

void FUN_00078038(undefined1 *param_1, undefined4 param_2)

{
    param_1[3] = (char)param_2;
    param_1[2] = (char)((uint)param_2 >> 8);
    param_1[1] = (char)((uint)param_2 >> 0x10);
    *param_1 = (char)((uint)param_2 >> 0x18);
    return;
}

uint FUN_000780bc(uint param_1)

{
    return param_1 << 0x18 | (param_1 >> 8 & 0xff) << 0x10 |
           (param_1 >> 0x10 & 0xff) << 8 | param_1 >> 0x18;
}

ushort FUN_000780e4(ushort param_1)

{
    return param_1 << 8 | param_1 >> 8;
}

void FUN_00078114(int param_1, char param_2)

{
    undefined4 local_34;
    undefined1 local_30[12];
    undefined1 auStack_24[8];
    undefined1 local_1c;
    char local_1b;
    undefined2 local_1a;
    undefined4 local_14;

    memset(auStack_24, 0, 0x10);
    local_14 = 0;
    local_34 = 0;
    local_1c = 0;
    local_1b = (char)*(undefined4 *)(param_1 + 0x1ac) * param_2;
    local_1a = 0;
    (**(code **)(param_1 + 0x120))(param_1, auStack_24, 1, local_30, &local_34);
    return;
}

int FUN_000781dc(int param_1, uint param_2)

{
    undefined4 uVar1;
    undefined1 auStack_15c4[4096];
    char local_5c4[1024];
    char acStack_1c4[256];
    int local_c4;
    undefined1 auStack_c0[8];
    undefined1 local_b8;
    undefined2 local_b6;
    undefined4 local_b0;
    undefined4 uStack_ac;
    undefined4 uStack_a8;
    undefined4 uStack_a4;
    undefined4 local_a0;
    undefined4 uStack_9c;
    undefined4 uStack_98;
    undefined4 uStack_94;
    undefined4 local_90;
    undefined4 uStack_8c;
    undefined4 uStack_88;
    undefined4 uStack_84;
    undefined4 local_80;
    undefined4 uStack_7c;
    undefined4 uStack_78;
    undefined4 uStack_74;
    undefined4 local_70;
    undefined4 uStack_6c;
    undefined4 uStack_68;
    undefined4 uStack_64;
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    int local_30;
    int local_2c;
    int local_28;
    char *local_24;
    uint local_20;
    uint local_1c;
    int local_18;
    void *local_14;

    local_c4 = 0;
    local_18 = 0;
    local_1c = 0;
    memset(acStack_1c4, 0, 0x100);
    V_LOCK();
    logfmt_raw(auStack_15c4, 0x1000, 0, "%s chip_no %d",
               "ChipSetting_get_addr_LTC_1491", param_2);
    V_UNLOCK();
    uVar1 = 0x32;
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_get_addr_LTC_1491", 0x1d, 0x32, 0x14, auStack_15c4);
    memset(auStack_c0, 0, 0x10);
    local_b8 = 1;
    local_b6 = 0;
    local_14 = malloc(param_2 * 0xc);
    memset(local_14, 0, param_2 * 0xc);
    (**(code **)(param_1 + 0x120))(param_1, auStack_c0, param_2, local_14,
                                   &local_c4, uVar1, 3000, 0);
    V_LOCK();
    FUN_00077ce8(&local_b0, &local_b0, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_15c4, 0x1000, 0, uStack_94, local_b0, uStack_ac,
               uStack_a8, uStack_a4, local_a0, uStack_9c, uStack_98, uStack_94,
               "%s detect %d chips", "ChipSetting_get_addr_LTC_1491", local_c4);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_get_addr_LTC_1491", 0x1d, 0x3c, 0x14, auStack_15c4);
    for (local_2c = 0; local_2c < local_c4; local_2c = local_2c + 1) {
        local_1c = (*(uint *)((int)local_14 + local_2c * 0xc) & 0xff) << 8 |
                   *(uint *)((int)local_14 + local_2c * 0xc) >> 8 & 0xff;
        V_LOCK();
        logfmt_raw(auStack_15c4, 0x1000, 0,
                   "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x",
                   local_1c, *(undefined4 *)(param_1 + 0x148), local_2c,
                   *(undefined2 *)((int)local_14 + local_2c * 0xc + 6),
                   *(undefined1 *)((int)local_14 + local_2c * 0xc + 4));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_get_addr_LTC_1491", 0x1d, 0x40, 0x14,
             auStack_15c4);
        if (local_1c == *(uint *)(param_1 + 0x148)) {
            local_30 = FUN_000cc2a0(
                *(undefined1 *)((int)local_14 + local_2c * 0xc + 4),
                *(undefined4 *)(param_1 + 0x1ac));
            acStack_1c4[local_30] = acStack_1c4[local_30] + '\x01';
            local_18 = local_18 + 1;
            V_LOCK();
            FUN_00077ce8(&local_90, &local_90, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(auStack_15c4, 0x1000, 0, uStack_74, local_90, uStack_8c,
                       uStack_88, uStack_84, local_80, uStack_7c, uStack_78,
                       uStack_74, "chip_id:%d, %03d", local_30,
                       *(undefined1 *)((int)local_14 + local_2c * 0xc + 4));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./backend/"
                 "chip_setting.c",
                 0xa2, "ChipSetting_get_addr_LTC_1491", 0x1d, 0x46, 0x14,
                 auStack_15c4);
        }
    }
    local_28 = 0;
    memset(local_5c4, 0, 0x400);
    local_5c4[0] = '\n';
    local_24 = local_5c4;
    for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
        if (acStack_1c4[local_20] == '\0') {
            sprintf(local_24, "%03d ", local_20);
            local_24 = local_24 + 4;
            local_28 = local_28 + 1;
        }
    }
    if (local_18 < *(int *)(param_1 + 0x150)) {
        V_LOCK();
        FUN_00077ce8(&local_70, &local_70, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        FUN_00077cb0(&local_50, "asic num error");
        logfmt_raw(auStack_15c4, 0x1000, 0, uStack_54, local_70, uStack_6c,
                   uStack_68, uStack_64, local_60, uStack_5c, uStack_58,
                   uStack_54, local_50, uStack_4c, uStack_48, uStack_44,
                   local_40, uStack_3c, uStack_38, uStack_34,
                   "detected asic num less than design(%d<%d)", local_18,
                   *(undefined4 *)(param_1 + 0x150));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_get_addr_LTC_1491", 0x1d, 0x5f, 100,
             auStack_15c4);
        V_LOCK();
        logfmt_raw(auStack_15c4, 0x1000, 0, "bad asic: %s", local_5c4);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_get_addr_LTC_1491", 0x1d, 0x60, 0x28,
             auStack_15c4);
    }
    free(local_14);
    *(int *)(param_1 + 0x1a8) = local_18;
    return local_c4;
}

undefined4 FUN_00078978(int param_1)

{
    undefined4 uVar1;
    undefined1 auStack_101c[4096];
    undefined4 local_1c[2];
    undefined1 local_14;
    undefined1 local_13;
    undefined2 local_12;

    V_LOCK();
    logfmt_raw(auStack_101c, 0x1000, 0, "bridge reset %s %02x",
               "ChipSetting_bridge_reset_LTC_1491", 0x44);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_bridge_reset_LTC_1491", 0x21, 0x6e, 0x14,
         auStack_101c);
    memset(local_1c, 0, 0x10);
    local_14 = 1;
    local_13 = 0;
    local_12 = 0x44;
    local_1c[0] = 2;
    uVar1 = (**(code **)(param_1 + 0x10c))(param_1, local_1c);
    return uVar1;
}

undefined4 FUN_00078a8c(int param_1)

{
    undefined4 uVar1;
    undefined1 auStack_101c[4096];
    undefined4 local_1c[2];
    undefined1 local_14;
    undefined1 local_13;
    undefined2 local_12;

    V_LOCK();
    logfmt_raw(auStack_101c, 0x1000, 0, "software_reset %s %02x",
               "ChipSetting_software_reset_LTC_1491", 0x44);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_software_reset_LTC_1491", 0x23, 0x7b, 0x14,
         auStack_101c);
    memset(local_1c, 0, 0x10);
    local_14 = 1;
    local_13 = 0;
    local_12 = 0x44;
    local_1c[0] = 3;
    uVar1 = (**(code **)(param_1 + 0x10c))(param_1, local_1c);
    return uVar1;
}

undefined4 FUN_00078ba0(int param_1, undefined4 param_2)

{
    undefined4 uVar1;
    char cVar2;
    undefined1 auStack_101c[4096];
    undefined4 local_1c[2];
    undefined1 local_14;
    char local_13;
    undefined2 local_12;

    V_LOCK();
    logfmt_raw(auStack_101c, 0x1000, 0, "software_reset %s %02x",
               "ChipSetting_software_reset_one_asic_LTC_1491", 0x44);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_software_reset_one_asic_LTC_1491", 0x2c, 0x88, 0x14,
         auStack_101c, param_2);
    cVar2 = (char)param_2;
    memset(local_1c, 0, 0x10);
    local_14 = 0;
    local_13 = (char)*(undefined4 *)(param_1 + 0x1ac) * cVar2;
    local_12 = 0x44;
    local_1c[0] = 3;
    uVar1 = (**(code **)(param_1 + 0x10c))(param_1, local_1c);
    return uVar1;
}

undefined4 FUN_00078ce8(int param_1, undefined4 param_2)

{
    undefined4 uVar1;
    char cVar2;
    undefined1 auStack_101c[4096];
    undefined4 local_1c[2];
    undefined1 local_14;
    char local_13;
    undefined2 local_12;

    V_LOCK();
    logfmt_raw(auStack_101c, 0x1000, 0, "software_reset %s %02x",
               "ChipSetting_software_reset_one_asic_core_LTC_1491", 0x44);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_software_reset_one_asic_core_LTC_1491", 0x31, 0x95,
         0x14, auStack_101c, param_2);
    cVar2 = (char)param_2;
    memset(local_1c, 0, 0x10);
    local_14 = 0;
    local_13 = (char)*(undefined4 *)(param_1 + 0x1ac) * cVar2;
    local_12 = 0x44;
    local_1c[0] = 1;
    uVar1 = (**(code **)(param_1 + 0x10c))(param_1, local_1c);
    return uVar1;
}

undefined4 FUN_00078e30(int param_1, byte param_2)

{
    undefined1 auStack_1050[4096];
    uint local_50[2];
    undefined1 local_48;
    undefined1 local_47;
    undefined2 local_46;
    undefined1 local_44;
    undefined1 local_43;
    undefined1 local_42;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    undefined4 local_1c;
    uint local_18;
    undefined4 local_14;

    local_14 = 0;
    local_18 = (uint)param_2;
    memset(local_50, 0, 0x10);
    V_LOCK();
    FUN_00077ce8(&local_40, &local_40, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_1050, 0x1000, 0, uStack_24, local_40, uStack_3c,
               uStack_38, uStack_34, local_30, uStack_2c, uStack_28, uStack_24,
               "set core ticket mask reg %02x tm %02x", 0xff, param_2);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_core_ticket_mask_LTC_1491", 0x25, 0xb6, 0x28,
         auStack_1050);
    local_48 = 1;
    local_47 = 0;
    local_46 = 0xff;
    local_50[0] = (uint)param_2;
    local_42 = 1;
    local_44 = 0xff;
    local_43 = (undefined1) * (undefined4 *)(param_1 + 0x154);
    local_1c = (**(code **)(param_1 + 0x110))(param_1, local_50);
    usleep(1000);
    *(uint *)(param_1 + 0x1b0) = (uint)param_2;
    return local_1c;
}

undefined4 FUN_00079000(int param_1, byte param_2, undefined4 param_3)

{
    undefined1 auStack_1048[4096];
    undefined4 local_48[2];
    undefined1 local_40;
    undefined1 local_3f;
    undefined2 local_3e;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    undefined4 local_18;
    undefined1 local_11;

    local_18 = 0;
    if (*(int *)(param_1 + 0x150) < (int)(uint)param_2) {
        local_11 = 0;
    } else {
        local_11 = *(undefined1 *)(*(int *)(param_1 + 0x1ec) + (uint)param_2);
    }
    memset(local_48, 0, 0x10);
    local_40 = 0;
    local_3f = local_11;
    local_3e = 0x30;
    local_48[0] = param_3;
    V_LOCK();
    FUN_00077ce8(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_1048, 0x1000, 0, uStack_1c, local_38, uStack_34,
               uStack_30, uStack_2c, local_28, uStack_24, uStack_20, uStack_1c,
               "chip_id %02x, chip_addr %02x, set io drive strengh %08x",
               param_2, local_11, local_48[0]);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_io_drive_strenth_LTC_1491", 0x25, 0xd7, 0x28,
         auStack_1048);
    local_18 = (**(code **)(param_1 + 0x10c))(param_1, local_48);
    usleep(10000);
    return local_18;
}

undefined4 FUN_000791f8(int param_1, undefined4 param_2)

{
    undefined1 auStack_1048[4096];
    undefined4 local_48[2];
    undefined1 local_40;
    undefined1 local_3f;
    undefined2 local_3e;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    undefined4 local_14;

    memset(local_48, 0, 0x10);
    local_40 = 1;
    local_3f = 0;
    local_3e = 0x1c;
    local_48[0] = param_2;
    V_LOCK();
    FUN_00077ce8(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_1048, 0x1000, 0, uStack_1c, local_38, uStack_34,
               uStack_30, uStack_2c, local_28, uStack_24, uStack_20, uStack_1c,
               "set misc ctrl %08x", local_48[0]);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_misc_ctrl_LTC_1491", 0x1e, 0xe6, 0x28,
         auStack_1048);
    local_14 = (**(code **)(param_1 + 0x10c))(param_1, local_48);
    usleep(10000);
    return local_14;
}

undefined4 FUN_00079360(int param_1, undefined4 param_2)

{
    undefined1 auStack_1048[4096];
    undefined4 local_48[2];
    undefined1 local_40;
    undefined1 local_3f;
    undefined2 local_3e;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    undefined4 local_14;

    memset(local_48, 0, 0x10);
    local_40 = 1;
    local_3f = 0;
    local_3e = 0x61;
    local_48[0] = param_2;
    V_LOCK();
    FUN_00077ce8(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_1048, 0x1000, 0, uStack_1c, local_38, uStack_34,
               uStack_30, uStack_2c, local_28, uStack_24, uStack_20, uStack_1c,
               "set bist err num threshold %08x", local_48[0]);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_bist_threshold_set_rvn_LTC_1491", 0x2b, 0xf6, 0x28,
         auStack_1048);
    local_14 = (**(code **)(param_1 + 0x10c))(param_1, local_48);
    usleep(10000);
    return local_14;
}

undefined4 FUN_000794c8(int param_1, undefined4 param_2)

{
    undefined1 auStack_1048[4096];
    undefined4 local_48[2];
    undefined1 local_40;
    undefined1 local_3f;
    undefined2 local_3e;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    undefined4 local_14;

    memset(local_48, 0, 0x10);
    local_40 = 1;
    local_3f = 0;
    local_3e = 100;
    local_48[0] = param_2;
    V_LOCK();
    FUN_00077ce8(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_1048, 0x1000, 0, uStack_1c, local_38, uStack_34,
               uStack_30, uStack_2c, local_28, uStack_24, uStack_20, uStack_1c,
               "set retin on %08x", local_48[0]);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_retin_on_rvn_LTC_1491", 0x21, 0x104, 0x28,
         auStack_1048);
    local_14 = (**(code **)(param_1 + 0x10c))(param_1, local_48);
    usleep(10000);
    return local_14;
}

undefined4 FUN_00079630(int param_1, undefined4 param_2)

{
    undefined1 auStack_1048[4096];
    undefined4 local_48[2];
    undefined1 local_40;
    undefined1 local_3f;
    undefined2 local_3e;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    undefined4 local_14;

    memset(local_48, 0, 0x10);
    local_40 = 1;
    local_3f = 0;
    local_3e = 0x30;
    local_48[0] = param_2;
    V_LOCK();
    FUN_00077ce8(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_1048, 0x1000, 0, uStack_1c, local_38, uStack_34,
               uStack_30, uStack_2c, local_28, uStack_24, uStack_20, uStack_1c,
               "set io drive strenth %08x", local_48[0]);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_io_drive_strenth_all_LTC_1491", 0x29, 0x112, 0x28,
         auStack_1048);
    local_14 = (**(code **)(param_1 + 0x10c))(param_1, local_48);
    usleep(10000);
    return local_14;
}

undefined4 FUN_00079798(int param_1, uint param_2)

{
    undefined1 auStack_1078[4096];
    uint local_78;
    int local_74;
    uint local_70[2];
    undefined1 local_68;
    undefined1 local_67;
    undefined2 local_66;
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    undefined4 local_1c;
    undefined4 *local_18;
    int local_14;

    local_74 = 0;
    memset(local_70, 0, 0x10);
    local_68 = 1;
    local_67 = 0;
    local_66 = 0x1c;
    local_18 = (undefined4 *)malloc(*(int *)(param_1 + 0x150) * 0xc);
    memset(local_18, 0, *(int *)(param_1 + 0x150) * 0xc);
    (**(code **)(param_1 + 0x120))(param_1, local_70,
                                   *(undefined4 *)(param_1 + 0x150), local_18,
                                   &local_74);
    for (local_14 = 0; local_14 < local_74; local_14 = local_14 + 1) {
        if (*(short *)((int)local_18 + local_14 * 0xc + 6) == 0x1c) {
            V_LOCK();
            FUN_00077ce8(&local_60, &local_60, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(auStack_1078, 0x1000, 0, uStack_44, local_60, uStack_5c,
                       uStack_58, uStack_54, local_50, uStack_4c, uStack_48,
                       uStack_44, "[MISC CTRL] asic %02x, reg %02x state %08x",
                       *(undefined1 *)(local_18 + local_14 * 3 + 1),
                       *(undefined2 *)((int)local_18 + local_14 * 0xc + 6),
                       local_18[local_14 * 3]);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./backend/"
                 "chip_setting.c",
                 0xa2, "ChipSetting_pll_sel_LTC_1491", 0x1c, 0x128, 0x14,
                 auStack_1078);
        }
    }
    local_78 = 0;
    FUN_00078038(&local_78, *local_18);
    free(local_18);
    local_68 = 1;
    local_67 = 0;
    local_66 = 0x1c;
    local_70[0] = local_78 & 0xfffffffb | (param_2 & 1) << 2;
    V_LOCK();
    FUN_00077ce8(&local_40, &local_40, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_1078, 0x1000, 0, uStack_24, local_40, uStack_3c,
               uStack_38, uStack_34, local_30, uStack_2c, uStack_28, uStack_24,
               "set pll sel %u %08x", param_2, local_70[0]);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_pll_sel_LTC_1491", 0x1c, 0x134, 0x28, auStack_1078);
    local_1c = (**(code **)(param_1 + 0x10c))(param_1, local_70);
    usleep(10000);
    return local_1c;
}

undefined4 FUN_00079b74(int param_1, undefined4 param_2)

{
    undefined1 auStack_1048[4096];
    undefined4 local_48[2];
    undefined1 local_40;
    undefined1 local_3f;
    undefined2 local_3e;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    undefined4 local_14;

    memset(local_48, 0, 0x10);
    local_40 = 1;
    local_3f = 0;
    local_3e = 0x54;
    local_48[0] = param_2;
    V_LOCK();
    FUN_00077ce8(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_1048, 0x1000, 0, uStack_1c, local_38, uStack_34,
               uStack_30, uStack_2c, local_28, uStack_24, uStack_20, uStack_1c,
               "set nonce len value %08x", local_48[0]);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_nonce_len_LTC_1491", 0x1e, 0x144, 0x28,
         auStack_1048);
    local_14 = (**(code **)(param_1 + 0x10c))(param_1, local_48);
    usleep(10000);
    return local_14;
}

undefined4 FUN_00079cdc(int param_1, undefined4 param_2)

{
    undefined1 auStack_1048[4096];
    undefined4 local_48[2];
    undefined1 local_40;
    undefined1 local_3f;
    undefined2 local_3e;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    undefined4 local_14;

    memset(local_48, 0, 0x10);
    local_40 = 1;
    local_3f = 0;
    local_3e = 0x2c;
    local_48[0] = param_2;
    V_LOCK();
    FUN_00077ce8(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_1048, 0x1000, 0, uStack_1c, local_38, uStack_34,
               uStack_30, uStack_2c, local_28, uStack_24, uStack_20, uStack_1c,
               "set io cfg value %08x", local_48[0]);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_io_cfg_LTC_1491", 0x1b, 0x154, 0x28, auStack_1048);
    local_14 = (**(code **)(param_1 + 0x10c))(param_1, local_48);
    usleep(10000);
    return local_14;
}

int FUN_00079e44(int param_1, int param_2, uint param_3)

{
    undefined1 auStack_109c[4096];
    uint local_9c[2];
    undefined1 local_94;
    undefined1 local_93;
    undefined2 local_92;
    undefined1 local_90;
    int local_8c;
    undefined4 local_88;
    undefined4 uStack_84;
    undefined4 uStack_80;
    undefined4 uStack_7c;
    undefined4 local_78;
    undefined4 uStack_74;
    undefined4 uStack_70;
    undefined4 uStack_6c;
    undefined4 local_68;
    undefined4 uStack_64;
    undefined4 uStack_60;
    undefined4 uStack_5c;
    undefined4 local_58;
    undefined4 uStack_54;
    undefined4 uStack_50;
    undefined4 uStack_4c;
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    void *local_28;
    undefined1 local_21;
    int local_20;
    int local_1c;
    undefined1 local_15;
    uint local_14;

    local_1c = 0;
    local_8c = 0;
    local_14 = param_3 & 1;
    local_15 = 0;
    local_21 = 0;
    if ((param_2 == -1) || (*(int *)(param_1 + 0x150) < param_2)) {
        local_15 = 1;
    } else {
        local_21 = *(undefined1 *)(*(int *)(param_1 + 0x1ec) + param_2);
    }
    memset(local_9c, 0, 0x10);
    local_94 = 0;
    local_93 = local_21;
    local_92 = 0xff;
    local_9c[0] = 0;
    local_90 = 0;
    local_28 = malloc(0xc);
    memset(local_28, 0, 0xc);
    (**(code **)(param_1 + 300))(param_1, local_9c, 1, local_28, &local_8c);
    for (local_20 = 0; local_20 < local_8c; local_20 = local_20 + 1) {
        if (*(short *)((int)local_28 + local_20 * 0xc + 6) == 0xff) {
            V_LOCK();
            FUN_00077ce8(&local_88, &local_88, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(auStack_109c, 0x1000, 0, uStack_6c, local_88, uStack_84,
                       uStack_80, uStack_7c, local_78, uStack_74, uStack_70,
                       uStack_6c,
                       "%s chip %02x, core %02x, reg %02x, core_mode %08x",
                       "ChipSetting_same_nonce_LTC_1491",
                       *(undefined1 *)((int)local_28 + local_20 * 0xc + 4),
                       *(undefined1 *)((int)local_28 + local_20 * 0xc + 8),
                       *(undefined2 *)((int)local_28 + local_20 * 0xc + 6),
                       *(undefined4 *)((int)local_28 + local_20 * 0xc));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./backend/"
                 "chip_setting.c",
                 0xa2, "ChipSetting_same_nonce_LTC_1491", 0x1f, 0x177, 0x14,
                 auStack_109c);
            local_14 = *(uint *)((int)local_28 + local_20 * 0xc) | param_3 & 1;
        } else {
            V_LOCK();
            FUN_00077ce8(&local_68, &local_68, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(
                auStack_109c, 0x1000, 0, uStack_4c, local_68, uStack_64,
                uStack_60, uStack_5c, local_58, uStack_54, uStack_50, uStack_4c,
                "%s chip %02x, expected reg %02x, but %02x, core_mode %08x",
                "ChipSetting_same_nonce_LTC_1491",
                *(undefined1 *)((int)local_28 + local_20 * 0xc + 4), 0xff,
                *(undefined2 *)((int)local_28 + local_20 * 0xc + 6),
                *(undefined4 *)((int)local_28 + local_20 * 0xc));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./backend/"
                 "chip_setting.c",
                 0xa2, "ChipSetting_same_nonce_LTC_1491", 0x1f, 0x17b, 100,
                 auStack_109c);
        }
    }
    free(local_28);
    local_94 = local_15;
    local_93 = local_21;
    local_92 = 0xff;
    local_90 = 0xff;
    local_9c[0] = local_14;
    local_1c = (**(code **)(param_1 + 0x110))(param_1, local_9c);
    if (local_1c < 0) {
        V_LOCK();
        FUN_00077ce8(&local_48, &local_48, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_109c, 0x1000, 0, uStack_2c, local_48, uStack_44,
                   uStack_40, uStack_3c, local_38, uStack_34, uStack_30,
                   uStack_2c, "set same nonce failed! chip_id:%d", param_2);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_same_nonce_LTC_1491", 0x1f, 0x188, 100,
             auStack_109c);
        local_1c = -1;
    }
    return local_1c;
}

/* WARNING: Type propagation algorithm not settling */

bool FUN_0007a3ec(int param_1, int param_2, int *param_3)

{
    uint uVar1;
    undefined1 auStack_10c8[4096];
    int local_c8;
    int local_c4[3];
    undefined1 local_b8;
    undefined1 local_b7;
    undefined2 local_b6;
    undefined1 local_b4;
    undefined4 local_b0;
    undefined4 uStack_ac;
    undefined4 uStack_a8;
    undefined4 uStack_a4;
    undefined4 local_a0;
    undefined4 uStack_9c;
    undefined4 uStack_98;
    undefined4 uStack_94;
    undefined4 local_90;
    undefined4 uStack_8c;
    undefined4 uStack_88;
    undefined4 uStack_84;
    undefined4 local_80;
    undefined4 uStack_7c;
    undefined4 uStack_78;
    undefined4 uStack_74;
    undefined4 local_70;
    undefined4 uStack_6c;
    undefined4 uStack_68;
    undefined4 uStack_64;
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    void *local_30;
    int local_2c;
    undefined4 *local_28;
    int local_24;
    int local_20;
    int local_1c;
    undefined1 local_15;
    int local_14;

    local_c4[0] = 0;
    local_1c = 0;
    local_14 = 0;
    if ((param_2 == -1) || (*(int *)(param_1 + 0x150) < param_2)) {
        local_15 = 0;
    } else {
        local_15 = *(undefined1 *)(*(int *)(param_1 + 0x1ec) + param_2);
    }
    memset(local_c4 + 1, 0, 0x10);
    local_b8 = 0;
    local_b7 = local_15;
    local_b6 = 0x3c;
    local_28 = (undefined4 *)malloc(0xc);
    memset(local_28, 0, 0xc);
    (**(code **)(param_1 + 0x120))(param_1, local_c4 + 1, 1, local_28,
                                   local_c4);
    for (local_24 = 0; local_24 < local_c4[0]; local_24 = local_24 + 1) {
        if (*(short *)((int)local_28 + local_24 * 0xc + 6) == 0x3c) {
            local_c8 = 0;
            FUN_00078038(&local_c8, *local_28);
            local_1c = local_1c + local_c8;
            V_LOCK();
            FUN_00077ce8(&local_b0, &local_b0, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(
                auStack_10c8, 0x1000, 0, uStack_94, local_b0, uStack_ac,
                uStack_a8, uStack_a4, local_a0, uStack_9c, uStack_98, uStack_94,
                "[Top Nonce Cnt] asic %02x, reg %02x cnt %08x",
                *(undefined1 *)(local_28 + local_24 * 3 + 1),
                *(undefined2 *)((int)local_28 + local_24 * 0xc + 6), local_c8);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./backend/"
                 "chip_setting.c",
                 0xa2, "ChipSetting_nonce_counter_LTC_1491", 0x22, 0x1ac, 0x14,
                 auStack_10c8);
        }
    }
    free(local_28);
    *param_3 = local_1c;
    memset(local_c4 + 1, 0, 0x10);
    local_b8 = 0;
    local_b7 = 0;
    local_b6 = 10;
    local_c4[1] = 1;
    local_b4 = 0xff;
    local_2c = *(int *)(param_1 + 0x154);
    local_30 = malloc(local_2c * 0xc);
    memset(local_30, 0, local_2c * 0xc);
    (**(code **)(param_1 + 300))(param_1, local_c4 + 1, local_2c, local_30,
                                 local_c4);
    for (local_20 = 0; local_20 < local_c4[0]; local_20 = local_20 + 1) {
        if (*(short *)((int)local_30 + local_20 * 0xc + 6) == 10) {
            local_14 = *(int *)((int)local_30 + local_20 * 0xc) + local_14;
            V_LOCK();
            FUN_00077ce8(&local_90, &local_90, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(auStack_10c8, 0x1000, 0, uStack_74, local_90, uStack_8c,
                       uStack_88, uStack_84, local_80, uStack_7c, uStack_78,
                       uStack_74,
                       "%s chip %02x, core %02x, reg %02x, core_nonce_cnt %08x",
                       "ChipSetting_nonce_counter_LTC_1491",
                       *(undefined1 *)((int)local_30 + local_20 * 0xc + 4),
                       *(undefined1 *)((int)local_30 + local_20 * 0xc + 8),
                       *(undefined2 *)((int)local_30 + local_20 * 0xc + 6),
                       *(undefined4 *)((int)local_30 + local_20 * 0xc));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./backend/"
                 "chip_setting.c",
                 0xa2, "ChipSetting_nonce_counter_LTC_1491", 0x22, 0x1c3, 0x14,
                 auStack_10c8);
        } else {
            V_LOCK();
            FUN_00077ce8(&local_70, &local_70, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(
                auStack_10c8, 0x1000, 0, uStack_54, local_70, uStack_6c,
                uStack_68, uStack_64, local_60, uStack_5c, uStack_58, uStack_54,
                "%s chip %02x, expected reg %02x, but %02x, core_nonce_cnt "
                "%08x",
                "ChipSetting_nonce_counter_LTC_1491",
                *(undefined1 *)((int)local_30 + local_20 * 0xc + 4), 0xff,
                *(undefined2 *)((int)local_30 + local_20 * 0xc + 6),
                *(undefined4 *)((int)local_30 + local_20 * 0xc));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./backend/"
                 "chip_setting.c",
                 0xa2, "ChipSetting_nonce_counter_LTC_1491", 0x22, 0x1c6, 100,
                 auStack_10c8);
        }
    }
    free(local_30);
    V_LOCK();
    FUN_00077ce8(&local_50, &local_50, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    if (local_1c == local_14) {
        uVar1 = 0x3ad0;
    } else {
        uVar1 = 0x3ad8;
    }
    logfmt_raw(auStack_10c8, 0x1000, 0, uStack_34, local_50, uStack_4c,
               uStack_48, uStack_44, local_40, uStack_3c, uStack_38, uStack_34,
               "check nonce counter, top_nonce_cnt %d, core_nocne_cnt %d (%s)",
               local_1c, local_14, uVar1 | 0x120000);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_nonce_counter_LTC_1491", 0x22, 0x1cc, 0x28,
         auStack_10c8);
    return local_1c != local_14;
}

undefined4 FUN_0007ab90(int param_1, word *param_2, uint param_3)

{
    undefined1 auStack_1054[4096];
    uint local_54;
    uint local_50[2];
    undefined1 local_48;
    undefined1 local_47;
    undefined2 local_46;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    undefined4 local_20;
    undefined4 local_1c;
    uint local_18;
    uint local_14;

    local_18 = 0x1a;
    local_14 = 0;
    local_1c = 0;
    memset(local_50, 0, 0x10);
    local_48 = 1;
    local_47 = 0;
    local_46 = 0x60;
    if (param_2 == (word *)0x16e360) {
    LAB_0007ad24:
        local_18 = 1;
        goto LAB_0007ad6c;
    }
    if ((int)param_2 < 0x16e361) {
        if (param_2 == (word *)0x70800) {
            local_18 = 6;
            goto LAB_0007ad6c;
        }
        if ((int)param_2 < 0x70801) {
            if (param_2 == (word *)0x9600) {
                local_18 = 0x50;
                goto LAB_0007ad6c;
            }
            if (param_2 == &WORD_0001c200) {
                local_18 = 0x1a;
                goto LAB_0007ad6c;
            }
        } else if ((param_2 == (word *)&UNK_000e1000) ||
                   (param_2 == (word *)&UNK_000fe502)) {
            local_18 = 2;
            goto LAB_0007ad6c;
        }
    } else {
        if (param_2 == (word *)0x2faf08) {
        LAB_0007ad18:
            local_18 = 0;
            goto LAB_0007ad6c;
        }
        if ((int)param_2 < 0x2faf09) {
            if (param_2 == (word *)0x17d784)
                goto LAB_0007ad24;
            if (param_2 == (word *)0x2dc6c0)
                goto LAB_0007ad18;
        } else {
            if (param_2 == (word *)0x5f5e10) {
                local_14 = 1;
                local_18 = 1;
                goto LAB_0007ad6c;
            }
            if (param_2 == (word *)0xbebc20) {
                local_14 = 1;
                local_18 = 0;
                goto LAB_0007ad6c;
            }
        }
    }
    local_18 = 0x1a;
LAB_0007ad6c:
    if (local_14 != 0) {
        (**(code **)(param_1 + 0xc0))(0x42c80000, param_1, 1);
    }
    local_54 = (local_18 & 0x1ff) << 8 | (param_3 & 3) << 4 | local_14 & 1;
    local_50[0] = local_54;
    V_LOCK();
    FUN_00077ce8(&local_40, &local_40, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_1054, 0x1000, 0, uStack_24, local_40, uStack_3c,
               uStack_38, uStack_34, local_30, uStack_2c, uStack_28, uStack_24,
               "set fuart cfg value %08x/%d", local_50[0], param_2);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_fuart_cfg_LTC_1491", 0x1e, 0x210, 0x28,
         auStack_1054);
    local_20 = (**(code **)(param_1 + 0x10c))(param_1, local_50);
    usleep(10000);
    return local_20;
}

float FUN_0007aefc(float param_1, uint *param_2)

{
    undefined1 auStack_102c[4096];
    float fStack_2c;
    uint local_28;
    float fStack_24;
    float local_20;
    uint local_1c;
    uint local_18;
    uint local_14;
    uint local_10;
    float local_c;

    *param_2 = 0xc0540165;
    local_10 = 2;
    do {
        if ((int)local_10 < 1) {
            return 0.0;
        }
        for (local_18 = 0; (int)local_18 < 8; local_18 = local_18 + 1) {
            for (local_1c = local_18; -1 < (int)local_1c;
                 local_1c = local_1c - 1) {
                fStack_24 = (((float)(longlong)(int)(local_18 + 1) * param_1 *
                              (float)(longlong)(int)(local_1c + 1) *
                              (float)(longlong)(int)local_10) /
                             25.0) *
                            100.0;
                if ((int)fStack_24 % 100 < 0x33) {
                    local_14 = (int)fStack_24 / 100;
                } else {
                    local_14 = (int)fStack_24 / 100 + 1;
                }
                local_20 = ((float)(longlong)(int)local_14 * 25.0) /
                           (float)(longlong)(int)local_10;
                if (((((int)local_14 < 0xfb) && (0xf < (int)local_14)) &&
                     ((local_10 != 1 || (local_20 <= 3125.0)))) &&
                    ((local_20 <= 3200.0 && (2000.0 <= local_20)))) {
                    local_28 = (uint)(2400.0 < local_20);
                    local_c = ((((float)(longlong)(int)local_14 * 25.0) /
                                (float)(longlong)(int)local_10) /
                               (float)(longlong)(int)(local_18 + 1)) /
                              (float)(longlong)(int)(local_1c + 1);
                    *param_2 = local_28 << 0x1c | (local_14 & 0xfff) << 0x10 |
                               (local_10 & 0x3f) << 8 | (local_18 & 7) << 4 |
                               local_1c & 7 | 0xc0000000;
                    fStack_2c = ABS(local_c - param_1);
                    if (fStack_2c < 3.0) {
                        V_LOCK();
                        logfmt_raw(
                            auStack_102c, 0x1000, 0,
                            "target_freq:%.2f actual_freq:%.2f,vco:%.2f "
                            "fbdiv:%d refdiv:%d postdiv1:%d, postdiv2:%d",
                            (double)param_1, (double)local_c, (double)local_20,
                            local_14, local_10, local_18, local_1c);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/./backend/"
                             "chip_setting.c",
                             0xa2, "inferred_plldivider", 0x13, 0x244, 0x14,
                             auStack_102c);
                        return local_c;
                    }
                }
            }
        }
        local_10 = local_10 - 1;
    } while (true);
}

float FUN_0007b35c(float param_1, uint *param_2)

{
    undefined4 uVar1;
    int iVar2;
    undefined1 auStack_102c[4096];
    float fStack_2c;
    uint local_28;
    float fStack_24;
    float local_20;
    uint local_1c;
    uint local_18;
    uint local_14;
    uint local_10;
    float local_c;

    *param_2 = 0xc0540165;
    local_10 = 2;
    do {
        if ((int)local_10 < 1) {
            return 0.0;
        }
        for (local_18 = 0; (int)local_18 < 8; local_18 = local_18 + 1) {
            for (local_1c = local_18; local_c = 0.0, -1 < (int)local_1c;
                 local_1c = local_1c - 1) {
                fStack_24 = (((float)(longlong)(int)local_18 * param_1 *
                              (float)(longlong)(int)local_1c *
                              (float)(longlong)(int)local_10) /
                             25.0) *
                            100.0;
                if ((int)fStack_24 % 100 < 0x33) {
                    local_14 = (int)fStack_24 / 100;
                } else {
                    local_14 = (int)fStack_24 / 100 + 1;
                }
                local_20 = ((float)(longlong)(int)local_14 * 25.0) /
                           (float)(longlong)(int)local_10;
                if (((((int)local_14 < 0xfb) && (0xf < (int)local_14)) &&
                     ((local_10 != 1 || (local_20 <= 3125.0)))) &&
                    ((local_20 <= 3200.0 && (2000.0 <= local_20)))) {
                    local_28 = (uint)(2400.0 < local_20);
                    uVar1 = FUN_000cc518(local_14 * 0x19, local_10);
                    uVar1 = FUN_000cc518(uVar1, local_18);
                    iVar2 = FUN_000cc518(uVar1, local_1c);
                    local_c = (float)(longlong)iVar2;
                    *param_2 = local_28 << 0x1c | (local_14 & 0xfff) << 0x10 |
                               (local_10 & 0x3f) << 8 | (local_18 & 7) << 4 |
                               local_1c & 7 | 0xc0000000;
                    fStack_2c = ABS(local_c - param_1);
                    if (fStack_2c < 3.0) {
                        V_LOCK();
                        logfmt_raw(
                            auStack_102c, 0x1000, 0,
                            "target_freq:%.2f actual_freq:%.2f,vco:%.2f "
                            "fbdiv:%d refdiv:%d postdiv1:%d, postdiv2:%d",
                            (double)param_1, (double)local_c, (double)local_20,
                            local_14, local_10, local_18, local_1c);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/./backend/"
                             "chip_setting.c",
                             0xa2, "inferred_plldivider_kas", 0x17, 0x276, 0x14,
                             auStack_102c);
                        return local_c;
                    }
                }
            }
        }
        local_10 = local_10 - 1;
    } while (true);
}

undefined4 FUN_0007b7ac(float param_1, int param_2, int param_3,
                        undefined1 param_4, undefined1 param_5)

{
    undefined1 auStack_104c[4096];
    undefined4 local_4c[2];
    undefined1 local_44;
    undefined1 local_43;
    undefined2 local_42;
    undefined4 local_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    float fStack_18;
    undefined4 local_14;

    local_3c = 0;
    memset(local_4c, 0, 0x10);
    if (param_3 == 0) {
        local_42 = 8;
    } else if (param_3 == 1) {
        local_42 = 0xc;
    }
    local_44 = param_4;
    local_43 = param_5;
    fStack_18 = (float)FUN_0007b35c(param_1, &local_3c);
    local_4c[0] = local_3c;
    V_LOCK();
    FUN_00077ce8(&local_38, &local_38, *(int *)(param_2 + 0xfc),
                 *(int *)(param_2 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_104c, 0x1000, 0, uStack_1c, local_38, uStack_34,
               uStack_30, uStack_2c, local_28, uStack_24, uStack_20, uStack_1c,
               "KAS_set pll_no %d freq: %.2f, expected freq: %.2f", param_3,
               (double)fStack_18, (double)param_1);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_freq_kas_LTC_1491", 0x1d, 0x291, 0x28,
         auStack_104c);
    local_14 = 0xffffffff;
    if (0.0 < fStack_18) {
        local_14 = (**(code **)(param_2 + 0x10c))(param_2, local_4c);
    }
    usleep(10000);
    return local_14;
}

undefined4 FUN_0007b9e4(float param_1, int param_2, int param_3)

{
    undefined1 auStack_104c[4096];
    undefined4 local_4c[2];
    undefined1 local_44;
    undefined1 local_43;
    undefined2 local_42;
    undefined4 local_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    float fStack_18;
    undefined4 local_14;

    local_3c = 0;
    memset(local_4c, 0, 0x10);
    local_44 = 1;
    local_43 = 0;
    if (param_3 == 0) {
        local_42 = 8;
    } else if (param_3 == 1) {
        local_42 = 0xc;
    }
    fStack_18 = (float)FUN_0007aefc(param_1, &local_3c);
    local_4c[0] = local_3c;
    V_LOCK();
    FUN_00077ce8(&local_38, &local_38, *(int *)(param_2 + 0xfc),
                 *(int *)(param_2 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_104c, 0x1000, 0, uStack_1c, local_38, uStack_34,
               uStack_30, uStack_2c, local_28, uStack_24, uStack_20, uStack_1c,
               "set pll_no %d freq: %.2f, expected freq: %.2f", param_3,
               (double)fStack_18, (double)param_1);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_freq_LTC_1491", 0x19, 0x2a8, 0x28, auStack_104c);
    local_14 = 0xffffffff;
    if (0.0 < fStack_18) {
        local_14 = (**(code **)(param_2 + 0x10c))(param_2, local_4c);
    }
    usleep(10000);
    return local_14;
}

undefined4 FUN_0007bbec(undefined4 param_1, int param_2, char param_3,
                        int param_4)

{
    undefined1 auStack_104c[4096];
    undefined4 local_4c[2];
    undefined1 local_44;
    char local_43;
    undefined2 local_42;
    undefined4 local_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    undefined4 local_18;
    undefined4 uStack_14;

    local_3c = 0;
    memset(local_4c, 0, 0x10);
    local_44 = 0;
    local_43 = (char)*(undefined4 *)(param_2 + 0x1ac) * param_3;
    if (param_4 == 0) {
        local_42 = 8;
    } else if (param_4 == 1) {
        local_42 = 0xc;
    }
    uStack_14 = FUN_0007aefc(param_1, &local_3c);
    local_4c[0] = local_3c;
    V_LOCK();
    FUN_00077ce8(&local_38, &local_38, *(int *)(param_2 + 0xfc),
                 *(int *)(param_2 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_104c, 0x1000, 0, uStack_1c, local_38, uStack_34,
               uStack_30, uStack_2c, local_28, uStack_24, uStack_20, uStack_1c,
               "set freq: %.2f, expected freq: %.2f");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_one_asic_freq_LTC_1491", 0x22, 0x2be, 0x14,
         auStack_104c);
    local_18 = (**(code **)(param_2 + 0x10c))(param_2, local_4c);
    usleep(10000);
    return local_18;
}

int FUN_0007be00(int param_1)

{
    undefined4 uVar1;
    undefined1 auStack_1074[4096];
    int local_74;
    undefined1 auStack_70[8];
    undefined1 local_68;
    undefined2 local_66;
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    void *local_1c;
    int local_18;
    int local_14;

    V_LOCK();
    FUN_00077ce8(&local_60, &local_60, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_1074, 0x1000, 0, uStack_44, local_60, uStack_5c,
               uStack_58, uStack_54, local_50, uStack_4c, uStack_48, uStack_44,
               "get start nonce offset %s chip_no %d",
               *(undefined4 *)(param_1 + 0x150));
    V_UNLOCK();
    uVar1 = 0x2ed;
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_start_nonce_offset_LTC_1491", 0x27, 0x2ed, 0x14,
         auStack_1074);
    memset(auStack_70, 0, 0x10);
    local_68 = 1;
    local_1c = malloc(*(int *)(param_1 + 0x150) * 0xc);
    for (local_14 = 0; local_14 < 2; local_14 = local_14 + 1) {
        local_66 = (undefined2)((local_14 + 2U & 0xffff) << 3);
        memset(local_1c, 0, *(int *)(param_1 + 0x150) * 0xc);
        (**(code **)(param_1 + 0x120))(param_1, auStack_70,
                                       *(undefined4 *)(param_1 + 0x150),
                                       local_1c, &local_74, uVar1, 2000, 0);
        local_18 = 0;
        while (true) {
            if (local_74 <= local_18)
                break;
            V_LOCK();
            FUN_00077ce8(&local_40, &local_40, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(auStack_1074, 0x1000, 0, uStack_24, local_40, uStack_3c,
                       uStack_38, uStack_34, local_30, uStack_2c, uStack_28,
                       uStack_24,
                       "start_nonce_offset asic %d, reg %02x SNO %08x",
                       *(undefined1 *)((int)local_1c + local_18 * 0xc + 4),
                       *(undefined2 *)((int)local_1c + local_18 * 0xc + 6),
                       *(undefined4 *)((int)local_1c + local_18 * 0xc));
            V_UNLOCK();
            uVar1 = 0x2fa;
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./backend/"
                 "chip_setting.c",
                 0xa2, "ChipSetting_start_nonce_offset_LTC_1491", 0x27, 0x2fa,
                 0x28, auStack_1074);
            local_18 = local_18 + 1;
        }
    }
    free(local_1c);
    return local_74;
}

int FUN_0007c140(int param_1, undefined4 param_2)

{
    undefined4 uVar1;
    undefined1 auStack_10c0[4096];
    undefined4 local_c0;
    int local_bc;
    undefined4 local_b8[2];
    undefined1 local_b0;
    undefined2 local_ae;
    undefined1 local_ac;
    undefined4 local_a8;
    undefined4 uStack_a4;
    undefined4 uStack_a0;
    undefined4 uStack_9c;
    undefined4 local_98;
    undefined4 uStack_94;
    undefined4 uStack_90;
    undefined4 uStack_8c;
    undefined4 local_88;
    undefined4 uStack_84;
    undefined4 uStack_80;
    undefined4 uStack_7c;
    undefined4 local_78;
    undefined4 uStack_74;
    undefined4 uStack_70;
    undefined4 uStack_6c;
    undefined4 local_68;
    undefined4 uStack_64;
    undefined4 uStack_60;
    undefined4 uStack_5c;
    undefined4 local_58;
    undefined4 uStack_54;
    undefined4 uStack_50;
    undefined4 uStack_4c;
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    void *local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;

    V_LOCK();
    FUN_00077ce8(&local_a8, &local_a8, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_10c0, 0x1000, 0, uStack_8c, local_a8, uStack_a4,
               uStack_a0, uStack_9c, local_98, uStack_94, uStack_90, uStack_8c,
               "set clock delay chip_no %d, value %08x",
               *(undefined4 *)(param_1 + 0x150), param_2);
    V_UNLOCK();
    uVar1 = 0x309;
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_clock_delay_LTC_1491", 0x20, 0x309, 0x28,
         auStack_10c0);
    memset(local_b8, 0, 0x10);
    local_b0 = 1;
    local_ae = 0xff;
    local_ac = 0xff;
    local_b8[0] = param_2;
    local_1c = (**(code **)(param_1 + 0x110))(param_1, local_b8);
    if (local_1c < 0) {
        V_LOCK();
        FUN_00077ce8(&local_88, &local_88, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_10c0, 0x1000, 0, uStack_6c, local_88, uStack_84,
                   uStack_80, uStack_7c, local_78, uStack_74, uStack_70,
                   uStack_6c, "%s failed, set reg:%02x",
                   "ChipSetting_clock_delay_LTC_1491", local_ae);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_clock_delay_LTC_1491", 0x20, 0x312, 100,
             auStack_10c0);
        local_18 = -1;
    } else {
        usleep(100000);
        local_ac = 0;
        local_18 = 0;
        local_20 = *(int *)(param_1 + 0x154) * *(int *)(param_1 + 0x150);
        local_24 = malloc(local_20 * 0xc);
        memset(local_24, 0, local_20 * 0xc);
        (**(code **)(param_1 + 300))(param_1, local_b8, local_20, local_24,
                                     &local_bc, uVar1, 2000, 0);
        for (local_14 = 0; local_14 < local_bc; local_14 = local_14 + 1) {
            local_c0 = 0;
            FUN_00078038(&local_c0,
                         *(undefined4 *)((int)local_24 + local_14 * 0xc));
            if (*(short *)((int)local_24 + local_14 * 0xc + 6) == 0xff) {
                local_18 = local_18 + 1;
                V_LOCK();
                FUN_00077ce8(&local_68, &local_68, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(
                    auStack_10c0, 0x1000, 0, uStack_4c, local_68, uStack_64,
                    uStack_60, uStack_5c, local_58, uStack_54, uStack_50,
                    uStack_4c,
                    "[DP] chip %02x, core %02x, reg %02x, clk_delay %08x",
                    *(undefined1 *)((int)local_24 + local_14 * 0xc + 4),
                    *(undefined1 *)((int)local_24 + local_14 * 0xc + 8),
                    *(undefined2 *)((int)local_24 + local_14 * 0xc + 6),
                    local_c0);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/./backend/"
                     "chip_setting.c",
                     0xa2, "ChipSetting_clock_delay_LTC_1491", 0x20, 0x322,
                     0x14, auStack_10c0);
            } else {
                V_LOCK();
                FUN_00077ce8(&local_48, &local_48, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(
                    auStack_10c0, 0x1000, 0, uStack_2c, local_48, uStack_44,
                    uStack_40, uStack_3c, local_38, uStack_34, uStack_30,
                    uStack_2c,
                    "[DP] chip %02x, expected reg %02x, but %02x, data %08x",
                    *(undefined1 *)((int)local_24 + local_14 * 0xc + 4), 0xff,
                    *(undefined2 *)((int)local_24 + local_14 * 0xc + 6),
                    local_c0);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/./backend/"
                     "chip_setting.c",
                     0xa2, "ChipSetting_clock_delay_LTC_1491", 0x20, 0x325, 100,
                     auStack_10c0);
            }
        }
        free(local_24);
    }
    return local_18;
}

/* WARNING: Type propagation algorithm not settling */

int FUN_0007c714(int param_1)

{
    undefined4 uVar1;
    undefined1 auStack_10c0[4096];
    undefined4 local_c0;
    int local_bc[3];
    undefined1 local_b0;
    undefined1 local_af;
    undefined2 local_ae;
    undefined1 local_ac;
    undefined4 local_a8;
    undefined4 uStack_a4;
    undefined4 uStack_a0;
    undefined4 uStack_9c;
    undefined4 local_98;
    undefined4 uStack_94;
    undefined4 uStack_90;
    undefined4 uStack_8c;
    undefined4 local_88;
    undefined4 uStack_84;
    undefined4 uStack_80;
    undefined4 uStack_7c;
    undefined4 local_78;
    undefined4 uStack_74;
    undefined4 uStack_70;
    undefined4 uStack_6c;
    undefined4 local_68;
    undefined4 uStack_64;
    undefined4 uStack_60;
    undefined4 uStack_5c;
    undefined4 local_58;
    undefined4 uStack_54;
    undefined4 uStack_50;
    undefined4 uStack_4c;
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    void *local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;

    V_LOCK();
    FUN_00077ce8(&local_a8, &local_a8, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_10c0, 0x1000, 0, uStack_8c, local_a8, uStack_a4,
               uStack_a0, uStack_9c, local_98, uStack_94, uStack_90, uStack_8c,
               "get hash clock count chip_no %d",
               *(undefined4 *)(param_1 + 0x150));
    V_UNLOCK();
    uVar1 = 0x368;
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_hash_clock_count_LTC_1491", 0x25, 0x368, 0x14,
         auStack_10c0);
    memset(local_bc + 1, 0, 0x10);
    local_b0 = 1;
    local_ae = 0xff;
    local_bc[1] = 1;
    local_ac = 0xff;
    local_1c = (**(code **)(param_1 + 0x110))(param_1, local_bc + 1);
    if (local_1c < 0) {
        V_LOCK();
        FUN_00077ce8(&local_88, &local_88, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_10c0, 0x1000, 0, uStack_6c, local_88, uStack_84,
                   uStack_80, uStack_7c, local_78, uStack_74, uStack_70,
                   uStack_6c, "%s failed, set reg:%02x",
                   "ChipSetting_hash_clock_count_LTC_1491", local_ae);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_hash_clock_count_LTC_1491", 0x25, 0x371, 100,
             auStack_10c0);
        local_18 = -1;
    } else {
        usleep(20000);
        local_b0 = 1;
        local_af = 0;
        local_ae = 0xff;
        local_ac = 0;
        local_18 = 0;
        local_20 = *(int *)(param_1 + 0x154) * *(int *)(param_1 + 0x150);
        local_24 = malloc(local_20 * 0xc);
        memset(local_24, 0, local_20 * 0xc);
        (**(code **)(param_1 + 300))(param_1, local_bc + 1, local_20, local_24,
                                     local_bc, uVar1, 2000, 0);
        for (local_14 = 0; local_14 < local_bc[0]; local_14 = local_14 + 1) {
            local_c0 = 0;
            FUN_00078038(&local_c0,
                         *(undefined4 *)((int)local_24 + local_14 * 0xc));
            if (*(short *)((int)local_24 + local_14 * 0xc + 6) == 0xff) {
                local_18 = local_18 + 1;
                V_LOCK();
                FUN_00077ce8(&local_68, &local_68, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(auStack_10c0, 0x1000, 0, uStack_4c, local_68,
                           uStack_64, uStack_60, uStack_5c, local_58, uStack_54,
                           uStack_50, uStack_4c,
                           "[Hash clk cnt] chip %02x, core %02x, reg %02x, "
                           "clk_cnt %08x",
                           *(undefined1 *)((int)local_24 + local_14 * 0xc + 4),
                           *(undefined1 *)((int)local_24 + local_14 * 0xc + 8),
                           *(undefined2 *)((int)local_24 + local_14 * 0xc + 6),
                           local_c0);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/./backend/"
                     "chip_setting.c",
                     0xa2, "ChipSetting_hash_clock_count_LTC_1491", 0x25, 900,
                     0x28, auStack_10c0);
            } else {
                V_LOCK();
                FUN_00077ce8(&local_48, &local_48, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(auStack_10c0, 0x1000, 0, uStack_2c, local_48,
                           uStack_44, uStack_40, uStack_3c, local_38, uStack_34,
                           uStack_30, uStack_2c,
                           "[Hash clk cnt] chip %02x, expected reg %02x, but "
                           "%02x, clk_cnt %08x",
                           *(undefined1 *)((int)local_24 + local_14 * 0xc + 4),
                           0xff,
                           *(undefined2 *)((int)local_24 + local_14 * 0xc + 6),
                           local_c0);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/./backend/"
                     "chip_setting.c",
                     0xa2, "ChipSetting_hash_clock_count_LTC_1491", 0x25, 0x387,
                     100, auStack_10c0);
            }
        }
        free(local_24);
    }
    return local_18;
}

undefined4 FUN_0007ccd8(int param_1, undefined4 param_2)

{
    undefined4 uVar1;
    undefined1 auStack_104c[4096];
    undefined4 local_4c[2];
    undefined1 local_44;
    undefined1 local_43;
    undefined2 local_42;
    undefined4 local_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;

    local_3c = 0;
    memset(local_4c, 0, 0x10);
    local_44 = 1;
    local_43 = 0;
    local_42 = 0x40;
    local_4c[0] = param_2;
    local_3c = param_2;
    V_LOCK();
    FUN_00077ce8(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_104c, 0x1000, 0, uStack_1c, local_38, uStack_34,
               uStack_30, uStack_2c, local_28, uStack_24, uStack_20, uStack_1c,
               "set analog value %08x", local_4c[0]);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_analog_mux_LTC_1491", 0x1f, 0x39d, 0x28,
         auStack_104c);
    uVar1 = (**(code **)(param_1 + 0x10c))(param_1, local_4c);
    return uVar1;
}

undefined4 FUN_0007ce48(int param_1, undefined1 param_2, int param_3)

{
    undefined4 uVar1;
    undefined1 auStack_1054[4096];
    uint local_54[2];
    undefined1 local_4c;
    undefined1 local_4b;
    undefined2 local_4a;
    uint local_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    int local_1c;
    int local_18;
    uint local_14;

    local_44 = 0xf0000;
    local_18 = 0;
    local_1c = 1;
    local_14 = 1;
    memset(local_54, 0, 0x10);
    local_4c = 0;
    local_4a = 0x5c;
    local_54[0] = param_3 << 0x10 | local_18 << 2 | local_1c << 1 | local_14;
    local_4b = param_2;
    local_44 = local_54[0];
    V_LOCK();
    FUN_00077ce8(&local_40, &local_40, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_1054, 0x1000, 0, uStack_24, local_40, uStack_3c,
               uStack_38, uStack_34, local_30, uStack_2c, uStack_28, uStack_24,
               "set uart relay, chip:%02x, %08x", param_2, local_54[0]);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_uart_relay_LTC_1491", 0x1f, 0x3b3, 0x28,
         auStack_1054);
    uVar1 = (**(code **)(param_1 + 0x10c))(param_1, local_54);
    return uVar1;
}

undefined4 FUN_0007d01c(int param_1, undefined1 param_2, undefined1 param_3,
                        uint param_4)

{
    undefined4 uVar1;
    ulonglong local_18;
    undefined8 local_10;

    local_10 = (ulonglong)CONCAT22(0xff, CONCAT11(param_3, param_2));
    local_18 = (ulonglong)param_4;
    uVar1 = (**(code **)(param_1 + 0x10c))(param_1, &local_18);
    return uVar1;
}

int FUN_0007d094(int param_1, char param_2, uint param_3, undefined4 *param_4,
                 undefined4 *param_5, size_t param_6)

{
    undefined8 uVar1;
    int local_34;
    undefined8 local_30;
    undefined8 local_28;
    undefined4 *local_20;
    size_t local_1c;
    int local_18;
    int local_14;

    local_30 = 0;
    local_28 = 0;
    if ((int)*(size_t *)(param_1 + 0x150) <= (int)param_6) {
        param_6 = *(size_t *)(param_1 + 0x150);
    }
    local_1c = param_6;
    local_20 = (undefined4 *)calloc(param_6, 0xc);
    uVar1 = local_28;
    local_28._4_4_ = SUB84(uVar1, 4);
    local_28._0_4_ = CONCAT22(0xff, CONCAT11((char)param_3, param_2));
    (**(code **)(param_1 + 0x120))(param_1, &local_30, local_1c, local_20,
                                   &local_34);
    if (param_2 == '\0') {
        if ((local_34 == 1) && (param_3 == *(byte *)(local_20 + 1))) {
            *param_4 = *local_20;
            *param_5 = 1;
        }
    } else {
        for (local_14 = 0; local_14 < local_34; local_14 = local_14 + 1) {
            for (local_18 = 0; local_18 < (int)local_1c;
                 local_18 = local_18 + 1) {
                if (*(char *)(local_20 + local_14 * 3 + 1) ==
                    *(char *)(*(int *)(param_1 + 0x1ec) + local_18)) {
                    param_4[local_18] = local_20[local_14 * 3];
                    param_5[local_18] = 1;
                    break;
                }
            }
        }
    }
    free(local_20);
    return local_34;
}

undefined4 FUN_0007d274(undefined4 param_1, undefined1 param_2,
                        undefined4 param_3, uint param_4, void *param_5,
                        void *param_6, int param_7)

{
    int iVar1;
    undefined4 uVar2;

    iVar1 = FUN_0007d01c(param_1, param_2, param_3, param_4 | 0x1980000);
    if (iVar1 == 0) {
        usleep(50000);
        memset(param_5, 0, param_7 << 2);
        memset(param_6, 0, param_7 << 2);
        uVar2 =
            FUN_0007d094(param_1, param_2, param_3, param_5, param_6, param_7);
    } else {
        uVar2 = 0;
    }
    return uVar2;
}

int FUN_0007d338(undefined4 param_1, int param_2, undefined4 *param_3,
                 int param_4)

{
    void *__ptr;
    void *__ptr_00;
    int iVar1;
    int local_c;

    __ptr = malloc(param_4 << 2);
    __ptr_00 = malloc(param_4 << 2);
    *param_3 = 0;
    iVar1 = FUN_0007d274(param_1, 1, 0, 0, __ptr, __ptr_00, param_4);
    for (local_c = 0; local_c < iVar1; local_c = local_c + 1) {
        *(uint *)(param_2 + local_c * 4) =
            (*(uint *)((int)__ptr + local_c * 4) >> 0x18) - 0x40;
        param_3[local_c] = *(undefined4 *)((int)__ptr_00 + local_c * 4);
    }
    free(__ptr_00);
    free(__ptr);
    return iVar1;
}

int FUN_0007d470(undefined4 param_1, int param_2, undefined4 *param_3,
                 int param_4)

{
    void *__ptr;
    void *__ptr_00;
    int iVar1;
    int local_c;

    __ptr = malloc(param_4 << 2);
    __ptr_00 = malloc(param_4 << 2);
    *param_3 = 0;
    iVar1 = FUN_0007d274(param_1, 1, 0, 0x100, __ptr, __ptr_00, param_4);
    for (local_c = 0; local_c < iVar1; local_c = local_c + 1) {
        *(uint *)(param_2 + local_c * 4) =
            (*(uint *)((int)__ptr + local_c * 4) >> 0x18) - 0x40;
        param_3[local_c] = *(undefined4 *)((int)__ptr_00 + local_c * 4);
    }
    free(__ptr_00);
    free(__ptr);
    return iVar1;
}

int FUN_0007d5a8(int param_1, uint *param_2, undefined4 *param_3,
                 undefined4 param_4)

{
    int iVar1;
    undefined4 local_18;
    uint local_14[3];

    local_14[1] = 0;
    *param_3 = 0;
    *param_2 = 0xffffffc0;
    iVar1 = FUN_0007d274(param_1, 0, param_4, 0, local_14, &local_18, 1);
    if (iVar1 == 1) {
        local_14[2] = local_14[0] >> 0x18;
        if (*(int *)(param_1 + 0x200) == 1) {
            local_14[2] = local_14[2] - 0x40;
        }
        *param_2 = local_14[2];
        *param_3 = local_18;
    }
    return iVar1;
}

int FUN_0007d670(int param_1, uint *param_2, undefined4 *param_3,
                 undefined4 param_4)

{
    int iVar1;
    undefined4 local_18;
    uint local_14[3];

    local_14[1] = 0;
    *param_3 = 0;
    *param_2 = 0xffffffc0;
    iVar1 = FUN_0007d274(param_1, 0, param_4, 0x100, local_14, &local_18, 1);
    if (iVar1 == 1) {
        local_14[2] = local_14[0] >> 0x18;
        if (*(int *)(param_1 + 0x200) == 1) {
            local_14[2] = local_14[2] - 0x40;
        }
        *param_2 = local_14[2];
        *param_3 = local_18;
    }
    return iVar1;
}

int FUN_0007d738(int param_1, int *param_2, undefined4 *param_3, uint param_4)

{
    undefined1 auStack_1010[4099];
    char local_d;
    int local_c;

    *param_3 = 0;
    *param_2 = -0x40;
    local_c =
        pic1704_write_iic(*(uint *)(param_1 + 0xfc) & 0xff, param_4 & 0xff);
    if (local_c == 0) {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0,
                   "pic temp write iic error! chain %d iic_addr %d",
                   *(undefined4 *)(param_1 + 0xfc), param_4);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_read_sensor_temp_local_on_pic_LTC_1491", 0x32,
             1099, 0x14, auStack_1010);
    } else {
        usleep(10000);
        local_c = pic1704_read_iic(*(uint *)(param_1 + 0xfc) & 0xff,
                                   param_4 & 0xff, &local_d);
        if (local_c == 0) {
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0,
                       "fail to read pic temp for chain %d iic_addr %d",
                       *(undefined4 *)(param_1 + 0xfc), param_4);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./backend/"
                 "chip_setting.c",
                 0xa2, "ChipSetting_read_sensor_temp_local_on_pic_LTC_1491",
                 0x32, 0x456, 0x14, auStack_1010);
        } else {
            *param_3 = 1;
            *param_2 = (int)local_d;
        }
    }
    return local_c;
}

int FUN_0007d9a0(int param_1, int *param_2, undefined4 *param_3, uint param_4)

{
    undefined1 auStack_1010[4099];
    char local_d;
    int local_c;

    *param_3 = 0;
    *param_2 = -0x40;
    local_c =
        pic1704_write_iic(*(uint *)(param_1 + 0xfc) & 0xff, param_4 & 0xff);
    if (local_c == 0) {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0,
                   "pic temp write iic error! chain %d iic_addr %d",
                   *(undefined4 *)(param_1 + 0xfc), param_4);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_read_sensor_temp_remote_on_pic_LTC_1491", 0x33,
             0x465, 0x14, auStack_1010);
    } else {
        usleep(10000);
        local_c = pic1704_read_iic(*(uint *)(param_1 + 0xfc) & 0xff,
                                   param_4 & 0xff, &local_d);
        if (local_c == 0) {
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0,
                       "fail to read pic temp for chain %d iic_addr %d",
                       *(undefined4 *)(param_1 + 0xfc), param_4);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./backend/"
                 "chip_setting.c",
                 0xa2, "ChipSetting_read_sensor_temp_remote_on_pic_LTC_1491",
                 0x33, 0x470, 0x14, auStack_1010);
        } else {
            *param_3 = 1;
            *param_2 = local_d + 0xf;
        }
    }
    return local_c;
}

int FUN_0007dc08(int param_1, int *param_2, undefined4 *param_3, uint param_4)

{
    undefined1 auStack_103c[4096];
    char local_3c[4];
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    int local_14;

    V_LOCK();
    logfmt_raw(auStack_103c, 0x1000, 0, "%s chain[%d] iic_addr:%d",
               "ChipSetting_read_sensor_temp_local_on_ctrlboard_LTC_1491",
               *(undefined4 *)(param_1 + 0xfc), param_4);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_read_sensor_temp_local_on_ctrlboard_LTC_1491", 0x38,
         0x47e, 0x14, auStack_103c);
    *param_3 = 0;
    local_14 = tsensor_read(*(undefined4 *)(param_1 + 0xfc), param_4 & 0xff, 0,
                            local_3c, 2);
    if (local_14 == 2) {
        *param_3 = 1;
        *param_2 = (int)local_3c[0];
        V_LOCK();
        FUN_00077ce8(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_103c, 0x1000, 0, uStack_1c, local_38, uStack_34,
                   uStack_30, uStack_2c, local_28, uStack_24, uStack_20,
                   uStack_1c, "read ctrlboard temp, local[%02x] %d", param_4,
                   *param_2);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_read_sensor_temp_local_on_ctrlboard_LTC_1491",
             0x38, 0x48a, 0x14, auStack_103c);
    } else {
        *param_2 = -0x40;
        V_LOCK();
        logfmt_raw(auStack_103c, 0x1000, 0,
                   "failed to read ctrlboard-temp for chain %d",
                   *(undefined4 *)(param_1 + 0xfc));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_read_sensor_temp_local_on_ctrlboard_LTC_1491",
             0x38, 0x485, 0x50, auStack_103c);
        local_14 = -1;
    }
    return local_14;
}

undefined4 FUN_0007df0c(int param_1, int *param_2, undefined4 *param_3,
                        undefined1 param_4)

{
    undefined4 uVar1;
    undefined1 auStack_1010[4096];
    char local_10[4];
    int local_c;

    *param_3 = 0;
    local_c =
        tsensor_read(*(undefined4 *)(param_1 + 0xfc), param_4, 0, local_10, 2);
    if (local_c == 2) {
        *param_3 = 1;
        *param_2 = (int)local_10[0] + (uint) * (byte *)(param_1 + 0x45c);
        uVar1 = 2;
    } else {
        *param_2 = -0x40;
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0,
                   "failed to read ctrlboard-temp for chain %d",
                   *(undefined4 *)(param_1 + 0xfc));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_read_sensor_temp_remote_on_ctrlboard_LTC_1491",
             0x39, 0x498, 0x50, auStack_1010);
        uVar1 = 0xffffffff;
    }
    return uVar1;
}

undefined4 FUN_0007e0a4(undefined4 param_1)

{
    undefined4 uVar1;

    uVar1 = FUN_0007d01c(param_1, 1, 0, 0x1990904);
    usleep(100000);
    return uVar1;
}

undefined4 FUN_0007e0f8(int param_1)

{
    undefined4 local_1c[2];
    undefined1 local_14;
    undefined1 local_13;
    undefined2 local_12;
    undefined4 local_c;

    memset(local_1c, 0, 0x10);
    local_14 = 1;
    local_13 = 0;
    local_12 = 0x34;
    local_1c[0] = 0x80000000;
    local_c = (**(code **)(param_1 + 0x10c))(param_1, local_1c);
    usleep(100000);
    return local_c;
}

int FUN_0007e178(int param_1, void *param_2, uint param_3)

{
    uint uVar1;
    undefined1 auStack_104c[4096];
    int local_4c;
    undefined1 auStack_48[8];
    undefined1 local_40;
    undefined1 local_3f;
    undefined2 local_3e;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    void *local_18;
    int local_14;

    local_4c = 0;
    memset(auStack_48, 0, 0x10);
    local_40 = 1;
    local_3f = 0;
    local_3e = 0x34;
    local_18 = malloc(*(int *)(param_1 + 0x1a8) * 0xc);
    memset(local_18, 0, *(int *)(param_1 + 0x1a8) * 0xc);
    (**(code **)(param_1 + 0x120))(param_1, auStack_48,
                                   *(undefined4 *)(param_1 + 0x1a8), local_18,
                                   &local_4c);
    for (local_14 = 0; local_14 < local_4c; local_14 = local_14 + 1) {
        if (*(short *)((int)local_18 + local_14 * 0xc + 6) == 0x34) {
            V_LOCK();
            FUN_00077ce8(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(auStack_104c, 0x1000, 0, uStack_1c, local_38, uStack_34,
                       uStack_30, uStack_2c, local_28, uStack_24, uStack_20,
                       uStack_1c,
                       "[Chip status] asic %02x, reg %02x state %08x",
                       *(undefined1 *)((int)local_18 + local_14 * 0xc + 4),
                       *(undefined2 *)((int)local_18 + local_14 * 0xc + 6),
                       *(undefined4 *)((int)local_18 + local_14 * 0xc));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./backend/"
                 "chip_setting.c",
                 0xa2, "ChipSetting_get_crc_status_LTC_1491", 0x23, 0x4c7, 0x3c,
                 auStack_104c);
        }
    }
    if (param_2 != (void *)0x0) {
        uVar1 = *(uint *)(param_1 + 0x1a8);
        if (param_3 <= uVar1) {
            uVar1 = param_3;
        }
        memcpy(param_2, local_18, uVar1 * 0xc);
    }
    free(local_18);
    return local_4c;
}

undefined4 FUN_0007e454(int param_1, undefined1 param_2, undefined4 param_3,
                        void *param_4)

{
    undefined4 local_28;
    undefined1 auStack_24[4];
    undefined4 local_20;
    undefined1 local_1c;
    undefined1 local_1b;
    void *local_14;

    local_28 = 0;
    memset(auStack_24, 0, 0x10);
    local_1c = 0;
    local_20 = param_3;
    local_1b = param_2;
    local_14 = malloc(0x4c);
    memset(local_14, 0, 0xc);
    (**(code **)(param_1 + 0x124))(param_1, auStack_24, 1, local_14, &local_28);
    if (param_4 != (void *)0x0) {
        memcpy(param_4, (void *)((int)local_14 + 10), 0x40);
    }
    free(local_14);
    return local_28;
}

uint FUN_0007e534(int param_1, uint param_2, void *param_3)

{
    uint uVar1;
    undefined1 auStack_104c[4096];
    uint local_4c;
    undefined1 auStack_48[8];
    undefined1 local_40;
    undefined1 local_3f;
    undefined2 local_3e;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    void *local_18;
    int local_14;

    local_4c = 0;
    memset(auStack_48, 0, 0x10);
    local_40 = 1;
    local_3f = 0;
    local_3e = (undefined2)param_2;
    local_18 = malloc(0x528);
    memset(local_18, 0, 0x528);
    (**(code **)(param_1 + 0x120))(param_1, auStack_48, 0x6e, local_18,
                                   &local_4c);
    for (local_14 = 0; local_14 < (int)local_4c; local_14 = local_14 + 1) {
        if (param_2 == *(ushort *)((int)local_18 + local_14 * 0xc + 6)) {
            V_LOCK();
            FUN_00077ce8(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(auStack_104c, 0x1000, 0, uStack_1c, local_38, uStack_34,
                       uStack_30, uStack_2c, local_28, uStack_24, uStack_20,
                       uStack_1c,
                       "[Chip status] asic %02x, reg %02x state %08x",
                       *(undefined1 *)((int)local_18 + local_14 * 0xc + 4),
                       *(undefined2 *)((int)local_18 + local_14 * 0xc + 6),
                       *(undefined4 *)((int)local_18 + local_14 * 0xc));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./backend/"
                 "chip_setting.c",
                 0xa2, "ChipSetting_get_chip_status_LTC_1491", 0x24, 0x4fc,
                 0x14, auStack_104c);
        }
    }
    if (param_3 != (void *)0x0) {
        uVar1 = *(uint *)(param_1 + 0x1a8);
        if (local_4c <= uVar1) {
            uVar1 = local_4c;
        }
        memcpy(param_3, local_18, uVar1 * 0xc);
    }
    free(local_18);
    return local_4c;
}

int FUN_0007e7e0(int param_1, undefined1 param_2, undefined1 param_3,
                 uint param_4, void *param_5)

{
    int iVar1;
    undefined1 auStack_104c[4096];
    int local_4c;
    undefined1 auStack_48[8];
    undefined1 local_40;
    undefined1 local_3f;
    undefined2 local_3e;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    void *local_18;
    int local_14;

    local_4c = 0;
    memset(auStack_48, 0, 0x10);
    local_3e = (undefined2)param_4;
    local_40 = param_2;
    local_3f = param_3;
    local_18 = malloc(0xc);
    memset(local_18, 0, 0xc);
    (**(code **)(param_1 + 0x120))(param_1, auStack_48, 1, local_18, &local_4c);
    for (local_14 = 0; local_14 < local_4c; local_14 = local_14 + 1) {
        if (param_4 == *(ushort *)((int)local_18 + local_14 * 0xc + 6)) {
            V_LOCK();
            FUN_00077ce8(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(auStack_104c, 0x1000, 0, uStack_1c, local_38, uStack_34,
                       uStack_30, uStack_2c, local_28, uStack_24, uStack_20,
                       uStack_1c,
                       "[Chip status] asic %02x, reg %02x state %08x",
                       *(undefined1 *)((int)local_18 + local_14 * 0xc + 4),
                       *(undefined2 *)((int)local_18 + local_14 * 0xc + 6),
                       *(undefined4 *)((int)local_18 + local_14 * 0xc));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./backend/"
                 "chip_setting.c",
                 0xa2, "ChipSetting_get_chip_status_rvn_LTC_1491", 0x28, 0x51c,
                 0x28, auStack_104c);
        }
    }
    if (param_5 != (void *)0x0) {
        iVar1 = local_4c;
        if (0 < local_4c) {
            iVar1 = 1;
        }
        memcpy(param_5, local_18, iVar1 * 0xc);
    }
    free(local_18);
    return local_4c;
}

undefined4 FUN_0007eaa0(int param_1, undefined2 param_2, uint param_3)

{
    undefined4 uVar1;
    ulonglong local_18;
    undefined8 local_10;

    local_10 = (ulonglong)CONCAT22(param_2, 1);
    local_18 = (ulonglong)param_3;
    uVar1 = (**(code **)(param_1 + 0x10c))(param_1, &local_18);
    return uVar1;
}

undefined4 FUN_0007eb10(int param_1, undefined1 param_2, undefined2 param_3,
                        uint param_4)

{
    undefined4 uVar1;
    ulonglong local_18;
    longlong local_10;

    local_10 = (ulonglong)CONCAT21(param_3, param_2) << 8;
    local_18 = (ulonglong)param_4;
    uVar1 = (**(code **)(param_1 + 0x10c))(param_1, &local_18);
    return uVar1;
}

undefined4 FUN_0007eb88(int param_1, undefined2 param_2, undefined4 param_3)

{
    undefined4 uVar1;
    undefined4 local_1c[2];
    undefined1 local_14;
    undefined2 local_12;
    undefined1 local_10;

    memset(local_1c, 0, 0x10);
    local_14 = 1;
    local_10 = 0xff;
    local_1c[0] = param_3;
    local_12 = param_2;
    uVar1 = (**(code **)(param_1 + 0x110))(param_1, local_1c);
    return uVar1;
}

undefined4 FUN_0007ec08(int param_1, undefined2 param_2, undefined4 param_3,
                        undefined1 param_4)

{
    undefined4 uVar1;
    undefined4 local_1c[2];
    undefined1 local_14;
    undefined2 local_12;
    undefined1 local_10;

    memset(local_1c, 0, 0x10);
    local_14 = 1;
    local_1c[0] = param_3;
    local_12 = param_2;
    local_10 = param_4;
    uVar1 = (**(code **)(param_1 + 0x110))(param_1, local_1c);
    return uVar1;
}

undefined4 FUN_0007ec90(int param_1)

{
    undefined4 uVar1;

    uVar1 = (**(code **)(param_1 + 0x108))(param_1);
    return uVar1;
}

undefined4 FUN_0007ecc8(int param_1, undefined2 param_2, undefined4 param_3)

{
    undefined4 uVar1;
    undefined4 local_1c[2];
    undefined1 local_14;
    undefined2 local_12;
    undefined1 local_10;
    undefined1 local_f;

    memset(local_1c, 0, 0x10);
    local_14 = 1;
    local_10 = 0;
    local_f = 0x3f;
    local_1c[0] = param_3;
    local_12 = param_2;
    uVar1 = (**(code **)(param_1 + 0x110))(param_1, local_1c);
    return uVar1;
}

undefined4 FUN_0007ed50(int param_1, undefined2 param_2, undefined4 param_3)

{
    undefined4 uVar1;
    undefined4 local_1c[2];
    undefined1 local_14;
    undefined2 local_12;
    undefined1 local_10;
    undefined1 local_f;

    memset(local_1c, 0, 0x10);
    local_14 = 1;
    local_10 = 0;
    local_f = 0x3f;
    local_1c[0] = param_3;
    local_12 = param_2;
    uVar1 = (**(code **)(param_1 + 0x110))(param_1, local_1c);
    return uVar1;
}

undefined4 FUN_0007edd8(int param_1, undefined1 param_2, undefined2 param_3,
                        undefined4 param_4)

{
    undefined4 local_1c[2];
    undefined1 local_14;
    undefined1 local_13;
    undefined2 local_12;
    undefined1 local_10;
    undefined4 local_c;

    memset(local_1c, 0, 0x10);
    local_14 = 0;
    local_10 = 0xff;
    local_1c[0] = param_4;
    local_13 = param_2;
    local_12 = param_3;
    local_c = (**(code **)(param_1 + 0x110))(param_1, local_1c);
    usleep(80000);
    return local_c;
}

undefined4 FUN_0007ee74(int param_1, undefined1 param_2, undefined1 param_3,
                        undefined4 param_4, undefined4 param_5)

{
    undefined4 local_1c[2];
    undefined1 local_14;
    undefined1 local_13;
    undefined2 local_12;
    undefined1 local_10;
    undefined4 local_c;

    memset(local_1c, 0, 0x10);
    local_14 = 0;
    local_12 = (undefined2)param_4;
    local_1c[0] = param_5;
    local_13 = param_2;
    local_10 = param_3;
    local_c = (**(code **)(param_1 + 0x110))(
        param_1, local_1c, local_1c, *(code **)(param_1 + 0x110), param_4);
    usleep(80000);
    return local_c;
}

undefined4 FUN_0007ef14(int param_1, undefined1 param_2, undefined2 param_3,
                        undefined4 param_4)

{
    undefined4 local_1c[2];
    undefined1 local_14;
    undefined2 local_12;
    undefined1 local_10;
    undefined4 local_c;

    memset(local_1c, 0, 0x10);
    local_14 = 1;
    local_1c[0] = param_4;
    local_12 = param_3;
    local_10 = param_2;
    local_c = (**(code **)(param_1 + 0x110))(param_1, local_1c);
    usleep(80000);
    return local_c;
}

int FUN_0007efa8(int param_1, short param_2, undefined2 param_3, void *param_4)

{
    undefined4 uVar1;
    undefined1 auStack_1054[4096];
    int local_54;
    undefined1 auStack_50[8];
    undefined1 local_48;
    undefined1 local_47;
    undefined2 local_46;
    undefined1 local_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    void *local_1c;
    int local_18;
    int local_14;

    local_54 = 0;
    local_14 = *(int *)(param_1 + 0x1a8);
    if (param_2 == 0xff) {
        local_14 = *(int *)(param_1 + 0x1a8) * 0x88;
    }
    V_LOCK();
    logfmt_raw(auStack_1054, 0x1000, 0, "%s core_no %d",
               "ChipSetting_get_core_status_LTC_1491", local_14);
    V_UNLOCK();
    uVar1 = 0x5a6;
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_get_core_status_LTC_1491", 0x24, 0x5a6, 0x14,
         auStack_1054);
    memset(auStack_50, 0, 0x10);
    local_48 = 1;
    local_47 = 0;
    local_1c = malloc(local_14 * 0xc);
    local_44 = (undefined1)param_2;
    local_46 = param_3;
    memset(local_1c, 0, local_14 * 0xc);
    (**(code **)(param_1 + 300))(param_1, auStack_50, local_14, local_1c,
                                 &local_54, uVar1, 2000, 0);
    local_18 = 0;
    while (true) {
        if (local_54 <= local_18)
            break;
        V_LOCK();
        FUN_00077ce8(&local_40, &local_40, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_1054, 0x1000, 0, uStack_24, local_40, uStack_3c,
                   uStack_38, uStack_34, local_30, uStack_2c, uStack_28,
                   uStack_24,
                   "[Core State] asic %02x core %02x reg %04x state %08x",
                   *(undefined1 *)((int)local_1c + local_18 * 0xc + 4),
                   *(undefined1 *)((int)local_1c + local_18 * 0xc + 8),
                   *(undefined2 *)((int)local_1c + local_18 * 0xc + 6),
                   *(undefined4 *)((int)local_1c + local_18 * 0xc));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_get_core_status_LTC_1491", 0x24, 0x5b2, 0x14,
             auStack_1054);
        local_18 = local_18 + 1;
    }
    if (param_4 != (void *)0x0) {
        memcpy(param_4, local_1c, local_14 * 0xc);
    }
    free(local_1c);
    return local_54;
}

int FUN_0007f334(int param_1, short param_2, undefined2 param_3, void *param_4)

{
    undefined4 uVar1;
    undefined1 auStack_1054[4096];
    int local_54;
    undefined1 auStack_50[8];
    undefined1 local_48;
    undefined1 local_47;
    undefined2 local_46;
    undefined1 local_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    void *local_1c;
    int local_18;
    int local_14;

    local_54 = 0;
    local_14 = *(int *)(param_1 + 0x1a8);
    if (param_2 == 0xff) {
        local_14 = *(int *)(param_1 + 0x1a8) * 0x88;
    }
    memset(auStack_50, 0, 0x10);
    local_48 = 1;
    local_47 = 0;
    local_1c = malloc(local_14 * 0xc);
    local_44 = (undefined1)param_2;
    local_46 = param_3;
    memset(local_1c, 0, local_14 * 0xc);
    uVar1 = 0;
    (**(code **)(param_1 + 300))(param_1, auStack_50, local_14, local_1c,
                                 &local_54);
    V_LOCK();
    logfmt_raw(auStack_1054, 0x1000, 0, "%s core_no %d, response_num %d",
               "ChipSetting_get_core_status_debug_LTC_1491", local_14, local_54,
               uVar1);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_get_core_status_debug_LTC_1491", 0x2a, 0x5cb, 0x28,
         auStack_1054);
    local_18 = 0;
    while (true) {
        if (local_54 <= local_18)
            break;
        V_LOCK();
        FUN_00077ce8(&local_40, &local_40, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_1054, 0x1000, 0, uStack_24, local_40, uStack_3c,
                   uStack_38, uStack_34, local_30, uStack_2c, uStack_28,
                   uStack_24,
                   "[Core State] asic %02x core %02x reg %04x state %08x",
                   *(undefined1 *)((int)local_1c + local_18 * 0xc + 4),
                   *(undefined1 *)((int)local_1c + local_18 * 0xc + 8),
                   *(undefined2 *)((int)local_1c + local_18 * 0xc + 6),
                   *(undefined4 *)((int)local_1c + local_18 * 0xc));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_get_core_status_debug_LTC_1491", 0x2a, 0x5ce,
             0x28, auStack_1054);
        local_18 = local_18 + 1;
    }
    if (param_4 != (void *)0x0) {
        memcpy(param_4, local_1c, local_14 * 0xc);
    }
    free(local_1c);
    return local_54;
}

int FUN_0007f6c8(int param_1, undefined1 param_2, undefined2 param_3,
                 void *param_4)

{
    undefined1 uVar1;
    undefined1 uVar2;
    undefined4 uVar3;
    undefined4 uVar4;
    undefined1 auStack_105c[4096];
    int local_5c;
    undefined1 auStack_58[8];
    undefined1 local_50;
    undefined1 local_4f;
    undefined2 local_4e;
    undefined1 local_4c;
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    void *local_24;
    int local_20;
    int local_1c;

    local_5c = 0;
    local_1c = *(int *)(param_1 + 0x1a8) << 6;
    V_LOCK();
    logfmt_raw(auStack_105c, 0x1000, 0, "%s core_no %d",
               "ChipSetting_get_cache_done_status_rvn_LTC_1491", local_1c);
    V_UNLOCK();
    uVar4 = 0x5e2;
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_get_cache_done_status_rvn_LTC_1491", 0x2e, 0x5e2,
         0x28, auStack_105c);
    memset(auStack_58, 0, 0x10);
    local_50 = 0;
    local_4f = 0;
    local_24 = malloc(local_1c * 0xc);
    local_4e = param_3;
    local_4c = param_2;
    memset(local_24, 0, local_1c * 0xc);
    (**(code **)(param_1 + 300))(param_1, auStack_58, local_1c, local_24,
                                 &local_5c, uVar4, 2000, 0);
    local_20 = 0;
    while (true) {
        if (local_5c <= local_20)
            break;
        V_LOCK();
        FUN_00077ce8(&local_48, &local_48, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        uVar1 = *(undefined1 *)((int)local_24 + local_20 * 0xc + 4);
        uVar2 = *(undefined1 *)((int)local_24 + local_20 * 0xc + 8);
        uVar4 =
            FUN_000780e4(*(undefined2 *)((int)local_24 + local_20 * 0xc + 6));
        uVar3 = FUN_000780bc(*(undefined4 *)((int)local_24 + local_20 * 0xc));
        logfmt_raw(auStack_105c, 0x1000, 0, uStack_2c, local_48, uStack_44,
                   uStack_40, uStack_3c, local_38, uStack_34, uStack_30,
                   uStack_2c,
                   "[Core State] asic %02x core %02x reg %04x state %08x",
                   uVar1, uVar2, uVar4, uVar3);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_get_cache_done_status_rvn_LTC_1491", 0x2e,
             0x5ee, 0x28, auStack_105c);
        local_20 = local_20 + 1;
    }
    if (param_4 != (void *)0x0) {
        memcpy(param_4, local_24, local_1c * 0xc);
    }
    free(local_24);
    return local_5c;
}

int FUN_0007fa40(int param_1, short param_2, undefined2 param_3, void *param_4)

{
    undefined1 uVar1;
    undefined4 uVar2;
    undefined1 auStack_10e4[4096];
    int local_e4;
    undefined1 auStack_e0[8];
    undefined1 local_d8;
    undefined1 local_d7;
    undefined2 local_d6;
    undefined1 local_d4;
    undefined4 local_d0;
    undefined4 uStack_cc;
    undefined4 uStack_c8;
    undefined4 uStack_c4;
    undefined4 local_c0;
    undefined4 uStack_bc;
    undefined4 uStack_b8;
    undefined4 uStack_b4;
    undefined4 local_b0;
    undefined4 uStack_ac;
    undefined4 uStack_a8;
    undefined4 uStack_a4;
    undefined4 local_a0;
    undefined4 uStack_9c;
    undefined4 uStack_98;
    undefined4 uStack_94;
    undefined4 local_90;
    undefined4 uStack_8c;
    undefined4 uStack_88;
    undefined4 uStack_84;
    undefined4 local_80;
    undefined4 uStack_7c;
    undefined4 uStack_78;
    undefined4 uStack_74;
    undefined4 local_70;
    undefined4 uStack_6c;
    undefined4 uStack_68;
    undefined4 uStack_64;
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    int local_2c;
    int local_28;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    void *local_14;

    local_e4 = 0;
    local_18 = *(int *)(param_1 + 0x1a8);
    if (param_2 == 0xff) {
        local_18 = *(int *)(param_1 + 0x1a8) * 0x88;
    }
    V_LOCK();
    logfmt_raw(auStack_10e4, 0x1000, 0, "%s core_no %d",
               "ChipSetting_get_core_status_5chips_LTC_1491", local_18);
    V_UNLOCK();
    uVar2 = 0x5ff;
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_get_core_status_5chips_LTC_1491", 0x2b, 0x5ff, 0x14,
         auStack_10e4);
    memset(auStack_e0, 0, 0x10);
    local_d8 = 0;
    local_d7 = 0;
    local_14 = malloc(local_18 * 0xc);
    uVar1 = (undefined1)param_2;
    local_d6 = param_3;
    local_d4 = uVar1;
    memset(local_14, 0, local_18 * 0xc);
    (**(code **)(param_1 + 300))(param_1, auStack_e0, local_18, local_14,
                                 &local_e4, uVar2, 2000, 0);
    local_20 = 0;
    while (true) {
        if (local_e4 <= local_20)
            break;
        V_LOCK();
        FUN_00077ce8(&local_d0, &local_d0, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_10e4, 0x1000, 0, uStack_b4, local_d0, uStack_cc,
                   uStack_c8, uStack_c4, local_c0, uStack_bc, uStack_b8,
                   uStack_b4,
                   "[Core State] asic %02x core %02x reg %04x state %08x",
                   *(undefined1 *)((int)local_14 + local_20 * 0xc + 4),
                   *(undefined1 *)((int)local_14 + local_20 * 0xc + 8),
                   *(undefined2 *)((int)local_14 + local_20 * 0xc + 6),
                   *(undefined4 *)((int)local_14 + local_20 * 0xc));
        V_UNLOCK();
        uVar2 = 0x60b;
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_get_core_status_5chips_LTC_1491", 0x2b, 0x60b,
             0x14, auStack_10e4);
        local_20 = local_20 + 1;
    }
    local_d8 = 0;
    local_d7 = 0x33;
    local_14 = malloc(local_18 * 0xc);
    local_d6 = param_3;
    local_d4 = uVar1;
    memset(local_14, 0, local_18 * 0xc);
    (**(code **)(param_1 + 300))(param_1, auStack_e0, local_18, local_14,
                                 &local_e4, uVar2, 2000, 0);
    local_24 = 0;
    while (true) {
        if (local_e4 <= local_24)
            break;
        V_LOCK();
        FUN_00077ce8(&local_b0, &local_b0, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_10e4, 0x1000, 0, uStack_94, local_b0, uStack_ac,
                   uStack_a8, uStack_a4, local_a0, uStack_9c, uStack_98,
                   uStack_94,
                   "[Core State] asic %02x core %02x reg %04x state %08x",
                   *(undefined1 *)((int)local_14 + local_24 * 0xc + 4),
                   *(undefined1 *)((int)local_14 + local_24 * 0xc + 8),
                   *(undefined2 *)((int)local_14 + local_24 * 0xc + 6),
                   *(undefined4 *)((int)local_14 + local_24 * 0xc));
        V_UNLOCK();
        uVar2 = 0x616;
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_get_core_status_5chips_LTC_1491", 0x2b, 0x616,
             0x14, auStack_10e4);
        local_24 = local_24 + 1;
    }
    local_d8 = 0;
    local_d7 = 0x66;
    local_14 = malloc(local_18 * 0xc);
    local_d6 = param_3;
    local_d4 = uVar1;
    memset(local_14, 0, local_18 * 0xc);
    (**(code **)(param_1 + 300))(param_1, auStack_e0, local_18, local_14,
                                 &local_e4, uVar2, 2000, 0);
    local_28 = 0;
    while (true) {
        if (local_e4 <= local_28)
            break;
        V_LOCK();
        FUN_00077ce8(&local_90, &local_90, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_10e4, 0x1000, 0, uStack_74, local_90, uStack_8c,
                   uStack_88, uStack_84, local_80, uStack_7c, uStack_78,
                   uStack_74,
                   "[Core State] asic %02x core %02x reg %04x state %08x",
                   *(undefined1 *)((int)local_14 + local_28 * 0xc + 4),
                   *(undefined1 *)((int)local_14 + local_28 * 0xc + 8),
                   *(undefined2 *)((int)local_14 + local_28 * 0xc + 6),
                   *(undefined4 *)((int)local_14 + local_28 * 0xc));
        V_UNLOCK();
        uVar2 = 0x621;
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_get_core_status_5chips_LTC_1491", 0x2b, 0x621,
             0x14, auStack_10e4);
        local_28 = local_28 + 1;
    }
    local_d8 = 0;
    local_d7 = 0x99;
    local_14 = malloc(local_18 * 0xc);
    local_d6 = param_3;
    local_d4 = uVar1;
    memset(local_14, 0, local_18 * 0xc);
    (**(code **)(param_1 + 300))(param_1, auStack_e0, local_18, local_14,
                                 &local_e4, uVar2, 2000, 0);
    local_2c = 0;
    while (true) {
        if (local_e4 <= local_2c)
            break;
        V_LOCK();
        FUN_00077ce8(&local_70, &local_70, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_10e4, 0x1000, 0, uStack_54, local_70, uStack_6c,
                   uStack_68, uStack_64, local_60, uStack_5c, uStack_58,
                   uStack_54,
                   "[Core State] asic %02x core %02x reg %04x state %08x",
                   *(undefined1 *)((int)local_14 + local_2c * 0xc + 4),
                   *(undefined1 *)((int)local_14 + local_2c * 0xc + 8),
                   *(undefined2 *)((int)local_14 + local_2c * 0xc + 6),
                   *(undefined4 *)((int)local_14 + local_2c * 0xc));
        V_UNLOCK();
        uVar2 = 0x62c;
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_get_core_status_5chips_LTC_1491", 0x2b, 0x62c,
             0x14, auStack_10e4);
        local_2c = local_2c + 1;
    }
    local_d8 = 0;
    local_d7 = 0xcc;
    local_14 = malloc(local_18 * 0xc);
    local_d6 = param_3;
    local_d4 = uVar1;
    memset(local_14, 0, local_18 * 0xc);
    (**(code **)(param_1 + 300))(param_1, auStack_e0, local_18, local_14,
                                 &local_e4, uVar2, 2000, 0);
    local_1c = 0;
    while (true) {
        if (local_e4 <= local_1c)
            break;
        V_LOCK();
        FUN_00077ce8(&local_50, &local_50, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_10e4, 0x1000, 0, uStack_34, local_50, uStack_4c,
                   uStack_48, uStack_44, local_40, uStack_3c, uStack_38,
                   uStack_34,
                   "[Core State] asic %02x core %02x reg %04x state %08x",
                   *(undefined1 *)((int)local_14 + local_1c * 0xc + 4),
                   *(undefined1 *)((int)local_14 + local_1c * 0xc + 8),
                   *(undefined2 *)((int)local_14 + local_1c * 0xc + 6),
                   *(undefined4 *)((int)local_14 + local_1c * 0xc));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_get_core_status_5chips_LTC_1491", 0x2b, 0x637,
             0x14, auStack_10e4);
        local_1c = local_1c + 1;
    }
    if (param_4 != (void *)0x0) {
        memcpy(param_4, local_14, local_18 * 0xc);
    }
    free(local_14);
    return local_e4;
}

int FUN_0008060c(int param_1, undefined1 param_2, short param_3,
                 undefined2 param_4, void *param_5)

{
    undefined4 uVar1;
    undefined1 auStack_1054[4096];
    int local_54;
    undefined1 auStack_50[8];
    undefined1 local_48;
    undefined1 local_47;
    undefined2 local_46;
    undefined1 local_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    void *local_1c;
    int local_18;
    int local_14;

    local_54 = 0;
    local_14 = 1;
    if (param_3 == 0xff) {
        local_14 = 0x88;
    }
    memset(auStack_50, 0, 0x10);
    local_48 = 0;
    local_47 = param_2;
    local_1c = malloc(local_14 * 0xc);
    local_44 = (undefined1)param_3;
    local_46 = param_4;
    memset(local_1c, 0, local_14 * 0xc);
    uVar1 = 0;
    (**(code **)(param_1 + 300))(param_1, auStack_50, local_14, local_1c,
                                 &local_54);
    V_LOCK();
    logfmt_raw(auStack_1054, 0x1000, 0, "%s core_no %d response_num %d",
               "ChipSetting_get_single_chip_core_status_LTC_1491", local_14,
               local_54, uVar1);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/./backend/chip_setting.c",
         0xa2, "ChipSetting_get_single_chip_core_status_LTC_1491", 0x30, 0x64f,
         0x28, auStack_1054);
    local_18 = 0;
    while (true) {
        if (local_54 <= local_18)
            break;
        V_LOCK();
        FUN_00077ce8(&local_40, &local_40, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_1054, 0x1000, 0, uStack_24, local_40, uStack_3c,
                   uStack_38, uStack_34, local_30, uStack_2c, uStack_28,
                   uStack_24,
                   "[Core State] asic %02x core %02x reg %04x state %08x",
                   *(undefined1 *)((int)local_1c + local_18 * 0xc + 4),
                   *(undefined1 *)((int)local_1c + local_18 * 0xc + 8),
                   *(undefined2 *)((int)local_1c + local_18 * 0xc + 6),
                   *(undefined4 *)((int)local_1c + local_18 * 0xc));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/./backend/chip_setting.c",
             0xa2, "ChipSetting_get_single_chip_core_status_LTC_1491", 0x30,
             0x652, 0x28, auStack_1054);
        local_18 = local_18 + 1;
    }
    if (param_5 != (void *)0x0) {
        memcpy(param_5, local_1c, local_14 * 0xc);
    }
    free(local_1c);
    return local_54;
}

undefined4 global_idx_init_ltc(int param_1)

{
    void *__s;

    __s = malloc(0x6a08);
    memset(__s, 0, 0x6a08);
    *(void **)(param_1 + 0x338) = __s;
    printf("__custom_data init %p\n", __s);
    return 0;
}

undefined4 global_idx_free_ltc(int param_1)

{
    free(*(void **)(param_1 + 0x338));
    return 0;
}

void FUN_00080a10(int param_1, undefined1 param_2)

{
    int iVar1;
    undefined1 auStack_2010[4096];
    char acStack_1010[4096];
    int local_10;
    uint local_c;

    local_10 = 0;
    for (local_c = 0; local_c < 0x50; local_c = local_c + 1) {
        iVar1 = snprintf(acStack_1010 + local_10, 0x1000 - local_10, "%02x ",
                         (uint) * (byte *)(param_1 + local_c + 0x48));
        local_10 = local_10 + iVar1;
    }
    V_LOCK();
    logfmt_raw(auStack_2010, 0x1000, 0,
               "ltc dump work jobid %s, work count %02x", param_1 + 8, param_2);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/backend_ltc_1491.c",
        0xb5, "dump_work_ltc", 0xd, 0x85, 0x14, auStack_2010);
    V_LOCK();
    logfmt_raw(auStack_2010, 0x1000, 0, "dump work: %s", acStack_1010);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/backend_ltc_1491.c",
        0xb5, "dump_work_ltc", 0xd, 0x86, 0x14, auStack_2010);
    return;
}

undefined4 FUN_00080be8(int param_1, int param_2, byte *param_3)

{
    int iVar1;
    uint uVar2;
    uint uVar3;

    uVar3 = (((uint)*param_3 << 0x18 | (uint)param_3[1] << 0x10 |
              (uint)param_3[2] << 8 | (uint)param_3[3]) -
             param_2) *
            0x80;
    uVar2 = uVar3 >> 0x11 & 0xff;
    iVar1 = FUN_000cc2a0(uVar2, *(undefined4 *)(param_1 + 0x1ac));
    uVar3 = uVar3 & 0xfe01ffff;
    uVar2 = uVar3 |
            (uVar2 - *(byte *)(*(int *)(param_1 + 0x1ec) + iVar1)) * 0x20000;
    *param_3 = (byte)(uVar2 >> 0x18);
    param_3[1] = (byte)(uVar2 >> 0x10);
    param_3[2] = (byte)(uVar3 >> 8);
    param_3[3] = (byte)uVar3;
    return 0;
}

undefined4 work_2_packet_ltc(int param_1, undefined4 *param_2,
                             undefined1 *param_3, undefined4 *param_4)

{
    char cVar1;
    int iVar2;
    undefined4 *puVar3;
    undefined4 uVar4;
    undefined1 auStack_101c[4098];
    undefined2 local_1a;
    int local_18;
    undefined4 local_14;
    undefined4 *local_10;
    undefined1 *local_c;

    local_14 = 0;
    local_18 = *(int *)(param_1 + 0x338);
    *param_3 = 0x55;
    param_3[1] = 0xaa;
    param_3[2] = 0x20;
    if (*(int *)(param_1 + 0x1f0) == 1) {
        param_3[2] = param_3[2] | 0x10;
    }
    uVar4 = param_2[1];
    puVar3 =
        (undefined4 *)(local_18 + (uint) * (byte *)(local_18 + 0x6a00) * 8);
    *puVar3 = *param_2;
    puVar3[1] = uVar4;
    *(undefined4 *)(local_18 + (*(byte *)(local_18 + 0x6a00) + 0x1300) * 4) =
        param_2[0x26];
    local_10 = param_2;
    local_c = param_3;
    memcpy((void *)(local_18 + (*(byte *)(local_18 + 0x6a00) + 0x270) * 0x20),
           param_2 + 0x27, 0x20);
    strcpy((char *)(local_18 + (*(byte *)(local_18 + 0x6a00) + 0x10) * 0x40),
           (char *)(local_10 + 2));
    memcpy((void *)(local_18 + (uint) * (byte *)(local_18 + 0x6a00) * 0x50 +
                    0x2400),
           local_10 + 0x12, 0x50);
    memcpy((void *)(local_18 + (*(byte *)(local_18 + 0x6a00) + 0x5e0) * 0x10),
           local_10 + 0x2f, local_10[0x33]);
    *(undefined4 *)(local_18 + (*(byte *)(local_18 + 0x6a00) + 0x1980) * 4) =
        local_10[0x33];
    *(undefined4 *)(local_18 + (*(byte *)(local_18 + 0x6a00) + 0x1a00) * 4) =
        local_10[0x34];
    cVar1 = *(char *)(local_18 + 0x6a00);
    *(char *)(local_18 + 0x6a00) = cVar1 + '\x01';
    local_c[3] = cVar1;
    *(byte *)(local_18 + 0x6a00) = *(byte *)(local_18 + 0x6a00) & 0x7f;
    rev(local_10 + 0x12, 0x50);
    memcpy(local_c + 4, local_10 + 0x13, 0x4c);
    local_c[0x50] = *(undefined1 *)(local_10 + 0x12);
    local_c[0x51] = *(undefined1 *)((int)local_10 + 0x49);
    local_c[0x52] = *(undefined1 *)((int)local_10 + 0x4a);
    local_c[0x53] = *(undefined1 *)((int)local_10 + 0x4b);
    iVar2 = memcmp(last_work_ltc_1491 + 4, local_10 + 0x13, 0x4c);
    if (iVar2 == 0) {
        V_LOCK();
        logfmt_raw(auStack_101c, 0x1000, 0, "found repeat work");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "backend_ltc_1491.c",
             0xb5, "work_2_packet_ltc", 0x11, 0xca, 0x50, auStack_101c);
        FUN_00080a10(local_10, local_c[3]);
    }
    memcpy(last_work_ltc_1491 + 4, local_10 + 0x13, 0x4c);
    local_14 = 0x52;
    local_1a = BM_CRC16(local_c + 2, 0x52);
    local_c[0x54] = (char)((ushort)local_1a >> 8);
    local_c[0x55] = (char)local_1a;
    *param_4 = 0x56;
    if ((*(char *)(param_1 + 0x101) != '\0') &&
        (*(char *)(param_1 + 0x102) != '\0')) {
        memset(*(void **)(param_1 + 0x1c8), 0,
               *(int *)(param_1 + 0x150) * 0x30);
        chip_setting_ticket_mask_ltc(param_1, 0xfff);
        chip_setting_misc_ltc(param_1, 0, 0, 1, 0);
        *(undefined1 *)(param_1 + 0x101) = 0;
    }
    return 0;
}

void FUN_00081220(int param_1, int param_2, int param_3)

{
    int iVar1;
    undefined1 auStack_2038[4096];
    char acStack_1038[4096];
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    uint local_18;
    int local_14;

    local_14 = 0;
    for (local_18 = 0; local_18 < 4; local_18 = local_18 + 1) {
        iVar1 = snprintf(acStack_1038 + local_14, 0x1000 - local_14, "%02x ",
                         (uint) * (byte *)(param_2 + local_18 + 3));
        local_14 = local_14 + iVar1;
    }
    V_LOCK();
    logfmt_raw(auStack_2038, 0x1000, 0, "work_id: %02x diff %02x",
               *(undefined1 *)(param_2 + 8), *(byte *)(param_2 + 7) & 0x3f);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/backend_ltc_1491.c",
        0xb5, "dump_nonce_ltc", 0xe, 0xe9, 0x14, auStack_2038);
    V_LOCK();
    logfmt_raw(auStack_2038, 0x1000, 0, "back nonce: %s", acStack_1038);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/backend_ltc_1491.c",
        0xb5, "dump_nonce_ltc", 0xe, 0xea, 0x14, auStack_2038);
    local_14 = 0;
    for (local_18 = 0; local_18 < 4; local_18 = local_18 + 1) {
        iVar1 = snprintf(acStack_1038 + local_14, 0x1000 - local_14, "%02x ",
                         (uint) * (byte *)(param_3 + local_18 + 0x50));
        local_14 = local_14 + iVar1;
    }
    V_LOCK();
    FUN_00077ce8(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_2038, 0x1000, 0, uStack_1c, local_38, uStack_34,
               uStack_30, uStack_2c, local_28, uStack_24, uStack_20, uStack_1c,
               "asic %d core %d addr_interval %d", *(undefined4 *)(param_3 + 8),
               *(undefined4 *)(param_3 + 0xc),
               *(undefined4 *)(param_1 + 0x1ac));
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/backend_ltc_1491.c",
        0xb5, "dump_nonce_ltc", 0xe, 0xf0, 0x14, auStack_2038);
    V_LOCK();
    logfmt_raw(auStack_2038, 0x1000, 0, "nonce: %s", acStack_1038);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/backend_ltc_1491.c",
        0xb5, "dump_nonce_ltc", 0xe, 0xf1, 0x14, auStack_2038);
    return;
}

undefined4 packet_2_nonce_ltc(int param_1, int param_2, undefined4 *param_3,
                              undefined1 *param_4, undefined4 *param_5,
                              uint *param_6, undefined4 *param_7)

{
    ushort uVar1;
    byte bVar2;
    ushort uVar3;
    uint extraout_r1;
    undefined4 uVar4;
    int iVar5;
    undefined4 *puVar6;

    if (*(char *)(param_2 + 9) < '\0') {
        uVar3 = BM_CRC5(param_2 + 2, 0x3b);
        uVar1 = *(byte *)(param_2 + 9) & 0x1f;
        if (uVar3 == uVar1) {
            iVar5 = *(int *)(param_1 + 0x338);
            puVar6 = (undefined4 *)(iVar5 + (uint) * (byte *)(param_2 + 8) * 8);
            uVar4 = puVar6[1];
            *param_3 = *puVar6;
            param_3[1] = uVar4;
            *param_7 =
                *(undefined4 *)(iVar5 + (uint) * (byte *)(param_2 + 8) * 8);
            strcpy((char *)(param_3 + 4),
                   (char *)(iVar5 + (*(byte *)(param_2 + 8) + 0x10) * 0x40));
            param_3[0x14] = *(undefined4 *)(param_2 + 3);
            *(undefined1 *)(param_3 + 0x15) = *(undefined1 *)(param_2 + 7);
            *(undefined1 *)((int)param_3 + 0x55) = *(undefined1 *)(param_2 + 8);
            memcpy((void *)((int)param_3 + 0x56),
                   (void *)(iVar5 + (*(byte *)(param_2 + 8) + 0x5e0) * 0x10),
                   *(size_t *)(iVar5 + (*(byte *)(param_2 + 8) + 0x1980) * 4));
            param_3[0x1a] =
                *(undefined4 *)(iVar5 + (*(byte *)(param_2 + 8) + 0x1980) * 4);
            param_3[0x1b] =
                *(undefined4 *)(iVar5 + (*(byte *)(param_2 + 8) + 0x1a00) * 4);
            bVar2 = FUN_000cc2a0(*(undefined1 *)(param_2 + 4),
                                 *(undefined4 *)(param_1 + 0x1ac));
            if ((int)(uint)bVar2 < *(int *)(param_1 + 0x150)) {
                *param_6 = (uint)bVar2;
            } else {
                iVar5 = rand();
                FUN_000cc7ac(iVar5, *(undefined4 *)(param_1 + 0x150));
                *param_6 = extraout_r1;
            }
            param_3[2] = *param_6;
            param_3[3] = (uint) * (byte *)(param_2 + 3);
            *param_5 = param_3[0x14];
            *param_4 = 1;
            uVar4 = 0;
        } else {
            printf("chain[%d] get nonce crc error calc value %04x expected "
                   "value %04x\n",
                   *(undefined4 *)(param_1 + 0xf8), (uint)uVar3, (uint)uVar1);
            uVar4 = 0x65;
        }
    } else {
        uVar4 = 100;
    }
    return uVar4;
}

undefined4 FUN_000818d8(int param_1)

{
    int iVar1;
    undefined4 uVar2;
    undefined1 auStack_1038[4096];
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    int local_18;
    uint local_14;

    local_18 = *(int *)(param_1 + 0x150);
    local_14 = 0;
    do {
        FUN_000781dc(param_1, local_18);
        V_LOCK();
        FUN_00077ce8(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_1038, 0x1000, 0, uStack_1c, local_38, uStack_34,
                   uStack_30, uStack_2c, local_28, uStack_24, uStack_20,
                   uStack_1c, "detect chip num %d design num %d",
                   *(undefined4 *)(param_1 + 0x1a8), local_18);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "backend_ltc_1491.c",
             0xb5, "check_asic_num_ltc", 0x12, 0x12d, 0x3c, auStack_1038);
        if (local_18 != *(int *)(param_1 + 0x1a8)) {
            usleep(300000);
            iVar1 = dev_ctrl();
            (**(code **)(iVar1 + 0x18))(*(undefined4 *)(param_1 + 0xf8),
                                        *(undefined4 *)(param_1 + 0x454),
                                        *(undefined4 *)(param_1 + 0x468));
            iVar1 = dev_ctrl();
            (**(code **)(iVar1 + 0x2c))(*(undefined4 *)(param_1 + 0xf8));
        }
    } while ((local_18 != *(int *)(param_1 + 0x1a8)) &&
             (local_14 = local_14 + 1, local_14 < 3));
    if (local_18 == *(int *)(param_1 + 0x1a8)) {
        uVar2 = 0;
    } else {
        uVar2 = 0x66;
    }
    return uVar2;
}

undefined4 get_chip_temperature_str_ltc(int param_1, char *param_2,
                                        uint param_3)

{
    int iVar1;
    int local_14;
    int local_10;
    int local_c;

    *param_2 = '\0';
    if (3999 < param_3) {
        param_3 = 4000;
    }
    local_c = snprintf(param_2, param_3, "chain %d, chip temperature array:",
                       *(undefined4 *)(param_1 + 0xfc));
    for (local_10 = 0; local_10 < 10; local_10 = local_10 + 1) {
        iVar1 = snprintf(param_2 + local_c, param_3 - local_c, "\n");
        local_c = local_c + iVar1;
        for (local_14 = 0; local_14 < 0xb; local_14 = local_14 + 1) {
            iVar1 =
                *(int *)(&DAT_0014fdf8 + (local_10 * 0xb + local_14) * 4) + -1;
            if ((iVar1 < 0) || (0x6d < iVar1)) {
                iVar1 = snprintf(param_2 + local_c, param_3 - local_c, "XXX ");
            } else {
                iVar1 = snprintf(
                    param_2 + local_c, param_3 - local_c, "%3d ",
                    *(undefined4 *)(*(int *)(param_1 + 0x210) + iVar1 * 0x2c));
            }
            local_c = local_c + iVar1;
        }
    }
    return 0;
}

undefined4 calc_chip_temp_min_max_avg_ltc(int param_1, int *param_2,
                                          int *param_3, undefined4 *param_4,
                                          int *param_5)

{
    void *__base;
    undefined4 uVar1;
    int iVar2;
    int local_1c;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    local_c = 0;
    local_10 = 0;
    *param_5 = 1;
    __base = malloc(*(int *)(param_1 + 0x150) << 2);
    for (local_14 = 0; local_14 < *(int *)(param_1 + 0x150);
         local_14 = local_14 + 1) {
        pthread_mutex_lock((pthread_mutex_t *)(*(int *)(param_1 + 0x210) +
                                               local_14 * 0x2c + 0x14));
        *(undefined4 *)((int)__base + local_14 * 4) =
            *(undefined4 *)(*(int *)(param_1 + 0x210) + local_14 * 0x2c);
        pthread_mutex_unlock((pthread_mutex_t *)(*(int *)(param_1 + 0x210) +
                                                 local_14 * 0x2c + 0x14));
    }
    qsort(__base, *(size_t *)(param_1 + 0x150), 4, cmpfunc_int);
    *param_2 = -0x40;
    local_18 = 0;
    while (true) {
        iVar2 = *(int *)(param_1 + 0x150) + -1;
        if (*(int *)(param_1 + 0x150) + -6 < 0 == SBORROW4(iVar2, 5)) {
            iVar2 = 5;
        }
        if (iVar2 <= local_18)
            goto LAB_00081e74;
        if (*(int *)((int)__base + local_18 * 4) != -0x40)
            break;
        local_18 = local_18 + 1;
    }
    *param_2 = *(int *)((int)__base + local_18 * 4);
LAB_00081e74:
    *param_3 =
        *(int *)((int)__base + (*(int *)(param_1 + 0x150) + 0x3fffffff) * 4);
    if (*param_2 + 0x37 < *param_3) {
        *param_5 = 0;
    }
    for (local_1c = 4; local_1c < *(int *)(param_1 + 0x150) + -4;
         local_1c = local_1c + 1) {
        local_10 = local_10 + *(int *)((int)__base + local_1c * 4);
        local_c = local_c + 1;
    }
    if (local_c < 1) {
        *param_5 = 0;
    } else {
        uVar1 = FUN_000cc518(local_10, local_c);
        *param_4 = uVar1;
    }
    free(__base);
    if (*param_5 == 0) {
        uVar1 = 0;
    } else {
        uVar1 = 4;
    }
    return uVar1;
}

uint FUN_00081f84(int param_1, int param_2, undefined4 *param_3)

{
    uint uVar1;
    int iVar2;
    undefined1 auStack_206c[4096];
    uint local_106c;
    undefined1 auStack_1068[4000];
    undefined4 local_c8;
    int local_c4;
    undefined4 local_c0[2];
    undefined1 local_b8;
    undefined1 local_b7;
    undefined2 local_b6;
    undefined4 local_b0;
    undefined4 uStack_ac;
    undefined4 uStack_a8;
    undefined4 uStack_a4;
    undefined4 local_a0;
    undefined4 uStack_9c;
    undefined4 uStack_98;
    undefined4 uStack_94;
    undefined4 local_90;
    undefined4 uStack_8c;
    undefined4 uStack_88;
    undefined4 uStack_84;
    undefined4 local_80;
    undefined4 uStack_7c;
    undefined4 uStack_78;
    undefined4 uStack_74;
    undefined4 local_70;
    undefined4 uStack_6c;
    undefined4 uStack_68;
    undefined4 uStack_64;
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    uint local_30;
    void *local_2c;
    uint local_28;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    float local_14;

    local_c4 = 0;
    local_14 = 0.0;
    local_24 = 0;
    local_c8 = 0x11000000;
    *param_3 = 1;
    for (local_20 = 0; local_20 < *(int *)(param_1 + 0x150);
         local_20 = local_20 + 1) {
        *(undefined4 *)(param_2 + local_20 * 4) = 0xc2800000;
    }
    memset(local_c0, 0, 0x10);
    local_b8 = 1;
    local_b7 = 0;
    local_b6 = 0x8c;
    local_c0[0] = local_c8;
    local_28 = (**(code **)(param_1 + 0x10c))(param_1, local_c0);
    usleep(10000);
    local_c8 = 0x11020000;
    memset(local_c0, 0, 0x10);
    local_b8 = 1;
    local_b7 = 0;
    local_b6 = 0x8c;
    local_c0[0] = local_c8;
    uVar1 = (**(code **)(param_1 + 0x10c))(param_1, local_c0);
    local_28 = local_28 | uVar1;
    usleep(50000);
    memset(local_c0, 0, 0x10);
    local_b8 = 1;
    local_b7 = 0;
    local_b6 = 0x90;
    local_2c = malloc(*(int *)(param_1 + 0x150) * 0xc);
    memset(local_2c, 0, *(int *)(param_1 + 0x150) * 0xc);
    (**(code **)(param_1 + 0x120))(param_1, local_c0,
                                   *(undefined4 *)(param_1 + 0x150), local_2c,
                                   &local_c4);
    local_1c = 0;
    while (true) {
        iVar2 = *(int *)(param_1 + 0x150);
        if (local_c4 <= iVar2) {
            iVar2 = local_c4;
        }
        if (iVar2 <= local_1c)
            break;
        if (*(short *)((int)local_2c + local_1c * 0xc + 6) == 0x90) {
            V_LOCK();
            FUN_00077ce8(&local_b0, &local_b0, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(auStack_206c, 0x1000, 0, uStack_94, local_b0, uStack_ac,
                       uStack_a8, uStack_a4, local_a0, uStack_9c, uStack_98,
                       uStack_94, "[MISC CTRL] asic %02x, reg %02x state %08x",
                       *(undefined1 *)((int)local_2c + local_1c * 0xc + 4),
                       *(undefined2 *)((int)local_2c + local_1c * 0xc + 6),
                       *(undefined4 *)((int)local_2c + local_1c * 0xc));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "backend_ltc_1491/backend_ltc_1491.c",
                 0xb5, "update_chip_temp_ltc", 0x14, 0x1b4, 0x14, auStack_206c);
            if ((*(uint *)((int)local_2c + local_1c * 0xc) & 0x80) != 0) {
                local_106c = 0;
                FUN_00078038(&local_106c,
                             *(undefined4 *)((int)local_2c + local_1c * 0xc));
                local_14 =
                    (float)((((double)(local_106c & 0xffff) - 0.5) * 662.88) /
                                4096.0 -
                            287.48);
                local_30 = *(int *)(param_1 + 0x150) - 1;
                uVar1 =
                    (uint)(*(byte *)((int)local_2c + local_1c * 0xc + 4) >> 1);
                if ((int)uVar1 <= (int)local_30) {
                    local_30 = uVar1;
                }
                if ((*(float *)(param_2 + local_30 * 4) + 64.0 < 0.1) &&
                    (-0.1 < *(float *)(param_2 + local_30 * 4) + 64.0)) {
                    *(float *)(param_2 + local_30 * 4) = local_14;
                    local_24 = local_24 + 1;
                }
            }
        }
        local_1c = local_1c + 1;
    }
    (**(code **)(param_1 + 0xd0))(param_1, auStack_1068, 4000);
    V_LOCK();
    FUN_00077ce8(&local_90, &local_90, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_206c, 0x1000, 0, uStack_74, local_90, uStack_8c,
               uStack_88, uStack_84, local_80, uStack_7c, uStack_78, uStack_74,
               &DAT_00124198, auStack_1068);
    V_UNLOCK();
    zlog(
        g_temp_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/backend_ltc_1491.c",
        0xb5, "update_chip_temp_ltc", 0x14, 0x1c6, 0x28, auStack_206c);
    if (4 < *(int *)(param_1 + 0x150) - local_24) {
        *param_3 = 0;
        V_LOCK();
        FUN_00077ce8(&local_70, &local_70, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_206c, 0x1000, 0, uStack_54, local_70, uStack_6c,
                   uStack_68, uStack_64, local_60, uStack_5c, uStack_58,
                   uStack_54, "is_temp_return 0 design %d valid_return_num: %d",
                   *(undefined4 *)(param_1 + 0x150), local_24);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "backend_ltc_1491.c",
             0xb5, "update_chip_temp_ltc", 0x14, 0x1ca, 0x3c, auStack_206c);
        FUN_000781dc(param_1, *(undefined4 *)(param_1 + 0x150));
        V_LOCK();
        FUN_00077ce8(&local_50, &local_50, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_206c, 0x1000, 0, uStack_34, local_50, uStack_4c,
                   uStack_48, uStack_44, local_40, uStack_3c, uStack_38,
                   uStack_34, "detect chip num %d design num %d",
                   *(undefined4 *)(param_1 + 0x1a8),
                   *(undefined4 *)(param_1 + 0x150));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "backend_ltc_1491.c",
             0xb5, "update_chip_temp_ltc", 0x14, 0x1cc, 0x3c, auStack_206c);
    }
    for (local_18 = 0; local_18 < *(int *)(param_1 + 0x150);
         local_18 = local_18 + 1) {
        pthread_mutex_lock((pthread_mutex_t *)(*(int *)(param_1 + 0x210) +
                                               local_18 * 0x2c + 0x14));
        *(int *)(*(int *)(param_1 + 0x210) + local_18 * 0x2c) =
            (int)*(float *)(param_2 + local_18 * 4);
        pthread_mutex_unlock((pthread_mutex_t *)(*(int *)(param_1 + 0x210) +
                                                 local_18 * 0x2c + 0x14));
    }
    free(local_2c);
    return local_28;
}

undefined4 FUN_0008292c(int param_1, int param_2)

{
    undefined1 auStack_12cc[4096];
    int local_2cc;
    undefined4 local_2c8;
    undefined4 local_2c4;
    undefined4 local_2c0;
    int local_2bc;
    undefined1 auStack_2b8[440];
    int local_100;
    undefined4 uStack_fc;
    int local_f8;
    undefined4 uStack_f4;
    undefined4 local_f0;
    undefined4 uStack_ec;
    undefined4 uStack_e8;
    int local_e4;
    undefined4 local_e0;
    undefined4 uStack_dc;
    undefined4 uStack_d8;
    undefined4 uStack_d4;
    undefined4 local_d0;
    undefined4 uStack_cc;
    undefined4 uStack_c8;
    undefined4 uStack_c4;
    undefined4 local_c0;
    undefined4 uStack_bc;
    undefined4 uStack_b8;
    undefined4 uStack_b4;
    undefined4 local_b0;
    undefined4 uStack_ac;
    undefined4 uStack_a8;
    undefined4 uStack_a4;
    undefined4 local_a0;
    undefined4 uStack_9c;
    undefined4 uStack_98;
    undefined4 uStack_94;
    undefined4 local_90;
    undefined4 uStack_8c;
    undefined4 uStack_88;
    undefined4 uStack_84;
    undefined4 local_80;
    undefined4 uStack_7c;
    undefined4 uStack_78;
    undefined4 uStack_74;
    undefined4 local_70;
    undefined4 uStack_6c;
    undefined4 uStack_68;
    undefined4 uStack_64;
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 *local_3c;
    undefined4 local_38;
    int local_34;
    int local_30;
    int local_2c;
    int local_28;
    undefined4 local_24;

    local_e4 = -0x40;
    local_24 = 0xffffffc0;
    local_100 = *(int *)(param_1 + 0x184);
    uStack_fc = *(undefined4 *)(param_1 + 0x188);
    local_f8 = *(int *)(param_1 + 0x18c);
    uStack_f4 = *(undefined4 *)(param_1 + 400);
    local_f0 = *(undefined4 *)(param_1 + 0x194);
    uStack_ec = *(undefined4 *)(param_1 + 0x198);
    uStack_e8 = *(undefined4 *)(param_1 + 0x19c);
    local_2c0 = 0xffffffc0;
    local_2c4 = 0xffffffc0;
    local_2c8 = 0xffffffc0;
    local_38 = 0;
    if (param_2 == 0) {
        V_LOCK();
        FUN_00077ce8(&local_e0, &local_e0, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_12cc, 0x1000, 0, uStack_c4, local_e0, uStack_dc,
                   uStack_d8, uStack_d4, local_d0, uStack_cc, uStack_c8,
                   uStack_c4, "input sensor_status NULL error");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "backend_ltc_1491.c",
             0xb5, "read_temperature_ltc", 0x14, 0x1ed, 100, auStack_12cc);
        local_38 = 4;
    } else {
        if (*(char *)(param_1 + 0x100) != '\0') {
            local_30 = 0;
            while ((local_30 < 3 &&
                    (FUN_00081f84(param_1, auStack_2b8, &local_2bc),
                     local_2bc == 0))) {
                local_30 = local_30 + 1;
            }
            if (local_2bc == 0) {
                V_LOCK();
                FUN_00077ce8(&local_a0, &local_a0, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(auStack_12cc, 0x1000, 0, uStack_84, local_a0,
                           uStack_9c, uStack_98, uStack_94, local_90, uStack_8c,
                           uStack_88, uStack_84, "failed getting chip temp");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "backend_ltc_1491/backend_ltc_1491.c",
                     0xb5, "read_temperature_ltc", 0x14, 0x214, 100,
                     auStack_12cc);
                for (local_2c = 0; local_2c < local_f8;
                     local_2c = local_2c + 1) {
                    *(undefined4 *)(param_2 + local_2c * 0xc + 8) = 0xffffffc0;
                    *(undefined4 *)(param_2 + local_2c * 0xc + 4) = 0xffffffc0;
                }
                local_38 = 4;
            } else {
                for (local_34 = 0; local_34 < local_f8;
                     local_34 = local_34 + 1) {
                    calc_chip_temp_min_max_avg_ltc(param_1, &local_2c0,
                                                   &local_2c4, &local_2c8,
                                                   &local_2bc);
                    if (local_2bc == 0) {
                        V_LOCK();
                        FUN_00077ce8(&local_c0, &local_c0,
                                     *(int *)(param_1 + 0xfc),
                                     *(int *)(param_1 + 0xfc) >> 0x1f);
                        logfmt_raw(
                            auStack_12cc, 0x1000, 0, uStack_a4, local_c0,
                            uStack_bc, uStack_b8, uStack_b4, local_b0,
                            uStack_ac, uStack_a8, uStack_a4,
                            "calc temp failed, sensors may occur errors");
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/"
                             "backend_ltc_1491/backend_ltc_1491.c",
                             0xb5, "read_temperature_ltc", 0x14, 0x20b, 100,
                             auStack_12cc);
                        *(undefined4 *)(param_2 + local_34 * 0xc + 8) =
                            0xffffffc0;
                        *(undefined4 *)(param_2 + local_34 * 0xc + 4) =
                            0xffffffc0;
                        local_38 = 4;
                    } else {
                        *(undefined4 *)(param_2 + local_34 * 0xc + 8) =
                            local_2c8;
                        if (*(int *)(local_100 + local_34 * 0x18 + 0xc) == 0) {
                            *(undefined4 *)(param_2 + local_34 * 0xc + 4) =
                                local_2c0;
                        } else if (*(int *)(local_100 + local_34 * 0x18 +
                                            0xc) == 1) {
                            *(undefined4 *)(param_2 + local_34 * 0xc + 4) =
                                local_2c4;
                        }
                    }
                }
            }
        }
        for (local_28 = 0; local_28 < local_f8; local_28 = local_28 + 1) {
            local_3c = (undefined4 *)(local_100 + local_28 * 0x18);
            local_2cc = 0;
            (**(code **)(param_1 + 0x9c))(
                param_1, &local_e4, &local_2cc, *local_3c, local_3c[1],
                local_3c[2], local_3c[3], local_3c[4], local_3c[5]);
            if (local_2cc == 0) {
                local_e4 = -0x40;
                V_LOCK();
                FUN_00077ce8(&local_60, &local_60, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(auStack_12cc, 0x1000, 0, uStack_44, local_60,
                           uStack_5c, uStack_58, uStack_54, local_50, uStack_4c,
                           uStack_48, uStack_44,
                           "read sensor failed, sensor[%d], addr:%02x",
                           *local_3c, local_3c[5]);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "backend_ltc_1491/backend_ltc_1491.c",
                     0xb5, "read_temperature_ltc", 0x14, 0x22d, 100,
                     auStack_12cc);
            } else if (local_e4 + 0x3f < 0 != SCARRY4(local_e4, 0x3f)) {
                local_e4 = -0x40;
                V_LOCK();
                FUN_00077ce8(&local_80, &local_80, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(auStack_12cc, 0x1000, 0, uStack_64, local_80,
                           uStack_7c, uStack_78, uStack_74, local_70, uStack_6c,
                           uStack_68, uStack_64,
                           "got uneffective temp, sensor[%d], addr:%02x",
                           *local_3c, local_3c[5]);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "backend_ltc_1491/backend_ltc_1491.c",
                     0xb5, "read_temperature_ltc", 0x14, 0x228, 100,
                     auStack_12cc);
            }
            *(int *)(param_2 + local_28 * 0xc) = local_e4;
        }
    }
    return local_38;
}

undefined4 FUN_00083104(undefined4 param_1, undefined4 param_2)

{
    int iVar1;
    undefined4 uVar2;

    iVar1 = FUN_00079798(param_1, param_2);
    if (iVar1 == 0) {
        uVar2 = 0;
    } else {
        uVar2 = 0x6d;
    }
    return uVar2;
}

undefined4 FUN_00083148(float param_1, int param_2, undefined4 param_3)

{
    double dVar1;
    undefined8 uVar2;
    undefined1 auStack_100c[4096];
    undefined4 local_c;

    local_c = 0;
    chip_setting_freq_ltc(param_1, param_2, 1, 0, param_3);
    dVar1 =
        ((205520895.99999997 / (double)(longlong)(int)param_1) * 70.0) / 100.0;
    uVar2 = FUN_000cce60(SUB84(dVar1, 0), (int)((ulonglong)dVar1 >> 0x20));
    *(undefined8 *)(param_2 + 0x460) = uVar2;
    *(int *)(param_2 + 0x1d0) = (int)param_1;
    V_LOCK();
    logfmt_raw(auStack_100c, 0x1000, 0, "timeout %ld frequency %d",
               *(undefined4 *)(param_2 + 0x460),
               *(undefined4 *)(param_2 + 0x464),
               *(undefined4 *)(param_2 + 0x1d0));
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/backend_ltc_1491.c",
        0xb5, "set_frequency_ltc", 0x11, 0x273, 0x14, auStack_100c);
    return local_c;
}

undefined4 FUN_00083350(undefined4 param_1, undefined4 param_2)

{
    int iVar1;
    undefined4 uVar2;

    iVar1 = FUN_0007ccd8(param_1, param_2);
    if (iVar1 == 0) {
        uVar2 = 0;
    } else {
        uVar2 = 0x6d;
    }
    return uVar2;
}

undefined4 FUN_00083394(int param_1)

{
    int iVar1;
    uint local_c;

    local_c = 10;
    while (true) {
        if ((int)(local_c + *(int *)(param_1 + 0x150) * -2) < 0 ==
            SBORROW4(local_c, *(int *)(param_1 + 0x150) * 2)) {
            return 0;
        }
        iVar1 = FUN_0007ce48(param_1, local_c & 0xff, 0xf);
        if (iVar1 != 0)
            break;
        local_c = local_c + 10;
    }
    return 0x6d;
}

undefined4 FUN_00083464(int param_1, byte param_2)

{
    undefined4 uVar1;
    undefined4 local_c;

    uVar1 = FUN_000cc518(0x100, param_2);
    for (local_c = 0; local_c < (int)(uint)param_2; local_c = local_c + 1) {
        *(char *)(param_1 + local_c) = (char)uVar1 * (char)local_c;
    }
    return uVar1;
}

undefined4 send_online_work_ltc(int param_1)

{
    int iVar1;
    undefined1 auStack_68[88];
    undefined4 local_10;
    int local_c;

    local_c = 10;
    memcpy(auStack_68, &DAT_001242bc, 0x56);
    local_10 = 0x56;
    puts("send online pattern");
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x430));
    iVar1 = dev_ctrl();
    (**(code **)(iVar1 + 0x34))(*(undefined4 *)(param_1 + 0xf8), auStack_68,
                                local_10);
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x430));
    while (local_c != 0) {
        local_c = local_c + -1;
        usleep(10000);
    }
    return 0;
}

undefined4 top_init_ltc(int param_1)

{
    int iVar1;
    undefined4 uVar2;
    undefined1 auStack_103c[4112];
    float local_2c;
    float local_28;
    undefined4 local_24;
    undefined4 local_20;
    undefined4 local_1c;
    undefined4 local_18;
    float fStack_14;
    int local_10;
    uint local_c;

    local_c = *(uint *)(param_1 + 0x150);
    V_LOCK();
    logfmt_raw(auStack_103c, 0x1000, 0, "get chip address %s ", "top_init_ltc");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/backend_ltc_1491.c",
        0xb5, "top_init_ltc", 0xc, 0x2cd, 0x14, auStack_103c);
    iVar1 = FUN_000818d8(param_1);
    if (iVar1 == 0) {
        uVar2 = FUN_00083464(*(undefined4 *)(param_1 + 0x1ec), local_c & 0xff);
        *(undefined4 *)(param_1 + 0x1ac) = uVar2;
        (**(code **)(param_1 + 0x104))(
            param_1, *(undefined4 *)(param_1 + 0x1ec), local_c);
        local_18 = 0;
        local_1c = 0;
        local_20 = 0;
        local_24 = 0;
        chip_setting_misc_ltc(param_1, 0, 0, 0, 0);
        local_28 = 50.0;
        local_2c = 50.0;
        fStack_14 = (float)(longlong) * (int *)(param_1 + 0x1d0) - 50.0;
        while (true) {
            if (fStack_14 < local_28)
                break;
            (**(code **)(param_1 + 0xc0))(fStack_14, param_1, 0);
            usleep(200000);
            fStack_14 = fStack_14 - local_2c;
        }
        for (local_10 = 0; local_10 < 3; local_10 = local_10 + 1) {
            (**(code **)(param_1 + 0x3c))(param_1);
        }
        chip_setting_working_mode_ltc(
            param_1, 1, 0, *(undefined4 *)(param_1 + 0x154), 0, 0xff);
        chip_setting_core_error_ctrl_ltc(param_1);
        (**(code **)(param_1 + 0x24))(param_1);
        uVar2 = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_103c, 0x1000, 0, "get chip address failed ");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "backend_ltc_1491.c",
             0xb5, "top_init_ltc", 0xc, 0x2cf, 100, auStack_103c);
        uVar2 = 0x66;
    }
    return uVar2;
}

undefined4 dhash_start_ltc(int param_1)

{
    undefined1 auStack_1030[4096];
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    undefined4 local_20;
    undefined4 uStack_1c;
    undefined4 uStack_18;
    undefined4 uStack_14;

    V_LOCK();
    FUN_00077ce8(&local_30, &local_30, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_1030, 0x1000, 0, uStack_14, local_30, uStack_2c,
               uStack_28, uStack_24, local_20, uStack_1c, uStack_18, uStack_14,
               "dhash_start_ltc");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/backend_ltc_1491.c",
        0xb5, "dhash_start_ltc", 0xf, 0x2f4, 0x14, auStack_1030);
    *(undefined1 *)(param_1 + 0x101) = 1;
    return 0;
}

undefined4 FUN_00083a5c(float param_1, float param_2, int param_3,
                        undefined4 param_4)

{
    undefined1 auStack_1014[4096];
    float local_14;
    char *local_10;
    int local_c;

    local_c = 1;
    local_10 = "time";
    local_14 = param_1;
    if (25.0 <= param_2) {
        local_10 = (char *)0x30d40;
    }
    do {
        FUN_0007b9e4(local_14, param_3, param_4);
        usleep((__useconds_t)local_10);
        local_14 = param_1 + (float)(longlong)local_c * param_2;
        local_c = local_c + 1;
    } while (local_14 <= *(float *)(param_3 + 0x450));
    local_14 = local_14 - param_2;
    if (local_14 < *(float *)(param_3 + 0x450)) {
        FUN_0007b9e4(*(undefined4 *)(param_3 + 0x450), param_3, param_4);
        usleep((__useconds_t)local_10);
        local_14 = *(float *)(param_3 + 0x450);
    }
    V_LOCK();
    logfmt_raw(auStack_1014, 0x1000, 0, "Set chip final freq=%.2f",
               (double)local_14);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/backend_ltc_1491.c",
        0xb5, "set_working_freq_by_steps", 0x19, 0x323, 0x28, auStack_1014);
    return 0;
}

undefined4 setup_all_chip_ltc(int param_1)

{
    int iVar1;
    undefined4 uVar2;
    undefined1 auStack_102c[4096];
    undefined4 local_2c[2];
    undefined1 local_24;
    undefined1 local_23;
    undefined2 local_22;
    undefined4 local_1c;
    undefined4 local_18;
    undefined4 local_14;
    uint local_10;
    undefined4 local_c;

    local_10 = *(uint *)(param_1 + 0x150);
    V_LOCK();
    logfmt_raw(auStack_102c, 0x1000, 0, &DAT_00124198, "setup_all_chip_ltc");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/backend_ltc_1491.c",
        0xb5, "setup_all_chip_ltc", 0x12, 0x32b, 0x3c, auStack_102c);
    iVar1 = FUN_000818d8(param_1);
    if (iVar1 == 0) {
        uVar2 = 0x66;
    } else {
        uVar2 = FUN_00083464(*(undefined4 *)(param_1 + 0x1ec), local_10 & 0xff);
        *(undefined4 *)(param_1 + 0x1ac) = uVar2;
        (**(code **)(param_1 + 0x104))(
            param_1, *(undefined4 *)(param_1 + 0x1ec), local_10);
        local_c = 0;
        local_14 = 0;
        local_18 = 1;
        local_1c = 0;
        chip_setting_misc_ltc(param_1, 0, 0, 1, 0);
        chip_setting_ticket_mask_ltc(param_1, 0xffffffff);
        chip_setting_working_mode_ltc(
            param_1, 1, 0, *(undefined4 *)(param_1 + 0x154), 0, 0xff);
        V_LOCK();
        logfmt_raw(auStack_102c, 0x1000, 0, "reset nonce count %s %02x",
                   "setup_all_chip_ltc", 0x44);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "backend_ltc_1491.c",
             0xb5, "setup_all_chip_ltc", 0x12, 0x33c, 0x28, auStack_102c);
        memset(local_2c, 0, 0x10);
        local_24 = 1;
        local_23 = 0;
        local_22 = 0x3c;
        local_2c[0] = 0;
        (**(code **)(param_1 + 0x10c))(param_1, local_2c);
        *(undefined4 *)(param_1 + 0x1d0) = 900;
        V_LOCK();
        logfmt_raw(auStack_102c, 0x1000, 0, "get addr after open cores");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "backend_ltc_1491.c",
             0xb5, "setup_all_chip_ltc", 0x12, 0x348, 0x3c, auStack_102c);
        iVar1 = FUN_000818d8(param_1);
        if (iVar1 == 0) {
            uVar2 = 0x66;
        } else {
            uVar2 = 0;
        }
    }
    return uVar2;
}

undefined4 set_baud_ltc(undefined4 param_1, undefined4 param_2)

{
    undefined4 uVar1;

    uVar1 = chip_setting_buadrate_ltc(param_1, param_2);
    return uVar1;
}

undefined1 FUN_0008404c(int param_1, int param_2)

{
    int local_10;

    local_10 = 7;
    while (true) {
        if (local_10 < 0) {
            return 1;
        }
        if (*(uint *)(param_2 + local_10 * 4) <
            *(uint *)(param_1 + local_10 * 4))
            break;
        if (*(uint *)(param_1 + local_10 * 4) <
            *(uint *)(param_2 + local_10 * 4)) {
            return 1;
        }
        local_10 = local_10 + -1;
    }
    return 0;
}

undefined4 check_nonce_ltc(int param_1, int param_2)

{
    char cVar1;
    undefined4 uVar2;
    undefined1 auStack_108c[4096];
    uint local_8c;
    undefined1 auStack_88[32];
    undefined1 auStack_68[76];
    uint local_1c;
    int local_18;
    uint local_14;
    int local_10;
    byte local_9;

    local_10 = *(int *)(param_1 + 0x338);
    local_14 = *(uint *)(local_10 + (*(byte *)(param_2 + 0x55) + 0x1300) * 4);
    local_18 = param_2;
    memcpy(
        auStack_68,
        (void *)(local_10 + (uint) * (byte *)(param_2 + 0x55) * 0x50 + 0x2400),
        0x50);
    local_8c = (uint) * (byte *)(local_18 + 0x50) << 0x18 |
               (uint) * (byte *)(local_18 + 0x51) << 0x10 |
               (uint) * (byte *)(local_18 + 0x52) << 8 |
               (uint) * (byte *)(local_18 + 0x53);
    local_1c = local_8c;
    scrypt_regenhash(auStack_88, auStack_68, 0x50);
    local_9 = target_to_diff_ltc(auStack_88);
    if (local_9 < 0x1c) {
        V_LOCK();
        logfmt_raw(auStack_108c, 0x1000, 0,
                   "hw error calculate diff %02x ans diff %02x "
                   "TICKET_MASK_ZERO_COUNT_LTC %02x",
                   local_9, *(undefined1 *)(local_18 + 0x54), 0x1c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "backend_ltc_1491.c",
             0xb5, "check_nonce_ltc", 0xf, 0x394, 0x14, auStack_108c);
        uVar2 = 2;
    } else {
        if ((*(byte *)(local_18 + 0x54) & 0x20) == 0) {
            if ((uint)local_9 != *(byte *)(local_18 + 0x54) + 0x10) {
                V_LOCK();
                logfmt_raw(auStack_108c, 0x1000, 0,
                           "diff not match, calculate %02x ans diff %02x",
                           local_9, *(undefined1 *)(local_18 + 0x54));
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "backend_ltc_1491/backend_ltc_1491.c",
                     0xb5, "check_nonce_ltc", 0xf, 0x39f, 0x14, auStack_108c);
                return 3;
            }
        } else if (local_9 < 0x30) {
            V_LOCK();
            logfmt_raw(auStack_108c, 0x1000, 0,
                       "calculate diff %02x, but ans diff %02x (bit5 is 1)",
                       local_9, *(undefined1 *)(local_18 + 0x54));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "backend_ltc_1491/backend_ltc_1491.c",
                 0xb5, "check_nonce_ltc", 0xf, 0x39a, 0x14, auStack_108c);
            return 3;
        }
        if ((local_14 <= local_9) &&
            (cVar1 = FUN_0008404c(
                 auStack_88,
                 local_10 + (*(byte *)(local_18 + 0x55) + 0x270) * 0x20),
             cVar1 == '\x01')) {
            return 0;
        }
        V_LOCK();
        logfmt_raw(auStack_108c, 0x1000, 0, "hw diff (%d<%d) not reach pool",
                   local_9, local_14);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "backend_ltc_1491.c",
             0xb5, "check_nonce_ltc", 0xf, 0x3a5, 0x14, auStack_108c);
        uVar2 = 1;
    }
    return uVar2;
}

undefined4 get_chip_status_ltc(void)

{
    return 0;
}

undefined4 softreset_all_chip_ltc(undefined4 param_1)

{
    chip_setting_software_reset_ltc(param_1);
    chip_setting_ticket_mask_ltc(param_1, 0xffffffff);
    return 0;
}

undefined4 get_theory_hashrate_ltc(int param_1, double *param_2)

{
    *param_2 = (double)(longlong) * (int *)(param_1 + 0x150) *
               ((double)*(float *)(param_1 + 0x450) / 50176.0) * 2048.0 *
               1000.0 * 1000.0;
    return 0;
}

undefined4 FUN_00084610(void)

{
    return 0x3f7ae148;
}

undefined4 get_sale_hashrate_ltc(int param_1, double *param_2,
                                 undefined4 *param_3)

{
    int iVar1;
    float fVar2;
    undefined4 local_18;
    undefined4 uStack_14;
    undefined4 local_10;
    undefined4 local_c;

    local_c = 0;
    local_18 = 0;
    uStack_14 = 0;
    local_10 = 0;
    (**(code **)(param_1 + 0x88))(param_1, &local_18);
    iVar1 = strcmp((char *)(param_1 + 0x130), "L9");
    if (iVar1 == 0) {
        fVar2 = (float)FUN_00084610(param_1);
        *param_2 = (double)fVar2 * (double)CONCAT44(uStack_14, local_18);
        *param_3 = 1;
    } else {
        local_c = 0xcd;
    }
    return local_c;
}

undefined4 FUN_000846f8(void)

{
    return 0x3f7851ec;
}

undefined4 get_qualify_hashrate_ltc(int param_1, double *param_2)

{
    int iVar1;
    float fVar2;
    undefined4 local_18;
    undefined4 uStack_14;
    undefined4 local_10;
    undefined4 local_c;

    local_c = 0;
    local_18 = 0;
    uStack_14 = 0;
    local_10 = 0;
    (**(code **)(param_1 + 0x88))(param_1, &local_18);
    iVar1 = strcmp((char *)(param_1 + 0x130), "L9");
    if (iVar1 == 0) {
        fVar2 = (float)FUN_000846f8(param_1);
        *param_2 = (double)fVar2 * (double)CONCAT44(uStack_14, local_18);
    } else {
        local_c = 0xcd;
    }
    return local_c;
}

undefined4 get_qualify_nonce_num_ltc(int param_1, float *param_2)

{
    double dVar1;
    undefined8 uVar2;
    double dVar3;
    ulonglong in_d17;
    undefined4 local_20;
    undefined4 uStack_1c;
    undefined4 local_14;

    local_14 = 0;
    local_20 = 0;
    uStack_1c = 0;
    (**(code **)(param_1 + 0x88))(param_1, &local_20);
    dVar1 = (double)CONCAT44(uStack_1c, local_20);
    uVar2 =
        VectorShiftLeft(1,
                        in_d17 & 0xffffffffffff0000 |
                            (ulonglong) * (uint *)(param_1 + 0x1b0) & 0xffff,
                        8, 1);
    dVar3 = (double)FUN_000ccad4((int)uVar2, (int)((ulonglong)uVar2 >> 0x20));
    *param_2 = (float)(((dVar1 / dVar3) / 110.0) * 0.1);
    return local_14;
}

undefined4 set_sensor_extern_mode_ltc(int param_1)

{
    int iVar1;

    iVar1 = FUN_0007e0a4(param_1);
    if (iVar1 == 0) {
        *(undefined4 *)(param_1 + 0x200) = 1;
    }
    return 0;
}

undefined4
read_sensor_temp_local_ltc(int param_1, undefined4 param_2, undefined4 param_3,
                           undefined4 param_4, undefined4 param_5, int param_6,
                           undefined4 param_7, undefined4 param_8, int param_9)

{
    undefined4 uVar1;
    undefined4 local_14;

    local_14 = -1;
    if (param_6 == 0) {
        local_14 = FUN_0007d738(param_1, param_2, param_3, param_9);
    } else if (param_6 == 1) {
        local_14 =
            FUN_0007d5a8(param_1, param_2, param_3,
                         *(undefined1 *)(*(int *)(param_1 + 0x1ec) + param_9));
    } else if (param_6 == 2) {
        local_14 = FUN_0007dc08(param_1, param_2, param_3, param_9);
    }
    if (local_14 == -1) {
        uVar1 = 4;
    } else {
        uVar1 = 0;
    }
    return uVar1;
}

undefined4
read_sensor_temp_remote_ltc(int param_1, undefined4 param_2, undefined4 param_3,
                            undefined4 param_4, undefined4 param_5, int param_6,
                            undefined4 param_7, undefined4 param_8, int param_9)

{
    undefined4 uVar1;
    undefined4 local_14;

    local_14 = -1;
    if (param_6 == 0) {
        local_14 = FUN_0007d9a0(param_1, param_2, param_3, param_9);
    } else if (param_6 == 1) {
        local_14 =
            FUN_0007d670(param_1, param_2, param_3,
                         *(undefined1 *)(*(int *)(param_1 + 0x1ec) + param_9));
    } else if (param_6 == 2) {
        local_14 = FUN_0007df0c(param_1, param_2, param_3, param_9);
    }
    if (local_14 == -1) {
        uVar1 = 4;
    } else {
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 parameter_update_ltc(int param_1, char param_2, int param_3,
                                char param_4, int param_5)

{
    if (*(char *)(param_1 + 0x100) != '\x01') {
        if (((param_2 != '\0') && (899 < param_3)) && (param_3 < 0x5dd)) {
            *(float *)(param_1 + 0x450) = (float)(longlong)param_3;
        }
        if (((param_4 != '\0') && (0x527 < param_5)) && (param_5 < 0x5dd)) {
            *(int *)(param_1 + 0x454) = param_5;
        }
    }
    return 0;
}

undefined4 overclock_update_ltc(void)

{
    return 0;
}

undefined4 get_pcba_test_level_ltc(void)

{
    return 0;
}

int get_packet_remain_len_ltc(int param_1)

{
    undefined4 local_c;

    local_c = *(byte *)(param_1 + 2) - 1;
    if (8 < local_c) {
        local_c = 8;
    }
    return local_c;
}

undefined4 adjust_working_freq_ltc(int param_1, int param_2)

{
    float local_10;
    undefined4 local_c;

    local_c = 0x6c;
    local_10 = (float)(longlong)(*(int *)(param_1 + 0x1d0) + param_2);
    if (local_10 < *(float *)(param_1 + 0x450)) {
        if (local_10 < 900.0) {
            return 0x6c;
        }
    } else {
        local_10 = *(float *)(param_1 + 0x450);
        local_c = 0;
    }
    chip_setting_freq_ltc(local_10, param_1, 1, 0, 0);
    *(int *)(param_1 + 0x1d0) = (int)local_10;
    return local_c;
}

undefined4 chip_temp_ltc_1491(int param_1, int param_2)

{
    undefined1 auStack_305c[4096];
    uint local_205c;
    undefined4 local_2058;
    char acStack_2054[4096];
    char acStack_1054[4096];
    int local_54;
    undefined4 local_50[2];
    undefined1 local_48;
    undefined1 local_47;
    undefined2 local_46;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    void *local_20;
    undefined4 local_1c;
    float local_18;
    int local_14;

    local_54 = 0;
    memset(acStack_1054, 0, 0x1000);
    memset(acStack_2054, 0, 0x1000);
    local_18 = 0.0;
    local_2058 = 0x11000000;
    memset(local_50, 0, 0x10);
    local_48 = 1;
    local_47 = 0;
    local_46 = 0x8c;
    local_50[0] = local_2058;
    local_1c = (**(code **)(param_1 + 0x10c))(param_1, local_50);
    usleep(10000);
    local_2058 = 0x11020000;
    memset(local_50, 0, 0x10);
    local_48 = 1;
    local_47 = 0;
    local_46 = 0x8c;
    local_50[0] = local_2058;
    local_1c = (**(code **)(param_1 + 0x10c))(param_1, local_50);
    usleep(10000);
    memset(local_50, 0, 0x10);
    local_48 = 1;
    local_47 = 0;
    local_46 = 0x90;
    local_20 = malloc(*(int *)(param_1 + 0x150) * 0xc);
    memset(local_20, 0, *(int *)(param_1 + 0x150) * 0xc);
    (**(code **)(param_1 + 0x120))(param_1, local_50,
                                   *(undefined4 *)(param_1 + 0x150), local_20,
                                   &local_54);
    local_14 = 0;
    while (true) {
        if (local_54 <= local_14) {
            printf("line:\n%s\n", acStack_1054);
            free(local_20);
            return 0;
        }
        if ((*(short *)((int)local_20 + local_14 * 0xc + 6) != 0x90) ||
            ((*(uint *)((int)local_20 + local_14 * 0xc) & 0x80) == 0))
            break;
        V_LOCK();
        FUN_00077ce8(&local_40, &local_40, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_305c, 0x1000, 0, uStack_24, local_40, uStack_3c,
                   uStack_38, uStack_34, local_30, uStack_2c, uStack_28,
                   uStack_24, "[MISC CTRL] asic %02x, reg %02x state %08x",
                   *(undefined1 *)((int)local_20 + local_14 * 0xc + 4),
                   *(undefined2 *)((int)local_20 + local_14 * 0xc + 6),
                   *(undefined4 *)((int)local_20 + local_14 * 0xc));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "backend_ltc_1491.c",
             0xb5, "chip_temp_ltc_1491", 0x12, 0x47d, 0x14, auStack_305c);
        local_205c = 0;
        FUN_00078038(&local_205c,
                     *(undefined4 *)((int)local_20 + local_14 * 0xc));
        local_18 =
            (float)((((double)(local_205c & 0xffff) - 0.5) * 662.88) / 4096.0 -
                    287.48);
        *(float *)(param_2 +
                   (uint)(*(byte *)((int)local_20 + local_14 * 0xc + 4) >> 1) *
                       4) = local_18;
        sprintf(acStack_2054, "%.1f ", SUB84((double)local_18, 0),
                (int)((ulonglong)(double)local_18 >> 0x20));
        strcat(acStack_1054, acStack_2054);
        local_14 = local_14 + 1;
    }
    free(local_20);
    return 0x132;
}

undefined4 send_fake_work_ltc(int param_1)

{
    int iVar1;
    uint uVar2;
    undefined1 auStack_68[88];
    uint local_10;
    int local_c;

    local_c = 3;
    memcpy(auStack_68, &DAT_001244ac, 0x56);
    local_10 = 0x56;
    printf("send %d triger work\n", local_c);
    while (local_c != 0) {
        local_c = local_c + -1;
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x430));
        do {
            iVar1 = dev_ctrl();
            uVar2 =
                (**(code **)(iVar1 + 0x44))(*(undefined4 *)(param_1 + 0xf8));
        } while (uVar2 < local_10);
        iVar1 = dev_ctrl();
        (**(code **)(iVar1 + 0x34))(*(undefined4 *)(param_1 + 0xf8), auStack_68,
                                    local_10);
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x430));
        usleep(10000);
    }
    return 0;
}

void *runtime_ctrl_ltc_1491(void)

{
    code *local_590;
    code *local_58c;
    code *local_580;
    code *local_57c;
    code *local_578;
    code *local_574;
    code *local_570;
    code *local_56c;
    code *local_568;
    code *local_564;
    code *local_560;
    code *local_554;
    code *local_550;
    code *local_54c;
    code *local_548;
    code *local_544;
    code *local_540;
    code *local_53c;
    code *local_538;
    undefined1 *local_534;
    code *local_530;
    code *local_52c;
    code *local_528;
    undefined1 *local_524;
    undefined1 *local_51c;
    undefined1 *local_518;
    code *local_50c;
    code *local_508;
    code *local_504;
    code *local_500;
    code *local_4fc;
    code *local_4f8;
    code *local_4f4;
    code *local_4f0;
    code *local_4ec;
    code *local_4e8;
    code *local_4e4;
    code *local_4e0;
    code *local_4d4;
    code *local_4d0;
    code *local_4cc;
    undefined1 *local_4c8;
    undefined1 *local_4c4;
    code *local_4c0;
    code *local_4bc;
    code *local_4b4;
    code *local_4ac;
    code *local_4a8;
    code *local_4a0;
    code *local_49c;
    code *local_48c;
    code *local_488;
    code *local_484;
    code *local_480;
    code *local_47c;
    code *local_478;
    code *local_474;
    code *local_470;
    code *local_464;
    undefined4 local_460;
    undefined4 local_45c;
    undefined4 uStack_458;
    undefined4 uStack_454;
    undefined4 local_450;
    undefined1 local_44c;
    undefined2 local_44b;
    undefined1 local_449;
    undefined4 local_448;
    undefined4 local_444;
    undefined4 local_440;
    undefined4 local_43c;
    undefined4 local_438;
    undefined4 local_434;
    undefined4 local_42c;
    undefined4 local_41c;
    undefined4 uStack_418;
    undefined4 uStack_40c;
    undefined4 uStack_408;
    undefined4 uStack_404;
    undefined4 uStack_400;
    undefined4 local_3fc;
    undefined4 uStack_3f8;
    undefined4 uStack_3f4;
    undefined4 local_3e4;
    undefined4 local_3e0;
    undefined4 local_3c0;
    undefined4 local_384;
    undefined4 local_254;
    undefined4 local_250;
    undefined4 local_24c;
    undefined4 local_248;
    undefined4 local_244;
    undefined4 local_240;
    undefined4 local_23c;
    undefined4 local_144;
    undefined4 local_140;
    undefined4 local_13c;
    undefined4 local_130;
    undefined4 uStack_12c;
    undefined4 local_128;
    void *local_c;

    memset(&local_590, 0, 0x510);
    local_590 = backend_init_base;
    local_58c = reset_base;
    local_580 = dhash_mining_start_base;
    local_57c = dhash_mining_stop_base;
    local_578 = dhash_mining_reset_base;
    local_574 = backend_exit_base;
    local_570 = push_work_base;
    local_56c = send_fake_work_ltc;
    local_568 = async_push_work_base;
    local_564 = pop_ans_base;
    local_560 = try_pop_ans_base;
    local_554 = softreset_all_chip_ltc;
    local_550 = setup_all_chip_ltc;
    local_54c = work_2_packet_ltc;
    local_548 = packet_2_nonce_ltc;
    local_544 = check_nonce_ltc;
    local_540 = global_idx_init_ltc;
    local_53c = global_idx_free_ltc;
    local_538 = set_baud_ltc;
    local_534 = &LAB_000830dc;
    local_530 = FUN_00083104;
    local_52c = FUN_00083350;
    local_528 = FUN_00083394;
    local_524 = &LAB_0008341c;
    local_51c = &LAB_00083a30;
    local_518 = &LAB_00083a04;
    local_50c = get_chip_status_ltc;
    local_508 = get_theory_hashrate_ltc;
    local_504 = get_sale_hashrate_ltc;
    local_500 = get_qualify_hashrate_ltc;
    local_4fc = get_qualify_nonce_num_ltc;
    local_4f8 = set_sensor_extern_mode_ltc;
    local_4f4 = read_sensor_temp_local_ltc;
    local_4f0 = read_sensor_temp_remote_ltc;
    local_4ec = parameter_update_ltc;
    local_4e8 = overclock_update_ltc;
    local_4e4 = get_pcba_test_level_ltc;
    local_4e0 = get_packet_remain_len_ltc;
    local_4d4 = adjust_working_freq_ltc;
    local_4d0 = FUN_00083148;
    local_4cc = set_frequency_by_temp_single_base;
    local_4c8 = &LAB_000832f8;
    local_4c4 = &LAB_00083320;
    local_4c0 = get_chip_temperature_str_ltc;
    local_4bc = set_frequency_single_base;
    local_4b4 = FUN_000818d8;
    local_4ac = FUN_0008292c;
    local_4a8 = top_init_ltc;
    local_4a0 = dhash_start_ltc;
    local_49c = chip_temp_ltc_1491;
    local_48c = set_chipaddr_base;
    local_488 = set_inactive_base;
    local_484 = set_chip_reg_ltc;
    local_480 = set_core_reg_ltc;
    local_47c = set_core_reg_ltc;
    local_478 = set_core_enable_ltc;
    local_474 = sync_get_status_ltc;
    local_470 = sync_get_chip_reg_ltc;
    local_464 = sync_get_core_reg_ltc;
    local_460 = 0x394c;
    local_45c = 0;
    uStack_458 = 0;
    uStack_454 = 0;
    local_450 = 0x31393431;
    local_44c = 0;
    local_44b = 0;
    local_449 = 0;
    local_448 = 0x1491;
    local_444 = 1;
    local_440 = 0x6e;
    local_43c = 0x88;
    local_438 = 0x800;
    local_434 = 0x10;
    local_42c = 2;
    local_41c = DAT_0014fffc;
    uStack_418 = DAT_00150000;
    uStack_40c = sensor_info_ltc_1491._0_4_;
    uStack_408 = sensor_info_ltc_1491._4_4_;
    uStack_404 = sensor_info_ltc_1491._8_4_;
    uStack_400 = sensor_info_ltc_1491._12_4_;
    local_3fc = sensor_info_ltc_1491._16_4_;
    uStack_3f8 = sensor_info_ltc_1491._20_4_;
    uStack_3f4 = sensor_info_ltc_1491._24_4_;
    local_3e4 = 2;
    local_3e0 = 0x1c;
    local_3c0 = 900;
    local_384 = 2;
    local_254 = 0xd8;
    local_250 = 0x70;
    local_24c = 4;
    local_248 = 0x56;
    local_244 = 10;
    local_240 = 8;
    local_23c = 3;
    local_144 = 0x44610000;
    local_140 = 0x44960000;
    local_13c = 0x578;
    local_130 = 0x27069;
    uStack_12c = 0;
    local_128 = 1;
    local_c = calloc(1, 0x510);
    memcpy(local_c, &local_590, 0x510);
    return local_c;
}

undefined4 set_chip_reg_ltc(int param_1, undefined4 *param_2)

{
    byte bVar1;
    undefined4 uVar2;
    undefined1 local_14;
    undefined1 uStack_13;
    byte bStack_12;
    byte bStack_11;
    undefined1 uStack_10;
    undefined1 uStack_f;
    undefined2 uStack_e;
    undefined2 uStack_c;
    byte local_a;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        uStack_e = 0;
        uStack_c = 0;
        local_a = 0;
        local_14 = 0x55;
        uStack_13 = 0xaa;
        bStack_12 = (*(byte *)(param_2 + 2) & 1) << 4 | 0x41;
        bStack_11 = 9;
        uStack_10 = *(undefined1 *)((int)param_2 + 9);
        uStack_f = (undefined1) * (undefined2 *)((int)param_2 + 10);
        uVar2 = reverse_byte_order_32(*param_2);
        uStack_e = (undefined2)uVar2;
        uStack_c = (undefined2)((uint)uVar2 >> 0x10);
        bVar1 = BM_CRC5(&bStack_12, (bStack_11 - 1) * 8);
        local_a = local_a & 0xe0 | bVar1 & 0x1f;
        send_command_packet(param_1, &local_14, 0xb);
        uVar2 = 0;
    } else {
        uVar2 = 4;
    }
    return uVar2;
}

undefined4 sync_get_status_unclear_ltc(int param_1, int param_2, int param_3,
                                       int *param_4, undefined4 param_5,
                                       undefined4 param_6)

{
    int iVar1;
    uint uVar2;
    int extraout_r2;
    uint uVar3;
    undefined4 local_2c;
    int local_28;
    char local_24;
    char local_23;
    undefined4 local_22;
    undefined1 local_1e;
    byte local_1d;
    byte local_1c;
    undefined4 local_18;
    int local_14;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        local_14 = 0;
        local_18 = 0;
        FUN_000ccdfc(param_5, param_6, 1000, 0);
        local_28 = extraout_r2 * 1000000;
        local_2c = FUN_000ccdfc(param_5, param_6, 1000, 0);
        while (local_14 < param_2) {
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_24, 9, &local_2c);
            if (iVar1 == 0x6e) {
                local_18 = 3;
                break;
            }
            if (((local_24 != -0x56) || (local_23 != 'U')) ||
                ((local_1c & 0x80) != 0)) {
                local_18 = 1;
                break;
            }
            uVar3 = (uint)local_1c;
            uVar2 = BM_CRC5(&local_22, 0x33);
            if ((uVar3 & 0x1f) == uVar2) {
                *(undefined1 *)(param_3 + local_14 * 0xc + 4) = local_1e;
                *(ushort *)(param_3 + local_14 * 0xc + 6) = (ushort)local_1d;
                *(undefined4 *)(param_3 + local_14 * 0xc) = local_22;
                *(byte *)(param_3 + local_14 * 0xc + 9) =
                    (byte)(((uint)local_1c << 0x19) >> 0x1e);
                local_14 = local_14 + 1;
            } else {
                local_18 = 2;
            }
        }
        *param_4 = local_14;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_18 = 4;
    }
    return local_18;
}

undefined4 sync_get_status_ltc(int param_1, int param_2, int param_3,
                               int *param_4, undefined4 param_5,
                               undefined4 param_6)

{
    int iVar1;
    uint uVar2;
    int extraout_r2;
    uint uVar3;
    undefined4 local_2c;
    int local_28;
    char local_24;
    char local_23;
    undefined1 uStack_22;
    undefined4 local_21;
    undefined1 local_1d;
    byte local_1c;
    byte local_1b;
    undefined4 local_18;
    int local_14;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        queue_clear(*(undefined4 *)(param_1 + 0x364));
        local_14 = 0;
        local_18 = 0;
        FUN_000ccdfc(param_5, param_6, 1000, 0);
        local_28 = extraout_r2 * 1000000;
        local_2c = FUN_000ccdfc(param_5, param_6, 1000, 0);
        while (local_14 < param_2) {
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_24, 10, &local_2c);
            if (iVar1 == 0x6e) {
                local_18 = 3;
                break;
            }
            if ((((local_24 != -0x56) || (local_23 != 'U')) ||
                 ((local_1b & 0x40) != 0)) ||
                ((local_1b & 0x80) != 0)) {
                local_18 = 1;
                break;
            }
            uVar3 = (uint)local_1b;
            uVar2 = BM_CRC5(&uStack_22, 0x3b);
            if ((uVar3 & 0x1f) == uVar2) {
                *(undefined1 *)(param_3 + local_14 * 0xc + 4) = local_1d;
                *(ushort *)(param_3 + local_14 * 0xc + 6) = (ushort)local_1c;
                *(undefined4 *)(param_3 + local_14 * 0xc) = local_21;
                local_14 = local_14 + 1;
            } else {
                local_18 = 2;
            }
        }
        *param_4 = local_14;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_18 = 4;
    }
    return local_18;
}

undefined4 sync_get_chip_reg_ltc(int param_1, int param_2, int param_3,
                                 int param_4, int *param_5, undefined4 param_6,
                                 undefined4 param_7, undefined4 param_8)

{
    byte bVar1;
    int iVar2;
    uint uVar3;
    int extraout_r2;
    uint uVar4;
    int local_44;
    undefined4 local_34;
    int local_30;
    char local_2c;
    char local_2b;
    undefined1 uStack_2a;
    undefined4 local_29;
    undefined1 local_25;
    byte local_24;
    byte local_23;
    undefined1 local_20;
    undefined1 uStack_1f;
    byte abStack_1e[3];
    undefined1 local_1b;
    byte local_1a;
    undefined4 local_18;
    int local_14;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        local_1a = 0;
        local_20 = 0x55;
        uStack_1f = 0xaa;
        abStack_1e[0] = (*(byte *)(param_2 + 8) & 1) << 4 | 0x42;
        abStack_1e[1] = 5;
        abStack_1e[2] = *(undefined1 *)(param_2 + 9);
        local_1b = (undefined1) * (undefined2 *)(param_2 + 10);
        bVar1 = BM_CRC5(abStack_1e, 0x20);
        local_1a = local_1a & 0xe0 | bVar1 & 0x1f;
        local_44 = param_3;
        if (*(char *)(param_2 + 8) != '\x01') {
            local_44 = 1;
        }
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        queue_clear(*(undefined4 *)(param_1 + 0x364));
        send_command_packet(param_1, &local_20, 7);
        local_14 = 0;
        local_18 = 0;
        FUN_000ccdfc(param_7, param_8, 1000, 0);
        local_30 = extraout_r2 * 1000000;
        local_34 = FUN_000ccdfc(param_7, param_8, 1000, 0);
        while (local_14 < local_44) {
            iVar2 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_2c, 10, &local_34);
            if (iVar2 == 0x6e) {
                local_18 = 3;
                break;
            }
            if ((((local_2c != -0x56) || (local_2b != 'U')) ||
                 ((local_23 & 0x40) != 0)) ||
                ((local_23 & 0x80) != 0)) {
                local_18 = 1;
                break;
            }
            uVar4 = (uint)local_23;
            uVar3 = BM_CRC5(&uStack_2a, 0x3b);
            if ((uVar4 & 0x1f) == uVar3) {
                *(undefined1 *)(param_4 + local_14 * 0xc + 4) = local_25;
                *(ushort *)(param_4 + local_14 * 0xc + 6) = (ushort)local_24;
                *(undefined4 *)(param_4 + local_14 * 0xc) = local_29;
                local_14 = local_14 + 1;
            } else {
                local_18 = 2;
            }
        }
        *param_5 = local_14;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_18 = 4;
    }
    return local_18;
}

undefined4 set_core_reg_ltc(int param_1, undefined4 *param_2)

{
    byte bVar1;
    undefined4 uVar2;
    undefined1 local_14;
    undefined1 uStack_13;
    byte abStack_12[3];
    byte bStack_f;
    undefined1 uStack_e;
    undefined1 uStack_d;
    undefined1 local_c;
    undefined1 local_b;
    byte local_a;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        chip_setting_core_command_ltc(param_1,
                                      *(undefined1 *)((int)param_2 + 0xd));
        local_a = 0;
        local_14 = 0x55;
        uStack_13 = 0xaa;
        abStack_12[0] = (*(byte *)(param_2 + 2) & 1) << 4 | 0x44;
        abStack_12[1] = 9;
        abStack_12[2] = *(undefined1 *)((int)param_2 + 9);
        bStack_f = (byte) * (undefined2 *)((int)param_2 + 10) & 0xf;
        uStack_e = *(undefined1 *)(param_2 + 3);
        local_c = (undefined1)((uint)*param_2 >> 8);
        uStack_d = (undefined1)((uint)*param_2 >> 0x10);
        local_b = (undefined1)*param_2;
        bVar1 = BM_CRC5(abStack_12, 0x40);
        local_a = local_a & 0xe0 | bVar1 & 0x1f;
        send_command_packet(param_1, &local_14, 0xb);
        uVar2 = 0;
    } else {
        uVar2 = 4;
    }
    return uVar2;
}

undefined4 sync_get_core_reg_ltc(int param_1, int param_2, uint param_3,
                                 int param_4, int *param_5, undefined4 param_6,
                                 undefined4 param_7, undefined4 param_8)

{
    undefined7 uVar1;
    ulonglong uVar2;
    byte bVar3;
    int iVar4;
    uint uVar5;
    int extraout_r2;
    uint uVar6;
    uint local_1044;
    undefined1 auStack_1034[4096];
    undefined4 local_34;
    int local_30;
    char local_2c;
    char local_2b;
    undefined1 uStack_2a;
    undefined1 local_29;
    byte local_28;
    byte local_27;
    byte local_26;
    byte local_25;
    undefined1 local_24;
    byte local_23;
    byte local_22;
    undefined8 local_20;
    undefined4 local_18;
    int local_14;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        chip_setting_core_command_ltc(param_1, *(undefined1 *)(param_2 + 0xd));
        local_20._0_3_ =
            CONCAT12((*(byte *)(param_2 + 8) & 1) << 4 | 5, 0xaa55);
        local_20._0_3_ = (uint3)local_20 | 0x400000;
        local_20._0_5_ = CONCAT14(*(undefined1 *)(param_2 + 9),
                                  CONCAT13(6, (uint3)local_20));
        local_20 = (ulonglong)CONCAT15((char)*(undefined2 *)(param_2 + 10),
                                       (undefined5)local_20) &
                   0xffff0fffffffffff;
        uVar2 = local_20;
        local_20._0_7_ =
            CONCAT16(*(undefined1 *)(param_2 + 0xc), (undefined6)local_20);
        uVar1 = (undefined7)local_20;
        local_20._3_1_ = SUB81(uVar2, 3);
        uVar5 = (uint)local_20._3_1_;
        local_20._0_7_ = uVar1;
        local_20._7_1_ = 0;
        bVar3 = BM_CRC5((int)&local_20 + 2, (uVar5 - 1) * 8);
        local_20 = CONCAT17(local_20._7_1_ & 0xe0 | bVar3 & 0x1f,
                            (undefined7)local_20);
        local_1044 = param_3;
        if (*(char *)(param_2 + 8) != '\x01') {
            local_1044 = (uint) * (byte *)(param_2 + 0xd);
        }
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        queue_clear(*(undefined4 *)(param_1 + 0x364));
        send_command_packet(param_1, &local_20, 8);
        local_14 = 0;
        local_18 = 0;
        FUN_000ccdfc(param_7, param_8, 1000, 0);
        local_30 = extraout_r2 * 1000000;
        local_34 = FUN_000ccdfc(param_7, param_8, 1000, 0);
        while (local_14 < (int)local_1044) {
            iVar4 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_2c, 0xb, &local_34);
            if (iVar4 == 0x6e) {
                local_18 = 3;
                break;
            }
            V_LOCK();
            logfmt_raw(auStack_1034, 0x1000, 0,
                       "get core reg: chip addr %02x core id %02x reg addr "
                       "%02x reg value %02x%02x%02x%02x",
                       local_24, local_29, local_23, local_28, local_27,
                       local_26, local_25);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "backend_ltc_1491/chip_reg_io_ltc_1491.c",
                 0xb9, "sync_get_core_reg_ltc", 0x15, 0x17d, 0x14,
                 auStack_1034);
            if ((((local_2c != -0x56) || (local_2b != 'U')) ||
                 ((local_22 & 0x40) == 0)) ||
                ((local_22 & 0x80) != 0)) {
                local_18 = 1;
                break;
            }
            uVar6 = (uint)local_22;
            uVar5 = BM_CRC5(&uStack_2a, 0x43);
            if ((uVar6 & 0x1f) == uVar5) {
                *(undefined1 *)(param_4 + local_14 * 0xc + 4) = local_24;
                *(ushort *)(param_4 + local_14 * 0xc + 6) = (ushort)local_23;
                *(undefined1 *)(param_4 + local_14 * 0xc + 8) = local_29;
                *(uint *)(param_4 + local_14 * 0xc) =
                    (uint)local_28 << 0x18 | (uint)local_27 << 0x10 |
                    (uint)local_26 << 8 | (uint)local_25;
                local_14 = local_14 + 1;
            } else {
                local_18 = 2;
            }
        }
        *param_5 = local_14;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_18 = 4;
    }
    return local_18;
}

int set_core_enable_ltc(int param_1, undefined4 *param_2, __useconds_t param_3)

{
    undefined1 auStack_1010[4096];
    int local_10;
    int local_c;

    local_c = 0;
    while (true) {
        if ((int)(uint) * (byte *)((int)param_2 + 0xd) <= local_c) {
            return 0;
        }
        *param_2 = 0x84ff;
        *(undefined2 *)((int)param_2 + 10) = 0;
        *(char *)(param_2 + 3) = (char)local_c;
        *(undefined1 *)((int)param_2 + 0xe) = 0;
        *(undefined1 *)((int)param_2 + 0xf) = 0;
        local_10 = (**(code **)(param_1 + 0x114))(param_1, param_2);
        if (local_10 != 0)
            break;
        usleep(param_3);
        local_c = local_c + 1;
    }
    V_LOCK();
    logfmt_raw(auStack_1010, 0x1000, 0, "%s failed, reg:%02x, core_id:%d",
               "set_core_enable_ltc", *(undefined2 *)((int)param_2 + 10),
               local_c);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/chip_reg_io_ltc_1491.c",
        0xb9, "set_core_enable_ltc", 0x13, 0x1a9, 100, auStack_1010);
    return local_10;
}

undefined4 FUN_00086850(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "chain", param_3, param_4);
    return param_1;
}

void FUN_00086884(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_00086a10(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

void FUN_00086ba0(undefined1 *param_1, undefined4 param_2)

{
    param_1[3] = (char)param_2;
    param_1[2] = (char)((uint)param_2 >> 8);
    param_1[1] = (char)((uint)param_2 >> 0x10);
    *param_1 = (char)((uint)param_2 >> 0x18);
    return;
}

undefined4 chip_setting_buadrate_ltc(int param_1, word *param_2)

{
    undefined4 uVar1;
    uint local_20[2];
    undefined1 local_18;
    undefined1 local_17;
    undefined2 local_16;
    uint local_10;
    byte local_c;
    byte local_b;
    ushort local_a;

    local_10 = 0;
    local_a = 0x1a;
    local_b = 0;
    local_c = 0;
    memset(local_20, 0, 0x10);
    local_18 = 1;
    local_17 = 0;
    local_16 = 0x60;
    if (param_2 == (word *)&UNK_000e1000) {
    LAB_00086dd4:
        local_a = 2;
    } else {
        if ((int)param_2 < 0xe1001) {
            if (param_2 != &WORD_0001c200) {
                if ((int)param_2 < 0x1c201) {
                    if (param_2 != (word *)0x2580) {
                        if (param_2 == (word *)0x9600) {
                            local_a = 0x50;
                            goto LAB_00086e1c;
                        }
                        if (param_2 != (word *)0x2572)
                            goto LAB_00086e10;
                    }
                    local_a = 0x145;
                    goto LAB_00086e1c;
                }
                if ((param_2 == (word *)0x6cfdd) ||
                    (param_2 == (word *)0x70800)) {
                    local_a = 6;
                    goto LAB_00086e1c;
                }
                if (param_2 != &WORD_0001c41c)
                    goto LAB_00086e10;
            }
            local_a = 0x1a;
            goto LAB_00086e1c;
        }
        if (param_2 != (word *)0x2dc6c0) {
            if ((int)param_2 < 0x2dc6c1) {
                if ((param_2 == (word *)0x16e360) ||
                    (param_2 == (word *)0x17d784)) {
                    local_a = 1;
                    goto LAB_00086e1c;
                }
                if (param_2 != (word *)&UNK_000fe502) {
                LAB_00086e10:
                    local_a = 0x1a;
                    goto LAB_00086e1c;
                }
                goto LAB_00086dd4;
            }
            if (param_2 == (word *)0x5f5e10) {
                local_a = 1;
                local_b = 1;
                goto LAB_00086e1c;
            }
            if (param_2 == (word *)0xbebc20) {
                local_a = 0;
                local_b = 1;
                goto LAB_00086e1c;
            }
            if (param_2 != (word *)0x2faf08)
                goto LAB_00086e10;
        }
        local_a = 0;
    }
LAB_00086e1c:
    if (local_b != 0) {
        chip_setting_freq_ltc(0x42c80000, param_1, 1, 0, 1);
    }
    local_20[0] = (local_a & 0x1ff) << 8 | (local_c & 3) << 4 | local_b & 1;
    local_10 = local_20[0];
    uVar1 = (**(code **)(param_1 + 0x10c))(param_1, local_20);
    return uVar1;
}

undefined4 chip_setting_software_reset_ltc(int param_1)

{
    undefined1 auStack_1024[4096];
    undefined4 local_24[2];
    undefined1 local_1c;
    undefined1 local_1b;
    undefined2 local_1a;
    undefined4 local_14;
    undefined4 local_10;
    void *local_c;

    local_c = calloc(0x100, 0xc);
    local_10 = 0;
    V_LOCK();
    logfmt_raw(auStack_1024, 0x1000, 0, "software_reset %s %02x",
               "chip_setting_software_reset_ltc", 0x44);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/chip_setting_ltc_1491.c",
        0xba, "chip_setting_software_reset_ltc", 0x1f, 0x8b, 0x14,
        auStack_1024);
    memset(local_24, 0, 0x10);
    local_1c = 1;
    local_1b = 0;
    local_1a = 0x44;
    local_24[0] = 3;
    local_14 = (**(code **)(param_1 + 0x10c))(param_1, local_24);
    usleep(10000);
    free(local_c);
    return local_14;
}

undefined4 chip_setting_software_bridge_or_core_reset_ltc(int param_1,
                                                          int param_2,
                                                          uint param_3)

{
    undefined4 uVar1;
    undefined1 auStack_101c[4096];
    uint local_1c[2];
    undefined1 local_14;
    undefined1 local_13;
    undefined2 local_12;

    V_LOCK();
    logfmt_raw(auStack_101c, 0x1000, 0, "software_reset %s %02x",
               "chip_setting_software_bridge_or_core_reset_ltc", 0x44);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/chip_setting_ltc_1491.c",
        0xba, "chip_setting_software_bridge_or_core_reset_ltc", 0x2e, 0x9e,
        0x14, auStack_101c);
    memset(local_1c, 0, 0x10);
    local_14 = 1;
    local_13 = 0;
    local_12 = 0x44;
    local_1c[0] = param_2 << 1 | param_3;
    uVar1 = (**(code **)(param_1 + 0x10c))(param_1, local_1c);
    return uVar1;
}

undefined4 chip_setting_misc_ltc(int param_1, int param_2, int param_3,
                                 int param_4, int param_5)

{
    undefined4 uVar1;
    undefined1 auStack_1020[4096];
    uint local_20[2];
    undefined1 local_18;
    undefined1 local_17;
    undefined2 local_16;
    uint local_10;

    local_10 = 0;
    memset(local_20, 0, 0x10);
    local_18 = 1;
    local_17 = 0;
    local_16 = 0x1c;
    local_20[0] = param_2 << 0x16 | param_3 << 0x15 | param_4 << 0x14 |
                  param_5 << 2 | 0xc1021f10;
    local_10 = local_20[0];
    V_LOCK();
    logfmt_raw(auStack_1020, 0x1000, 0, "set_misc value %08x", local_20[0]);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/chip_setting_ltc_1491.c",
        0xba, "chip_setting_misc_ltc", 0x15, 0xb8, 0x14, auStack_1020);
    uVar1 = (**(code **)(param_1 + 0x10c))(param_1, local_20);
    return uVar1;
}

undefined4 chip_setting_core_command_ltc(int param_1, uint param_2)

{
    undefined4 uVar1;
    uint local_1028;
    undefined1 auStack_101c[4096];
    uint local_1c[2];
    undefined1 local_14;
    undefined1 local_13;
    undefined2 local_12;

    local_1028 = param_2;
    if (*(int *)(param_1 + 0x154) <= (int)param_2) {
        local_1028 = *(uint *)(param_1 + 0x154);
    }
    if ((int)local_1028 < 1) {
        uVar1 = 1;
    } else {
        V_LOCK();
        logfmt_raw(auStack_101c, 0x1000, 0, "core_command %s %02x",
                   "chip_setting_core_command_ltc", 0x94);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "chip_setting_ltc_1491.c",
             0xba, "chip_setting_core_command_ltc", 0x1d, 200, 0x14,
             auStack_101c);
        memset(local_1c, 0, 0x10);
        local_14 = 1;
        local_13 = 0;
        local_12 = 0x94;
        local_1c[0] = local_1028 & 0xff | 0x80000000;
        uVar1 = (**(code **)(param_1 + 0x10c))(param_1, local_1c);
    }
    return uVar1;
}

float FUN_0008744c(float param_1, uint *param_2)

{
    undefined4 uVar1;
    int iVar2;
    undefined1 auStack_102c[4096];
    float fStack_2c;
    uint local_28;
    float fStack_24;
    float local_20;
    uint local_1c;
    uint local_18;
    uint local_14;
    uint local_10;
    float local_c;

    *param_2 = 0xc0480110;
    local_10 = 2;
    do {
        if ((int)local_10 < 1) {
            return 0.0;
        }
        for (local_18 = 0; (int)local_18 < 8; local_18 = local_18 + 1) {
            for (local_1c = local_18; local_c = 0.0, -1 < (int)local_1c;
                 local_1c = local_1c - 1) {
                fStack_24 = (((float)(longlong)(int)(local_18 + 1) * param_1 *
                              (float)(longlong)(int)(local_1c + 1) *
                              (float)(longlong)(int)local_10) /
                             25.0) *
                            100.0;
                if ((int)fStack_24 % 100 < 0x33) {
                    local_14 = (int)fStack_24 / 100;
                } else {
                    local_14 = (int)fStack_24 / 100 + 1;
                }
                local_20 = ((float)(longlong)(int)local_14 * 25.0) /
                           (float)(longlong)(int)local_10;
                if (((((int)local_14 < 0x42b) && (7 < (int)local_14)) &&
                     ((local_10 != 1 || (local_20 <= 13325.0)))) &&
                    ((local_20 <= 3200.0 && (1600.0 <= local_20)))) {
                    local_28 = (uint)(2400.0 < local_20);
                    uVar1 = FUN_000cc518(local_14 * 0x19, local_10);
                    uVar1 = FUN_000cc518(uVar1, local_18 + 1);
                    iVar2 = FUN_000cc518(uVar1, local_1c + 1);
                    local_c = (float)(longlong)iVar2;
                    *param_2 = local_28 << 0x1c | (local_14 & 0xfff) << 0x10 |
                               (local_10 & 0x3f) << 8 | (local_18 & 7) << 4 |
                               local_1c & 7 | 0xc0000000;
                    fStack_2c = ABS(local_c - param_1);
                    if (fStack_2c < 3.0) {
                        V_LOCK();
                        logfmt_raw(
                            auStack_102c, 0x1000, 0,
                            "target_freq:%.2f actual_freq:%.2f,vco:%.2f "
                            "fbdiv:%d refdiv:%d postdiv1:%d, postdiv2:%d",
                            (double)param_1, (double)local_c, (double)local_20,
                            local_14, local_10, local_18, local_1c);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/"
                             "backend_ltc_1491/chip_setting_ltc_1491.c",
                             0xba, "inferred_plldivider_ltc", 0x17, 0xf8, 0x14,
                             auStack_102c);
                        return local_c;
                    }
                }
            }
        }
        local_10 = local_10 - 1;
    } while (true);
}

/* WARNING: Type propagation algorithm not settling */

undefined4 chip_setting_freq_ltc(float param_1, int param_2, char param_3,
                                 int param_4, int param_5)

{
    undefined1 auStack_105c[4096];
    uint local_5c[4];
    char local_4c;
    undefined1 local_4b;
    undefined2 local_4a;
    undefined4 local_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    uint *local_20;
    undefined4 local_1c;
    float fStack_18;
    float local_14;

    local_44 = 0;
    local_5c[1] = 0;
    local_14 = 0.0;
    memset(local_5c + 2, 0, 0x10);
    if (param_3 == '\0') {
        local_4b = *(undefined1 *)(*(int *)(param_2 + 0x1ec) + param_4);
    } else {
        local_4b = 0;
    }
    if (param_5 == 0) {
        local_4a = 8;
    } else if (param_5 == 1) {
        local_4a = 0xc;
    }
    local_4c = param_3;
    fStack_18 = (float)FUN_0008744c(param_1, &local_44);
    local_5c[2] = local_44;
    if (param_3 != '\0') {
        V_LOCK();
        logfmt_raw(auStack_105c, 0x1000, 0,
                   "set freq: %.2f, expected freq: %.2f", (double)fStack_18,
                   (double)param_1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "chip_setting_ltc_1491.c",
             0xba, "chip_setting_freq_ltc", 0x15, 0x118, 0x14, auStack_105c);
    }
    local_1c = (**(code **)(param_2 + 0x10c))(param_2, local_5c + 2);
    usleep(10000);
    local_4c = 0;
    local_4b = *(undefined1 *)(*(int *)(param_2 + 0x1ec) + 0x6d);
    local_4a = 0x48;
    local_20 = (uint *)malloc(0xc);
    memset(local_20, 0, 0xc);
    (**(code **)(param_2 + 0x120))(param_2, local_5c + 2, 1, local_20,
                                   local_5c + 1);
    if ((*local_20 & 0x10000) != 0) {
        local_5c[0] = 0;
        FUN_00086ba0(local_5c, *local_20);
        local_14 = (float)((double)((local_5c[0] & 0xffff) * 0x19) / 256.0);
        V_LOCK();
        FUN_00086850(&local_40, &local_40, *(int *)(param_2 + 0xfc),
                     *(int *)(param_2 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_105c, 0x1000, 0, uStack_24, local_40, uStack_3c,
                   uStack_38, uStack_34, local_30, uStack_2c, uStack_28,
                   uStack_24, "get_cnt freq:%f");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "chip_setting_ltc_1491.c",
             0xba, "chip_setting_freq_ltc", 0x15, 300, 0x14, auStack_105c);
    }
    return local_1c;
}

undefined4 sweep_chip_setting_freq_ltc(float param_1, int param_2, char param_3,
                                       int param_4)

{
    undefined1 auStack_1024[4096];
    undefined4 local_24[2];
    char local_1c;
    undefined1 local_1b;
    undefined2 local_1a;
    undefined4 local_14;
    undefined4 local_10;
    float fStack_c;

    local_14 = 0;
    memset(local_24, 0, 0x10);
    if (param_3 == '\0') {
        local_1b = *(undefined1 *)(*(int *)(param_2 + 0x1ec) + param_4);
    } else {
        local_1b = 0;
    }
    local_1a = 8;
    local_1c = param_3;
    fStack_c = (float)FUN_0008744c(param_1, &local_14);
    local_24[0] = local_14;
    if (param_3 != '\0') {
        V_LOCK();
        logfmt_raw(auStack_1024, 0x1000, 0,
                   "set freq: %.2f, expected freq: %.2f", (double)fStack_c,
                   (double)param_1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "chip_setting_ltc_1491.c",
             0xba, "sweep_chip_setting_freq_ltc", 0x1b, 0x140, 0x14,
             auStack_1024);
    }
    local_10 = (**(code **)(param_2 + 0x10c))(param_2, local_24);
    usleep(10000);
    return local_10;
}

undefined4 chip_setting_ticket_mask_ltc(int param_1, uint param_2)

{
    undefined1 auStack_1024[4096];
    uint local_24[2];
    undefined1 local_1c;
    undefined1 local_1b;
    undefined2 local_1a;
    undefined1 local_18;
    undefined1 local_17;
    undefined1 local_16;
    undefined4 local_14;
    uint local_10;
    int local_c;

    local_c = 0;
    local_10 = param_2;
    memset(local_24, 0, 0x10);
    V_LOCK();
    logfmt_raw(auStack_1024, 0x1000, 0, "ticket_mask %s reg %02x tm %08x",
               "chip_setting_ticket_mask_ltc", 2, param_2);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/chip_setting_ltc_1491.c",
        0xba, "chip_setting_ticket_mask_ltc", 0x1c, 0x151, 0x14, auStack_1024);
    local_1c = 1;
    local_1b = 0;
    local_1a = 2;
    local_24[0] = param_2 & 0xffff;
    local_16 = 1;
    local_18 = 0xff;
    local_17 = (undefined1) * (undefined4 *)(param_1 + 0x154);
    local_14 = (**(code **)(param_1 + 0x110))(param_1, local_24);
    usleep(1000);
    local_1c = 1;
    local_1b = 0;
    local_1a = 4;
    local_24[0] = param_2 >> 0x10;
    local_16 = 1;
    local_18 = 0xff;
    local_17 = (undefined1) * (undefined4 *)(param_1 + 0x154);
    local_14 = (**(code **)(param_1 + 0x110))(param_1, local_24);
    for (; (local_10 & 1) != 0; local_10 = local_10 >> 1) {
        local_c = local_c + 1;
    }
    local_c = local_c + 0x10;
    *(int *)(param_1 + 0x1b0) = local_c;
    V_LOCK();
    logfmt_raw(auStack_1024, 0x1000, 0, "cal mask %d", local_c);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/chip_setting_ltc_1491.c",
        0xba, "chip_setting_ticket_mask_ltc", 0x1c, 0x16e, 0x14, auStack_1024);
    return local_14;
}

undefined4 chip_setting_gen_nonce_cnt_ltc(int param_1, uint param_2)

{
    undefined4 uVar1;
    undefined1 auStack_101c[4096];
    uint local_1c[2];
    undefined1 local_14;
    undefined1 local_13;
    undefined2 local_12;
    undefined1 local_10;
    undefined1 local_f;
    undefined1 local_e;

    memset(local_1c, 0, 0x10);
    V_LOCK();
    logfmt_raw(auStack_101c, 0x1000, 0, "gen_nonce_cnt %s reg %02x value %08x",
               "chip_setting_gen_nonce_cnt_ltc", 3, param_2);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/chip_setting_ltc_1491.c",
        0xba, "chip_setting_gen_nonce_cnt_ltc", 0x1e, 0x184, 0x3c,
        auStack_101c);
    local_14 = 1;
    local_13 = 0;
    local_12 = 3;
    local_1c[0] = param_2 & 0xffff;
    local_e = 1;
    local_10 = 0xff;
    local_f = (undefined1) * (undefined4 *)(param_1 + 0x154);
    uVar1 = (**(code **)(param_1 + 0x110))(param_1, local_1c);
    return uVar1;
}

undefined4 chip_setting_check_bist_ltc(int param_1, char param_2, int param_3,
                                       undefined4 param_4)

{
    undefined4 uVar1;
    undefined1 auStack_105c[4096];
    int local_5c;
    undefined1 auStack_58[8];
    char local_50;
    undefined1 local_4f;
    undefined2 local_4e;
    undefined1 local_4c;
    undefined1 local_4b;
    undefined1 local_4a;
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    void *local_24;
    undefined4 local_20;
    int local_1c;
    undefined4 local_18;
    int local_14;

    local_5c = 0;
    if (param_2 == '\0') {
        local_1c = 1;
    } else {
        local_1c = *(int *)(param_1 + 0x150);
    }
    local_20 = 0;
    V_LOCK();
    logfmt_raw(auStack_105c, 0x1000, 0,
               "check bist result, chip_all %d chip_no %d core %d ", param_2,
               param_3, param_4);
    V_UNLOCK();
    uVar1 = 0x198;
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/chip_setting_ltc_1491.c",
        0xba, "chip_setting_check_bist_ltc", 0x1b, 0x198, 0x14, auStack_105c);
    local_24 = malloc(local_1c * 0xc);
    memset(local_24, 0, local_1c * 0xc);
    memset(auStack_58, 0, 0x10);
    if (param_2 == '\0') {
        local_4f = *(undefined1 *)(*(int *)(param_1 + 0x1ec) + param_3);
    } else {
        local_4f = 0;
    }
    local_4a = 0;
    local_4b = 1;
    local_4c = (undefined1)param_4;
    local_4e = 6;
    local_50 = param_2;
    (**(code **)(param_1 + 300))(param_1, auStack_58, local_1c, local_24,
                                 &local_5c, uVar1, 2000, 0);
    for (local_14 = 0; local_14 < local_5c; local_14 = local_14 + 1) {
        local_28 =
            FUN_000cc2a0(*(undefined1 *)((int)local_24 + local_14 * 0xc + 4),
                         *(undefined4 *)(param_1 + 0x1ac));
        if ((*(short *)((int)local_24 + local_14 * 0xc + 6) == 6) &&
            ((*(uint *)((int)local_24 + local_14 * 0xc) & 0x1000000) != 0)) {
            local_18 = 1;
        } else {
            local_18 = 0;
        }
    }
    if (local_5c < local_1c) {
        V_LOCK();
        FUN_00086850(&local_48, &local_48, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_105c, 0x1000, 0, uStack_2c, local_48, uStack_44,
                   uStack_40, uStack_3c, local_38, uStack_34, uStack_30,
                   uStack_2c,
                   "detected core %d get check bist results less than expect "
                   "num(%d < %d)",
                   param_4, local_5c, local_1c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "chip_setting_ltc_1491.c",
             0xba, "chip_setting_check_bist_ltc", 0x1b, 0x1b9, 0x50,
             auStack_105c);
    }
    free(local_24);
    return local_18;
}

int chip_setting_reset_bist_ltc(int param_1, char param_2, int param_3,
                                char param_4, int param_5)

{
    undefined1 auStack_1030[4096];
    undefined4 local_30[2];
    char local_28;
    undefined1 local_27;
    undefined2 local_26;
    undefined1 local_24;
    undefined1 local_23;
    undefined1 local_22;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    V_LOCK();
    logfmt_raw(auStack_1030, 0x1000, 0, &DAT_001254c8,
               "chip_setting_reset_bist_ltc");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/chip_setting_ltc_1491.c",
        0xba, "chip_setting_reset_bist_ltc", 0x1b, 0x1cc, 0x28, auStack_1030);
    if (param_4 == '\0') {
        local_14 = param_5;
        local_18 = param_5;
    } else {
        local_18 = 0;
        local_14 = *(int *)(param_1 + 0x154) + -1;
    }
    memset(local_30, 0, 0x10);
    if (param_2 == '\0') {
        local_27 = *(undefined1 *)(*(int *)(param_1 + 0x1ec) + param_3);
    } else {
        local_27 = 0;
    }
    local_23 = (undefined1) * (undefined4 *)(param_1 + 0x154);
    local_28 = param_2;
    for (local_10 = local_18; local_10 <= local_14; local_10 = local_10 + 1) {
        local_30[0] = 0x400;
        local_26 = 0;
        local_24 = (undefined1)local_10;
        local_22 = 0;
        local_20 = (**(code **)(param_1 + 0x110))(param_1, local_30);
        if (local_20 != 0) {
            V_LOCK();
            logfmt_raw(auStack_1030, 0x1000, 0,
                       "%s failed, reg:%02x, core_id:%d",
                       "chip_setting_reset_bist_ltc", local_26, local_10);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "backend_ltc_1491/chip_setting_ltc_1491.c",
                 0xba, "chip_setting_reset_bist_ltc", 0x1b, 0x1e2, 100,
                 auStack_1030);
            return local_20;
        }
        usleep(1000);
    }
    usleep(10000);
    memset(local_30, 0, 0x10);
    if (param_2 == '\0') {
        local_27 = *(undefined1 *)(*(int *)(param_1 + 0x1ec) + param_3);
    } else {
        local_27 = 0;
    }
    local_23 = (undefined1) * (undefined4 *)(param_1 + 0x154);
    local_c = local_18;
    local_28 = param_2;
    while (true) {
        if (local_14 < local_c) {
            usleep(10000);
            return 0;
        }
        local_30[0] = 0x401400;
        local_26 = 0;
        local_24 = (undefined1)local_c;
        local_22 = 0;
        local_1c = (**(code **)(param_1 + 0x110))(param_1, local_30);
        if (local_1c != 0)
            break;
        usleep(1000);
        local_c = local_c + 1;
    }
    V_LOCK();
    logfmt_raw(auStack_1030, 0x1000, 0, "%s failed, reg:%02x, core_id:%d",
               "chip_setting_reset_bist_ltc", local_26, local_c);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/chip_setting_ltc_1491.c",
        0xba, "chip_setting_reset_bist_ltc", 0x1b, 0x1f7, 100, auStack_1030);
    return local_1c;
}

undefined4 chip_setting_core_error_ctrl_ltc(int param_1)

{
    undefined4 local_1c[2];
    undefined1 local_14;
    undefined1 local_13;
    undefined2 local_12;
    undefined4 local_c;

    memset(local_1c, 0, 0x10);
    puts("chip_setting_core_error_ctrl_ltc");
    local_14 = 1;
    local_13 = 0;
    local_12 = 0xa8;
    local_1c[0] = 0x80640bb8;
    local_c = (**(code **)(param_1 + 0x10c))(param_1, local_1c);
    usleep(1000);
    return local_c;
}

int chip_setting_working_mode_ltc(int param_1, char param_2, int param_3,
                                  undefined4 param_4, undefined4 param_5,
                                  uint param_6)

{
    undefined1 auStack_101c[4096];
    uint local_1c[2];
    char local_14;
    undefined1 local_13;
    undefined2 local_12;
    undefined1 local_10;
    undefined1 local_f;
    int local_c;

    V_LOCK();
    logfmt_raw(auStack_101c, 0x1000, 0, &DAT_001254c8,
               "chip_setting_working_mode_ltc");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/chip_setting_ltc_1491.c",
        0xba, "chip_setting_working_mode_ltc", 0x1d, 0x214, 0x14, auStack_101c,
        param_4);
    local_f = (undefined1)param_4;
    memset(local_1c, 0, 0x10);
    if (param_2 == '\0') {
        local_13 = *(undefined1 *)(*(int *)(param_1 + 0x1ec) + param_3);
    } else {
        local_13 = 0;
    }
    local_1c[0] = param_6 & 0xff | 0x400;
    local_12 = 0;
    local_10 = 0xff;
    local_14 = param_2;
    local_c = (**(code **)(param_1 + 0x110))(param_1, local_1c);
    if (local_c == 0) {
        usleep(1000);
        local_c = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_101c, 0x1000, 0,
                   "%s failed, chip_all %d chip_addr %02x reg:%02x, all core",
                   "chip_setting_working_mode_ltc", local_14, local_13,
                   local_12);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "chip_setting_ltc_1491.c",
             0xba, "chip_setting_working_mode_ltc", 0x1d, 0x222, 100,
             auStack_101c);
    }
    return local_c;
}

int chip_setting_gen_nonce_count_ltc(int param_1, char param_2, int param_3,
                                     undefined4 param_4, undefined1 param_5,
                                     uint param_6)

{
    undefined1 auStack_101c[4096];
    int local_1c[2];
    char local_14;
    undefined1 local_13;
    undefined2 local_12;
    undefined1 local_10;
    undefined1 local_f;
    int local_c;

    V_LOCK();
    logfmt_raw(auStack_101c, 0x1000, 0, &DAT_001254c8,
               "chip_setting_gen_nonce_count_ltc");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/chip_setting_ltc_1491.c",
        0xba, "chip_setting_gen_nonce_count_ltc", 0x20, 0x238, 0x14,
        auStack_101c, param_4);
    local_f = (undefined1)param_4;
    memset(local_1c, 0, 0x10);
    if (param_2 == '\0') {
        local_13 = *(undefined1 *)(*(int *)(param_1 + 0x1ec) + param_3);
    } else {
        local_13 = 0;
    }
    local_1c[0] = (param_6 & 1) << 10;
    local_12 = 3;
    local_10 = param_5;
    local_14 = param_2;
    local_c = (**(code **)(param_1 + 0x110))(param_1, local_1c);
    if (local_c == 0) {
        usleep(1000);
        local_c = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_101c, 0x1000, 0,
                   "%s failed, chip_all %d chip_addr %02x reg:%02x, all core",
                   "chip_setting_gen_nonce_count_ltc", local_14, local_13,
                   local_12);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
             "chip_setting_ltc_1491.c",
             0xba, "chip_setting_gen_nonce_count_ltc", 0x20, 0x245, 100,
             auStack_101c);
    }
    return local_c;
}

undefined4 chip_setting_share_mode_ltc(int param_1)

{
    undefined4 local_1c[2];
    undefined1 local_14;
    undefined1 local_13;
    undefined2 local_12;
    undefined1 local_10;
    undefined1 local_e;
    undefined4 local_c;

    memset(local_1c, 0, 0x10);
    local_14 = 1;
    local_13 = 1;
    local_1c[0] = 0x4ff;
    local_12 = 0;
    local_10 = 0xff;
    local_e = 1;
    local_c = (**(code **)(param_1 + 0x110))(param_1, local_1c);
    usleep(1000);
    return 0;
}

undefined4 chip_setting_io_drive_ltc(int param_1)

{
    undefined1 auStack_101c[4096];
    undefined4 local_1c[2];
    undefined1 local_14;
    undefined1 local_13;
    undefined2 local_12;
    undefined4 local_c;

    memset(local_1c, 0, 0x10);
    V_LOCK();
    logfmt_raw(auStack_101c, 0x1000, 0,
               "io_drive_strenth %s reg %02x value %08x",
               "chip_setting_io_drive_ltc", 0x30, 0x77777);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_ltc_1491/chip_setting_ltc_1491.c",
        0xba, "chip_setting_io_drive_ltc", 0x19, 0x26a, 0x3c, auStack_101c);
    local_14 = 1;
    local_13 = 0;
    local_12 = 0x30;
    local_1c[0] = 0x77777;
    local_c = (**(code **)(param_1 + 0x10c))(param_1, local_1c);
    usleep(1000);
    return local_c;
}

undefined4 FUN_00089210(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "chain", param_3, param_4);
    return param_1;
}

void FUN_00089244(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_000893d0(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

undefined4 global_idx_init_x7(int param_1)

{
    void *__s;

    __s = malloc(0xbf88);
    memset(__s, 0, 0xbf88);
    *(undefined1 *)((int)__s + 0xbf80) = 1;
    *(void **)(param_1 + 0x338) = __s;
    printf("__custom_data init %p\n", __s);
    return 0;
}

undefined4 global_idx_free_x7(int param_1)

{
    free(*(void **)(param_1 + 0x338));
    return 0;
}

void FUN_000895fc(int param_1, undefined1 param_2)

{
    int iVar1;
    undefined1 auStack_2010[4096];
    char acStack_1010[4096];
    int local_10;
    uint local_c;

    local_10 = 0;
    local_c = 0;
    while (true) {
        if (*(byte *)(param_1 + 0x17e) <= local_c)
            break;
        iVar1 = snprintf(acStack_1010 + local_10, 0x1000 - local_10, "%02x ",
                         (uint) * (byte *)(param_1 + local_c + 0xb8));
        local_10 = local_10 + iVar1;
        local_c = local_c + 1;
    }
    V_LOCK();
    logfmt_raw(auStack_2010, 0x1000, 0,
               "x7 dump work jobid %s, work count %02x", param_1 + 0x78,
               param_2);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/backend_x7_2044.c",
        0xb3, "dump_work_x7", 0xc, 0x6b, 0x28, auStack_2010);
    V_LOCK();
    logfmt_raw(auStack_2010, 0x1000, 0, "dump work: %s", acStack_1010);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/backend_x7_2044.c",
        0xb3, "dump_work_x7", 0xc, 0x6c, 0x28, auStack_2010);
    return;
}

int FUN_000897e8(int param_1)

{
    int local_10;
    int local_c;

    local_c = 0;
    local_10 = 0x1f;
    while (true) {
        if (local_10 < 0) {
            return local_c;
        }
        if (*(char *)(param_1 + local_10) != '\0')
            break;
        local_c = local_c + 8;
        local_10 = local_10 + -1;
    }
    if (*(byte *)(param_1 + local_10) < 2) {
        return local_c + 7;
    }
    if (*(byte *)(param_1 + local_10) < 4) {
        return local_c + 6;
    }
    if (*(byte *)(param_1 + local_10) < 8) {
        return local_c + 5;
    }
    if (*(byte *)(param_1 + local_10) < 0x10) {
        return local_c + 4;
    }
    if (*(byte *)(param_1 + local_10) < 0x20) {
        return local_c + 3;
    }
    if (*(byte *)(param_1 + local_10) < 0x40) {
        return local_c + 2;
    }
    if (*(char *)(param_1 + local_10) < '\0') {
        return local_c;
    }
    return local_c + 1;
}

undefined1 FUN_00089984(undefined4 param_1, undefined4 param_2)

{
    undefined1 uVar1;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined8 local_2c;
    undefined8 uStack_24;
    undefined8 local_1c;
    undefined8 local_14;

    local_2c = 0;
    uStack_24 = 0;
    local_1c = 0;
    local_14 = 0;
    local_38 = param_1;
    uStack_34 = param_2;
    memcpy(&local_14, &local_38, 8);
    uVar1 = FUN_000897e8(&local_2c);
    return uVar1;
}

undefined4 work_2_packet_x7(int param_1, undefined4 *param_2,
                            undefined1 *param_3, int *param_4)

{
    char cVar1;
    undefined2 uVar2;
    int iVar3;
    undefined4 *puVar4;
    undefined4 uVar5;
    undefined1 auStack_1230[520];
    undefined1 auStack_1028[4096];
    int local_28;
    int local_24;
    undefined4 local_20;
    undefined4 *local_1c;
    undefined1 *local_18;
    uint local_14;
    int local_10;
    int local_c;

    local_20 = 0;
    local_1c = param_2;
    local_18 = param_3;
    wait_x7_chip_setting_not_pending(param_1);
    local_24 = *(int *)(param_1 + 0x338);
    *local_18 = 0x55;
    local_18[1] = 0xaa;
    local_18[2] = 3;
    local_18[3] = 0xff;
    local_18[4] = 0xff;
    local_18[5] = *(char *)((int)local_1c + 0x17e) + '\b';
    local_18[9] = (char)*(undefined4 *)(param_1 + 0x1b0);
    local_18[10] = 4;
    local_28 = *(int *)((int)local_1c + 0x17f);
    if (local_28 == -1) {
        local_28 = *(int *)(param_1 + 0xf8) * 0x1b0;
        *(int *)((int)local_1c + 0x17f) = local_28;
    }
    memset((void *)((int)local_1c + 0xdf), 0, 4);
    *(undefined4 *)(local_18 + 0xb) = *(undefined4 *)((int)local_1c + 0x17f);
    local_18[0xf] = *(undefined1 *)((int)local_1c + 0x17e);
    memcpy(local_18 + 0x10, local_1c + 0x2e,
           (uint) * (byte *)((int)local_1c + 0x17e));
    uVar5 = local_1c[1];
    puVar4 =
        (undefined4 *)(local_24 + (uint) * (byte *)(local_24 + 0xbf80) * 8);
    *puVar4 = *local_1c;
    puVar4[1] = uVar5;
    memcpy((void *)(local_24 + (*(byte *)(local_24 + 0xbf80) + 0x10) * 0x40),
           local_1c + 2, 0x40);
    memcpy((void *)(local_24 + (*(byte *)(local_24 + 0xbf80) + 0x120) * 0x20),
           local_1c + 0x12, 0x20);
    uVar5 = local_1c[0x1b];
    puVar4 =
        (undefined4 *)(local_24 + (*(byte *)(local_24 + 0xbf80) + 0x680) * 8);
    *puVar4 = local_1c[0x1a];
    puVar4[1] = uVar5;
    uVar5 = local_1c[0x1d];
    puVar4 =
        (undefined4 *)(local_24 + (*(byte *)(local_24 + 0xbf80) + 0x700) * 8);
    *puVar4 = local_1c[0x1c];
    puVar4[1] = uVar5;
    strcpy((char *)(local_24 + (*(byte *)(local_24 + 0xbf80) + 0xf0) * 0x40),
           (char *)(local_1c + 0x1e));
    memcpy((void *)(local_24 + (uint) * (byte *)(local_24 + 0xbf80) * 0xc6 +
                    0x5c00),
           local_1c + 0x2e, (uint) * (byte *)((int)local_1c + 0x17e));
    *(undefined1 *)(local_24 + (uint) * (byte *)(local_24 + 0xbf80) + 0xbf00) =
        *(undefined1 *)((int)local_1c + 0x17e);
    pthread_mutex_lock(
        (pthread_mutex_t *)(msg_ack_lock + *(int *)(param_1 + 0xf8) * 0x18));
    pthread_cond_broadcast((pthread_cond_t *)(msg_check_process_wakeup_cond +
                                              *(int *)(param_1 + 0xf8) * 0x30));
    cVar1 = *(char *)(local_24 + 0xbf80);
    *(char *)(local_24 + 0xbf80) = cVar1 + '\x01';
    local_18[8] = cVar1;
    pthread_mutex_unlock(
        (pthread_mutex_t *)(msg_ack_lock + *(int *)(param_1 + 0xf8) * 0x18));
    *(byte *)(local_24 + 0xbf80) = *(byte *)(local_24 + 0xbf80) & 0x7f;
    if (((*(byte *)((int)local_1c + 0x17e) == last_blob_len) &&
         (iVar3 =
              memcmp(&last_start_nonce_x7, (void *)((int)local_1c + 0x17f), 4),
          iVar3 == 0)) &&
        (iVar3 = memcmp(last_blob_x7, local_1c + 0x2e, (uint)last_blob_len),
         iVar3 == 0)) {
        V_LOCK();
        logfmt_raw(auStack_1028, 0x1000, 0, "found repeat work");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "backend_x7_2044.c",
             0xb3, "work_2_packet_x7", 0x10, 0xd6, 0x50, auStack_1028);
        FUN_000895fc(local_1c, local_18[8]);
    }
    last_blob_len = *(undefined1 *)((int)local_1c + 0x17e);
    memcpy(last_blob_x7, local_1c + 0x2e,
           (uint) * (byte *)((int)local_1c + 0x17e));
    last_start_nonce_x7 = *(undefined4 *)((int)local_1c + 0x17f);
    local_18[6] = 0;
    local_18[7] = 0;
    uVar2 = BM_CRC16(local_18, *(byte *)((int)local_1c + 0x17e) + 0x10);
    *(undefined2 *)(local_18 + 6) = uVar2;
    *param_4 = *(byte *)((int)local_1c + 0x17e) + 0x10;
    pthread_mutex_lock(
        (pthread_mutex_t *)(last_work_lock + *(int *)(param_1 + 0xf8) * 0x18));
    memcpy(last_work_packet + *(int *)(param_1 + 0xf8) * 0xd6, local_18, 0xd6);
    *(int *)(last_work_len + *(int *)(param_1 + 0xf8) * 4) = *param_4;
    pthread_mutex_unlock(
        (pthread_mutex_t *)(last_work_lock + *(int *)(param_1 + 0xf8) * 0x18));
    if ((*(char *)(param_1 + 0x101) != '\0') &&
        (*(char *)(param_1 + 0x102) != '\0')) {
        memset(*(void **)(param_1 + 0x1c8), 0,
               *(int *)(param_1 + 0x150) * 0x30);
        *(undefined1 *)(param_1 + 0x101) = 0;
    }
    iVar3 = memcmp(last_seed_hash_x7 + *(int *)(param_1 + 0xf8) * 0x20,
                   local_1c + 0x12, 0x20);
    if (iVar3 != 0) {
        for (local_c = 0; local_c < *(int *)(param_1 + 0x150);
             local_c = local_c + 1) {
            pthread_mutex_lock(
                (pthread_mutex_t *)(*(int *)(x7_chip_seed_status +
                                             *(int *)(param_1 + 0xf8) * 4) +
                                    local_c * 0x4c + 0x34));
        }
        chip_setting_seed_x7(param_1, local_1c + 0x12, 0x20, auStack_1230,
                             0xff);
        memcpy(last_seed_hash_x7 + *(int *)(param_1 + 0xf8) * 0x20,
               local_1c + 0x12, 0x20);
        for (local_10 = 0; local_10 < *(int *)(param_1 + 0x150);
             local_10 = local_10 + 1) {
            pthread_mutex_unlock(
                (pthread_mutex_t *)(*(int *)(x7_chip_seed_status +
                                             *(int *)(param_1 + 0xf8) * 4) +
                                    local_10 * 0x4c + 0x34));
        }
        local_14 = 0;
        while (true) {
            if (*(int *)(param_1 + 0x150) <= (int)local_14)
                break;
            chip_seed_status_set_calculating(param_1, local_14 & 0xff);
            local_14 = local_14 + 1;
        }
        V_LOCK();
        logfmt_raw(auStack_1028, 0x1000, 0, "new seed has come");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "backend_x7_2044.c",
             0xb3, "work_2_packet_x7", 0x10, 0x10b, 0x28, auStack_1028);
        set_x7_chip_setting_pending(param_1, 0x32);
        *param_4 = 0;
    }
    return 0;
}

void FUN_0008a348(int param_1, int param_2, int param_3)

{
    int iVar1;
    undefined1 auStack_2058[4096];
    char acStack_1058[4096];
    undefined4 local_58;
    undefined4 uStack_54;
    undefined4 uStack_50;
    undefined4 uStack_4c;
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    uint local_18;
    int local_14;

    local_14 = 0;
    iVar1 = snprintf(acStack_1058, 0x1000, "%08x ",
                     *(undefined4 *)(param_2 + 0x10));
    local_14 = local_14 + iVar1;
    V_LOCK();
    FUN_00089210(&local_58, &local_58, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_2058, 0x1000, 0, uStack_3c, local_58, uStack_54,
               uStack_50, uStack_4c, local_48, uStack_44, uStack_40, uStack_3c,
               "work_id: %02x", *(undefined1 *)(param_2 + 0xc));
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/backend_x7_2044.c",
        0xb3, "dump_nonce_x7", 0xd, 0x119, 0x28, auStack_2058);
    V_LOCK();
    logfmt_raw(auStack_2058, 0x1000, 0, "back nonce: %s", acStack_1058);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/backend_x7_2044.c",
        0xb3, "dump_nonce_x7", 0xd, 0x11a, 0x28, auStack_2058);
    local_14 = 0;
    for (local_18 = 0; local_18 < 4; local_18 = local_18 + 1) {
        iVar1 = snprintf(acStack_1058 + local_14, 0x1000 - local_14, "%02x ",
                         (uint) * (byte *)(param_3 + local_18 + 0xc0));
        local_14 = local_14 + iVar1;
    }
    V_LOCK();
    FUN_00089210(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_2058, 0x1000, 0, uStack_1c, local_38, uStack_34,
               uStack_30, uStack_2c, local_28, uStack_24, uStack_20, uStack_1c,
               "asic %d core %d addr_interval %d", *(undefined4 *)(param_3 + 8),
               *(undefined4 *)(param_3 + 0xc),
               *(undefined4 *)(param_1 + 0x1ac));
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/backend_x7_2044.c",
        0xb3, "dump_nonce_x7", 0xd, 0x120, 0x28, auStack_2058);
    V_LOCK();
    logfmt_raw(auStack_2058, 0x1000, 0, "nonce: %s", acStack_1058);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/backend_x7_2044.c",
        0xb3, "dump_nonce_x7", 0xd, 0x121, 0x28, auStack_2058);
    return;
}

undefined4 packet_2_nonce_x7(int param_1, int param_2, undefined4 *param_3,
                             undefined1 *param_4, undefined4 *param_5,
                             uint *param_6, undefined4 *param_7)

{
    ushort uVar1;
    ushort uVar2;
    uint extraout_r1;
    undefined4 uVar3;
    int iVar4;
    undefined4 *puVar5;
    int *piVar6;

    if (*(char *)(param_2 + 2) == '\x04') {
        uVar1 = *(ushort *)(param_2 + 8);
        *(undefined1 *)(param_2 + 8) = 0;
        *(undefined1 *)(param_2 + 9) = 0;
        uVar2 = BM_CRC16(param_2, 0x34);
        if (uVar2 == uVar1) {
            iVar4 = *(int *)(param_1 + 0x338);
            *(undefined1 *)(param_3 + 0x39) = *(undefined1 *)(param_2 + 0xc);
            puVar5 =
                (undefined4 *)(iVar4 + (uint) * (byte *)(param_2 + 0xc) * 8);
            uVar3 = puVar5[1];
            *param_3 = *puVar5;
            param_3[1] = uVar3;
            *param_7 =
                *(undefined4 *)(iVar4 + (uint) * (byte *)(param_2 + 0xc) * 8);
            param_3[2] = (uint) * (byte *)(param_2 + 3);
            strcpy((char *)(param_3 + 4),
                   (char *)(iVar4 + (*(byte *)(param_2 + 0xc) + 0x10) * 0x40));
            memcpy(param_3 + 0x14,
                   (void *)(iVar4 + (*(byte *)(param_2 + 0xc) + 0x120) * 0x20),
                   0x20);
            puVar5 =
                (undefined4 *)(iVar4 + (*(byte *)(param_2 + 0xc) + 0x680) * 8);
            uVar3 = puVar5[1];
            param_3[0x1c] = *puVar5;
            param_3[0x1d] = uVar3;
            puVar5 =
                (undefined4 *)(iVar4 + (*(byte *)(param_2 + 0xc) + 0x700) * 8);
            uVar3 = puVar5[1];
            param_3[0x1e] = *puVar5;
            param_3[0x1f] = uVar3;
            strcpy((char *)(param_3 + 0x20),
                   (char *)(iVar4 + (*(byte *)(param_2 + 0xc) + 0xf0) * 0x40));
            memcpy(param_3 + 0x30, (void *)(param_2 + 0x10), 0x20);
            memcpy(param_3 + 0x31, (void *)(param_2 + 0x14), 0x20);
            param_3[3] = (*(uint *)(param_2 + 0x10) % 0x1b0) % 0x48;
            if ((int)(uint) * (byte *)(param_2 + 3) <
                *(int *)(param_1 + 0x150)) {
                *param_6 = (uint) * (byte *)(param_2 + 3);
            } else {
                iVar4 = rand();
                FUN_000cc7ac(iVar4, *(undefined4 *)(param_1 + 0x150));
                *param_6 = extraout_r1;
            }
            *param_5 = param_3[0x30];
            *param_4 = 1;
            piVar6 =
                (int *)(*(int *)(param_1 + 0x1e4) +
                        (*(int *)(param_1 + 0x158) * *param_6 + param_3[3]) *
                            4);
            *piVar6 = *piVar6 + 1;
            uVar3 = 0;
        } else {
            printf("chain[%d] get nonce crc error calc value %04x expected "
                   "value %04x\n",
                   (uint)uVar2, (uint)uVar1);
            uVar3 = 0x65;
        }
    } else {
        uVar3 = 100;
    }
    return uVar3;
}

undefined4 FUN_0008aa6c(int param_1)

{
    int iVar1;
    undefined4 uVar2;
    undefined1 auStack_103c[4096];
    undefined4 local_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    int local_18;
    int local_14;

    local_18 = *(int *)(param_1 + 0x150);
    local_14 = 0;
    local_3c = 0;
    do {
        chip_setting_get_restart_reg_x7(param_1, 0xff, &local_3c);
        *(undefined4 *)(param_1 + 0x1a8) = local_3c;
        chip_setting_get_addr_x7(param_1, local_18);
        if (*(int *)(param_1 + 0x1a8) != local_18) {
            V_LOCK();
            FUN_00089210(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(auStack_103c, 0x1000, 0, uStack_1c, local_38, uStack_34,
                       uStack_30, uStack_2c, local_28, uStack_24, uStack_20,
                       uStack_1c, "some chip not found ,restart chain");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "backend_x7_2044/backend_x7_2044.c",
                 0xb3, "check_asic_num_x7", 0x11, 0x160, 0x50, auStack_103c);
            iVar1 = dev_ctrl();
            (**(code **)(iVar1 + 0x1c))(*(undefined4 *)(param_1 + 0xf8));
            sleep(10);
            iVar1 = dev_ctrl();
            (**(code **)(iVar1 + 0x18))(*(undefined4 *)(param_1 + 0xf8),
                                        *(undefined4 *)(param_1 + 0x454),
                                        *(undefined4 *)(param_1 + 0x468));
            sleep(5);
        }
    } while ((*(int *)(param_1 + 0x1a8) != local_18) &&
             (local_14 = local_14 + 1, local_14 < 3));
    if (*(int *)(param_1 + 0x1a8) == local_18) {
        uVar2 = 0;
    } else {
        uVar2 = 0x66;
    }
    return uVar2;
}

undefined4 FUN_0008aca4(int param_1, int param_2)

{
    undefined1 auStack_1068[4096];
    int local_68;
    undefined4 uStack_64;
    size_t local_60;
    undefined4 uStack_5c;
    undefined4 local_58;
    undefined4 uStack_54;
    undefined4 uStack_50;
    int local_4c;
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 *local_28;
    void *local_24;
    int local_20;
    void *local_1c;
    int local_18;
    int local_14;

    local_20 = -0x40;
    local_68 = *(int *)(param_1 + 0x184);
    uStack_64 = *(undefined4 *)(param_1 + 0x188);
    local_60 = *(size_t *)(param_1 + 0x18c);
    uStack_5c = *(undefined4 *)(param_1 + 400);
    local_58 = *(undefined4 *)(param_1 + 0x194);
    uStack_54 = *(undefined4 *)(param_1 + 0x198);
    uStack_50 = *(undefined4 *)(param_1 + 0x19c);
    local_24 = calloc(0xc, local_60);
    if (local_24 == (void *)0x0) {
        local_4c = 0;
    } else {
        chip_setting_read_all_sensor_temp(param_1, local_24, local_60,
                                          &local_4c);
    }
    local_18 = 0;
    do {
        if ((int)local_60 <= local_18) {
            if (local_24 != (void *)0x0) {
                free(local_24);
            }
            return 0;
        }
        local_28 = (undefined4 *)(local_68 + local_18 * 0x18);
        local_1c = (void *)0x0;
        for (local_14 = 0; local_14 < local_4c; local_14 = local_14 + 1) {
            if (local_28[5] == *(int *)((int)local_24 + local_14 * 0xc)) {
                local_1c = (void *)((int)local_24 + local_14 * 0xc);
                break;
            }
        }
        if ((local_1c == (void *)0x0) || (*(int *)((int)local_1c + 8) == 0)) {
            local_20 = -0x40;
            if (*(char *)(param_1 + 0x448) != '\x01') {
                V_LOCK();
                FUN_00089210(&local_48, &local_48, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(auStack_1068, 0x1000, 0, uStack_2c, local_48,
                           uStack_44, uStack_40, uStack_3c, local_38, uStack_34,
                           uStack_30, uStack_2c,
                           "read sensor failed, sensor[%d], addr:%02x",
                           *local_28, local_28[5]);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "backend_x7_2044/backend_x7_2044.c",
                     0xb3, "read_temperature_x7", 0x13, 400, 100, auStack_1068);
            }
        } else {
            local_20 = (*(int *)((int)local_1c + 4) + 500) / 1000;
        }
        if ((int)local_28[5] < *(int *)(param_1 + 0x150)) {
            pthread_mutex_lock((pthread_mutex_t *)(*(int *)(param_1 + 0x210) +
                                                   local_28[5] * 0x2c + 0x14));
            *(int *)(*(int *)(param_1 + 0x210) + local_28[5] * 0x2c) = local_20;
            pthread_mutex_unlock((pthread_mutex_t *)(*(int *)(param_1 + 0x210) +
                                                     local_28[5] * 0x2c +
                                                     0x14));
        }
        *(int *)(param_2 + local_18 * 0xc) = local_20;
        *(int *)(param_2 + local_18 * 0xc + 4) = local_20;
        if (local_20 != DAT_001503ac) {
            DAT_001503ac = local_20;
        }
        local_18 = local_18 + 1;
    } while (true);
}

int read_rxu_status_x7(int param_1, undefined4 param_2, undefined4 param_3)

{
    undefined1 auStack_1038[4096];
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    int local_14;

    local_14 = chip_setting_get_all_rxu_status(
        param_1, param_2, *(undefined4 *)(param_1 + 0x150), param_3);
    if (local_14 == 0) {
        local_14 = 0;
    } else {
        V_LOCK();
        FUN_00089210(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(
            auStack_1038, 0x1000, 0, uStack_1c, local_38, uStack_34, uStack_30,
            uStack_2c, local_28, uStack_24, uStack_20, uStack_1c,
            "chip_setting_get_all_rxu_status failed ,err code %d", local_14);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "backend_x7_2044.c",
             0xb3, "read_rxu_status_x7", 0x12, 0x1ad, 100, auStack_1038);
    }
    return local_14;
}

undefined4 restart_one_chip_x7(int param_1, undefined1 param_2)

{
    undefined4 uVar1;
    undefined1 auStack_105c[4096];
    int local_5c;
    undefined4 local_58;
    undefined4 uStack_54;
    undefined4 uStack_50;
    undefined4 uStack_4c;
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    int local_14;

    local_14 = chip_setting_restart_one_chip_x7(param_1, param_2, &local_5c);
    if (local_14 == 0) {
        if (local_5c == 1) {
            uVar1 = 0;
        } else {
            V_LOCK();
            FUN_00089210(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(
                auStack_105c, 0x1000, 0, uStack_1c, local_38, uStack_34,
                uStack_30, uStack_2c, local_28, uStack_24, uStack_20, uStack_1c,
                "restart_one_chip response count err, count:%d, should be 1",
                local_5c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "backend_x7_2044/backend_x7_2044.c",
                 0xb3, "restart_one_chip_x7", 0x13, 0x1c0, 100, auStack_105c);
            uVar1 = 0x6d;
        }
    } else {
        V_LOCK();
        FUN_00089210(&local_58, &local_58, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_105c, 0x1000, 0, uStack_3c, local_58, uStack_54,
                   uStack_50, uStack_4c, local_48, uStack_44, uStack_40,
                   uStack_3c, "restart_one_chip failed ,err code %d", local_14);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "backend_x7_2044.c",
             0xb3, "restart_one_chip_x7", 0x13, 0x1bb, 100, auStack_105c);
        uVar1 = 0x6d;
    }
    return uVar1;
}

undefined4 top_init_x7(void)

{
    return 0;
}

undefined4 dhash_start_x7(int param_1)

{
    undefined1 auStack_1030[4096];
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    undefined4 local_20;
    undefined4 uStack_1c;
    undefined4 uStack_18;
    undefined4 uStack_14;

    V_LOCK();
    FUN_00089210(&local_30, &local_30, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_1030, 0x1000, 0, uStack_14, local_30, uStack_2c,
               uStack_28, uStack_24, local_20, uStack_1c, uStack_18, uStack_14,
               "dhash_start_x7");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/backend_x7_2044.c",
        0xb3, "dhash_start_x7", 0xe, 0x1f0, 0x28, auStack_1030);
    *(undefined1 *)(param_1 + 0x101) = 1;
    if (*(char *)(param_1 + 0x1cc) != '\x01') {
        *(int *)(param_1 + 0x1d0) = (int)*(float *)(param_1 + 0x450);
    }
    return 0;
}

undefined4 setup_all_chip_x7(int param_1)

{
    int iVar1;
    undefined4 uVar2;
    undefined1 auStack_100c[4096];
    undefined4 local_c;

    V_LOCK();
    logfmt_raw(auStack_100c, 0x1000, 0, "setup_all_chip_x7() in");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/backend_x7_2044.c",
        0xb3, "setup_all_chip_x7", 0x11, 0x205, 0x28, auStack_100c);
    local_c = *(undefined4 *)(param_1 + 0x150);
    V_LOCK();
    logfmt_raw(auStack_100c, 0x1000, 0, &DAT_0012dd34, "setup_all_chip_x7");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/backend_x7_2044.c",
        0xb3, "setup_all_chip_x7", 0x11, 0x208, 0x3c, auStack_100c);
    iVar1 = FUN_0008aa6c(param_1);
    if (iVar1 == 0) {
        uVar2 = 0x66;
    } else {
        *(undefined4 *)(param_1 + 0x1d0) = 0;
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0,
                   "get addr after open cores and set frequency.");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "backend_x7_2044.c",
             0xb3, "setup_all_chip_x7", 0x11, 0x210, 0x3c, auStack_100c);
        iVar1 = FUN_0008aa6c(param_1);
        if (iVar1 == 0) {
            uVar2 = 0x66;
        } else {
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, "setup_all_chip_x7() in");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "backend_x7_2044/backend_x7_2044.c",
                 0xb3, "setup_all_chip_x7", 0x11, 0x214, 0x28, auStack_100c);
            uVar2 = 0;
        }
    }
    return uVar2;
}

undefined4 set_baud_x7(void)

{
    return 0;
}

bool check_nonce_x7(undefined4 param_1, int param_2)

{
    bool bVar1;
    undefined1 auStack_1044[4096];
    undefined4 local_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 local_34;
    undefined4 uStack_30;
    uint local_2c;
    uint uStack_28;
    undefined4 local_24;
    uint local_20;
    uint uStack_1c;
    int local_14;

    local_24 = *(undefined4 *)(param_2 + 0xc0);
    local_44 = *(undefined4 *)(param_2 + 0xc4);
    uStack_40 = *(undefined4 *)(param_2 + 200);
    uStack_3c = *(undefined4 *)(param_2 + 0xcc);
    uStack_38 = *(undefined4 *)(param_2 + 0xd0);
    local_34 = *(undefined4 *)(param_2 + 0xd4);
    uStack_30 = *(undefined4 *)(param_2 + 0xd8);
    local_2c = *(uint *)(param_2 + 0xdc);
    uStack_28 = *(uint *)(param_2 + 0xe0);
    bVar1 = *(uint *)(param_2 + 0x7c) <= uStack_28;
    if (uStack_28 == *(uint *)(param_2 + 0x7c)) {
        bVar1 = *(uint *)(param_2 + 0x78) <= local_2c;
    }
    if (bVar1) {
        local_14 = param_2;
        local_20 = local_2c;
        uStack_1c = uStack_28;
        V_LOCK();
        logfmt_raw(
            auStack_1044, 0x1000, 0, "hw diff (%llu<%llu) not reach pool",
            *(undefined4 *)(local_14 + 0x78), *(undefined4 *)(local_14 + 0x7c),
            local_20, uStack_1c, param_2, param_1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "backend_x7_2044.c",
             0xb3, "check_nonce_x7", 0xe, 0x259, 0x14, auStack_1044);
    }
    return bVar1;
}

undefined4 get_chip_status_x7(void)

{
    return 0;
}

undefined4 softreset_all_chip_x7(void)

{
    return 0;
}

undefined4 get_theory_hashrate_x7(undefined4 param_1, undefined4 *param_2)

{
    *param_2 = 0;
    param_2[1] = 0x40f19040;
    return 0;
}

undefined4 get_sale_hashrate_x7(int param_1, double *param_2,
                                undefined4 *param_3)

{
    int iVar1;
    undefined4 local_18;
    undefined4 uStack_14;
    undefined4 local_c;

    local_c = 0;
    local_18 = 0;
    uStack_14 = 0;
    (**(code **)(param_1 + 0x88))(param_1, &local_18);
    iVar1 = strcmp((char *)(param_1 + 0x130), "X5");
    if (iVar1 == 0) {
        *param_2 = (double)CONCAT44(uStack_14, local_18) * 0.985;
        *param_3 = 1;
    } else {
        local_c = 0xcd;
    }
    return local_c;
}

undefined4 get_qualify_hashrate_x7(void)

{
    return 0;
}

undefined4 get_qualify_nonce_num_x7(int param_1, float *param_2)

{
    double dVar1;
    undefined8 uVar2;
    double dVar3;
    ulonglong in_d17;
    undefined4 local_20;
    undefined4 uStack_1c;
    undefined4 local_14;

    local_14 = 0;
    local_20 = 0;
    uStack_1c = 0;
    (**(code **)(param_1 + 0x88))(param_1, &local_20);
    dVar1 = (double)CONCAT44(uStack_1c, local_20);
    uVar2 =
        VectorShiftLeft(1,
                        in_d17 & 0xffffffffffff0000 |
                            (ulonglong) * (uint *)(param_1 + 0x1b0) & 0xffff,
                        8, 1);
    dVar3 = (double)FUN_000ccad4((int)uVar2, (int)((ulonglong)uVar2 >> 0x20));
    *param_2 = (float)(((dVar1 / dVar3) / 6.0) * 0.75);
    return 0;
}

undefined4 set_sensor_extern_mode_x7(void)

{
    return 0;
}

undefined4 read_sensor_temp_local_x7(undefined4 param_1, undefined4 param_2,
                                     int *param_3)

{
    undefined4 uVar1;
    undefined1 in_stack_00000010;

    chip_setting_read_one_sensor_temp_x7(param_1, param_2, param_3,
                                         in_stack_00000010);
    if (*param_3 == 1) {
        uVar1 = 0;
    } else {
        uVar1 = 4;
    }
    return uVar1;
}

undefined4 read_sensor_temp_remote_x7(undefined4 param_1, undefined4 param_2,
                                      int *param_3)

{
    undefined4 uVar1;
    undefined1 in_stack_00000010;

    chip_setting_read_one_sensor_temp_x7(param_1, param_2, param_3,
                                         in_stack_00000010);
    if (*param_3 == 1) {
        uVar1 = 0;
    } else {
        uVar1 = 4;
    }
    return uVar1;
}

undefined4 parameter_update_x7(int param_1)

{
    *(undefined4 *)(param_1 + 0x450) = 0x44fa0000;
    return 0;
}

undefined4 overclock_update_x7(void)

{
    return 0;
}

undefined4 get_pcba_test_level_x7(void)

{
    return 0;
}

undefined1 get_packet_remain_len_x7(int param_1)

{
    return *(undefined1 *)(param_1 + 6);
}

undefined4 adjust_working_freq_x7(void)

{
    return 0;
}

undefined4 send_fake_work_x7(int param_1)

{
    int iVar1;
    uint uVar2;
    undefined1 auStack_6c[92];
    uint local_10;
    int local_c;

    local_c = 3;
    memcpy(auStack_6c, &DAT_0012dda8, 0x5c);
    local_10 = 0x5c;
    printf("send %d triger work\n", local_c);
    while (local_c != 0) {
        local_c = local_c + -1;
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x430));
        do {
            iVar1 = dev_ctrl();
            uVar2 =
                (**(code **)(iVar1 + 0x44))(*(undefined4 *)(param_1 + 0xf8));
        } while (uVar2 < local_10);
        iVar1 = dev_ctrl();
        (**(code **)(iVar1 + 0x34))(*(undefined4 *)(param_1 + 0xf8), auStack_6c,
                                    local_10);
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x430));
        usleep(10000);
    }
    return 0;
}

undefined4 dhash_mining_reset_x7(int param_1)

{
    int iVar1;
    undefined4 extraout_r3;
    undefined1 auStack_1260[4096];
    undefined1 auStack_260[520];
    undefined4 local_58;
    undefined4 uStack_54;
    undefined4 uStack_50;
    undefined4 uStack_4c;
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    uint local_18;
    undefined4 local_14;

    local_14 = 0;
    pthread_mutex_lock(
        (pthread_mutex_t *)(*(int *)(param_1 + 0xf8) * 0x18 + 0x15f7c0));
    V_LOCK();
    FUN_00089210(&local_58, &local_58, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_1260, 0x1000, 0, uStack_3c, local_58, uStack_54,
               uStack_50, uStack_4c, local_48, uStack_44, uStack_40, uStack_3c,
               "dhash mining reset!");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/backend_x7_2044.c",
        0xb3, "dhash_mining_reset_x7", 0x15, 0x346, 0x50, auStack_1260);
    (**(code **)(param_1 + 4))(param_1);
    *(undefined1 *)(param_1 + 0x101) = 0;
    *(undefined1 *)(param_1 + 0x102) = 0;
    iVar1 = dev_ctrl();
    (**(code **)(iVar1 + 0x1c))(*(undefined4 *)(param_1 + 0xf8));
    sleep(10);
    iVar1 = dev_ctrl();
    (**(code **)(iVar1 + 0x18))(*(undefined4 *)(param_1 + 0xf8),
                                *(undefined4 *)(param_1 + 0x454),
                                *(undefined4 *)(param_1 + 0x468));
    sleep(10);
    iVar1 = (**(code **)(param_1 + 0xdc))(param_1);
    if (iVar1 != 0) {
        V_LOCK();
        FUN_00089210(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_1260, 0x1000, 0, uStack_1c, local_38, uStack_34,
                   uStack_30, uStack_2c, local_28, uStack_24, uStack_20,
                   uStack_1c, "finding chip failed after restart");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "backend_x7_2044.c",
             0xb3, "dhash_mining_reset_x7", 0x15, 0x34f, 0x78, auStack_1260);
        /* WARNING: Subroutine does not return */
        exit(-1);
    }
    memset(last_seed_hash_x7 + *(int *)(param_1 + 0xf8) * 0x20, 0, 0x20);
    iVar1 = dev_ctrl();
    (**(code **)(iVar1 + 0x2c))(*(undefined4 *)(param_1 + 0xf8));
    iVar1 = dev_ctrl();
    (**(code **)(iVar1 + 4))(*(undefined4 *)(param_1 + 0xf8));
    (**(code **)(param_1 + 0x10))(param_1);
    chip_setting_seed_x7(param_1,
                         last_seed_hash_x7 + *(int *)(param_1 + 0xf8) * 0x20,
                         0x20, auStack_260, 0xff);
    for (local_18 = 0; (int)local_18 < *(int *)(param_1 + 0x150);
         local_18 = local_18 + 1) {
        reset_chip_seed_status(param_1, local_18 & 0xff);
        chip_seed_status_set_calculating(param_1, local_18 & 0xff);
    }
    pthread_mutex_unlock(
        (pthread_mutex_t *)(*(int *)(param_1 + 0xf8) * 0x18 + 0x15f7c0));
    return extraout_r3;
}

void *runtime_ctrl_x7_2044(void)

{
    undefined1 auStack_1608[4096];
    code *local_608;
    code *local_604;
    code *local_5f8;
    code *local_5f4;
    code *local_5f0;
    code *local_5ec;
    code *local_5e8;
    code *local_5e4;
    code *local_5e0;
    code *local_5dc;
    code *local_5d8;
    code *local_5cc;
    code *local_5c8;
    code *local_5c4;
    code *local_5c0;
    code *local_5bc;
    code *local_5b8;
    code *local_5b4;
    code *local_5b0;
    undefined1 *local_5ac;
    undefined1 *local_5a8;
    undefined1 *local_5a4;
    undefined1 *local_5a0;
    undefined1 *local_59c;
    undefined1 *local_598;
    undefined1 *local_594;
    undefined1 *local_590;
    undefined1 *local_58c;
    code *local_584;
    code *local_580;
    code *local_57c;
    code *local_578;
    code *local_574;
    code *local_570;
    code *local_56c;
    code *local_568;
    code *local_564;
    code *local_560;
    code *local_55c;
    code *local_558;
    code *local_54c;
    undefined1 *local_548;
    code *local_544;
    code *local_538;
    code *local_52c;
    code *local_524;
    code *local_520;
    code *local_518;
    undefined4 local_4d8;
    undefined4 local_4d4;
    undefined4 uStack_4d0;
    undefined4 uStack_4cc;
    undefined4 local_4c8;
    undefined4 local_4c4;
    undefined4 local_4c0;
    undefined4 local_4bc;
    undefined4 local_4b8;
    undefined4 local_4b4;
    undefined4 local_4b0;
    undefined4 local_4ac;
    undefined4 local_4a4;
    undefined4 local_494;
    undefined4 uStack_490;
    undefined4 uStack_484;
    undefined4 uStack_480;
    undefined4 uStack_47c;
    undefined4 uStack_478;
    undefined4 local_474;
    undefined4 uStack_470;
    undefined4 uStack_46c;
    undefined4 local_45c;
    undefined4 local_458;
    undefined4 local_2cc;
    undefined4 local_2c8;
    undefined4 local_2c4;
    undefined4 local_2c0;
    undefined4 local_2bc;
    undefined4 local_2b4;
    undefined4 local_220;
    undefined4 local_1b4;
    undefined4 local_1a8;
    undefined4 uStack_1a4;
    undefined4 local_1a0;
    void *local_c;

    V_LOCK();
    logfmt_raw(auStack_1608, 0x1000, 0, "runtime_ctrl_x7() in");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/backend_x7_2044.c",
        0xb3, "runtime_ctrl_x7_2044", 0x14, 0x381, 0x28, auStack_1608);
    memset(&local_608, 0, 0x510);
    local_608 = backend_init_base;
    local_604 = reset_base;
    local_5f8 = dhash_mining_start_base;
    local_5f4 = dhash_mining_stop_base;
    local_5f0 = dhash_mining_reset_x7;
    local_5ec = backend_exit_base;
    local_5e8 = push_work_base;
    local_5e4 = send_fake_work_x7;
    local_5e0 = async_push_work_base;
    local_5dc = pop_ans_base;
    local_5d8 = try_pop_ans_base;
    local_5cc = softreset_all_chip_x7;
    local_5c8 = setup_all_chip_x7;
    local_5c4 = work_2_packet_x7;
    local_5c0 = packet_2_nonce_x7;
    local_5bc = check_nonce_x7;
    local_5b8 = global_idx_init_x7;
    local_5b4 = global_idx_free_x7;
    local_5b0 = set_baud_x7;
    local_5ac = &LAB_0008b3ec;
    local_5a8 = &LAB_0008b414;
    local_5a4 = &LAB_0008b468;
    local_5a0 = &LAB_0008b490;
    local_59c = &LAB_0008b4c0;
    local_598 = &LAB_0008b4e4;
    local_594 = &LAB_0008b6d0;
    local_590 = &LAB_0008b6a4;
    local_58c = &LAB_0008b508;
    local_584 = get_chip_status_x7;
    local_580 = get_theory_hashrate_x7;
    local_57c = get_sale_hashrate_x7;
    local_578 = get_qualify_hashrate_x7;
    local_574 = get_qualify_nonce_num_x7;
    local_570 = set_sensor_extern_mode_x7;
    local_56c = read_sensor_temp_local_x7;
    local_568 = read_sensor_temp_remote_x7;
    local_564 = parameter_update_x7;
    local_560 = overclock_update_x7;
    local_55c = get_pcba_test_level_x7;
    local_558 = get_packet_remain_len_x7;
    local_54c = adjust_working_freq_x7;
    local_548 = &LAB_0008b43c;
    local_544 = set_frequency_by_temp_single_base;
    local_538 = get_chip_temperature_str_base;
    local_52c = FUN_0008aa6c;
    local_524 = FUN_0008aca4;
    local_520 = top_init_x7;
    local_518 = dhash_start_x7;
    local_4d8 = 0x3758;
    local_4d4 = 0;
    uStack_4d0 = 0;
    uStack_4cc = 0;
    local_4c8 = 0x726d78;
    local_4c4 = 0;
    local_4c0 = 0x2044;
    local_4bc = 1;
    local_4b8 = 6;
    local_4b4 = 1;
    local_4b0 = 0x20;
    local_4ac = 1;
    local_4a4 = 1;
    local_494 = DAT_0015f7b8;
    uStack_490 = DAT_0015f7bc;
    uStack_484 = sensor_info_x7_2044._0_4_;
    uStack_480 = sensor_info_x7_2044._4_4_;
    uStack_47c = sensor_info_x7_2044._8_4_;
    uStack_478 = sensor_info_x7_2044._12_4_;
    local_474 = sensor_info_x7_2044._16_4_;
    uStack_470 = sensor_info_x7_2044._20_4_;
    uStack_46c = sensor_info_x7_2044._24_4_;
    local_45c = 1;
    local_458 = 0xe;
    local_2cc = 0x188;
    local_2c8 = 0xe8;
    local_2c4 = 4;
    local_2c0 = 0xd6;
    local_2bc = 0x34;
    local_2b4 = 8;
    local_220 = 4;
    local_1b4 = 0x4b0;
    local_1a8 = 0x20000000;
    uStack_1a4 = 0;
    local_1a0 = 1;
    local_c = calloc(1, 0x510);
    memcpy(local_c, &local_608, 0x510);
    V_LOCK();
    logfmt_raw(auStack_1608, 0x1000, 0, "runtime_ctrl_x7() out");
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/backend_x7_2044.c",
        0xb3, "runtime_ctrl_x7_2044", 0x14, 0x3ef, 0x28, auStack_1608);
    return local_c;
}

int try_get_seed_status(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    int iVar1;

    iVar1 = sync_unblocked_get_seed_status_x7(param_1, 2, param_2, param_3,
                                              param_4);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    return iVar1;
}

int try_get_msg_ack(undefined4 param_1, undefined4 param_2, undefined4 param_3,
                    undefined4 param_4)

{
    int iVar1;

    iVar1 =
        sync_unblocked_get_msg_x7(param_1, 3, param_2, param_3, 0xd, param_4);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    return iVar1;
}

undefined4 check_chip_msg_ack_thread(int *param_1)

{
    pthread_t __th;
    int iVar1;
    uint uVar2;
    undefined1 auStack_11c0[4096];
    pthread_condattr_t pStack_1c0;
    int local_1bc;
    timespec local_1b8;
    undefined1 auStack_1b0[216];
    undefined4 local_d8;
    undefined4 uStack_d4;
    undefined4 uStack_d0;
    undefined4 uStack_cc;
    undefined4 local_c8;
    undefined4 uStack_c4;
    undefined4 uStack_c0;
    undefined4 uStack_bc;
    undefined4 local_b8;
    undefined4 uStack_b4;
    undefined4 uStack_b0;
    undefined4 uStack_ac;
    undefined4 local_a8;
    undefined4 uStack_a4;
    undefined4 uStack_a0;
    undefined4 uStack_9c;
    undefined4 local_98;
    undefined4 uStack_94;
    undefined4 uStack_90;
    undefined4 uStack_8c;
    undefined4 local_88;
    undefined4 uStack_84;
    undefined4 uStack_80;
    undefined4 uStack_7c;
    undefined4 local_78;
    undefined4 uStack_74;
    undefined4 uStack_70;
    undefined4 uStack_6c;
    undefined4 local_68;
    undefined4 uStack_64;
    undefined4 uStack_60;
    undefined4 uStack_5c;
    undefined4 local_58;
    undefined4 uStack_54;
    undefined4 uStack_50;
    undefined4 uStack_4c;
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    int local_38;
    int local_34;
    int local_30;
    int local_2c;
    int local_28;
    int *local_24;
    uint local_20;
    byte local_19;
    int local_18;
    int local_14;

    local_18 = *param_1;
    local_19 = *(byte *)(param_1 + 1);
    local_24 = param_1;
    memcpy(auStack_1b0, (void *)((int)param_1 + 5), 0xd6);
    local_20 = local_24[0x37];
    free(param_1);
    local_14 = *(int *)(local_18 + 0x338);
    __th = pthread_self();
    pthread_detach(__th);
    pthread_mutex_lock(
        (pthread_mutex_t *)(*(int *)(local_18 + 0xf8) * 0x18 + 0x15f808));
    if ((&DAT_0015f850)[*(int *)(local_18 + 0xf8)] != '\x01') {
        pthread_condattr_init(&pStack_1c0);
        pthread_condattr_setclock(&pStack_1c0, 1);
        pthread_cond_init((pthread_cond_t *)(msg_check_process_wakeup_cond +
                                             *(int *)(local_18 + 0xf8) * 0x30),
                          &pStack_1c0);
        (&DAT_0015f850)[*(int *)(local_18 + 0xf8)] = 1;
        DAT_0015f854 = malloc(*(int *)(local_18 + 0x150) * 0x20c);
        if (DAT_0015f854 == (void *)0x0) {
            V_LOCK();
            FUN_00089210(&local_d8, &local_d8, *(int *)(local_18 + 0xfc),
                         *(int *)(local_18 + 0xfc) >> 0x1f);
            logfmt_raw(auStack_11c0, 0x1000, 0, uStack_bc, local_d8, uStack_d4,
                       uStack_d0, uStack_cc, local_c8, uStack_c4, uStack_c0,
                       uStack_bc, "malloc failed");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "backend_x7_2044/backend_x7_2044.c",
                 0xb3, "check_chip_msg_ack_thread", 0x19, 0x43d, 0x78,
                 auStack_11c0);
            /* WARNING: Subroutine does not return */
            exit(1);
        }
    }
    if ((uint) * (byte *)(local_14 + 0xbf80) == local_19 + 1) {
        for (local_2c = 0; local_2c < 3; local_2c = local_2c + 1) {
            clock_gettime(1, &local_1b8);
            local_1b8.tv_sec = local_1b8.tv_sec + 1;
            local_34 = *(int *)(local_18 + 0x150);
            local_30 = 0;
            do {
                if (local_30 == 0x6e)
                    goto LAB_0008d298;
                pthread_mutex_lock(
                    (pthread_mutex_t *)(msg_ack_lock +
                                        *(int *)(local_18 + 0xf8) * 0x18));
                local_30 = pthread_cond_timedwait(
                    (pthread_cond_t *)(msg_check_process_wakeup_cond +
                                       *(int *)(local_18 + 0xf8) * 0x30),
                    (pthread_mutex_t *)(msg_ack_lock +
                                        *(int *)(local_18 + 0xf8) * 0x18),
                    &local_1b8);
                if ((uint) * (byte *)(local_14 + 0xbf80) != local_19 + 1) {
                    pthread_mutex_unlock(
                        (pthread_mutex_t *)(msg_ack_lock +
                                            *(int *)(local_18 + 0xf8) * 0x18));
                    V_LOCK();
                    FUN_00089210(&local_b8, &local_b8,
                                 *(int *)(local_18 + 0xfc),
                                 *(int *)(local_18 + 0xfc) >> 0x1f);
                    logfmt_raw(auStack_11c0, 0x1000, 0, uStack_9c, local_b8,
                               uStack_b4, uStack_b0, uStack_ac, local_a8,
                               uStack_a4, uStack_a0, uStack_9c,
                               "msg debug: new msg come");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/backend_x7_2044/backend_x7_2044.c",
                         0xb3, "check_chip_msg_ack_thread", 0x19, 0x454, 0x14,
                         auStack_11c0);
                    goto LAB_0008d2b8;
                }
                pthread_mutex_unlock(
                    (pthread_mutex_t *)(msg_ack_lock +
                                        *(int *)(local_18 + 0xf8) * 0x18));
                local_38 = try_get_msg_ack(local_18, local_34, DAT_0015f854,
                                           &local_1bc);
                if (local_38 != 0) {
                    V_LOCK();
                    FUN_00089210(&local_98, &local_98,
                                 *(int *)(local_18 + 0xfc),
                                 *(int *)(local_18 + 0xfc) >> 0x1f);
                    logfmt_raw(auStack_11c0, 0x1000, 0, uStack_7c, local_98,
                               uStack_94, uStack_90, uStack_8c, local_88,
                               uStack_84, uStack_80, uStack_7c,
                               "err while try_get_msg_ack, code %d", local_38);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/backend_x7_2044/backend_x7_2044.c",
                         0xb3, "check_chip_msg_ack_thread", 0x19, 0x45c, 100,
                         auStack_11c0);
                    goto LAB_0008d298;
                }
                for (local_28 = 0; local_28 < local_1bc;
                     local_28 = local_28 + 1) {
                    if (local_19 ==
                        *(byte *)((int)DAT_0015f854 + local_28 * 0x20c + 0xc)) {
                        local_34 = local_34 + -1;
                    }
                }
                if (local_34 < 1) {
                    V_LOCK();
                    FUN_00089210(&local_78, &local_78,
                                 *(int *)(local_18 + 0xfc),
                                 *(int *)(local_18 + 0xfc) >> 0x1f);
                    logfmt_raw(auStack_11c0, 0x1000, 0, uStack_5c, local_78,
                               uStack_74, uStack_70, uStack_6c, local_68,
                               uStack_64, uStack_60, uStack_5c,
                               "msg debug: msg ack success");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/backend_x7_2044/backend_x7_2044.c",
                         0xb3, "check_chip_msg_ack_thread", 0x19, 0x46a, 0x14,
                         auStack_11c0);
                    goto LAB_0008d2b8;
                }
            } while (local_30 != 0x6e);
            V_LOCK();
            FUN_00089210(&local_58, &local_58, *(int *)(local_18 + 0xfc),
                         *(int *)(local_18 + 0xfc) >> 0x1f);
            logfmt_raw(
                auStack_11c0, 0x1000, 0, uStack_3c, local_58, uStack_54,
                uStack_50, uStack_4c, local_48, uStack_44, uStack_40, uStack_3c,
                "msg ack expired, resend msg remain_packet_num:%d", local_34);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "backend_x7_2044/backend_x7_2044.c",
                 0xb3, "check_chip_msg_ack_thread", 0x19, 0x470, 0x28,
                 auStack_11c0);
            pthread_mutex_lock((pthread_mutex_t *)(local_18 + 0x430));
            do {
                iVar1 = dev_ctrl();
                uVar2 = (**(code **)(iVar1 + 0x44))(
                    *(undefined4 *)(local_18 + 0xf8));
            } while (uVar2 < local_20);
            iVar1 = dev_ctrl();
            (**(code **)(iVar1 + 0x34))(*(undefined4 *)(local_18 + 0xf8),
                                        auStack_1b0, local_20);
            pthread_mutex_unlock((pthread_mutex_t *)(local_18 + 0x430));
        LAB_0008d298:
        }
    }
LAB_0008d2b8:
    pthread_mutex_unlock(
        (pthread_mutex_t *)(*(int *)(local_18 + 0xf8) * 0x18 + 0x15f808));
    return 0;
}

undefined4 check_chip_msg_ack_x7(int param_1, void *param_2, int param_3)

{
    undefined1 auStack_103c[4096];
    pthread_t pStack_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    int *local_14;

    local_14 = (int *)malloc(0xe0);
    if (local_14 == (int *)0x0) {
        V_LOCK();
        FUN_00089210(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_103c, 0x1000, 0, uStack_1c, local_38, uStack_34,
                   uStack_30, uStack_2c, local_28, uStack_24, uStack_20,
                   uStack_1c, "malloc failed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "backend_x7_2044.c",
             0xb3, "check_chip_msg_ack_x7", 0x15, 0x48b, 0x78, auStack_103c);
        /* WARNING: Subroutine does not return */
        exit(1);
    }
    *local_14 = param_1;
    *(undefined1 *)(local_14 + 1) = *(undefined1 *)((int)param_2 + 8);
    memcpy((void *)((int)local_14 + 5), param_2, 0xd6);
    local_14[0x37] = param_3;
    pthread_create(&pStack_3c, (pthread_attr_t *)0x0, check_chip_msg_ack_thread,
                   local_14);
    return 0;
}

undefined4 x7_chip_seed_status_init(int param_1)

{
    void *pvVar1;
    undefined4 uVar2;
    int iVar3;
    undefined1 auStack_1014[4096];
    int local_14;

    if ((&DAT_0015f7b4)[*(int *)(param_1 + 0xfc)] == '\0') {
        iVar3 = *(int *)(param_1 + 0xf8);
        pvVar1 = calloc(1, *(int *)(param_1 + 0x150) * 0x4c);
        *(void **)(x7_chip_seed_status + iVar3 * 4) = pvVar1;
        if (*(int *)(x7_chip_seed_status + *(int *)(param_1 + 0xf8) * 4) == 0) {
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0, "%s malloc failed",
                       "x7_chip_seed_status_init");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "backend_x7_2044/backend_x7_2044.c",
                 0xb3, "x7_chip_seed_status_init", 0x18, 0x4a5, 0x78,
                 auStack_1014);
            /* WARNING: Subroutine does not return */
            exit(-1);
        }
        for (local_14 = 0; local_14 < *(int *)(param_1 + 0x150);
             local_14 = local_14 + 1) {
            pthread_mutex_init(
                (pthread_mutex_t *)(*(int *)(x7_chip_seed_status +
                                             *(int *)(param_1 + 0xf8) * 4) +
                                    local_14 * 0x4c + 0x34),
                (pthread_mutexattr_t *)0x0);
        }
        (&DAT_0015f7b4)[*(int *)(param_1 + 0xfc)] = 1;
        uVar2 = 0;
    } else {
        uVar2 = 0xc9;
    }
    return uVar2;
}

undefined4 reset_chip_seed_status(int param_1, byte param_2)

{
    undefined4 uVar1;
    undefined1 auStack_100c[4096];
    timespec *local_c;

    if ((&DAT_0015f7b4)[*(int *)(param_1 + 0xfc)] == '\x01') {
        pthread_mutex_lock(
            (pthread_mutex_t *)(*(int *)(x7_chip_seed_status +
                                         *(int *)(param_1 + 0xf8) * 4) +
                                (uint)param_2 * 0x4c + 0x34));
        *(undefined1 *)(*(int *)(x7_chip_seed_status +
                                 *(int *)(param_1 + 0xf8) * 4) +
                        (uint)param_2 * 0x4c) = 0;
        *(undefined1 *)(*(int *)(x7_chip_seed_status +
                                 *(int *)(param_1 + 0xf8) * 4) +
                        (uint)param_2 * 0x4c + 0x21) = 0;
        memset((void *)(*(int *)(x7_chip_seed_status +
                                 *(int *)(param_1 + 0xf8) * 4) +
                        (uint)param_2 * 0x4c + 1),
               0, 0x20);
        local_c = (timespec *)(*(int *)(x7_chip_seed_status +
                                        *(int *)(param_1 + 0xf8) * 4) +
                               (uint)param_2 * 0x4c + 0x24);
        clock_gettime(1, local_c);
        pthread_mutex_unlock(
            (pthread_mutex_t *)(*(int *)(x7_chip_seed_status +
                                         *(int *)(param_1 + 0xf8) * 4) +
                                (uint)param_2 * 0x4c + 0x34));
        uVar1 = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0,
                   "%s chip_seed_status used before init",
                   "reset_chip_seed_status");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "backend_x7_2044.c",
             0xb3, "reset_chip_seed_status", 0x16, 0x4c5, 100, auStack_100c);
        uVar1 = 0x6e;
    }
    return uVar1;
}

undefined4 chip_seed_status_set_calculating(int param_1, byte param_2)

{
    undefined4 uVar1;
    undefined1 auStack_100c[4096];
    timespec *local_c;

    if ((&DAT_0015f7b4)[*(int *)(param_1 + 0xfc)] == '\x01') {
        pthread_mutex_lock(
            (pthread_mutex_t *)(*(int *)(x7_chip_seed_status +
                                         *(int *)(param_1 + 0xf8) * 4) +
                                (uint)param_2 * 0x4c + 0x34));
        *(undefined1 *)(*(int *)(x7_chip_seed_status +
                                 *(int *)(param_1 + 0xf8) * 4) +
                        (uint)param_2 * 0x4c + 0x22) = 1;
        *(undefined1 *)(*(int *)(x7_chip_seed_status +
                                 *(int *)(param_1 + 0xf8) * 4) +
                        (uint)param_2 * 0x4c + 0x21) = 1;
        local_c = (timespec *)(*(int *)(x7_chip_seed_status +
                                        *(int *)(param_1 + 0xf8) * 4) +
                               (uint)param_2 * 0x4c + 0x24);
        clock_gettime(1, local_c);
        pthread_mutex_unlock(
            (pthread_mutex_t *)(*(int *)(x7_chip_seed_status +
                                         *(int *)(param_1 + 0xf8) * 4) +
                                (uint)param_2 * 0x4c + 0x34));
        uVar1 = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0,
                   "%s chip_seed_status used before init",
                   "chip_seed_status_set_calculating");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "backend_x7_2044.c",
             0xb3, "chip_seed_status_set_calculating", 0x20, 0x4d9, 100,
             auStack_100c);
        uVar1 = 0x6e;
    }
    return uVar1;
}

undefined4 update_seed_status_receive_ack(int param_1, byte param_2,
                                          void *param_3)

{
    undefined4 uVar1;
    undefined1 auStack_1008[4096];

    if ((&DAT_0015f7b4)[*(int *)(param_1 + 0xfc)] == '\x01') {
        pthread_mutex_lock(
            (pthread_mutex_t *)(*(int *)(x7_chip_seed_status +
                                         *(int *)(param_1 + 0xf8) * 4) +
                                (uint)param_2 * 0x4c + 0x34));
        *(undefined1 *)(*(int *)(x7_chip_seed_status +
                                 *(int *)(param_1 + 0xf8) * 4) +
                        0x23) = 1;
        *(undefined1 *)(*(int *)(x7_chip_seed_status +
                                 *(int *)(param_1 + 0xf8) * 4) +
                        (uint)param_2 * 0x4c + 0x22) = 1;
        *(undefined1 *)(*(int *)(x7_chip_seed_status +
                                 *(int *)(param_1 + 0xf8) * 4) +
                        (uint)param_2 * 0x4c) = 1;
        *(undefined1 *)(*(int *)(x7_chip_seed_status +
                                 *(int *)(param_1 + 0xf8) * 4) +
                        (uint)param_2 * 0x4c + 0x21) = 0;
        memcpy((void *)(*(int *)(x7_chip_seed_status +
                                 *(int *)(param_1 + 0xf8) * 4) +
                        (uint)param_2 * 0x4c + 1),
               param_3, 0x20);
        pthread_mutex_unlock(
            (pthread_mutex_t *)(*(int *)(x7_chip_seed_status +
                                         *(int *)(param_1 + 0xf8) * 4) +
                                (uint)param_2 * 0x4c + 0x34));
        uVar1 = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0,
                   "%s chip_seed_status used before init",
                   "update_seed_status_receive_ack");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "backend_x7_2044.c",
             0xb3, "update_seed_status_receive_ack", 0x1e, 0x4eb, 100,
             auStack_1008);
        uVar1 = 0x6e;
    }
    return uVar1;
}

undefined4 update_seed_status_expired(int param_1, byte param_2)

{
    undefined4 uVar1;
    int iVar2;
    bool bVar3;
    uint uVar4;
    undefined8 uVar5;
    undefined1 auStack_1038[4096];
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    undefined4 local_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    int *local_14;

    if ((&DAT_0015f7b4)[*(int *)(param_1 + 0xfc)] == '\x01') {
        pthread_mutex_lock(
            (pthread_mutex_t *)(*(int *)(x7_chip_seed_status +
                                         *(int *)(param_1 + 0xf8) * 4) +
                                (uint)param_2 * 0x4c + 0x34));
        if (*(char *)(*(int *)(x7_chip_seed_status +
                               *(int *)(param_1 + 0xf8) * 4) +
                      (uint)param_2 * 0x4c + 0x21) != '\0') {
            iVar2 =
                *(int *)(x7_chip_seed_status + *(int *)(param_1 + 0xf8) * 4) +
                (uint)param_2 * 0x4c;
            local_14 = (int *)(iVar2 + 0x24);
            clock_gettime(1, (timespec *)(iVar2 + 0x2c));
            iVar2 = local_14[2] - *local_14;
            uVar5 = VectorShiftLeft((longlong)iVar2, 5, 0x40, 0);
            uVar5 = VectorSub(uVar5, (longlong)iVar2, 8);
            uVar5 = VectorAdd(uVar5, uVar5, 8);
            uVar4 = (uint)uVar5;
            uVar5 = VectorAdd(CONCAT44((int)((ulonglong)uVar5 >> 0x20) * 2 +
                                           (uint)CARRY4(uVar4, uVar4),
                                       uVar4 * 2),
                              (longlong)iVar2, 8);
            uVar5 = VectorShiftLeft(uVar5, 3, 0x40, 0);
            uVar4 = (local_14[3] - local_14[1]) / 1000000;
            iVar2 = ((int)uVar4 >> 0x1f) + (int)((ulonglong)uVar5 >> 0x20) +
                    (uint)CARRY4(uVar4, (uint)uVar5);
            bVar3 = "time" < (char *)(uVar4 + (uint)uVar5);
            if (0 < (int)(iVar2 + (uint)bVar3) !=
                SBORROW4(-iVar2, (uint)bVar3)) {
                V_LOCK();
                FUN_00089210(&local_38, &local_38, *(int *)(param_1 + 0xfc),
                             *(int *)(param_1 + 0xfc) >> 0x1f);
                logfmt_raw(auStack_1038, 0x1000, 0, uStack_1c, local_38,
                           uStack_34, uStack_30, uStack_2c, local_28, uStack_24,
                           uStack_20, uStack_1c,
                           "seed calculating response expired");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "backend_x7_2044/backend_x7_2044.c",
                     0xb3, "update_seed_status_expired", 0x1a, 0x509, 0x50,
                     auStack_1038);
                *(undefined1 *)(*(int *)(x7_chip_seed_status +
                                         *(int *)(param_1 + 0xf8) * 4) +
                                (uint)param_2 * 0x4c + 0x21) = 0;
            }
        }
        pthread_mutex_unlock(
            (pthread_mutex_t *)(*(int *)(x7_chip_seed_status +
                                         *(int *)(param_1 + 0xf8) * 4) +
                                (uint)param_2 * 0x4c + 0x34));
        uVar1 = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1038, 0x1000, 0,
                   "%s chip_seed_status used before init",
                   "update_seed_status_expired");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "backend_x7_2044.c",
             0xb3, "update_seed_status_expired", 0x1a, 0x500, 100,
             auStack_1038);
        uVar1 = 0x6e;
    }
    return uVar1;
}

undefined4 update_outdated_chip_seed(int param_1, byte param_2)

{
    int iVar1;
    undefined4 uVar2;
    undefined1 auStack_1008[4096];

    if ((&DAT_0015f7b4)[*(int *)(param_1 + 0xfc)] == '\x01') {
        pthread_mutex_lock(
            (pthread_mutex_t *)(*(int *)(x7_chip_seed_status +
                                         *(int *)(param_1 + 0xf8) * 4) +
                                (uint)param_2 * 0x4c + 0x34));
        if ((*(char *)(*(int *)(x7_chip_seed_status +
                                *(int *)(param_1 + 0xf8) * 4) +
                       (uint)param_2 * 0x4c + 0x21) == '\x01') ||
            (iVar1 = memcmp((void *)(*(int *)(x7_chip_seed_status +
                                              *(int *)(param_1 + 0xf8) * 4) +
                                     (uint)param_2 * 0x4c + 1),
                            last_seed_hash_x7 + *(int *)(param_1 + 0xf8) * 0x20,
                            0x20),
             iVar1 == 0)) {
            pthread_mutex_unlock(
                (pthread_mutex_t *)(*(int *)(x7_chip_seed_status +
                                             *(int *)(param_1 + 0xf8) * 4) +
                                    (uint)param_2 * 0x4c + 0x34));
        } else {
            chip_setting_seed_x7(
                param_1, last_seed_hash_x7 + *(int *)(param_1 + 0xf8) * 0x20,
                0x20, auStack_1008, param_2);
            pthread_mutex_unlock(
                (pthread_mutex_t *)(*(int *)(x7_chip_seed_status +
                                             *(int *)(param_1 + 0xf8) * 4) +
                                    (uint)param_2 * 0x4c + 0x34));
            chip_seed_status_set_calculating(param_1, param_2);
        }
        uVar2 = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0,
                   "%s chip_seed_status used before init",
                   "update_outdated_chip_seed");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "backend_x7_2044.c",
             0xb3, "update_outdated_chip_seed", 0x19, 0x516, 100, auStack_1008);
        uVar2 = 0x6e;
    }
    return uVar2;
}

undefined4 scanseed(int param_1)

{
    undefined1 auStack_1274[4096];
    int local_274;
    undefined1 auStack_270[3];
    byte local_26d;
    undefined1 auStack_264[500];
    undefined4 local_70;
    undefined4 uStack_6c;
    undefined4 uStack_68;
    undefined4 uStack_64;
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    byte local_29;
    int local_28;
    undefined1 *local_24;
    int local_20;
    int local_1c;
    int local_18;
    uint local_14;

    local_20 = *(int *)(param_1 + 0x508);
    local_24 = (undefined1 *)0x0;
    local_1c = param_1;
    memset(auStack_270, 0, 0x200);
    do {
        do {
            if (*(char *)(local_20 + 8) != '\0') {
                *(undefined1 *)(local_20 + 8) = 0;
                return 0;
            }
            for (local_18 = 0; local_18 < 10; local_18 = local_18 + 1) {
                if (*(char *)(local_1c + 0x102) != '\0') {
                    do {
                        if (*(char *)(local_20 + 8) != '\0') {
                            *(undefined1 *)(local_20 + 8) = 0;
                            return 0;
                        }
                        local_274 = 0;
                        local_28 = try_get_seed_status(local_1c, 1, auStack_270,
                                                       &local_274);
                        if (local_28 != 0) {
                            V_LOCK();
                            FUN_00089210(&local_70, &local_70,
                                         *(int *)(local_1c + 0xfc),
                                         *(int *)(local_1c + 0xfc) >> 0x1f);
                            logfmt_raw(auStack_1274, 0x1000, 0, uStack_54,
                                       local_70, uStack_6c, uStack_68,
                                       uStack_64, local_60, uStack_5c,
                                       uStack_58, uStack_54,
                                       "get seed err, code %d", local_28);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/backend/"
                                 "backend_x7_2044/backend_x7_2044.c",
                                 0xb3, "scanseed", 8, 0x546, 100, auStack_1274);
                        }
                        if (local_274 != 0) {
                            local_24 = auStack_270;
                            local_29 = local_26d;
                            if ((int)(uint)local_26d <
                                *(int *)(local_1c + 0x150)) {
                                update_seed_status_receive_ack(
                                    local_1c, local_26d, auStack_264);
                                pthread_mutex_lock(
                                    (pthread_mutex_t *)(last_work_lock +
                                                        *(int *)(local_1c +
                                                                 0xf8) *
                                                            0x18));
                                chip_setting_msg_x7(
                                    local_1c,
                                    last_work_packet +
                                        *(int *)(local_1c + 0xf8) * 0xd6,
                                    *(uint *)(last_work_len +
                                              *(int *)(local_1c + 0xf8) * 4) &
                                        0xff,
                                    local_29);
                                pthread_mutex_unlock(
                                    (pthread_mutex_t *)(last_work_lock +
                                                        *(int *)(local_1c +
                                                                 0xf8) *
                                                            0x18));
                            } else {
                                V_LOCK();
                                FUN_00089210(&local_50, &local_50,
                                             *(int *)(local_1c + 0xfc),
                                             *(int *)(local_1c + 0xfc) >> 0x1f);
                                logfmt_raw(auStack_1274, 0x1000, 0, uStack_34,
                                           local_50, uStack_4c, uStack_48,
                                           uStack_44, local_40, uStack_3c,
                                           uStack_38, uStack_34,
                                           "chip_id %d is invalid", local_29);
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/backend/"
                                     "backend_x7_2044/backend_x7_2044.c",
                                     0xb3, "scanseed", 8, 0x54f, 100,
                                     auStack_1274);
                            }
                        }
                    } while (local_274 != 0);
                }
                usleep(500000);
            }
        } while (*(char *)(local_1c + 0x102) == '\0');
        for (local_14 = 0; (int)local_14 < *(int *)(local_1c + 0x150);
             local_14 = local_14 + 1) {
            if (*(char *)(local_20 + 8) != '\0') {
                *(undefined1 *)(local_20 + 8) = 0;
                return 0;
            }
            update_seed_status_expired(local_1c, local_14 & 0xff);
            update_outdated_chip_seed(local_1c, local_14 & 0xff);
        }
    } while (true);
}

undefined4 scan_rxu_hang(int param_1)

{
    undefined4 extraout_r3;
    float fVar1;
    undefined1 auStack_1294[4096];
    int local_294[5];
    undefined1 auStack_280[512];
    undefined4 local_80;
    undefined4 uStack_7c;
    undefined4 uStack_78;
    undefined4 uStack_74;
    undefined4 local_70;
    undefined4 uStack_6c;
    undefined4 uStack_68;
    undefined4 uStack_64;
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    int local_40;
    void *local_3c;
    void *local_38;
    undefined4 local_34;
    int local_30;
    int local_2c;
    int local_28;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;

    local_30 = *(int *)(param_1 + 0x508);
    local_34 = 0;
    local_2c = param_1;
    memset(auStack_280, 0, 0x200);
    local_18 = 0;
    local_14 = 1;
    local_38 = calloc(1, *(int *)(local_2c + 0x150) << 3);
    local_3c = calloc(1, *(int *)(local_2c + 0x150) * 0xc);
    while (*(char *)(local_30 + 9) == '\0') {
        if (*(char *)(local_2c + 0x102) != '\0') {
            if (local_18 == 1) {
                local_40 = read_rxu_status_x7(local_2c, local_3c, local_294);
                if (local_40 != 0) {
                    V_LOCK();
                    FUN_00089210(&local_80, &local_80,
                                 *(int *)(local_2c + 0xfc),
                                 *(int *)(local_2c + 0xfc) >> 0x1f);
                    logfmt_raw(auStack_1294, 0x1000, 0, uStack_64, local_80,
                               uStack_7c, uStack_78, uStack_74, local_70,
                               uStack_6c, uStack_68, uStack_64,
                               "read_rxu_status_x7 err, code %d", local_40);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/backend_x7_2044/backend_x7_2044.c",
                         0xb3, "scan_rxu_hang", 0xd, 0x598, 100, auStack_1294);
                }
                local_1c = 0;
                local_20 = 0;
                for (local_24 = 0; local_24 < local_294[0];
                     local_24 = local_24 + 1) {
                    if (*(int *)((int)local_3c + local_24 * 0xc) <
                        *(int *)(local_2c + 0x150)) {
                        local_1c = local_1c +
                                   *(int *)((int)local_3c + local_24 * 0xc + 4);
                        *(int *)((int)local_38 +
                                 *(int *)((int)local_3c + local_24 * 0xc) * 8) =
                            *(int *)((int)local_38 +
                                     *(int *)((int)local_3c + local_24 * 0xc) *
                                         8) +
                            *(int *)((int)local_3c + local_24 * 0xc + 4);
                        *(float *)((int)local_38 +
                                   *(int *)((int)local_3c + local_24 * 0xc) *
                                       8 +
                                   4) =
                            (float)((double)*(
                                        float *)((int)local_38 +
                                                 *(int *)((int)local_3c +
                                                          local_24 * 0xc) *
                                                     8 +
                                                 4) +
                                    (double)(longlong) *
                                        (int *)((int)local_3c + local_24 * 0xc +
                                                4) *
                                        0.4);
                        if ((double)*(float *)((int)local_38 +
                                               *(int *)((int)local_3c +
                                                        local_24 * 0xc) *
                                                   8 +
                                               4) <=
                            (double)(longlong) *
                                    (int *)((int)local_38 +
                                            *(int *)((int)local_3c +
                                                     local_24 * 0xc) *
                                                8) +
                                0.001) {
                            fVar1 = *(float *)((int)local_38 +
                                               *(int *)((int)local_3c +
                                                        local_24 * 0xc) *
                                                   8 +
                                               4);
                        } else {
                            fVar1 =
                                (float)((double)(longlong) *
                                            (int *)((int)local_38 +
                                                    *(int *)((int)local_3c +
                                                             local_24 * 0xc) *
                                                        8) +
                                        0.001);
                        }
                        *(float *)((int)local_38 +
                                   *(int *)((int)local_3c + local_24 * 0xc) *
                                       8 +
                                   4) = fVar1;
                        local_20 = local_20 +
                                   (int)*(float *)((int)local_38 +
                                                   *(int *)((int)local_3c +
                                                            local_24 * 0xc) *
                                                       8 +
                                                   4);
                    }
                }
                if (local_1c - local_20 < 1) {
                    usleep(480000000);
                } else {
                    local_14 = 2;
                    V_LOCK();
                    FUN_00089210(&local_60, &local_60,
                                 *(int *)(local_2c + 0xfc),
                                 *(int *)(local_2c + 0xfc) >> 0x1f);
                    logfmt_raw(auStack_1294, 0x1000, 0, uStack_44, local_60,
                               uStack_5c, uStack_58, uStack_54, local_50,
                               uStack_4c, uStack_48, uStack_44,
                               "%d rxu hang, prepare to restart chip",
                               local_1c);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/backend_x7_2044/backend_x7_2044.c",
                         0xb3, "scan_rxu_hang", 0xd, 0x5bc, 0x28, auStack_1294);
                }
            } else if (local_18 == 0) {
                usleep(480000000);
                local_14 = 1;
            } else if (local_18 == 2) {
                for (local_28 = 0; local_28 < *(int *)(local_2c + 0x150);
                     local_28 = local_28 + 1) {
                    if (*(float *)((int)local_38 +
                                   *(int *)((int)local_3c + local_28 * 0xc) *
                                       8 +
                                   4) <
                        (float)(longlong) *
                            (int *)((int)local_38 +
                                    *(int *)((int)local_3c + local_28 * 0xc) *
                                        8)) {
                        *(undefined1 *)(local_2c + 0x448) = 1;
                        *(undefined4 *)((int)local_38 +
                                        *(int *)((int)local_3c +
                                                 local_28 * 0xc) *
                                            8) = 0;
                        local_40 = restart_one_chip_x7(
                            local_2c,
                            *(undefined4 *)((int)local_3c + local_28 * 0xc));
                        *(undefined1 *)(local_2c + 0x448) = 0;
                        pthread_mutex_lock(
                            (pthread_mutex_t
                                 *)(*(int *)(x7_chip_seed_status +
                                             *(int *)(local_2c + 0xf8) * 4) +
                                    *(int *)((int)local_3c + local_28 * 0xc) *
                                        0x4c +
                                    0x34));
                        chip_setting_seed_x7(
                            local_2c,
                            last_seed_hash_x7 +
                                *(int *)(local_2c + 0xf8) * 0x20,
                            0x20, auStack_1294,
                            *(uint *)((int)local_3c + local_28 * 0xc) & 0xff);
                        pthread_mutex_unlock(
                            (pthread_mutex_t
                                 *)(*(int *)(x7_chip_seed_status +
                                             *(int *)(local_2c + 0xf8) * 4) +
                                    *(int *)((int)local_3c + local_28 * 0xc) *
                                        0x4c +
                                    0x34));
                        reset_chip_seed_status(
                            local_2c,
                            *(uint *)((int)local_3c + local_28 * 0xc) & 0xff);
                        chip_seed_status_set_calculating(
                            local_2c,
                            *(uint *)((int)local_3c + local_28 * 0xc) & 0xff);
                        sleep(0xf);
                    }
                }
                usleep(480000000);
                local_14 = 1;
            }
            local_18 = local_14;
        }
        usleep(500000);
    }
    *(undefined1 *)(local_30 + 9) = 0;
    free(local_38);
    free(local_3c);
    return extraout_r3;
}

undefined4 backend_init_x7(void *param_1)

{
    void *pvVar1;
    int iVar2;
    undefined4 uVar3;
    pthread_t *__newthread;
    int local_c;

    pvVar1 = calloc(1, 0xc);
    *(void **)((int)param_1 + 0x508) = pvVar1;
    __newthread = *(pthread_t **)((int)param_1 + 0x508);
    iVar2 = dev_ctrl();
    uVar3 = (**(code **)(iVar2 + 0x30))(*(undefined4 *)((int)param_1 + 0xf8));
    *(undefined4 *)((int)param_1 + 0xfc) = uVar3;
    iVar2 = dev_ctrl();
    (**(code **)(iVar2 + 0x2c))(*(undefined4 *)((int)param_1 + 0xf8));
    iVar2 = dev_ctrl();
    (**(code **)(iVar2 + 4))(*(undefined4 *)((int)param_1 + 0xf8));
    uVar3 = queue_new(1, 0);
    *(undefined4 *)((int)param_1 + 0x35c) = uVar3;
    uVar3 = queue_new(*(undefined4 *)((int)param_1 + 0x340), 0);
    *(undefined4 *)((int)param_1 + 0x360) = uVar3;
    uVar3 = queue_new(1, 0);
    *(undefined4 *)((int)param_1 + 0x364) = uVar3;
    local_c = 0;
    while (true) {
        if (*(int *)((int)param_1 + 1000) <= local_c)
            break;
        uVar3 = queue_new(1, 0);
        *(undefined4 *)((int)param_1 + (local_c + 0xda) * 4) = uVar3;
        local_c = local_c + 1;
    }
    uVar3 = queue_new(*(undefined4 *)((int)param_1 + 0x33c), 0);
    *(undefined4 *)((int)param_1 + 0x358) = uVar3;
    pthread_mutex_init((pthread_mutex_t *)((int)param_1 + 0x400),
                       (pthread_mutexattr_t *)0x0);
    pthread_mutex_init((pthread_mutex_t *)((int)param_1 + 0x418),
                       (pthread_mutexattr_t *)0x0);
    pthread_mutex_init((pthread_mutex_t *)((int)param_1 + 0x430),
                       (pthread_mutexattr_t *)0x0);
    pvVar1 = calloc(*(size_t *)((int)param_1 + 0x150), 1);
    *(void **)((int)param_1 + 0x1ec) = pvVar1;
    pvVar1 = calloc(*(size_t *)((int)param_1 + 0x150), 4);
    *(void **)((int)param_1 + 0x1e0) = pvVar1;
    pvVar1 = calloc(
        *(int *)((int)param_1 + 0x150) * *(int *)((int)param_1 + 0x158), 4);
    *(void **)((int)param_1 + 0x1e4) = pvVar1;
    pvVar1 = calloc(*(size_t *)((int)param_1 + 0x150),
                    *(int *)((int)param_1 + 0x344) << 1);
    *(void **)((int)param_1 + 0x1e8) = pvVar1;
    pvVar1 = calloc(*(size_t *)((int)param_1 + 0x150), 0x30);
    *(void **)((int)param_1 + 0x1c8) = pvVar1;
    *(undefined8 *)((int)param_1 + 0x1b8) = 0;
    *(undefined8 *)((int)param_1 + 0x1c0) = 0;
    *(undefined4 *)((int)param_1 + 0x1ac) = 0xffffffff;
    *(undefined1 *)((int)param_1 + 0x1cc) = 0;
    *(undefined4 *)((int)param_1 + 0x1d0) = 0;
    *(undefined4 *)((int)param_1 + 0x1d8) = 0;
    *(undefined4 *)((int)param_1 + 0x1dc) = 0;
    *(undefined4 *)((int)param_1 + 0x1f0) = 0;
    *(undefined4 *)((int)param_1 + 0x200) = 0;
    if (*(int *)((int)param_1 + 0x350) != 0) {
        pvVar1 = calloc(*(size_t *)((int)param_1 + 0x150),
                        *(size_t *)((int)param_1 + 0x350));
        *(void **)((int)param_1 + 0x204) = pvVar1;
    }
    *(undefined4 *)((int)param_1 + 0x208) = 0;
    memset((void *)((int)param_1 + 0x238), 0, 0x100);
    *(undefined1 *)((int)param_1 + 0x3fc) = 0;
    *(undefined1 *)((int)param_1 + 0x3fd) = 0;
    *(undefined1 *)((int)param_1 + 0x3fe) = 0;
    *(undefined1 *)(__newthread + 2) = 0;
    *(undefined1 *)((int)__newthread + 9) = 0;
    if (*(int *)((int)param_1 + 0x3ec) == 0) {
        *(void **)((int)param_1 + 0x3ec) = param_1;
    }
    if (*(int *)((int)param_1 + 0x50) != 0) {
        (**(code **)((int)param_1 + 0x50))(param_1);
    }
    x7_chip_seed_status_init(param_1);
    pthread_create((pthread_t *)((int)param_1 + 0x3f4), (pthread_attr_t *)0x0,
                   get_response, param_1);
    pthread_create((pthread_t *)((int)param_1 + 0x3f0), (pthread_attr_t *)0x0,
                   scanhash, param_1);
    if (*(char *)((int)__newthread + 10) != '\0') {
        pthread_create(__newthread, (pthread_attr_t *)0x0, scanseed, param_1);
        pthread_create(__newthread + 1, (pthread_attr_t *)0x0, scan_rxu_hang,
                       param_1);
    }
    pthread_create((pthread_t *)((int)param_1 + 0x3f8), (pthread_attr_t *)0x0,
                   send_work, param_1);
    *(undefined1 *)((int)param_1 + 0x100) = 1;
    return 0;
}

undefined4 backend_exit_x7(int param_1)

{
    int iVar1;
    void *pvStack_18;
    pthread_t *local_14;
    int local_10;
    int local_c;

    local_14 = *(pthread_t **)(param_1 + 0x508);
    *(undefined1 *)(param_1 + 0x101) = 0;
    *(undefined1 *)(param_1 + 0x102) = 0;
    *(undefined1 *)(param_1 + 0x100) = 0;
    (**(code **)(param_1 + 0x3c))(param_1);
    if (*(int *)(param_1 + 0x54) != 0) {
        (**(code **)(param_1 + 0x54))(param_1);
    }
    *(undefined1 *)(param_1 + 0x3fc) = 1;
    *(undefined1 *)(local_14 + 2) = 1;
    *(undefined1 *)((int)local_14 + 9) = 1;
    *(undefined1 *)(param_1 + 0x3fd) = 1;
    *(undefined1 *)(param_1 + 0x3fe) = 1;
    queue_force_wakeup(*(undefined4 *)(param_1 + 0x35c));
    queue_force_wakeup(*(undefined4 *)(param_1 + 0x360));
    queue_force_wakeup(*(undefined4 *)(param_1 + 0x364));
    for (local_c = 0; local_c < *(int *)(param_1 + 1000);
         local_c = local_c + 1) {
        queue_force_wakeup(*(undefined4 *)(param_1 + (local_c + 0xda) * 4));
    }
    queue_force_wakeup(*(undefined4 *)(param_1 + 0x358));
    pthread_join(*(pthread_t *)(param_1 + 0x3f4), &pvStack_18);
    pthread_join(*(pthread_t *)(param_1 + 0x3f0), &pvStack_18);
    if (*(char *)((int)local_14 + 10) != '\0') {
        pthread_join(*local_14, &pvStack_18);
        pthread_join(local_14[1], &pvStack_18);
    }
    pthread_join(*(pthread_t *)(param_1 + 0x3f8), &pvStack_18);
    pthread_mutex_destroy((pthread_mutex_t *)(param_1 + 0x400));
    pthread_mutex_destroy((pthread_mutex_t *)(param_1 + 0x418));
    pthread_mutex_destroy((pthread_mutex_t *)(param_1 + 0x430));
    queue_free(*(undefined4 *)(param_1 + 0x35c));
    queue_free(*(undefined4 *)(param_1 + 0x360));
    queue_free(*(undefined4 *)(param_1 + 0x364));
    for (local_10 = 0; local_10 < *(int *)(param_1 + 1000);
         local_10 = local_10 + 1) {
        queue_free(*(undefined4 *)(param_1 + (local_10 + 0xda) * 4));
    }
    queue_free(*(undefined4 *)(param_1 + 0x358));
    free(*(void **)(param_1 + 0x1ec));
    free(*(void **)(param_1 + 0x1e0));
    free(*(void **)(param_1 + 0x1e8));
    free(*(void **)(param_1 + 0x1c8));
    free(*(void **)(param_1 + 0x1e4));
    if (*(int *)(param_1 + 0x350) != 0) {
        free(*(void **)(param_1 + 0x204));
    }
    *(undefined4 *)(param_1 + 0x208) = 0;
    *(undefined4 *)(param_1 + 0x1ac) = 0xffffffff;
    *(undefined8 *)(param_1 + 0x1b8) = 0;
    *(undefined8 *)(param_1 + 0x1c0) = 0;
    *(undefined4 *)(param_1 + 0x3ec) = 0;
    free(local_14);
    iVar1 = dev_ctrl();
    (**(code **)(iVar1 + 0x1c))(*(undefined4 *)(param_1 + 0xf8));
    return 0;
}

undefined4 FUN_0008f818(undefined4 param_1, undefined4 param_2)

{
    V_STR(param_1, "error", param_2);
    return param_1;
}

undefined4 FUN_0008f850(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "chain", param_3, param_4);
    return param_1;
}

void FUN_0008f884(int param_1, int param_2, undefined4 param_3)

{
    char extraout_r1;
    int local_40;
    char local_34[32];
    int local_14;
    int local_10;
    int local_c;

    local_34[0] = '\0';
    local_34[1] = '\0';
    local_34[2] = '\0';
    local_34[3] = '\0';
    local_34[4] = '\0';
    local_34[5] = '\0';
    local_34[6] = '\0';
    local_34[7] = '\0';
    local_34[8] = '\0';
    local_34[9] = '\0';
    local_34[10] = '\0';
    local_34[0xb] = '\0';
    local_34[0xc] = '\0';
    local_34[0xd] = '\0';
    local_34[0xe] = '\0';
    local_34[0xf] = '\0';
    local_34[0x10] = '\0';
    local_34[0x11] = '\0';
    local_34[0x12] = '\0';
    local_34[0x13] = '\0';
    local_34[0x14] = '\0';
    local_34[0x15] = '\0';
    local_34[0x16] = '\0';
    local_34[0x17] = '\0';
    local_34[0x18] = '\0';
    local_34[0x19] = '\0';
    local_34[0x1a] = '\0';
    local_34[0x1b] = '\0';
    local_34[0x1c] = '\0';
    local_34[0x1d] = '\0';
    local_c = 0;
    local_40 = param_2;
    while ((local_40 != 0 && (local_c < 0x1e))) {
        FUN_000cc7ac(local_40, param_3);
        local_34[local_c] = extraout_r1 + '0';
        local_c = local_c + 1;
        local_40 = FUN_000cc518(local_40, param_3);
    }
    local_14 = local_c + -1;
    for (local_10 = 0; local_10 < local_c; local_10 = local_10 + 1) {
        *(char *)(param_1 + local_10) = local_34[local_14];
        local_14 = local_14 + -1;
    }
    return;
}

int FUN_0008fa10(byte param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    if ((param_1 < 0x30) || (0x39 < param_1)) {
        if ((param_1 < 0x61) || (0x66 < param_1)) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "The provided character %c is invalid and was not "
                       "rejected in preliminary hex checks!",
                       param_1);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/./util.h",
                 0x92, "get_value_from_lower_hex", 0x18, 0x32, 100,
                 auStack_1008);
            iVar1 = -1;
        } else {
            iVar1 = param_1 - 0x57;
        }
    } else {
        iVar1 = param_1 - 0x30;
    }
    return iVar1;
}

void wait_x7_chip_setting_not_pending(int param_1)

{
    int iVar1;
    int iVar2;
    int iVar3;
    bool bVar4;
    uint uVar5;
    undefined8 uVar6;

    if (pending[*(int *)(param_1 + 0xf8) * 0x40 + 0x38] != '\x01') {
        pthread_mutex_init((pthread_mutex_t *)(pending +
                                               *(int *)(param_1 + 0xf8) * 0x40 +
                                               0x20),
                           (pthread_mutexattr_t *)0x0);
        pending[*(int *)(param_1 + 0xf8) * 0x40 + 0x38] = 1;
    }
    while (pthread_mutex_lock(
               (pthread_mutex_t *)(pending + *(int *)(param_1 + 0xf8) * 0x40 +
                                   0x20)),
           pending[*(int *)(param_1 + 0xf8) * 0x40] == '\x01') {
        iVar1 = *(int *)(param_1 + 0xf8) * 0x40;
        clock_gettime(1, (timespec *)(pending + iVar1 + 0xc));
        iVar2 = *(int *)(pending + iVar1 + 0xc) - *(int *)(pending + iVar1 + 4);
        uVar6 = VectorShiftLeft((longlong)iVar2, 5, 0x40, 0);
        uVar6 = VectorSub(uVar6, (longlong)iVar2, 8);
        uVar6 = VectorAdd(uVar6, uVar6, 8);
        uVar5 = (uint)uVar6;
        uVar6 = VectorAdd(CONCAT44((int)((ulonglong)uVar6 >> 0x20) * 2 +
                                       (uint)CARRY4(uVar5, uVar5),
                                   uVar5 * 2),
                          (longlong)iVar2, 8);
        uVar6 = VectorShiftLeft(uVar6, 3, 0x40, 0);
        uVar5 =
            (*(int *)(pending + iVar1 + 0x10) - *(int *)(pending + iVar1 + 8)) /
            1000000;
        iVar2 = (int)((ulonglong)uVar6 >> 0x20) + ((int)uVar5 >> 0x1f) +
                (uint)CARRY4((uint)uVar6, uVar5);
        iVar1 = *(int *)(param_1 + 0xf8) * 0x40;
        iVar3 = *(int *)(pending + iVar1 + 0x1c);
        bVar4 = (uint)uVar6 + uVar5 < *(uint *)(pending + iVar1 + 0x18);
        if ((int)(iVar2 - (iVar3 + (uint)bVar4)) < 0 ==
            (SBORROW4(iVar2, iVar3) != SBORROW4(iVar2 - iVar3, (uint)bVar4)))
            break;
        pthread_mutex_unlock(
            (pthread_mutex_t *)(pending + *(int *)(param_1 + 0xf8) * 0x40 +
                                0x20));
        usleep(1000);
    }
    clock_gettime(1,
                  (timespec *)(pending + *(int *)(param_1 + 0xf8) * 0x40 + 4));
    *(undefined8 *)(pending + *(int *)(param_1 + 0xf8) * 0x40 + 0x18) = 0;
    pending[*(int *)(param_1 + 0xf8) * 0x40] = 0;
    pthread_mutex_unlock(
        (pthread_mutex_t *)(pending + *(int *)(param_1 + 0xf8) * 0x40 + 0x20));
    return;
}

void set_x7_chip_setting_pending(int param_1, int param_2)

{
    int iVar1;

    if (pending[*(int *)(param_1 + 0xf8) * 0x40 + 0x38] != '\x01') {
        pthread_mutex_init((pthread_mutex_t *)(pending +
                                               *(int *)(param_1 + 0xf8) * 0x40 +
                                               0x20),
                           (pthread_mutexattr_t *)0x0);
        pending[*(int *)(param_1 + 0xf8) * 0x40 + 0x38] = 1;
    }
    pthread_mutex_lock(
        (pthread_mutex_t *)(pending + *(int *)(param_1 + 0xf8) * 0x40 + 0x20));
    clock_gettime(1,
                  (timespec *)(pending + *(int *)(param_1 + 0xf8) * 0x40 + 4));
    iVar1 = *(int *)(param_1 + 0xf8) * 0x40;
    *(int *)(pending + iVar1 + 0x18) = param_2 * 1000;
    *(int *)(pending + iVar1 + 0x1c) = param_2 * 1000 >> 0x1f;
    if (pending[*(int *)(param_1 + 0xf8) * 0x40] != '\x01') {
        pending[*(int *)(param_1 + 0xf8) * 0x40] = 1;
    }
    pthread_mutex_unlock(
        (pthread_mutex_t *)(pending + *(int *)(param_1 + 0xf8) * 0x40 + 0x20));
    return;
}

void x7_chip_finish_pending(int param_1)

{
    if (pending[*(int *)(param_1 + 0xf8) * 0x40 + 0x38] != '\x01') {
        pthread_mutex_init((pthread_mutex_t *)(pending +
                                               *(int *)(param_1 + 0xf8) * 0x40 +
                                               0x20),
                           (pthread_mutexattr_t *)0x0);
        pending[*(int *)(param_1 + 0xf8) * 0x40 + 0x38] = 1;
    }
    pthread_mutex_lock(
        (pthread_mutex_t *)(pending + *(int *)(param_1 + 0xf8) * 0x40 + 0x20));
    *(undefined8 *)(pending + *(int *)(param_1 + 0xf8) * 0x40 + 0x18) = 0;
    pending[*(int *)(param_1 + 0xf8) * 0x40] = 0;
    pthread_mutex_unlock(
        (pthread_mutex_t *)(pending + *(int *)(param_1 + 0xf8) * 0x40 + 0x20));
    return;
}

undefined4 set_chip_reg_x7(int param_1, int param_2)

{
    undefined4 uVar1;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        wait_x7_chip_setting_not_pending(param_1);
        send_command_packet(param_1, param_2, *(byte *)(param_2 + 5) + 8);
        uVar1 = 0;
    } else {
        uVar1 = 4;
    }
    return uVar1;
}

undefined4 sync_get_status_x7(int param_1, uint param_2, int param_3,
                              int param_4, int param_5, int *param_6,
                              undefined4 param_7, undefined4 param_8,
                              char param_9)

{
    int iVar1;
    int extraout_r2;
    undefined1 auStack_1228[4096];
    undefined4 local_228;
    int local_224;
    char local_220;
    char local_21f;
    byte local_21e;
    byte local_21a;
    short local_218;
    undefined1 auStack_214[512];
    short local_14;
    short local_12;
    undefined4 local_10;
    int local_c;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        wait_x7_chip_setting_not_pending(param_1);
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        if (param_9 != '\0') {
            queue_clear(*(undefined4 *)(param_1 + 0x364));
        }
        local_c = 0;
        local_10 = 0;
        FUN_000ccdfc(param_7, param_8, 1000, 0);
        local_224 = extraout_r2 * 1000000;
        local_228 = FUN_000ccdfc(param_7, param_8, 1000, 0);
        while (local_c < param_3) {
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_220, 0xc, &local_228);
            if (iVar1 == 0x6e) {
                local_10 = 3;
                break;
            }
            if ((local_220 != -0x56) || (local_21f != 'U')) {
                local_10 = 1;
                break;
            }
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      auStack_214, local_21a, &local_228);
            if (iVar1 == 0x6e) {
                local_10 = 3;
                break;
            }
            if (param_2 == local_21e) {
                if ((uint)local_21a != param_5 - 0xcU) {
                    local_10 = 1;
                    break;
                }
                local_12 = local_218;
                local_218 = 0;
                local_14 = BM_CRC16(&local_220, param_5);
                if (local_12 != local_14) {
                    local_10 = 2;
                    break;
                }
                iVar1 = local_c * 0x20c;
                local_c = local_c + 1;
                memcpy((void *)(param_4 + iVar1), &local_220, 0x20c);
            } else {
                V_LOCK();
                logfmt_raw(auStack_1228, 0x1000, 0,
                           "received unexpected response package, cmd %d",
                           local_21e);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "backend_x7_2044/chip_setting_x7_2044.c",
                     0xb8, "sync_get_status_x7", 0x12, 0x7e, 0x14,
                     auStack_1228);
            }
        }
        *param_6 = local_c;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_10 = 4;
    }
    return local_10;
}

undefined4 sync_get_rxu_status_x7(int param_1, uint param_2, int param_3,
                                  int param_4, int param_5, int *param_6,
                                  undefined4 param_7, undefined4 param_8)

{
    int iVar1;
    int extraout_r2;
    undefined1 auStack_1228[4096];
    undefined4 local_228;
    int local_224;
    char local_220;
    char local_21f;
    byte local_21e;
    byte local_21a;
    short local_218;
    undefined1 auStack_214[512];
    short local_14;
    short local_12;
    undefined4 local_10;
    int local_c;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        wait_x7_chip_setting_not_pending(param_1);
        queue_clear(*(undefined4 *)(param_1 + 0x374));
        local_c = 0;
        local_10 = 0;
        FUN_000ccdfc(param_7, param_8, 1000, 0);
        local_224 = extraout_r2 * 1000000;
        local_228 = FUN_000ccdfc(param_7, param_8, 1000, 0);
        while (local_c < param_3) {
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x374),
                                      &local_220, 0xc, &local_228);
            if (iVar1 == 0x6e) {
                local_10 = 3;
                break;
            }
            if ((local_220 != -0x56) || (local_21f != 'U')) {
                local_10 = 1;
                break;
            }
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x374),
                                      auStack_214, local_21a, &local_228);
            if (iVar1 == 0x6e) {
                local_10 = 3;
                break;
            }
            if (param_2 == local_21e) {
                if ((uint)local_21a != param_5 - 0xcU) {
                    local_10 = 1;
                    break;
                }
                local_12 = local_218;
                local_218 = 0;
                local_14 = BM_CRC16(&local_220, param_5);
                if (local_12 != local_14) {
                    local_10 = 2;
                    break;
                }
                iVar1 = local_c * 0x20c;
                local_c = local_c + 1;
                memcpy((void *)(param_4 + iVar1), &local_220, 0x20c);
            } else {
                V_LOCK();
                logfmt_raw(auStack_1228, 0x1000, 0,
                           "received unexpected response package, cmd %d",
                           local_21e);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "backend_x7_2044/chip_setting_x7_2044.c",
                     0xb8, "sync_get_rxu_status_x7", 0x16, 0xbe, 0x14,
                     auStack_1228);
            }
        }
        *param_6 = local_c;
    } else {
        local_10 = 4;
    }
    return local_10;
}

undefined4 sync_get_temperature_status_x7(int param_1, uint param_2,
                                          int param_3, int param_4, int param_5,
                                          int *param_6, undefined4 param_7,
                                          undefined4 param_8)

{
    int iVar1;
    int extraout_r2;
    undefined1 auStack_1228[4096];
    undefined4 local_228;
    int local_224;
    char local_220;
    char local_21f;
    byte local_21e;
    byte local_21a;
    short local_218;
    undefined1 auStack_214[512];
    short local_14;
    short local_12;
    undefined4 local_10;
    int local_c;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        local_c = 0;
        local_10 = 0;
        FUN_000ccdfc(param_7, param_8, 1000, 0);
        local_224 = extraout_r2 * 1000000;
        local_228 = FUN_000ccdfc(param_7, param_8, 1000, 0);
        while (local_c < param_3) {
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x368),
                                      &local_220, 0xc, &local_228);
            if (iVar1 == 0x6e) {
                local_10 = 3;
                break;
            }
            if ((local_220 != -0x56) || (local_21f != 'U')) {
                local_10 = 1;
                break;
            }
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x368),
                                      auStack_214, local_21a, &local_228);
            if (iVar1 == 0x6e) {
                local_10 = 3;
                break;
            }
            if (param_2 == local_21e) {
                if ((uint)local_21a != param_5 - 0xcU) {
                    local_10 = 1;
                    break;
                }
                local_12 = local_218;
                local_218 = 0;
                local_14 = BM_CRC16(&local_220, param_5);
                if (local_12 != local_14) {
                    local_10 = 2;
                    break;
                }
                iVar1 = local_c * 0x20c;
                local_c = local_c + 1;
                memcpy((void *)(param_4 + iVar1), &local_220, 0x20c);
            } else {
                V_LOCK();
                logfmt_raw(auStack_1228, 0x1000, 0,
                           "received unexpected response package, cmd %d",
                           local_21e);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "backend_x7_2044/chip_setting_x7_2044.c",
                     0xb8, "sync_get_temperature_status_x7", 0x1e, 0xfe, 0x14,
                     auStack_1228);
            }
        }
        *param_6 = local_c;
    } else {
        local_10 = 4;
    }
    return local_10;
}

undefined4 sync_unblocked_get_status_x7(int param_1, uint param_2, int param_3,
                                        int param_4, int param_5, int *param_6)

{
    int iVar1;
    undefined1 auStack_1228[4096];
    undefined1 auStack_228[4];
    undefined4 local_224;
    char local_220;
    char local_21f;
    byte local_21e;
    byte local_21a;
    short local_218;
    undefined1 auStack_214[512];
    short local_14;
    short local_12;
    undefined4 local_10;
    int local_c;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        wait_x7_chip_setting_not_pending(param_1);
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        local_c = 0;
        local_10 = 0;
        local_224 = 100000000;
        while (local_c < param_3) {
            iVar1 = queue_try_dequeue(*(undefined4 *)(param_1 + 0x364),
                                      &local_220, 0xc);
            if (iVar1 == 0) {
                local_10 = 0;
                break;
            }
            if ((local_220 != -0x56) || (local_21f != 'U')) {
                local_10 = 1;
                break;
            }
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      auStack_214, local_21a, auStack_228);
            if (iVar1 == 0x6e) {
                local_10 = 3;
                break;
            }
            if (param_2 == local_21e) {
                if ((uint)local_21a != param_5 - 0xcU) {
                    local_10 = 1;
                    break;
                }
                local_12 = local_218;
                local_218 = 0;
                local_14 = BM_CRC16(&local_220, param_5);
                if (local_12 != local_14) {
                    local_10 = 2;
                    break;
                }
                iVar1 = local_c * 0x20c;
                local_c = local_c + 1;
                memcpy((void *)(param_4 + iVar1), &local_220, 0x20c);
            } else {
                V_LOCK();
                logfmt_raw(auStack_1228, 0x1000, 0,
                           "received unexpected response package, cmd %d",
                           local_21e);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "backend_x7_2044/chip_setting_x7_2044.c",
                     0xb8, "sync_unblocked_get_status_x7", 0x1c, 0x13b, 0x14,
                     auStack_1228);
            }
        }
        *param_6 = local_c;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_10 = 4;
    }
    return local_10;
}

undefined4 sync_unblocked_get_msg_x7(int param_1, uint param_2, int param_3,
                                     int param_4, int param_5, int *param_6)

{
    int iVar1;
    undefined1 auStack_1228[4096];
    undefined1 auStack_228[4];
    undefined4 local_224;
    char local_220;
    char local_21f;
    byte local_21e;
    byte local_21a;
    short local_218;
    undefined1 auStack_214[512];
    short local_14;
    short local_12;
    undefined4 local_10;
    int local_c;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        wait_x7_chip_setting_not_pending(param_1);
        local_c = 0;
        local_10 = 0;
        local_224 = 100000000;
        while (local_c < param_3) {
            iVar1 = queue_try_dequeue(*(undefined4 *)(param_1 + 0x36c),
                                      &local_220, 0xc);
            if (iVar1 == 0) {
                local_10 = 0;
                break;
            }
            if ((local_220 != -0x56) || (local_21f != 'U')) {
                local_10 = 1;
                break;
            }
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x36c),
                                      auStack_214, local_21a, auStack_228);
            if (iVar1 == 0x6e) {
                local_10 = 3;
                break;
            }
            if (param_2 == local_21e) {
                if ((uint)local_21a != param_5 - 0xcU) {
                    local_10 = 1;
                    break;
                }
                local_12 = local_218;
                local_218 = 0;
                local_14 = BM_CRC16(&local_220, param_5);
                if (local_12 != local_14) {
                    local_10 = 2;
                    break;
                }
                iVar1 = local_c * 0x20c;
                local_c = local_c + 1;
                memcpy((void *)(param_4 + iVar1), &local_220, 0x20c);
            } else {
                V_LOCK();
                logfmt_raw(auStack_1228, 0x1000, 0,
                           "received unexpected response package, cmd %d",
                           local_21e);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "backend_x7_2044/chip_setting_x7_2044.c",
                     0xb8, "sync_unblocked_get_msg_x7", 0x19, 0x179, 0x14,
                     auStack_1228);
            }
        }
        *param_6 = local_c;
    } else {
        local_10 = 4;
    }
    return local_10;
}

undefined4 sync_get_seed_status_x7(int param_1, uint param_2, int param_3,
                                   int param_4, int param_5, int *param_6,
                                   undefined4 param_7, undefined4 param_8)

{
    int iVar1;
    int extraout_r2;
    undefined1 auStack_1228[4096];
    undefined4 local_228;
    int local_224;
    char local_220;
    char local_21f;
    byte local_21e;
    byte local_21a;
    short local_218;
    undefined1 auStack_214[512];
    short local_14;
    short local_12;
    undefined4 local_10;
    int local_c;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        wait_x7_chip_setting_not_pending(param_1);
        queue_clear(*(undefined4 *)(param_1 + 0x370));
        local_c = 0;
        local_10 = 0;
        FUN_000ccdfc(param_7, param_8, 1000, 0);
        local_224 = extraout_r2 * 1000000;
        local_228 = FUN_000ccdfc(param_7, param_8, 1000, 0);
        while (local_c < param_3) {
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x370),
                                      &local_220, 0xc, &local_228);
            if (iVar1 == 0x6e) {
                local_10 = 3;
                break;
            }
            if ((local_220 != -0x56) || (local_21f != 'U')) {
                local_10 = 1;
                break;
            }
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x370),
                                      auStack_214, local_21a, &local_228);
            if (iVar1 == 0x6e) {
                local_10 = 3;
                break;
            }
            if (param_2 == local_21e) {
                if ((uint)local_21a != param_5 - 0xcU) {
                    local_10 = 1;
                    break;
                }
                local_12 = local_218;
                local_218 = 0;
                local_14 = BM_CRC16(&local_220, param_5);
                if (local_12 != local_14) {
                    local_10 = 2;
                    break;
                }
                iVar1 = local_c * 0x20c;
                local_c = local_c + 1;
                memcpy((void *)(param_4 + iVar1), &local_220, 0x20c);
            } else {
                V_LOCK();
                logfmt_raw(auStack_1228, 0x1000, 0,
                           "received unexpected response package, cmd %d",
                           local_21e);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "backend_x7_2044/chip_setting_x7_2044.c",
                     0xb8, "sync_get_seed_status_x7", 0x17, 0x1b9, 0x14,
                     auStack_1228);
            }
        }
        *param_6 = local_c;
    } else {
        local_10 = 4;
    }
    return local_10;
}

undefined4 sync_unblocked_get_seed_status_x7(int param_1, uint param_2,
                                             int param_3, int param_4,
                                             int *param_5)

{
    int iVar1;
    undefined1 auStack_122c[4096];
    undefined1 auStack_22c[4];
    undefined4 local_228;
    char local_224;
    char local_223;
    byte local_222;
    byte local_21e;
    short local_21c;
    undefined1 auStack_218[512];
    short local_18;
    short local_16;
    int local_14;
    undefined4 local_10;
    int local_c;

    local_14 = 0x2c;
    if (*(char *)(param_1 + 0x100) == '\x01') {
        wait_x7_chip_setting_not_pending(param_1);
        local_c = 0;
        local_10 = 0;
        local_228 = 100000000;
        while (local_c < param_3) {
            iVar1 = queue_try_dequeue(*(undefined4 *)(param_1 + 0x370),
                                      &local_224, 0xc);
            if (iVar1 == 0) {
                local_10 = 0;
                break;
            }
            if ((local_224 != -0x56) || (local_223 != 'U')) {
                local_10 = 1;
                break;
            }
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x370),
                                      auStack_218, local_21e, auStack_22c);
            if (iVar1 == 0x6e) {
                local_10 = 3;
                break;
            }
            if (param_2 == local_222) {
                if ((uint)local_21e != local_14 - 0xcU) {
                    local_10 = 1;
                    break;
                }
                local_16 = local_21c;
                local_21c = 0;
                local_18 = BM_CRC16(&local_224, local_14);
                if (local_16 != local_18) {
                    local_10 = 2;
                    break;
                }
                iVar1 = local_c * 0x20c;
                local_c = local_c + 1;
                memcpy((void *)(param_4 + iVar1), &local_224, 0x20c);
            } else {
                V_LOCK();
                logfmt_raw(auStack_122c, 0x1000, 0,
                           "received unexpected response package, cmd %d",
                           local_222);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "backend_x7_2044/chip_setting_x7_2044.c",
                     0xb8, "sync_unblocked_get_seed_status_x7", 0x21, 0x1f7,
                     0x14, auStack_122c);
            }
        }
        *param_5 = local_c;
    } else {
        local_10 = 4;
    }
    return local_10;
}

int sync_get_chip_reg_x7(int param_1, undefined4 param_2, int param_3,
                         undefined4 param_4, undefined4 param_5,
                         undefined4 param_6, undefined4 param_7,
                         undefined4 param_8)

{
    int iVar1;
    undefined4 local_c;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        wait_x7_chip_setting_not_pending(param_1);
        if (*(char *)(param_3 + 2) == '\0') {
            local_c = 0x14;
        } else if (*(char *)(param_3 + 2) == '\x12') {
            local_c = 0x10;
        } else if (*(char *)(param_3 + 2) == '\x14') {
            local_c = 0x10;
        } else {
            if ((*(char *)(param_3 + 2) != '\x10') &&
                (*(char *)(param_3 + 2) != '\a')) {
                return 1;
            }
            local_c = 0x10;
        }
        iVar1 = set_chip_reg_x7(param_1, param_3);
        if (iVar1 == 0) {
            iVar1 = sync_get_status_x7(param_1, *(undefined1 *)(param_3 + 2),
                                       param_2, param_4, local_c, param_5,
                                       param_7, param_8, 1);
        }
    } else {
        iVar1 = 4;
    }
    return iVar1;
}

int sync_get_chip_rxu_status_reg_x7(int param_1, undefined4 param_2,
                                    int param_3, undefined4 param_4,
                                    undefined4 param_5, undefined4 param_6,
                                    undefined4 param_7, undefined4 param_8)

{
    int iVar1;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        wait_x7_chip_setting_not_pending(param_1);
        if (*(char *)(param_3 + 2) == '\x13') {
            iVar1 = set_chip_reg_x7(param_1, param_3);
            if (iVar1 == 0) {
                iVar1 = sync_get_rxu_status_x7(
                    param_1, *(undefined1 *)(param_3 + 2), param_2, param_4,
                    0x10, param_5, param_7, param_8);
            }
        } else {
            iVar1 = 1;
        }
    } else {
        iVar1 = 4;
    }
    return iVar1;
}

int sync_get_chip_temperature_reg_x7(int param_1, undefined4 param_2,
                                     int param_3, undefined4 param_4,
                                     undefined4 param_5, undefined4 param_6,
                                     undefined4 param_7, undefined4 param_8)

{
    int iVar1;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        wait_x7_chip_setting_not_pending(param_1);
        if (*(char *)(param_3 + 2) == '\t') {
            queue_clear(*(undefined4 *)(param_1 + 0x368));
            iVar1 = set_chip_reg_x7(param_1, param_3);
            if (iVar1 == 0) {
                iVar1 = sync_get_temperature_status_x7(
                    param_1, *(undefined1 *)(param_3 + 2), param_2, param_4,
                    0x10, param_5, param_7, param_8);
            }
        } else {
            iVar1 = 1;
        }
    } else {
        iVar1 = 4;
    }
    return iVar1;
}

undefined4 chip_setting_get_addr_x7(int param_1, uint param_2)

{
    byte bVar1;
    undefined4 uVar2;
    undefined1 auStack_179c[4096];
    char local_79c[1024];
    char acStack_39c[256];
    int local_29c;
    undefined1 local_298;
    undefined1 local_297;
    undefined1 local_296;
    undefined1 local_295;
    undefined1 local_294;
    undefined1 local_293;
    undefined2 local_292;
    undefined4 local_90;
    undefined4 uStack_8c;
    undefined4 uStack_88;
    undefined4 uStack_84;
    undefined4 local_80;
    undefined4 uStack_7c;
    undefined4 uStack_78;
    undefined4 uStack_74;
    undefined4 local_70;
    undefined4 uStack_6c;
    undefined4 uStack_68;
    undefined4 uStack_64;
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    int local_2c;
    int local_28;
    char *local_24;
    uint local_20;
    undefined4 local_1c;
    int local_18;
    void *local_14;

    local_29c = 0;
    local_18 = 0;
    local_1c = 0;
    V_LOCK();
    logfmt_raw(auStack_179c, 0x1000, 0, "%s chip_no %d",
               "chip_setting_get_addr_x7", param_2);
    V_UNLOCK();
    uVar2 = 0x275;
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/chip_setting_x7_2044.c",
        0xb8, "chip_setting_get_addr_x7", 0x18, 0x275, 0x14, auStack_179c);
    memset(acStack_39c, 0, 0x100);
    local_14 = malloc(param_2 * 0x20c);
    memset(local_14, 0, param_2 * 0x20c);
    local_298 = 0x55;
    local_297 = 0xaa;
    local_296 = 0;
    local_295 = 0xff;
    local_294 = 0xff;
    local_293 = 0;
    local_292 = 0;
    local_292 = BM_CRC16(&local_298, 8);
    local_1c = sync_get_chip_reg_x7(param_1, param_2, &local_298, local_14,
                                    &local_29c, uVar2, 3000, 0);
    V_LOCK();
    FUN_0008f850(&local_90, &local_90, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_179c, 0x1000, 0, uStack_74, local_90, uStack_8c,
               uStack_88, uStack_84, local_80, uStack_7c, uStack_78, uStack_74,
               "%s detect %d chips", "chip_setting_get_addr_x7", local_29c);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/chip_setting_x7_2044.c",
        0xb8, "chip_setting_get_addr_x7", 0x18, 0x289, 0x3c, auStack_179c);
    for (local_2c = 0; local_2c < local_29c; local_2c = local_2c + 1) {
        if (*(char *)((int)local_14 + local_2c * 0x20c + 2) == '\0') {
            V_LOCK();
            logfmt_raw(auStack_179c, 0x1000, 0,
                       "[GET ADDR] fw version %c%c%c%c chip %d",
                       *(undefined1 *)((int)local_14 + local_2c * 0x20c + 0xc),
                       *(undefined1 *)((int)local_14 + local_2c * 0x20c + 0xd),
                       *(undefined1 *)((int)local_14 + local_2c * 0x20c + 0xe),
                       *(undefined1 *)((int)local_14 + local_2c * 0x20c + 0xf),
                       *(undefined1 *)((int)local_14 + local_2c * 0x20c + 3));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "backend_x7_2044/chip_setting_x7_2044.c",
                 0xb8, "chip_setting_get_addr_x7", 0x18, 0x28d, 0x3c,
                 auStack_179c);
            if (acStack_39c[*(byte *)((int)local_14 + local_2c * 0x20c + 3)] ==
                '\0') {
                bVar1 = *(byte *)((int)local_14 + local_2c * 0x20c + 3);
                acStack_39c[bVar1] = acStack_39c[bVar1] + '\x01';
                local_18 = local_18 + 1;
            }
        }
    }
    local_28 = 0;
    memset(local_79c, 0, 0x400);
    local_79c[0] = '\n';
    local_24 = local_79c;
    for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
        if (acStack_39c[local_20] == '\0') {
            sprintf(local_24, "%03d ", local_20);
            local_24 = local_24 + 4;
            local_28 = local_28 + 1;
        }
    }
    if (local_18 < *(int *)(param_1 + 0x150)) {
        V_LOCK();
        FUN_0008f850(&local_70, &local_70, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        FUN_0008f818(&local_50, "asic num error");
        logfmt_raw(auStack_179c, 0x1000, 0, uStack_54, local_70, uStack_6c,
                   uStack_68, uStack_64, local_60, uStack_5c, uStack_58,
                   uStack_54, local_50, uStack_4c, uStack_48, uStack_44,
                   local_40, uStack_3c, uStack_38, uStack_34,
                   "detected asic num less than design(%d<%d)", local_18,
                   *(undefined4 *)(param_1 + 0x150));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "chip_setting_x7_2044.c",
             0xb8, "chip_setting_get_addr_x7", 0x18, 0x2ab, 100, auStack_179c);
        V_LOCK();
        logfmt_raw(auStack_179c, 0x1000, 0, "Sweep error string = J%d:2.",
                   *(undefined4 *)(param_1 + 0xfc));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "chip_setting_x7_2044.c",
             0xb8, "chip_setting_get_addr_x7", 0x18, 0x2ac, 100, auStack_179c);
        V_LOCK();
        logfmt_raw(auStack_179c, 0x1000, 0, "bad asic: %s", local_79c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "chip_setting_x7_2044.c",
             0xb8, "chip_setting_get_addr_x7", 0x18, 0x2ad, 0x28, auStack_179c);
    }
    free(local_14);
    *(int *)(param_1 + 0x1a8) = local_18;
    return local_1c;
}

undefined4 chip_setting_seed_x7(undefined4 param_1, void *param_2, byte param_3,
                                void *param_4, undefined1 param_5)

{
    undefined4 uVar1;
    undefined1 local_210;
    undefined1 local_20f;
    undefined1 local_20e;
    undefined1 local_20d;
    undefined1 local_20c;
    byte local_20b;
    undefined2 local_20a;
    undefined1 auStack_208[512];

    local_210 = 0x55;
    local_20f = 0xaa;
    local_20e = 2;
    local_20d = param_5;
    local_20c = 0xff;
    local_20a = 0;
    local_20b = param_3;
    memcpy(auStack_208, param_2, (uint)param_3);
    local_20a = BM_CRC16(&local_210, local_20b + 8);
    memcpy(param_4, &local_210, local_20b + 8);
    uVar1 = set_chip_reg_x7(param_1, &local_210);
    return uVar1;
}

undefined4 chip_setting_msg_x7(int param_1, void *param_2, byte param_3,
                               undefined1 param_4)

{
    undefined4 uVar1;
    undefined1 auStack_1238[4096];
    undefined1 local_238;
    undefined1 local_237;
    undefined1 local_236;
    undefined1 local_235;
    undefined1 local_234;
    byte local_233;
    undefined2 local_232;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    undefined4 local_20;
    undefined4 uStack_1c;
    undefined4 uStack_18;
    undefined4 uStack_14;

    memcpy(&local_238, param_2, 0xd6);
    local_238 = 0x55;
    local_237 = 0xaa;
    local_236 = 3;
    local_234 = 0xff;
    local_233 = param_3 - 8;
    local_232 = 0;
    local_235 = param_4;
    local_232 = BM_CRC16(&local_238, local_233 + 8);
    if ((param_3 == 0) || (param_3 < 9)) {
        V_LOCK();
        FUN_0008f850(&local_30, &local_30, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_1238, 0x1000, 0, uStack_14, local_30, uStack_2c,
                   uStack_28, uStack_24, local_20, uStack_1c, uStack_18,
                   uStack_14, "packet_len is zero");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "chip_setting_x7_2044.c",
             0xb8, "chip_setting_msg_x7", 0x13, 0x2e1, 0x28, auStack_1238);
        uVar1 = 4;
    } else {
        uVar1 = set_chip_reg_x7(param_1, &local_238);
    }
    return uVar1;
}

undefined4 chip_setting_baud_x7(undefined4 param_1, undefined4 param_2)

{
    undefined1 auStack_1210[4096];
    undefined1 local_210;
    undefined1 local_20f;
    undefined1 local_20e;
    undefined1 local_20d;
    undefined1 local_20c;
    undefined1 local_20b;
    undefined2 local_20a;
    undefined4 local_208;

    local_210 = 0x55;
    local_20f = 0xaa;
    local_20e = 0xe;
    local_20d = 0xff;
    local_20c = 0xff;
    local_20b = 4;
    local_20a = 0;
    local_208 = param_2;
    local_20a = BM_CRC16(&local_210, 0xc);
    V_LOCK();
    logfmt_raw(auStack_1210, 0x1000, 0, "set baud value %d", param_2);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/chip_setting_x7_2044.c",
        0xb8, "chip_setting_baud_x7", 0x14, 0x300, 0x3c, auStack_1210);
    set_chip_reg_x7(param_1, &local_210);
    return 0;
}

int chip_setting_get_md5sum_x7(int param_1, int param_2, byte param_3,
                               void *param_4, size_t param_5, char *param_6)

{
    undefined4 uVar1;
    undefined1 auStack_1274[4096];
    int local_274;
    uint local_270;
    int local_26c;
    undefined1 local_268;
    undefined1 local_267;
    undefined1 local_266;
    undefined1 local_265;
    undefined1 local_264;
    byte local_263;
    undefined2 local_262;
    uint local_260;
    undefined1 auStack_25c[508];
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    void *local_1c;
    int local_18;
    int local_14;

    local_26c = 0;
    local_14 = 0;
    V_LOCK();
    logfmt_raw(auStack_1274, 0x1000, 0, "%s chip_no %d",
               "chip_setting_get_md5sum_x7", param_2);
    V_UNLOCK();
    uVar1 = 0x30f;
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/chip_setting_x7_2044.c",
        0xb8, "chip_setting_get_md5sum_x7", 0x1a, 0x30f, 0x14, auStack_1274);
    local_1c = malloc(param_2 * 0x20c);
    memset(local_1c, 0, param_2 * 0x20c);
    local_268 = 0x55;
    local_267 = 0xaa;
    local_266 = 0x12;
    local_265 = 0xff;
    local_264 = 0xff;
    local_263 = (char)param_5 + 4;
    local_270 = (uint)param_3;
    local_260 = local_270;
    memcpy(auStack_25c, param_4, param_5);
    local_262 = 0;
    local_262 = BM_CRC16(&local_268, local_263 + 8);
    local_14 = sync_get_chip_reg_x7(param_1, param_2, &local_268, local_1c,
                                    &local_26c, uVar1, 60000, 0);
    if (param_2 == local_26c) {
        if (local_14 == 0) {
            *param_6 = '\0';
            for (local_18 = 0; local_18 < local_26c; local_18 = local_18 + 1) {
                if (*(char *)((int)local_1c + local_18 * 0x20c + 2) == '\x12') {
                    local_274 =
                        *(int *)((int)local_1c + local_18 * 0x20c + 0xc);
                    if (local_274 == 0) {
                        V_LOCK();
                        FUN_0008f850(&local_40, &local_40,
                                     *(int *)(param_1 + 0xfc),
                                     *(int *)(param_1 + 0xfc) >> 0x1f);
                        logfmt_raw(auStack_1274, 0x1000, 0, uStack_24, local_40,
                                   uStack_3c, uStack_38, uStack_34, local_30,
                                   uStack_2c, uStack_28, uStack_24,
                                   "%s : chip %d md5sum check failed",
                                   "chip_setting_get_md5sum_x7",
                                   *(undefined1 *)((int)local_1c +
                                                   local_18 * 0x20c + 3));
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/"
                             "backend_x7_2044/chip_setting_x7_2044.c",
                             0xb8, "chip_setting_get_md5sum_x7", 0x1a, 0x335,
                             100, auStack_1274);
                    } else {
                        *param_6 = *param_6 + '\x01';
                    }
                }
            }
            free(local_1c);
        } else {
            free(local_1c);
        }
    } else {
        V_LOCK();
        FUN_0008f850(&local_60, &local_60, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_1274, 0x1000, 0, uStack_44, local_60, uStack_5c,
                   uStack_58, uStack_54, local_50, uStack_4c, uStack_48,
                   uStack_44, "%s get only %d response",
                   "chip_setting_get_md5sum_x7", local_26c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "chip_setting_x7_2044.c",
             0xb8, "chip_setting_get_md5sum_x7", 0x1a, 0x323, 100,
             auStack_1274);
        free(local_1c);
    }
    return local_14;
}

undefined4 chip_setting_get_restart_reg_x7(int param_1, char param_2,
                                           size_t *param_3)

{
    undefined1 auStack_1028[4096];
    int local_28;
    void *local_24;
    void *local_20;
    int local_1c;
    int local_18;
    undefined4 local_14;
    size_t local_10;
    undefined4 local_c;

    local_14 = 0;
    local_10 = 1;
    local_c = 0x10;
    if (param_2 == -1) {
        local_10 = *(size_t *)(param_1 + 0x150);
    }
    local_20 = malloc(local_10);
    memset(local_20, 0, local_10);
    local_24 = malloc(local_10 * 0x20c);
    memset(local_24, 0, local_10 * 0x20c);
    *param_3 = 0;
    local_14 = sync_get_status_x7(param_1, 0x14, local_10, local_24, local_c,
                                  &local_28, 30000, 0, 0);
    for (local_1c = 0; local_1c < local_28; local_1c = local_1c + 1) {
        if ((*(char *)((int)local_24 + local_1c * 0x20c + 2) == '\x14') &&
            ((param_2 == -1 ||
              (param_2 == *(char *)((int)local_24 + local_1c * 0x20c + 3))))) {
            *(undefined1 *)((int)local_20 + local_1c) = 1;
            *param_3 = *param_3 + 1;
        }
    }
    if (local_10 != *param_3) {
        if (param_2 == -1) {
            V_LOCK();
            logfmt_raw(auStack_1028, 0x1000, 0, "some chip not found");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "backend_x7_2044/chip_setting_x7_2044.c",
                 0xb8, "chip_setting_get_restart_reg_x7", 0x1f, 0x35f, 100,
                 auStack_1028);
        } else {
            V_LOCK();
            logfmt_raw(auStack_1028, 0x1000, 0,
                       "some chip not found, chip_id %d", param_2);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "backend_x7_2044/chip_setting_x7_2044.c",
                 0xb8, "chip_setting_get_restart_reg_x7", 0x1f, 0x361, 100,
                 auStack_1028);
        }
        for (local_18 = 0; local_18 < local_28; local_18 = local_18 + 1) {
            if (*(char *)((int)local_24 + local_18 * 0x20c + 2) == '\x14') {
                V_LOCK();
                logfmt_raw(
                    auStack_1028, 0x1000, 0, "responsed chip:%d",
                    *(undefined1 *)((int)local_24 + local_18 * 0x20c + 3));
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "backend_x7_2044/chip_setting_x7_2044.c",
                     0xb8, "chip_setting_get_restart_reg_x7", 0x1f, 0x366, 100,
                     auStack_1028);
            }
        }
    }
    free(local_24);
    free(local_20);
    return local_14;
}

int chip_setting_send_update_cmd_x7(int param_1, int param_2, byte param_3,
                                    char *param_4)

{
    undefined4 uVar1;
    undefined1 auStack_1278[4096];
    int local_278;
    int local_274;
    undefined1 local_270;
    undefined1 local_26f;
    undefined1 local_26e;
    undefined1 local_26d;
    undefined1 local_26c;
    undefined1 local_26b;
    undefined2 local_26a;
    undefined4 local_68;
    undefined4 uStack_64;
    undefined4 uStack_60;
    undefined4 uStack_5c;
    undefined4 local_58;
    undefined4 uStack_54;
    undefined4 uStack_50;
    undefined4 uStack_4c;
    undefined4 local_48;
    undefined4 uStack_44;
    undefined4 uStack_40;
    undefined4 uStack_3c;
    undefined4 local_38;
    undefined4 uStack_34;
    undefined4 uStack_30;
    undefined4 uStack_2c;
    uint local_24;
    void *local_20;
    int local_1c;
    int local_18;
    char *local_14;

    local_274 = 0;
    local_18 = 0;
    local_14 = &DAT_000f4240;
    V_LOCK();
    logfmt_raw(auStack_1278, 0x1000, 0, "%s chip_no %d",
               "chip_setting_send_update_cmd_x7", param_2);
    V_UNLOCK();
    uVar1 = 0x379;
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/backend_x7_2044/chip_setting_x7_2044.c",
        0xb8, "chip_setting_send_update_cmd_x7", 0x1f, 0x379, 0x14,
        auStack_1278);
    local_20 = malloc(param_2 * 0x20c);
    memset(local_20, 0, param_2 * 0x20c);
    local_270 = 0x55;
    local_26f = 0xaa;
    if (param_3 == 0) {
        local_26e = 7;
    } else {
        local_26e = 0x10;
    }
    local_26d = 0xff;
    local_26c = 0xff;
    local_26b = 0;
    local_24 = (uint)param_3;
    local_26a = 0;
    local_26a = BM_CRC16(&local_270, 8);
    if (param_3 == 0) {
        local_14 = "ce/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
                   "build/rootfs/buildroot/tmp/release/build/"
                   "godminer-origin_godminer-branch1/backend/backend_ltc_1491/"
                   "chip_reg_io_ltc_1491.c";
    } else {
        local_14 = (char *)0x7a120;
    }
    local_18 = sync_get_chip_reg_x7(param_1, param_2, &local_270, local_20,
                                    &local_274, uVar1, local_14, 0);
    if (param_2 == local_274) {
        if (local_18 == 0) {
            *param_4 = '\0';
            for (local_1c = 0; local_1c < local_274; local_1c = local_1c + 1) {
                local_278 = *(int *)((int)local_20 + local_1c * 0x20c + 0xc);
                if (local_278 == 0) {
                    V_LOCK();
                    FUN_0008f850(&local_48, &local_48, *(int *)(param_1 + 0xfc),
                                 *(int *)(param_1 + 0xfc) >> 0x1f);
                    logfmt_raw(
                        auStack_1278, 0x1000, 0, uStack_2c, local_48, uStack_44,
                        uStack_40, uStack_3c, local_38, uStack_34, uStack_30,
                        uStack_2c, "chip %d update failed",
                        "chip_setting_send_update_cmd_x7",
                        *(undefined1 *)((int)local_20 + local_1c * 0x20c + 3));
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/backend_x7_2044/chip_setting_x7_2044.c",
                         0xb8, "chip_setting_send_update_cmd_x7", 0x1f, 0x3a5,
                         100, auStack_1278);
                } else {
                    *param_4 = *param_4 + '\x01';
                }
            }
            free(local_20);
        } else {
            free(local_20);
        }
    } else {
        V_LOCK();
        FUN_0008f850(&local_68, &local_68, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_1278, 0x1000, 0, uStack_4c, local_68, uStack_64,
                   uStack_60, uStack_5c, local_58, uStack_54, uStack_50,
                   uStack_4c, "%s get only %d response",
                   "chip_setting_send_update_cmd_x7", local_274);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "chip_setting_x7_2044.c",
             0xb8, "chip_setting_send_update_cmd_x7", 0x1f, 0x392, 100,
             auStack_1278);
        free(local_20);
    }
    return local_18;
}

undefined4 chip_setting_restart_one_chip_x7(undefined4 param_1,
                                            undefined1 param_2,
                                            undefined4 param_3)

{
    undefined1 local_218;
    undefined1 local_217;
    undefined1 local_216;
    undefined1 local_215;
    undefined1 local_214;
    undefined1 local_213;
    undefined2 local_212;
    undefined4 local_10;
    void *local_c;

    local_c = (void *)0x0;
    local_10 = 0;
    local_218 = 0x55;
    local_217 = 0xaa;
    local_216 = 0x14;
    local_214 = 0xff;
    local_213 = 0;
    local_212 = 0;
    local_215 = param_2;
    local_212 = BM_CRC16(&local_218, 8);
    local_c = malloc(0x20c);
    memset(local_c, 0, 0x20c);
    local_10 = sync_get_chip_reg_x7(param_1, 1, &local_218, local_c, param_3);
    if (local_c != (void *)0x0) {
        free(local_c);
    }
    return local_10;
}

undefined4
chip_setting_read_one_sensor_temp_x7(undefined4 param_1, int *param_2,
                                     undefined4 *param_3, char param_4)

{
    int local_224;
    undefined1 local_220;
    undefined1 local_21f;
    undefined1 local_21e;
    undefined1 local_21d;
    undefined1 local_21c;
    undefined1 local_21b;
    undefined2 local_21a;
    undefined4 local_18;
    int local_14;
    void *local_10;
    int local_c;

    local_10 = (void *)0x0;
    local_14 = 6;
    local_18 = 0;
    local_220 = 0x55;
    local_21f = 0xaa;
    local_21e = 9;
    local_21d = 0xff;
    local_21c = 0xff;
    local_21b = 0;
    local_21a = 0;
    local_21a = BM_CRC16(&local_220, 8);
    local_10 = malloc(local_14 * 0x20c);
    memset(local_10, 0, local_14 * 0x20c);
    *param_3 = 0;
    *param_2 = -0x40;
    local_18 = sync_get_chip_temperature_reg_x7(param_1, local_14, &local_220,
                                                local_10, &local_224);
    local_c = 0;
    do {
        if (local_224 <= local_c) {
        LAB_00093558:
            if (local_10 != (void *)0x0) {
                free(local_10);
            }
            return local_18;
        }
        if ((*(char *)((int)local_10 + local_c * 0x20c + 2) == '\t') &&
            (param_4 == *(char *)((int)local_10 + local_c * 0x20c + 3))) {
            *param_2 = *(int *)((int)local_10 + local_c * 0x20c + 0xc);
            *param_2 = *param_2 / 1000;
            *param_3 = 1;
            goto LAB_00093558;
        }
        local_c = local_c + 1;
    } while (true);
}

undefined4 chip_setting_read_all_sensor_temp(undefined4 param_1, void *param_2,
                                             int param_3, int *param_4)

{
    int local_220;
    undefined1 local_21c;
    undefined1 local_21b;
    undefined1 local_21a;
    undefined1 local_219;
    undefined1 local_218;
    undefined1 local_217;
    undefined2 local_216;
    void *local_14;
    undefined4 local_10;
    int local_c;

    local_10 = 0;
    local_21c = 0x55;
    local_21b = 0xaa;
    local_21a = 9;
    local_219 = 0xff;
    local_218 = 0xff;
    local_217 = 0;
    local_216 = 0;
    local_216 = BM_CRC16(&local_21c, 8);
    local_14 = malloc(param_3 * 0x20c);
    memset(local_14, 0, param_3 * 0x20c);
    memset(param_2, 0, param_3 * 0xc);
    *param_4 = 0;
    local_10 = sync_get_chip_temperature_reg_x7(param_1, param_3, &local_21c,
                                                local_14, &local_220);
    for (local_c = 0; local_c < local_220; local_c = local_c + 1) {
        if (*(char *)((int)local_14 + local_c * 0x20c + 2) == '\t') {
            *(uint *)((int)param_2 + *param_4 * 0xc) =
                (uint) * (byte *)((int)local_14 + local_c * 0x20c + 3);
            *(undefined4 *)((int)param_2 + *param_4 * 0xc + 4) =
                *(undefined4 *)((int)local_14 + local_c * 0x20c + 0xc);
            *(undefined4 *)((int)param_2 + *param_4 * 0xc + 8) = 1;
            *param_4 = *param_4 + 1;
        }
    }
    free(local_14);
    return local_10;
}

undefined4 chip_setting_get_all_rxu_status(int param_1, void *param_2,
                                           int param_3, int *param_4)

{
    undefined1 auStack_124c[4096];
    int local_24c;
    undefined1 local_248;
    undefined1 local_247;
    undefined1 local_246;
    undefined1 local_245;
    undefined1 local_244;
    undefined1 local_243;
    undefined2 local_242;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    void *local_1c;
    int local_18;
    undefined4 local_14;

    local_14 = 0;
    local_248 = 0x55;
    local_247 = 0xaa;
    local_246 = 0x13;
    local_245 = 0xff;
    local_244 = 0xff;
    local_243 = 0;
    local_242 = 0;
    local_242 = BM_CRC16(&local_248, 8);
    local_1c = malloc(param_3 * 0x20c);
    memset(local_1c, 0, param_3 * 0x20c);
    memset(param_2, 0, param_3 * 0xc);
    *param_4 = 0;
    local_14 = sync_get_chip_rxu_status_reg_x7(param_1, param_3, &local_248,
                                               local_1c, &local_24c);
    for (local_18 = 0; local_18 < local_24c; local_18 = local_18 + 1) {
        if (*(char *)((int)local_1c + local_18 * 0x20c + 2) == '\x13') {
            *(uint *)((int)param_2 + *param_4 * 0xc) =
                (uint) * (byte *)((int)local_1c + local_18 * 0x20c + 3);
            *(undefined4 *)((int)param_2 + *param_4 * 0xc + 4) =
                *(undefined4 *)((int)local_1c + local_18 * 0x20c + 0xc);
            *(undefined4 *)((int)param_2 + *param_4 * 0xc + 8) = 1;
            *param_4 = *param_4 + 1;
        }
    }
    if (*param_4 != *(int *)(param_1 + 0x150)) {
        V_LOCK();
        FUN_0008f850(&local_40, &local_40, *(int *)(param_1 + 0xfc),
                     *(int *)(param_1 + 0xfc) >> 0x1f);
        logfmt_raw(auStack_124c, 0x1000, 0, uStack_24, local_40, uStack_3c,
                   uStack_38, uStack_34, local_30, uStack_2c, uStack_28,
                   uStack_24, "response rxu hang status packet not enough:%d",
                   *param_4);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/backend_x7_2044/"
             "chip_setting_x7_2044.c",
             0xb8, "chip_setting_get_all_rxu_status", 0x1f, 0x454, 0x50,
             auStack_124c);
    }
    free(local_1c);
    return local_14;
}

undefined4 chip_setting_send_update_single_packet(undefined4 param_1,
                                                  void *param_2, byte param_3,
                                                  char param_4)

{
    undefined4 uVar1;
    undefined1 local_214;
    undefined1 local_213;
    undefined1 local_212;
    undefined1 local_211;
    undefined1 local_210;
    byte local_20f;
    undefined2 local_20e;
    undefined1 auStack_20c[512];
    undefined4 local_c;

    local_c = 0;
    local_214 = 0x55;
    local_213 = 0xaa;
    if (param_4 == '\0') {
        local_212 = 6;
    } else {
        local_212 = 0xf;
    }
    local_211 = 0xff;
    local_210 = 0xff;
    local_20f = param_3;
    memcpy(auStack_20c, param_2, (uint)param_3);
    local_20e = 0;
    local_20e = BM_CRC16(&local_214, local_20f + 8);
    uVar1 = set_chip_reg_x7(param_1, &local_214);
    return uVar1;
}

undefined4 FUN_00093c84(undefined1 param_1)

{
    undefined4 uVar1;

    switch (param_1) {
    case 1:
        uVar1 = 0x22;
        break;
    case 2:
        uVar1 = 0x27;
        break;
    case 3:
        uVar1 = 0x2b;
        break;
    case 4:
        uVar1 = 0x2d;
        break;
    default:
        uVar1 = 0x72;
    }
    return uVar1;
}

void FUN_00093cf0(undefined4 param_1, int param_2, uint param_3)

{
    int iVar1;
    uint auStack_1040[4];
    undefined1 auStack_1030[4];
    uint local_102c;
    int local_1028;
    undefined4 local_1024;
    undefined1 auStack_101c[4096];
    undefined1 *local_1c;
    uint local_18;
    int local_14;

    local_14 = param_3 * 2;
    iVar1 = -(local_14 + 8U & 0xfffffff8);
    local_1c = auStack_1030 + iVar1;
    local_18 = 0;
    local_102c = param_3;
    local_1028 = param_2;
    local_1024 = param_1;
    while (true) {
        if (local_102c <= local_18)
            break;
        sprintf(local_1c + local_18 * 2, "%02x",
                (uint) * (byte *)(local_1028 + local_18));
        local_18 = local_18 + 1;
    }
    V_LOCK();
    *(undefined1 **)((int)auStack_1040 + iVar1 + 8) = local_1c;
    *(uint *)((int)auStack_1040 + iVar1 + 4) = local_102c;
    *(undefined4 *)((int)auStack_1040 + iVar1) = local_1024;
    logfmt_raw(auStack_101c, 0x1000, 0, "%s[%d]=%s");
    V_UNLOCK();
    *(undefined1 **)((int)auStack_1040 + iVar1 + 0xc) = auStack_101c;
    *(undefined4 *)((int)auStack_1040 + iVar1 + 8) = 0x14;
    *(undefined4 *)((int)auStack_1040 + iVar1 + 4) = 0x4e;
    *(undefined4 *)((int)auStack_1040 + iVar1) = 8;
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/drv_pic/mps2973.c",
        0xae, "hex_dump");
    return;
}

short FUN_00093e7c(int param_1, int param_2)

{
    undefined4 local_10;
    undefined2 local_a;

    local_a = 0;
    for (local_10 = 2; local_10 < param_2 - 2U; local_10 = local_10 + 1) {
        local_a = (ushort) * (byte *)(param_1 + local_10) + local_a;
    }
    *(char *)(param_1 + param_2 + -2) = (char)((ushort)local_a >> 8);
    *(char *)(param_1 + param_2 + -1) = (char)local_a;
    return local_a;
}

bool FUN_00093f38(int param_1, int param_2)

{
    uint local_10;
    short local_a;

    local_a = 0;
    for (local_10 = 0; local_10 < param_2 - 2U; local_10 = local_10 + 1) {
        local_a = (ushort) * (byte *)(param_1 + local_10) + local_a;
    }
    return local_a == 0 || *(char *)(param_1 + param_2 + -1) != '\0';
}

undefined1 FUN_00093ff4(int param_1, char param_2, void *param_3,
                        size_t param_4, char param_5, void *param_6,
                        size_t param_7)

{
    uint uVar1;
    int iVar2;
    undefined1 auStack_101c[4096];
    byte local_1c;
    char local_1b;
    char local_1a;
    char local_19;
    undefined1 auStack_18[13];
    byte local_b;
    byte local_a;
    undefined1 local_9;

    if (param_4 < 8) {
        if (param_4 == 0) {
            param_4 = 1;
        }
    } else {
        param_4 = 8;
    }
    if (*(int *)(g_bitmain_pic_state + param_1 * 8 + 4) == 0) {
        V_LOCK();
        logfmt_raw(auStack_101c, 0x1000, 0, "%s this chain not inited",
                   "pic_1704_cmd");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "mps2973.c",
             0xae, "pic_1704_cmd", 0xc, 0x6c, 100, auStack_101c);
        local_9 = 1;
    }
    local_1c = 0x55;
    local_1b = -0x56;
    local_1a = (char)param_4 + '\x04';
    local_19 = param_2;
    memcpy(auStack_18, param_3, param_4);
    local_a = (char)param_4 + 6;
    FUN_00093e7c(&local_1c, local_a);
    FUN_00093cf0("pic tx", &local_1c, local_a);
    pthread_mutex_lock((pthread_mutex_t *)i2c_mutex_all);
    uVar1 = iic_write(*(undefined4 *)(g_bitmain_pic_state + param_1 * 8),
                      &local_1c, local_a);
    if (uVar1 == local_a) {
        usleep(10000);
        memset(&local_1c, 0, 0x10);
        local_b = (char)param_7 + 5;
        uVar1 = iic_read(*(undefined4 *)(g_bitmain_pic_state + param_1 * 8),
                         &local_1c, local_b);
        if (uVar1 == local_b) {
            FUN_00093cf0("pic rx", &local_1c, local_b);
            if ((((local_b == local_1c) && (param_2 == local_1b)) &&
                 (param_5 == local_1a)) &&
                (iVar2 = FUN_00093f38(&local_1c, local_b), iVar2 != 0)) {
                if ((param_7 != 0) && (param_6 != (void *)0x0)) {
                    memcpy(param_6, &local_19, param_7);
                }
                local_9 = 0;
            } else {
                V_LOCK();
                logfmt_raw(auStack_101c, 0x1000, 0, "%s recv data format err",
                           "pic_1704_cmd");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/drv_pic/mps2973.c",
                     0xae, "pic_1704_cmd", 0xc, 0x8c, 100, auStack_101c);
                local_9 = 3;
            }
        } else {
            local_9 = 2;
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0, "%s read iic err",
                       "pic_1704_cmd");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/drv_pic/mps2973.c",
                 0xae, "pic_1704_cmd", 0xc, 0x86, 100, auStack_101c);
        }
    } else {
        V_LOCK();
        logfmt_raw(auStack_101c, 0x1000, 0, "%s write iic err", "pic_1704_cmd");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "mps2973.c",
             0xae, "pic_1704_cmd", 0xc, 0x7c, 100, auStack_101c);
        local_9 = 1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)i2c_mutex_all);
    return local_9;
}

bool FUN_000944f0(undefined4 param_1, undefined1 param_2, undefined1 param_3,
                  void *param_4, size_t param_5)

{
    int iVar1;
    undefined1 local_18;
    undefined1 local_17;
    undefined1 auStack_16[14];

    local_18 = param_2;
    local_17 = param_3;
    memcpy(auStack_16, param_4, param_5);
    iVar1 = FUN_00093ff4(param_1, 0x3b, &local_18, param_5 + 2, 0, 0, 0);
    return iVar1 == 0;
}

bool FUN_00094594(undefined4 param_1, undefined1 param_2, undefined1 param_3,
                  undefined4 param_4, undefined4 param_5)

{
    int iVar1;
    undefined1 local_c;
    undefined1 local_b;
    undefined1 local_a;

    local_a = (undefined1)param_5;
    local_c = param_2;
    local_b = param_3;
    iVar1 = FUN_00093ff4(param_1, 0x3c, &local_c, 3, 0, param_4, param_5);
    return iVar1 == 0;
}

undefined4 FUN_00094624(undefined4 param_1, undefined1 param_2, char param_3)

{
    char cVar1;
    undefined4 uVar2;
    char local_10[8];

    local_10[0] = param_3;
    uVar2 = FUN_00093c84(param_2);
    cVar1 = FUN_000944f0(param_1, uVar2, 0, local_10, 1);
    if (cVar1 == '\x01') {
        uVar2 = FUN_00093c84(param_2);
        cVar1 = FUN_00094594(param_1, uVar2, 0, local_10, 1);
        if (cVar1 == '\x01') {
            if (param_3 == local_10[0]) {
                uVar2 = 1;
            } else {
                uVar2 = 0;
            }
        } else {
            uVar2 = 0;
        }
    } else {
        uVar2 = 0;
    }
    return uVar2;
}

int get_chain_mps_voltage1(undefined4 param_1, undefined1 param_2,
                           ushort *param_3)

{
    char cVar1;
    undefined4 uVar2;
    undefined1 auStack_1018[4096];
    ushort local_18[4];
    ushort local_10;
    ushort local_e;
    int local_c;

    local_c = 0;
    *param_3 = 0xffff;
    cVar1 = FUN_00094624(param_1, param_2, 0);
    if (cVar1 == '\x01') {
        uVar2 = FUN_00093c84(param_2);
        cVar1 = FUN_00094594(param_1, uVar2, 0x21, local_18, 2);
        if (cVar1 == '\x01') {
            local_e = local_18[0];
            local_10 =
                (ushort)(((uint)local_18[0] << 0x17) >> 0x17) * 10 + 0x1ea;
            *param_3 = local_10;
            printf("chain-%d raw data: %u get_chain_mps_voltage1: %u\n",
                   param_1, (uint)local_18[0], (uint)local_10);
        } else {
            local_c = local_c + 1;
        }
    } else {
        local_c = local_c + 1;
    }
    if (0 < local_c) {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0,
                   "get_chain_mps_voltage2 error, fd %d", param_1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "mps2973.c",
             0xae, "get_chain_mps_voltage1", 0x16, 0xdb, 100, auStack_1018);
    }
    return local_c;
}

int get_chain_mps_voltage2(undefined4 param_1, undefined1 param_2,
                           ushort *param_3)

{
    char cVar1;
    undefined4 uVar2;
    undefined1 auStack_1018[4096];
    ushort local_18[4];
    ushort local_10;
    ushort local_e;
    int local_c;

    local_c = 0;
    *param_3 = 0xffff;
    cVar1 = FUN_00094624(param_1, param_2, 2);
    if (cVar1 == '\x01') {
        uVar2 = FUN_00093c84(param_2);
        cVar1 = FUN_00094594(param_1, uVar2, 0xd, local_18, 2);
        if (cVar1 == '\x01') {
            local_e = local_18[0];
            local_10 =
                (ushort)(((uint)(local_18[0] >> 5) << 0x17) >> 0x17) * 10 +
                0x1ea;
            *param_3 = local_10;
            printf("chain-%d graw data: %u get_chain_mps_voltage2: %u\n",
                   param_1, (uint)local_18[0], (uint)local_10);
        } else {
            local_c = local_c + 1;
        }
    } else {
        local_c = local_c + 1;
    }
    if (0 < local_c) {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0,
                   "get_chain_mps_voltage2 error, fd %d", param_1);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "mps2973.c",
             0xae, "get_chain_mps_voltage2", 0x16, 0xfa, 100, auStack_1018);
    }
    return local_c;
}

int set_chain_mps_voltage(undefined4 param_1, undefined1 param_2,
                          ushort param_3, ushort param_4)

{
    char cVar1;
    undefined4 uVar2;
    int iVar3;
    ushort local_102a;
    ushort local_1028;
    undefined1 auStack_101c[4096];
    ushort local_1c;
    ushort local_1a;
    undefined1 local_18;
    byte local_17;
    ushort local_e;
    int local_c;

    local_c = 0;
    local_1028 = param_3;
    if ((0xa5a < param_3) || (param_3 < 0x92e)) {
        if (param_3 < 0xa5a) {
            if (param_3 < 0x92e) {
                local_1028 = 0x92e;
            }
        } else {
            local_1028 = 0xa5a;
        }
        V_LOCK();
        logfmt_raw(
            auStack_101c, 0x1000, 0,
            "the mps_voltage_1 value-%d is out of the allowed range(%d-%d)",
            local_1028, 0x92e, 0xa5a);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "mps2973.c",
             0xae, "set_chain_mps_voltage", 0x15, 0x108, 0x28, auStack_101c);
    }
    local_102a = param_4;
    if ((0xa5a < param_4) || (param_4 < 0x92e)) {
        if (param_4 < 0xa5a) {
            if (param_4 < 0x92e) {
                local_102a = 0x92e;
            }
        } else {
            local_102a = 0xa5a;
        }
        V_LOCK();
        logfmt_raw(
            auStack_101c, 0x1000, 0,
            "the mps_voltage_2 value-%d is out of the allowed range(%d-%d)",
            local_102a, 0x92e, 0xa5a);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "mps2973.c",
             0xae, "set_chain_mps_voltage", 0x15, 0x10e, 0x28, auStack_101c);
    }
    get_chain_mps_voltage1(param_1, param_2, &local_1a);
    if (local_1028 == local_1a) {
        V_LOCK();
        logfmt_raw(auStack_101c, 0x1000, 0, "voltage1 is already set to %d",
                   local_1028);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "mps2973.c",
             0xae, "set_chain_mps_voltage", 0x15, 0x114, 0x14, auStack_101c);
        local_c = 0;
    } else {
        get_chain_mps_voltage2(param_1, param_2, &local_1c);
        if (local_102a == local_1c) {
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0, "voltage2 is already set to %d",
                       local_102a);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/drv_pic/mps2973.c",
                 0xae, "set_chain_mps_voltage", 0x15, 0x11b, 0x14,
                 auStack_101c);
            local_c = 0;
        } else {
            cVar1 = FUN_00094624(param_1, param_2, 0);
            if (cVar1 == '\x01') {
                iVar3 = ((int)(local_1028 - 0x1ea) / 10) * 0x800000;
                local_e = (ushort)((uint)iVar3 >> 0x17);
                local_18 = (undefined1)local_e;
                local_17 = (byte)((uint)iVar3 >> 0x1f);
                uVar2 = FUN_00093c84(param_2);
                cVar1 = FUN_000944f0(param_1, uVar2, 0x21, &local_18, 2);
                if (cVar1 == '\x01') {
                    cVar1 = FUN_00094624(param_1, param_2, 2);
                    if (cVar1 == '\x01') {
                        local_e =
                            (short)((int)(local_102a - 0x1ea) / 10) * 0x20 &
                            0x3fe0;
                        local_18 = (undefined1)local_e;
                        uVar2 = FUN_00093c84(param_2);
                        cVar1 = FUN_000944f0(param_1, uVar2, 0xd, &local_18, 2);
                        if (cVar1 == '\x01') {
                            get_chain_mps_voltage1(param_1, param_2, &local_1a);
                            if (local_1028 == local_1a) {
                                get_chain_mps_voltage2(param_1, param_2,
                                                       &local_1c);
                                if (local_102a != local_1c) {
                                    V_LOCK();
                                    logfmt_raw(auStack_101c, 0x1000, 0,
                                               "voltage2 set failed!",
                                               local_102a);
                                    V_UNLOCK();
                                    zlog(g_zc,
                                         "/workspace/jenkins/jenkins/workspace/"
                                         "Antminer_L9_CVCtrl_release/build/"
                                         "rootfs/buildroot/tmp/release/build/"
                                         "godminer-origin_godminer-branch1/"
                                         "backend/device/hal/drv_pic/mps2973.c",
                                         0xae, "set_chain_mps_voltage", 0x15,
                                         0x149, 100, auStack_101c);
                                    local_c = local_c + 1;
                                }
                            } else {
                                V_LOCK();
                                logfmt_raw(auStack_101c, 0x1000, 0,
                                           "voltage1 set failed!", local_1028);
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/backend/"
                                     "device/hal/drv_pic/mps2973.c",
                                     0xae, "set_chain_mps_voltage", 0x15, 0x141,
                                     100, auStack_101c);
                                local_c = local_c + 1;
                            }
                        } else {
                            local_c = local_c + 1;
                        }
                    } else {
                        local_c = local_c + 1;
                    }
                } else {
                    local_c = local_c + 1;
                }
            } else {
                local_c = local_c + 1;
            }
            if (0 < local_c) {
                V_LOCK();
                logfmt_raw(auStack_101c, 0x1000, 0,
                           "set_chain_mps_voltage error, fd %d", param_1);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/drv_pic/mps2973.c",
                     0xae, "set_chain_mps_voltage", 0x15, 0x150, 100,
                     auStack_101c);
            }
        }
    }
    return local_c;
}

void set_pic_device_high(undefined1 param_1)

{
    DAT_0015f930 = param_1;
    return;
}

void FUN_000953e4(undefined1 *param_1, undefined1 param_2, int param_3,
                  byte param_4)

{
    byte local_b;
    short local_a;

    *param_1 = 0x55;
    param_1[1] = 0xaa;
    param_1[2] = param_4 + 4;
    param_1[3] = param_2;
    local_a = (ushort)(byte)param_1[2] + (ushort)(byte)param_1[3];
    if (param_3 == 0) {
        param_1[4] = (char)((ushort)local_a >> 8);
        param_1[5] = (char)local_a;
    } else {
        for (local_b = 0; local_b < param_4; local_b = local_b + 1) {
            param_1[local_b + 4] = *(undefined1 *)(param_3 + (uint)local_b);
            local_a = (ushort) * (byte *)(param_3 + (uint)local_b) + local_a;
        }
        param_1[local_b + 4] = (char)((ushort)local_a >> 8);
        param_1[local_b + 5] = (char)local_a;
    }
    return;
}

void FUN_00095588(byte param_1, undefined4 param_2, undefined1 param_3,
                  undefined4 param_4, undefined1 param_5)

{
    pthread_mutex_lock((pthread_mutex_t *)i2c_mutex_all);
    iic_write(*(undefined4 *)(g_bitmain_pic_state + (uint)param_1 * 8), param_2,
              param_3);
    usleep(10000);
    iic_read(*(undefined4 *)(g_bitmain_pic_state + (uint)param_1 * 8), param_4,
             param_5);
    pthread_mutex_unlock((pthread_mutex_t *)i2c_mutex_all);
    return;
}

undefined4 FUN_00095620(uint param_1, undefined4 param_2, undefined4 param_3,
                        byte *param_4)

{
    bool bVar1;
    byte local_1818;
    char cStack_1817;
    byte bStack_1816;
    byte bStack_1815;
    char acStack_180c[2048];
    undefined1 auStack_100c[4099];
    byte local_9;

    local_9 = 0;
    cStack_1817 = (char)(param_1 >> 8);
    FUN_000953e4(param_3, param_1 & 0xff, param_2, cStack_1817);
    do {
        bStack_1815 = (byte)(param_1 >> 0x18);
        bStack_1816 = (byte)(param_1 >> 0x10);
        FUN_00095588(bStack_1815, param_3, cStack_1817 + '\x06', param_4,
                     bStack_1816);
        local_1818 = (byte)param_1;
        if (bStack_1816 == 2) {
            if ((*param_4 == local_1818) && (param_4[1] == 1)) {
                snprintf(acStack_180c, 0x800, "PICCMD %d passed on Chain[%d]!",
                         param_1 & 0xff, (uint)bStack_1815);
                V_LOCK();
                logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/drv_pic/pic_1704.c",
                     0xaf, "pic_process_cmd", 0xf, 99, 0x14, auStack_100c);
                return 1;
            }
            snprintf(acStack_180c, 0x800, "PICCMD %d failed on Chain[%d]!",
                     param_1 & 0xff, (uint)bStack_1815);
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/drv_pic/pic_1704.c",
                 0xaf, "pic_process_cmd", 0xf, 0x68, 0x14, auStack_100c);
            sleep(1);
        } else if (bStack_1816 < 3) {
            snprintf(acStack_180c, 0x800, "ret_len = %d should never happen!!",
                     (uint)bStack_1816);
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/drv_pic/pic_1704.c",
                 0xaf, "pic_process_cmd", 0xf, 0x7a, 0x14, auStack_100c);
        } else {
            if ((param_4[1] == local_1818) && (*param_4 == bStack_1816)) {
                snprintf(acStack_180c, 0x800, "PICCMD %d passed on Chain[%d]!",
                         param_1 & 0xff, (uint)bStack_1815);
                V_LOCK();
                logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/drv_pic/pic_1704.c",
                     0xaf, "pic_process_cmd", 0xf, 0x70, 0x14, auStack_100c);
                return 1;
            }
            snprintf(acStack_180c, 0x800, "PICCMD %d failed on Chain[%d]!",
                     param_1 & 0xff, (uint)bStack_1815);
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/drv_pic/pic_1704.c",
                 0xaf, "pic_process_cmd", 0xf, 0x75, 0x14, auStack_100c);
            sleep(1);
        }
        bVar1 = 2 < local_9;
        local_9 = local_9 + 1;
        if (bVar1) {
            return 0;
        }
    } while (true);
}

char pic1704_get_sw_version(undefined1 param_1, undefined1 *param_2)

{
    char cVar1;
    undefined4 local_24;
    undefined1 local_20;
    undefined4 local_1c;
    undefined2 local_18;
    undefined4 local_14;
    undefined4 local_10;

    local_1c = 0;
    local_18 = 0;
    local_20 = 0;
    local_24 = 0xff;
    *param_2 = 0xff;
    local_10 = 0;
    local_14 = CONCAT13(param_1, 0x50017);
    cVar1 = FUN_00095620(local_14, 0, &local_1c, &local_24);
    if (cVar1 != '\0') {
        *param_2 = local_24._2_1_;
    }
    return cVar1;
}

undefined1 pic1704_jump_to_app(undefined1 param_1)

{
    undefined1 uVar1;
    undefined2 local_20[2];
    undefined4 local_1c;
    undefined2 local_18;
    undefined4 local_14;
    undefined4 local_10;

    local_1c = 0;
    local_18 = 0;
    local_20[0] = 0xff;
    local_10 = 0;
    local_14 = CONCAT13(param_1, 0x20006);
    uVar1 = FUN_00095620(local_14, 0, &local_1c, local_20);
    return uVar1;
}

undefined1 pic1704_reset(undefined1 param_1)

{
    undefined1 uVar1;
    undefined2 local_20[2];
    undefined4 local_1c;
    undefined2 local_18;
    undefined4 local_14;
    undefined4 local_10;

    local_1c = 0;
    local_18 = 0;
    local_20[0] = 0xff;
    local_10 = 0;
    local_14 = CONCAT13(param_1, 0x20007);
    uVar1 = FUN_00095620(local_14, 0, &local_1c, local_20);
    return uVar1;
}

undefined1 pic1704_enable_disable_dc_dc(undefined1 param_1, undefined1 param_2)

{
    undefined1 uVar1;
    undefined1 local_22;
    undefined1 local_21;
    undefined2 local_20[2];
    undefined4 local_1c;
    undefined3 uStack_18;
    undefined4 local_14;
    undefined1 *local_10;

    local_1c = 0;
    uStack_18 = 0;
    local_20[0] = 0xff;
    local_10 = &local_22;
    local_14 = CONCAT13(param_1, 0x20115);
    local_22 = param_2;
    local_21 = param_1;
    uVar1 = FUN_00095620(local_14, local_10, &local_1c, local_20);
    return uVar1;
}

undefined1 pic1704_erase_program(undefined1 param_1)

{
    undefined1 uVar1;
    undefined2 local_20[2];
    undefined4 local_1c;
    undefined2 local_18;
    undefined4 local_14;
    undefined4 local_10;

    local_1c = 0;
    local_18 = 0;
    local_20[0] = 0xff;
    local_10 = 0;
    local_14 = CONCAT13(param_1, 0x20009);
    uVar1 = FUN_00095620(local_14, 0, &local_1c, local_20);
    return uVar1;
}

undefined1 pic1704_heart_beat(undefined1 param_1)

{
    undefined1 uVar1;
    undefined4 local_24;
    undefined2 local_20;
    undefined4 local_1c;
    undefined2 local_18;
    undefined4 local_14;
    undefined4 local_10;

    local_1c = 0;
    local_18 = 0;
    local_20 = 0;
    local_24 = 0xff;
    local_10 = 0;
    local_14 = CONCAT13(param_1, 0x60016);
    uVar1 = FUN_00095620(local_14, 0, &local_1c, &local_24);
    return uVar1;
}

undefined1 FUN_00095ed8(undefined1 param_1, undefined4 param_2)

{
    undefined1 uVar1;
    undefined2 local_30[2];
    undefined8 local_2c;
    undefined6 uStack_24;
    undefined2 local_1e;
    undefined6 uStack_1c;
    undefined4 local_14;
    undefined4 local_10;

    local_2c = 0;
    uStack_24 = 0;
    local_1e = 0;
    uStack_1c = 0;
    local_30[0] = 0xff;
    local_14 = CONCAT13(param_1, 0x21002);
    local_10 = param_2;
    uVar1 = FUN_00095620(local_14, param_2, &local_2c, local_30);
    return uVar1;
}

undefined4 pic1704_update_app_program(byte param_1)

{
    undefined4 uVar1;
    undefined8 *puVar2;
    char acStack_183c[2048];
    undefined1 auStack_103c[4096];
    undefined8 local_3c;
    undefined8 uStack_34;
    char local_2c[8];
    uint local_24;
    uint local_20;
    ulong local_1c;
    void *local_18;
    FILE *local_14;
    uint local_10;
    int local_c;

    local_10 = 0;
    local_2c[0] = '\0';
    local_2c[1] = '\0';
    local_2c[2] = '\0';
    local_2c[3] = '\0';
    local_2c[4] = '\0';
    local_2c[5] = '\0';
    local_2c[6] = '\0';
    local_3c = 0;
    uStack_34 = 0;
    local_1c = 0;
    local_20 = 0xdc0;
    local_24 = 0x370;
    local_c = 0;
    local_14 = fopen("/etc/config/dsPIC33EP16GS202_app.txt", "r");
    if (local_14 == (FILE *)0x0) {
        snprintf(acStack_183c, 0x800,
                 "%s open DSPIC33EP16GS202_PIC_PROGRAM failed chain[%d]!",
                 "pic1704_update_app_program", (uint)param_1);
        V_LOCK();
        logfmt_raw(auStack_103c, 0x1000, 0, acStack_183c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "pic_1704.c",
             0xaf, "pic1704_update_app_program", 0x1a, 0x113, 0x14,
             auStack_103c);
        uVar1 = 0xffffffff;
    } else {
        local_18 = malloc(0x3700);
        if (local_18 == (void *)0x0) {
            snprintf(acStack_183c, 0x800, "%s malloc failed chain[%d]!",
                     "pic1704_update_app_program", (uint)param_1);
            V_LOCK();
            logfmt_raw(auStack_103c, 0x1000, 0, acStack_183c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/drv_pic/pic_1704.c",
                 0xaf, "pic1704_update_app_program", 0x1a, 0x11a, 0x14,
                 auStack_103c);
            set_miner_6060info_malloc_failed_err(1);
            uVar1 = 0xffffffff;
        } else {
            fseek(local_14, 0, 0);
            memset(local_18, 0, 0x3700);
            for (local_10 = 0; local_10 < local_20; local_10 = local_10 + 1) {
                fgets(local_2c, 7, local_14);
                local_1c = strtoul(local_2c, (char **)0x0, 0x10);
                *(char *)((int)local_18 + local_10 * 4) =
                    (char)(local_1c >> 0x18);
                *(char *)((int)local_18 + local_10 * 4 + 1) =
                    (char)(local_1c >> 0x10);
                *(char *)((int)local_18 + local_10 * 4 + 2) =
                    (char)(local_1c >> 8);
                *(char *)((int)local_18 + local_10 * 4 + 3) = (char)local_1c;
            }
            fclose(local_14);
            local_c = pic1704_reset(param_1);
            if (local_c == 0) {
                snprintf(acStack_183c, 0x800, "%s reset pic error chain[%d]!",
                         "pic1704_update_app_program", (uint)param_1);
                V_LOCK();
                logfmt_raw(auStack_103c, 0x1000, 0, acStack_183c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/drv_pic/pic_1704.c",
                     0xaf, "pic1704_update_app_program", 0x1a, 0x134, 0x14,
                     auStack_103c);
                V_LOCK();
                logfmt_raw(auStack_103c, 0x1000, 0,
                           "Sweep error string = J%d:5.", param_1);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/drv_pic/pic_1704.c",
                     0xaf, "pic1704_update_app_program", 0x1a, 0x135, 100,
                     auStack_103c);
                free(local_18);
                uVar1 = 0;
            } else {
                local_c = pic1704_erase_program(param_1);
                if (local_c == 0) {
                    snprintf(acStack_183c, 0x800,
                             "%s erase pic error chain[%d]!",
                             "pic1704_update_app_program", (uint)param_1);
                    V_LOCK();
                    logfmt_raw(auStack_103c, 0x1000, 0, acStack_183c);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/drv_pic/pic_1704.c",
                         0xaf, "pic1704_update_app_program", 0x1a, 0x13e, 0x14,
                         auStack_103c);
                    free(local_18);
                    uVar1 = 0;
                } else {
                    for (local_10 = 0; local_10 < local_24;
                         local_10 = local_10 + 1) {
                        puVar2 =
                            (undefined8 *)((int)local_18 + local_10 * 0x10);
                        local_3c = *puVar2;
                        uStack_34 = puVar2[1];
                        local_c = FUN_00095ed8(param_1, &local_3c);
                        if (local_c == 0) {
                            snprintf(acStack_183c, 0x800,
                                     "%s send data to pic error chain[%d]!",
                                     "pic1704_update_app_program",
                                     (uint)param_1);
                            V_LOCK();
                            logfmt_raw(auStack_103c, 0x1000, 0, acStack_183c);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/backend/"
                                 "device/hal/drv_pic/pic_1704.c",
                                 0xaf, "pic1704_update_app_program", 0x1a,
                                 0x152, 0x14, auStack_103c);
                            free(local_18);
                            return 0;
                        }
                    }
                    local_c = pic1704_reset(param_1);
                    if (local_c == 0) {
                        snprintf(acStack_183c, 0x800,
                                 "%s reset error after program chain[%d]!",
                                 "pic1704_update_app_program", (uint)param_1);
                        V_LOCK();
                        logfmt_raw(auStack_103c, 0x1000, 0, acStack_183c);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/device/"
                             "hal/drv_pic/pic_1704.c",
                             0xaf, "pic1704_update_app_program", 0x1a, 0x15c,
                             0x14, auStack_103c);
                        V_LOCK();
                        logfmt_raw(auStack_103c, 0x1000, 0,
                                   "Sweep error string = J%d:5.", param_1);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/device/"
                             "hal/drv_pic/pic_1704.c",
                             0xaf, "pic1704_update_app_program", 0x1a, 0x15d,
                             100, auStack_103c);
                        free(local_18);
                        uVar1 = 0;
                    } else {
                        free(local_18);
                        uVar1 = 1;
                    }
                }
            }
        }
    }
    return uVar1;
}

undefined1 pic1704_set_voltage(undefined1 param_1, byte param_2)

{
    undefined1 uVar1;
    ushort local_28;
    undefined1 local_26;
    undefined2 local_24[2];
    undefined1 local_20;
    undefined7 uStack_1f;
    undefined1 uStack_18;
    undefined4 local_14;
    ushort *local_10;

    local_20 = 0;
    uStack_1f = 0;
    uStack_18 = 0;
    local_24[0] = 0xff;
    local_26 = 0;
    local_28 = (ushort)param_2;
    local_10 = &local_28;
    local_14 = CONCAT13(param_1, 0x20310);
    uVar1 = FUN_00095620(local_14, local_10, &local_20, local_24);
    return uVar1;
}

bool FUN_00096828(byte *param_1)

{
    bool bVar1;
    byte *local_181c;
    char acStack_1818[2048];
    undefined1 auStack_1018[4096];
    uint local_18;
    ushort local_12;
    uint local_10;
    ushort local_a;

    local_a = 0;
    if ((param_1 == (byte *)0x0) || (*param_1 < 4)) {
        bVar1 = false;
    } else {
        local_18 = (uint)*param_1;
        local_181c = param_1;
        for (local_10 = 0; local_10 < local_18 - 2; local_10 = local_10 + 1) {
            local_a = *local_181c + local_a;
            local_181c = local_181c + 1;
        }
        local_12 = CONCAT11(*local_181c, local_181c[1]);
        snprintf(acStack_1818, 0x800, "sum1,sum2 = %d,%d", (uint)local_a,
                 (uint)local_12);
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, acStack_1818);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "pic_1704.c",
             0xaf, "check_pic_crc", 0xd, 400, 0x14, auStack_1018);
        bVar1 = local_a == local_12;
    }
    return bVar1;
}

undefined4 FUN_00096a24(float param_1, uint param_2)

{
    undefined4 uVar1;
    undefined4 uVar2;
    double dVar3;
    char acStack_1818[2048];
    undefined1 auStack_1018[4096];
    undefined8 local_18;
    undefined8 local_10;

    dVar3 = ((double)param_2 * 3.3) / (double)(param_1 * 1024.0);
    local_10._0_4_ = SUB84(dVar3, 0);
    local_10._4_4_ = (undefined4)((ulonglong)dVar3 >> 0x20);
    uVar1 = local_10._4_4_;
    uVar2 = (undefined4)local_10;
    local_10 = dVar3;
    snprintf(acStack_1818, 0x800, "v_an2 = %f", acStack_1818, uVar2, uVar1);
    V_LOCK();
    logfmt_raw(auStack_1018, 0x1000, 0, acStack_1818);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/drv_pic/pic_1704.c",
        0xaf, "decode_an_voltage_buf", 0x15, 0x19a, 0x14, auStack_1018);
    dVar3 = local_10 * 7.599999904632568;
    local_18._0_4_ = SUB84(dVar3, 0);
    local_18._4_4_ = (undefined4)((ulonglong)dVar3 >> 0x20);
    uVar1 = local_18._4_4_;
    uVar2 = (undefined4)local_18;
    local_18 = dVar3;
    snprintf(acStack_1818, 0x800, "v_10 = %f", acStack_1818, uVar2, uVar1);
    V_LOCK();
    logfmt_raw(auStack_1018, 0x1000, 0, acStack_1818);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/drv_pic/pic_1704.c",
        0xaf, "decode_an_voltage_buf", 0x15, 0x19d, 0x14, auStack_1018);
    return (undefined4)local_18;
}

undefined4 pic1704_get_an_voltage1(undefined1 param_1)

{
    uint uVar1;
    undefined4 local_18;
    char local_11;
    ulonglong local_10;

    local_18 = 0;
    local_10 = 0;
    local_11 = pic1704_get_single_voltage(param_1, &local_18);
    if (local_11 != '\0') {
        uVar1 = FUN_00096a24(0x3f800000, local_18);
        local_10 = (ulonglong)uVar1;
    }
    return (undefined4)local_10;
}

undefined4 pic1704_get_an_voltage2(undefined1 param_1, char param_2)

{
    undefined4 uVar1;
    undefined8 in_d0;
    char local_1828[28];
    undefined4 local_180c;
    undefined1 auStack_1028[4096];
    uint local_28;
    uint local_24;
    uint local_20;
    float fStack_1c;
    double dStack_18;
    char local_9;

    local_20 = 0;
    local_24 = 0;
    local_28 = 0;
    local_9 = pic1704_get_all_voltage(param_1, &local_20, &local_24, &local_28);
    if (local_9 == '\0') {
        uVar1 = 0;
    } else {
        builtin_strncpy(local_1828, "Received an voltage response", 0x1c);
        local_180c = CONCAT22(local_180c._2_2_, 0x2e);
        V_LOCK();
        logfmt_raw(auStack_1028, 0x1000, 0, local_1828);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "pic_1704.c",
             0xaf, "pic1704_get_an_voltage2", 0x17, 0x1bd, 0x14, auStack_1028);
        snprintf(local_1828, 0x800, "an0 = %f, an2 %f, an6 %f.", local_1828,
                 ((double)local_20 * 3.3) / 1024.0,
                 ((double)local_24 * 3.3) / 1024.0,
                 ((double)local_28 * 3.3) / 1024.0);
        V_LOCK();
        logfmt_raw(auStack_1028, 0x1000, 0, local_1828);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "pic_1704.c",
             0xaf, "pic1704_get_an_voltage2", 0x17, 0x1be, 0x14, auStack_1028);
        if (param_2 == '\0') {
            uVar1 = FUN_00096a24(0x3f800000, local_24);
        } else {
            dStack_18 = ((double)local_28 * 3.3) / 1024.0;
            if (((double)(float)in_d0 <= dStack_18) &&
                (dStack_18 <= (double)(float)((ulonglong)in_d0 >> 0x20))) {
                fStack_1c = (float)(dStack_18 / 2.5);
                uVar1 = FUN_00096a24(fStack_1c, local_24);
                return uVar1;
            }
            builtin_strncpy(local_1828, "Ref an vol too high or too l", 0x1c);
            local_180c._0_1_ = 'o';
            local_180c._1_1_ = 'w';
            local_180c._2_1_ = '.';
            local_180c._3_1_ = '\0';
            V_LOCK();
            logfmt_raw(auStack_1028, 0x1000, 0, local_1828);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/drv_pic/pic_1704.c",
                 0xaf, "pic1704_get_an_voltage2", 0x17, 0x1c4, 0x14,
                 auStack_1028);
            uVar1 = 0;
        }
    }
    return uVar1;
}

undefined4 pic1704_get_single_voltage(undefined1 param_1, uint *param_2)

{
    char cVar1;
    undefined4 uVar2;
    char acStack_1824[2048];
    undefined1 auStack_1024[4096];
    byte local_24;
    byte bStack_23;
    byte bStack_22;
    undefined1 uStack_21;
    undefined1 local_20;
    undefined2 uStack_1f;
    undefined4 local_1c;
    undefined2 local_18;
    undefined4 local_14;
    undefined4 local_10;
    char local_9;

    local_1c = 0;
    local_18 = 0;
    bStack_23 = 0;
    bStack_22 = 0;
    uStack_21 = 0;
    local_20 = 0;
    uStack_1f = 0;
    local_24 = 0xff;
    local_10 = 0;
    local_14 = CONCAT13(param_1, 0x7003a);
    local_9 = FUN_00095620(local_14, 0, &local_1c, &local_24);
    if (local_9 == '\0') {
        uVar2 = 0;
    } else if ((bStack_22 == 1) &&
               (cVar1 = FUN_00096828(&local_24), cVar1 == '\x01')) {
        *param_2 = (uint)CONCAT11(uStack_21, local_20);
        snprintf(acStack_1824, 0x800,
                 "Received one voltage response: vol = %d.", *param_2);
        V_LOCK();
        logfmt_raw(auStack_1024, 0x1000, 0, acStack_1824);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "pic_1704.c",
             0xaf, "pic1704_get_single_voltage", 0x1a, 0x1e7, 0x14,
             auStack_1024);
        uVar2 = 1;
    } else {
        snprintf(acStack_1824, 0x800,
                 "ret_buff error: buff0 = %d, buff1 = %d, buff2 = %d.",
                 (uint)local_24, (uint)bStack_23, (uint)bStack_22);
        V_LOCK();
        logfmt_raw(auStack_1024, 0x1000, 0, acStack_1824);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "pic_1704.c",
             0xaf, "pic1704_get_single_voltage", 0x1a, 0x1e3, 0x14,
             auStack_1024);
        uVar2 = 1;
    }
    return uVar2;
}

bool pic1704_get_all_voltage(undefined1 param_1, uint *param_2, uint *param_3,
                             uint *param_4)

{
    bool bVar1;
    char acStack_1824[2048];
    undefined1 auStack_1024[4096];
    undefined1 local_24;
    undefined2 uStack_23;
    undefined1 uStack_21;
    undefined1 uStack_20;
    undefined1 uStack_1f;
    undefined1 uStack_1e;
    undefined1 uStack_1d;
    undefined1 local_1c;
    undefined2 uStack_1b;
    undefined4 local_18;
    undefined4 local_14;
    undefined4 local_10;
    char local_9;

    local_18 = 0;
    uStack_23 = 0;
    uStack_21 = 0;
    uStack_20 = 0;
    uStack_1f = 0;
    uStack_1e = 0;
    uStack_1d = 0;
    local_1c = 0;
    uStack_1b = 0;
    local_24 = 0xff;
    local_10 = 0;
    local_14 = CONCAT13(param_1, 0xb0037);
    local_9 = FUN_00095620(local_14, 0, &local_18, &local_24);
    bVar1 = local_9 != '\0';
    if (bVar1) {
        *param_2 = (uint)CONCAT11(uStack_21, uStack_20);
        *param_3 = (uint)CONCAT11(uStack_1f, uStack_1e);
        *param_4 = (uint)CONCAT11(uStack_1d, local_1c);
        snprintf(
            acStack_1824, 0x800,
            "Received all voltage response: vol0 = %d, vol1 = %d, vol2 = %d.",
            *param_2, *param_3, *param_4);
        V_LOCK();
        logfmt_raw(auStack_1024, 0x1000, 0, acStack_1824);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "pic_1704.c",
             0xaf, "pic1704_get_all_voltage", 0x17, 0x202, 0x14, auStack_1024);
    }
    return bVar1;
}

undefined1 pic1704_voltage_clamp_ctrl(undefined1 param_1, undefined1 param_2)

{
    undefined1 uVar1;
    undefined1 local_22;
    undefined1 local_21;
    undefined2 local_20[2];
    undefined4 local_1c;
    undefined3 uStack_18;
    undefined4 local_14;
    undefined1 *local_10;

    local_1c = 0;
    uStack_18 = 0;
    local_20[0] = 0xff;
    local_10 = &local_22;
    local_14 = CONCAT13(param_1, 0x20131);
    local_22 = param_2;
    local_21 = param_1;
    uVar1 = FUN_00095620(local_14, local_10, &local_1c, local_20);
    return uVar1;
}

bool pic1704_get_PDCx(undefined1 param_1, uint *param_2, uint *param_3,
                      uint *param_4)

{
    char cVar1;
    undefined1 local_2c;
    undefined2 uStack_2b;
    undefined1 uStack_29;
    undefined1 uStack_28;
    undefined1 uStack_27;
    undefined1 uStack_26;
    undefined1 uStack_25;
    undefined1 local_24;
    undefined4 local_20;
    undefined2 local_1c;
    undefined4 local_18;
    undefined4 local_14;

    local_20 = 0;
    local_1c = 0;
    uStack_2b = 0;
    uStack_29 = 0;
    uStack_28 = 0;
    uStack_27 = 0;
    uStack_26 = 0;
    uStack_25 = 0;
    local_24 = 0;
    local_2c = 0xff;
    local_14 = 0;
    local_18 = CONCAT13(param_1, 0x9002b);
    cVar1 = FUN_00095620(local_18, 0, &local_20, &local_2c);
    if (cVar1 != '\0') {
        *param_2 = (uint)CONCAT11(uStack_29, uStack_28);
        *param_3 = (uint)CONCAT11(uStack_27, uStack_26);
        *param_4 = (uint)CONCAT11(uStack_25, local_24);
    }
    return cVar1 != '\0';
}

bool pic1704_get_raw_crab_voltage(undefined1 param_1, uint *param_2,
                                  uint *param_3, uint *param_4, uint *param_5)

{
    char cVar1;
    undefined1 local_30;
    undefined2 uStack_2f;
    undefined1 uStack_2d;
    undefined1 uStack_2c;
    undefined1 uStack_2b;
    undefined1 uStack_2a;
    undefined1 uStack_29;
    undefined1 local_28;
    undefined1 local_27;
    undefined1 local_26;
    undefined2 uStack_25;
    undefined4 local_20;
    undefined2 local_1c;
    undefined4 local_18;
    undefined4 local_14;

    local_20 = 0;
    local_1c = 0;
    uStack_2f = 0;
    uStack_2d = 0;
    uStack_2c = 0;
    uStack_2b = 0;
    uStack_2a = 0;
    uStack_29 = 0;
    local_28 = 0;
    local_27 = 0;
    local_26 = 0;
    uStack_25 = 0;
    local_30 = 0xff;
    local_14 = 0;
    local_18 = CONCAT13(param_1, 0xd0028);
    cVar1 = FUN_00095620(local_18, 0, &local_20, &local_30);
    if (cVar1 != '\0') {
        *param_2 = (uint)CONCAT11(uStack_2d, uStack_2c);
        *param_3 = (uint)CONCAT11(uStack_2b, uStack_2a);
        *param_4 = (uint)CONCAT11(uStack_29, local_28);
        *param_5 = (uint)CONCAT11(local_27, local_26);
    }
    return cVar1 != '\0';
}

undefined1 pic1704_write_iic(undefined1 param_1, undefined1 param_2)

{
    undefined1 uVar1;
    undefined1 local_24;
    undefined1 local_23;
    undefined2 local_20[2];
    undefined8 local_1c;
    undefined4 local_14;
    undefined1 *local_10;

    local_1c = 0;
    local_20[0] = 0xff;
    local_23 = 0;
    local_10 = &local_24;
    local_14 = CONCAT13(param_1, 0x2023b);
    local_24 = param_2;
    uVar1 = FUN_00095620(local_14, local_10, &local_1c, local_20);
    return uVar1;
}

undefined4 pic1704_read_iic(undefined1 param_1, undefined1 param_2,
                            undefined1 *param_3)

{
    undefined4 uVar1;
    undefined1 local_30;
    undefined1 local_2f;
    byte abStack_2e[10];
    undefined4 local_24;
    undefined3 uStack_20;
    undefined4 local_1c;
    undefined1 *local_18;
    char local_11;
    int local_10;
    ushort local_a;

    local_24 = 0;
    uStack_20 = 0;
    abStack_2e[3] = 0;
    abStack_2e[4] = '\0';
    abStack_2e[5] = 0;
    abStack_2e[6] = 0;
    abStack_2e[7] = 0;
    abStack_2e[8] = 0;
    abStack_2e[2] = 0xff;
    local_2f = 2;
    local_18 = &local_30;
    local_1c = CONCAT13(param_1, 0x7023c);
    local_30 = param_2;
    local_11 = FUN_00095620(local_1c, local_18, &local_24, abStack_2e + 2);
    if (local_11 == '\0') {
        uVar1 = 0;
    } else {
        local_a = 0;
        for (local_10 = 0; local_10 < (int)(local_1c._2_1_ - 2);
             local_10 = local_10 + 1) {
            local_a = abStack_2e[local_10 + 2] + local_a;
        }
        if ((local_a >> 8 == (ushort)abStack_2e[local_1c._2_1_]) &&
            ((local_a & 0xff) == (ushort)abStack_2e[local_1c._2_1_ + 1])) {
            if (abStack_2e[4] == '\x01') {
                *param_3 = abStack_2e[5];
                uVar1 = 1;
            } else {
                uVar1 = 0;
            }
        } else {
            uVar1 = 0;
        }
    }
    return uVar1;
}

undefined1 pic1704_write_flash(undefined1 param_1, void *param_2,
                               undefined1 param_3, size_t param_4)

{
    undefined4 local_24;
    undefined1 local_20;
    undefined4 local_1c;
    undefined1 *local_18;
    undefined1 local_11;
    undefined1 *local_10;
    void *local_c;

    local_20 = 0;
    local_24 = 0xff;
    local_c = malloc(param_4 + 8);
    local_10 = (undefined1 *)malloc(param_4 + 2);
    *local_10 = param_3;
    local_10[1] = (char)param_4;
    memcpy(local_10 + 2, param_2, param_4);
    local_18 = local_10;
    local_1c =
        CONCAT13(param_1, CONCAT12(5, CONCAT11((char)param_4 + '\x02', 0x33)));
    local_11 = FUN_00095620(local_1c, local_10, local_c, &local_24);
    free(local_10);
    free(local_c);
    return local_11;
}

char pic1704_read_flash(undefined1 param_1, void *param_2, undefined1 param_3,
                        size_t param_4)

{
    undefined1 local_28;
    char local_27;
    undefined8 local_24;
    undefined4 local_1c;
    undefined1 *local_18;
    void *local_14;
    uint local_10;
    ushort local_c;
    char local_9;

    local_24 = 0;
    local_14 = malloc(param_4 + 5);
    local_27 = (char)param_4;
    local_18 = &local_28;
    local_1c = CONCAT13(param_1, CONCAT12(local_27 + '\x05', 0x234));
    local_28 = param_3;
    local_9 = FUN_00095620(local_1c, local_18, &local_24, local_14);
    if (local_9 != '\0') {
        local_c = 0;
        for (local_10 = 0; local_10 < param_4 + 3; local_10 = local_10 + 1) {
            local_c = *(byte *)((int)local_14 + local_10) + local_c;
        }
        if ((local_c >> 8 ==
             (ushort) * (byte *)((int)local_14 + param_4 + 3)) &&
            ((local_c & 0xff) ==
             (ushort) * (byte *)((int)local_14 + param_4 + 4))) {
            memcpy(param_2, (void *)((int)local_14 + 3), param_4);
        } else {
            local_9 = '\0';
        }
    }
    free(local_14);
    return local_9;
}

int open_pic(byte param_1)

{
    uint local_14;
    undefined2 local_10;
    undefined1 local_e;
    byte local_d;
    int local_c;

    if ((*(int *)(g_bitmain_pic_state + (uint)param_1 * 8) == 0) ||
        (*(int *)(g_bitmain_pic_state + (uint)param_1 * 8 + 4) == 0)) {
        local_14 = (uint)param_1;
        local_10 = 0;
        local_e = DAT_0015f930;
        local_d = param_1;
        pthread_mutex_lock((pthread_mutex_t *)i2c_mutex_all);
        local_c = iic_init(&local_14);
        pthread_mutex_unlock((pthread_mutex_t *)i2c_mutex_all);
        if (-1 < local_c) {
            *(int *)(g_bitmain_pic_state + (uint)param_1 * 8) = local_c;
            *(undefined4 *)(g_bitmain_pic_state + (uint)param_1 * 8 + 4) = 1;
        }
    } else {
        local_c = *(int *)(g_bitmain_pic_state + (uint)param_1 * 8);
    }
    return local_c;
}

void close_pic(byte param_1)

{
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    if (param_1 < 0x10) {
        if ((*(int *)(g_bitmain_pic_state + (uint)param_1 * 8) != 0) ||
            (*(int *)(g_bitmain_pic_state + (uint)param_1 * 8 + 4) != 0)) {
            pthread_mutex_lock((pthread_mutex_t *)i2c_mutex_all);
            iic_uninit(
                *(undefined4 *)(g_bitmain_pic_state + (uint)param_1 * 8));
            *(undefined4 *)(g_bitmain_pic_state + (uint)param_1 * 8 + 4) = 0;
            pthread_mutex_unlock((pthread_mutex_t *)i2c_mutex_all);
        }
    } else {
        snprintf(acStack_1808, 0x800, "%s: Bad pic param, input chain is %d",
                 "close_pic", (uint)param_1);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "pic_1704.c",
             0xaf, "close_pic", 9, 0x2fd, 100, auStack_1008);
    }
    return;
}

undefined4 FUN_00097f6c(undefined4 param_1)

{
    int iVar1;
    undefined4 uVar2;

    iVar1 = hal_fan_addr(param_1);
    if (iVar1 < 0) {
        uVar2 = 0;
    } else {
        uVar2 = hal_fan_addr(param_1);
    }
    return uVar2;
}

int FUN_00097fb0(byte param_1, char *param_2)

{
    int iVar1;
    float fVar2;
    char *local_c;

    local_c = param_2;
    do {
        local_c = local_c + 1;
    } while (*local_c != ' ');
    *local_c = '\0';
    iVar1 = atoi(param_2);
    if (iVar1 == 0) {
        iVar1 = 0;
    } else {
        iVar1 = atoi(param_2);
        if (4000000 < iVar1) {
            iVar1 = atoi(param_2);
            *(int *)(&DAT_0015f93c + (uint)param_1 * 4) = iVar1;
        }
        fVar2 = 6e+10 /
                (float)(uint)(*(int *)(&DAT_0015f93c + (uint)param_1 * 4) << 1);
        iVar1 = (((uint)(0.0 < fVar2) * (int)(longlong)fVar2) / 10) * 10;
    }
    return iVar1;
}

undefined4 FUN_000980c4(void)

{
    FILE *pFVar1;
    int iVar2;
    undefined4 uVar3;
    undefined4 extraout_r3;
    uint uVar4;
    int iVar5;
    char local_1874[2048];
    undefined1 auStack_1074[4096];
    int local_74[8];
    char local_54[67];
    byte local_11;

    local_54[0] = '\0';
    local_54[1] = '\0';
    local_54[2] = '\0';
    local_54[3] = '\0';
    local_54[4] = '\0';
    local_54[5] = '\0';
    local_54[6] = '\0';
    local_54[7] = '\0';
    local_54[8] = '\0';
    local_54[9] = '\0';
    local_54[10] = '\0';
    local_54[0xb] = '\0';
    local_54[0xc] = '\0';
    local_54[0xd] = '\0';
    local_54[0xe] = '\0';
    local_54[0xf] = '\0';
    local_54[0x10] = '\0';
    local_54[0x11] = '\0';
    local_54[0x12] = '\0';
    local_54[0x13] = '\0';
    local_54[0x14] = '\0';
    local_54[0x15] = '\0';
    local_54[0x16] = '\0';
    local_54[0x17] = '\0';
    local_54[0x18] = '\0';
    local_54[0x19] = '\0';
    local_54[0x1a] = '\0';
    local_54[0x1b] = '\0';
    local_54[0x1c] = '\0';
    local_54[0x1d] = '\0';
    local_54[0x1e] = '\0';
    local_54[0x1f] = '\0';
    local_54[0x20] = '\0';
    local_54[0x21] = '\0';
    local_54[0x22] = '\0';
    local_54[0x23] = '\0';
    local_54[0x24] = '\0';
    local_54[0x25] = '\0';
    local_54[0x26] = '\0';
    local_54[0x27] = '\0';
    local_54[0x28] = '\0';
    local_54[0x29] = '\0';
    local_54[0x2a] = '\0';
    local_54[0x2b] = '\0';
    local_54[0x2c] = '\0';
    local_54[0x2d] = '\0';
    local_54[0x2e] = '\0';
    local_54[0x2f] = '\0';
    local_54[0x30] = '\0';
    local_54[0x31] = '\0';
    local_54[0x32] = '\0';
    local_54[0x33] = '\0';
    local_54[0x34] = '\0';
    local_54[0x35] = '\0';
    local_54[0x36] = '\0';
    local_54[0x37] = '\0';
    local_54[0x38] = '\0';
    local_54[0x39] = '\0';
    local_54[0x3a] = '\0';
    local_54[0x3b] = '\0';
    local_54[0x3c] = '\0';
    local_54[0x3d] = '\0';
    local_54[0x3e] = '\0';
    local_54[0x3f] = '\0';
    local_74[0] = 0;
    local_74[1] = 0;
    local_74[2] = 0;
    local_74[3] = 0;
    local_74[4] = 0;
    local_74[5] = 0;
    local_74[6] = 0;
    local_74[7] = 0;
    for (local_11 = 0;
         uVar4 = (uint)local_11, iVar2 = hal_fan_number(), (int)uVar4 < iVar2;
         local_11 = local_11 + 1) {
        do {
            memset(local_54, 0, 0x40);
            uVar3 = hal_fan_addr(local_11);
            snprintf(local_54, 0x40, "/sys/class/pwm/pwmchip12/pwm%d/capture",
                     uVar3);
            uVar4 = (uint)local_11;
            pFVar1 = fopen(local_54, "r");
            local_74[uVar4] = (int)pFVar1;
            if (local_74[local_11] == 0) {
                snprintf(local_1874, 0x800, "fail to open %s", local_54);
                V_LOCK();
                logfmt_raw(auStack_1074, 0x1000, 0, local_1874);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_fan.c",
                     0xb9, "fan_thread_function", 0x13, 0x3e, 100,
                     auStack_1074);
                usleep(3000000);
            }
        } while ((local_74[local_11] == 0) && (DAT_0015f938 == 1));
        snprintf(local_1874, 0x800, "%s open successfully", local_54);
        V_LOCK();
        logfmt_raw(auStack_1074, 0x1000, 0, local_1874);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_fan.c",
             0xb9, "fan_thread_function", 0x13, 0x43, 0x14, auStack_1074);
    }
    while (DAT_0015f938 != 0) {
        for (local_11 = 0; uVar4 = (uint)local_11, iVar2 = hal_fan_number(),
            (int)uVar4 < iVar2;
             local_11 = local_11 + 1) {
            fflush((FILE *)local_74[local_11]);
            fseek((FILE *)local_74[local_11], 0, 0);
            memset(local_54, 0, 0x40);
            fread(local_54, 1, 0x40, (FILE *)local_74[local_11]);
            uVar4 = (uint)local_11;
            uVar3 = FUN_00097fb0(local_11, local_54);
            *(undefined4 *)(&DAT_0015f95c + uVar4 * 4) = uVar3;
            *(undefined4 *)(&DAT_001505a8 + (uint)local_11 * 4) =
                *(undefined4 *)(&DAT_0015f95c + (uint)local_11 * 4);
            iVar5 = *(int *)(&DAT_001505a8 + (uint)local_11 * 4);
            iVar2 = fan_get_max_speed(local_11);
            if (iVar2 < iVar5) {
                uVar4 = (uint)local_11;
                uVar3 = fan_get_max_speed(local_11);
                *(undefined4 *)(&DAT_001505a8 + uVar4 * 4) = uVar3;
            }
        }
        usleep(100);
    }
    for (local_11 = 0;
         uVar4 = (uint)local_11, iVar2 = hal_fan_number(), (int)uVar4 < iVar2;
         local_11 = local_11 + 1) {
        fclose((FILE *)local_74[local_11]);
    }
    builtin_strncpy(local_1874, "fan thread exit\n", 0x10);
    local_1874[0x10] = 0;
    V_LOCK();
    logfmt_raw(auStack_1074, 0x1000, 0, local_1874);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/platform/cv183x/cv183x_fan.c",
        0xb9, "fan_thread_function", 0x13, 0x5e, 0x14, auStack_1074);
    return extraout_r3;
}

undefined4 fan_init(void)

{
    undefined4 uVar1;
    char local_1808[28];
    undefined2 local_17ec;
    undefined1 auStack_1008[4096];

    if (platform_inited == 0) {
        builtin_strncpy(local_1808, "please init platform first!!", 0x1c);
        local_17ec = 10;
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_fan.c",
             0xb9, "fan_init", 8, 0x65, 100, auStack_1008);
        uVar1 = 0xffffffff;
    } else {
        DAT_0015f938 = 1;
        pthread_create(&DAT_0015f934, (pthread_attr_t *)0x0, FUN_000980c4,
                       (void *)0x0);
        uVar1 = 0;
    }
    return uVar1;
}

void fan_uninit(void)

{
    DAT_0015f938 = 0;
    pthread_join(DAT_0015f934, (void **)0x0);
    return;
}

undefined4 fan_get_realtime_speed(uint param_1)

{
    char acStack_180c[2048];
    undefined1 auStack_100c[4096];
    undefined4 local_c;

    local_c = 0;
    if (7 < param_1) {
        snprintf(acStack_180c, 0x800, "bad fan id = %d\n", param_1);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_fan.c",
             0xb9, "fan_get_realtime_speed", 0x16, 0x80, 100, auStack_100c);
    }
    return *(undefined4 *)(&DAT_001505a8 + param_1 * 4);
}

undefined4 fan_get_max_num(void)

{
    undefined4 uVar1;

    uVar1 = hal_fan_number();
    return uVar1;
}

undefined4 fan_get_max_speed(undefined4 param_1)

{
    undefined4 uVar1;

    uVar1 = hal_fan_max_speed(param_1);
    return uVar1;
}

undefined4 fan_turn_on(void)

{
    return 0xffffffff;
}

undefined4 fan_turn_off(void)

{
    return 0xffffffff;
}

undefined4 fpga_init(void)

{
    return 0;
}

void fpga_uninit(void)

{
    return;
}

undefined4 fpga_read(void)

{
    return 0xffffffff;
}

undefined4 fpga_write(void)

{
    return 0xffffffff;
}

undefined4 get_fpga_map_mem_addr(void)

{
    return 0;
}

undefined4 get_hardware_version(void)

{
    return 0;
}

void fpga_reset(void)

{
    return;
}

int iic_init(int *param_1)

{
    int iVar1;
    char local_1810[8];
    undefined4 local_1808;
    char acStack_1804[8];
    uint local_17fc;
    undefined1 auStack_1010[4096];
    int local_10;
    int local_c;

    local_c = 0;
    local_10 = 0;
    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0015f97c);
    if (iVar1 == 0) {
        if (param_1 == (int *)0x0) {
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_0015f97c);
            builtin_strncpy(local_1810, "bad para", 8);
            local_1808 = CONCAT13(local_1808._3_1_, 0xa6d);
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_iic.c",
                 0xb9, "iic_init", 8, 0x27, 100, auStack_1010);
            local_c = -3;
        } else {
            if ((((*param_1 == 0) && ((short)param_1[1] == 1)) &&
                 (*(char *)((int)param_1 + 6) == '\x02')) &&
                (*(char *)((int)param_1 + 7) == '\0')) {
                local_10 = i2c_sim_init();
                if (local_10 < 0) {
                    builtin_strncpy(local_1810, "failed t", 8);
                    local_1808._0_1_ = 'o';
                    local_1808._1_1_ = ' ';
                    local_1808._2_1_ = 'i';
                    local_1808._3_1_ = '2';
                    builtin_strncpy(acStack_1804, "c_sim_in", 8);
                    local_17fc._0_1_ = 'i';
                    local_17fc._1_1_ = 't';
                    local_17fc._2_1_ = '\n';
                    local_17fc._3_1_ = '\0';
                    V_LOCK();
                    logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/platform/cv183x/cv183x_iic.c",
                         0xb9, "iic_init", 8, 0x33, 100, auStack_1010);
                }
                local_c = local_10;
            } else {
                local_10 = i2c_init("/dev/i2c-0");
                if (local_10 < 0) {
                    builtin_strncpy(local_1810, "failed t", 8);
                    local_1808._0_1_ = 'o';
                    local_1808._1_1_ = ' ';
                    local_1808._2_1_ = 'i';
                    local_1808._3_1_ = '2';
                    builtin_strncpy(acStack_1804, "c_init\n", 8);
                    V_LOCK();
                    logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/platform/cv183x/cv183x_iic.c",
                         0xb9, "iic_init", 8, 0x3d, 100, auStack_1010);
                    local_c = -1;
                } else {
                    iVar1 =
                        i2c_ioctl(local_10, 0x703,
                                  (uint) * (byte *)((int)param_1 + 6) << 4 |
                                      (uint) * (byte *)((int)param_1 + 7) << 1);
                    if (iVar1 == 0) {
                        local_c = local_10;
                        snprintf(
                            local_1810, 0x800,
                            "i2c chain = %d, master = 0x%x, slave = 0x%x\n",
                            *param_1, (uint) * (ushort *)(param_1 + 1),
                            (uint) * (byte *)((int)param_1 + 6) << 3 |
                                (uint) * (byte *)((int)param_1 + 7));
                        V_LOCK();
                        logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/device/"
                             "hal/platform/cv183x/cv183x_iic.c",
                             0xb9, "iic_init", 8, 0x4a, 0x14, auStack_1010);
                    } else {
                        builtin_strncpy(local_1810, "failed t", 8);
                        local_1808._0_1_ = 'o';
                        local_1808._1_1_ = ' ';
                        local_1808._2_1_ = 'i';
                        local_1808._3_1_ = '2';
                        builtin_strncpy(acStack_1804, "c_ioctl\n", 8);
                        local_17fc = local_17fc & 0xffffff00;
                        V_LOCK();
                        logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/device/"
                             "hal/platform/cv183x/cv183x_iic.c",
                             0xb9, "iic_init", 8, 0x44, 100, auStack_1010);
                        local_c = -1;
                    }
                }
            }
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_0015f97c);
        }
    } else {
        builtin_strncpy(local_1810, "failed t", 8);
        local_1808._0_1_ = 'o';
        local_1808._1_1_ = ' ';
        local_1808._2_1_ = 'i';
        local_1808._3_1_ = 'i';
        builtin_strncpy(acStack_1804, "c lock\n", 8);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_iic.c",
             0xb9, "iic_init", 8, 0x20, 100, auStack_1010);
        local_c = -4;
    }
    return local_c;
}

void iic_uninit(int param_1)

{
    int iVar1;
    char local_180c[2048];
    undefined1 auStack_100c[4096];
    undefined4 local_c;

    local_c = 0;
    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0015f97c);
    if (iVar1 == 0) {
        if (param_1 == 0xff) {
            i2c_sim_uninit();
        } else {
            i2c_uninit(param_1);
        }
        pthread_mutex_unlock((pthread_mutex_t *)&DAT_0015f97c);
    } else {
        builtin_strncpy(local_180c, "failed to i2c lock\n", 0x14);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_iic.c",
             0xb9, "iic_uninit", 10, 0x5c, 100, auStack_100c);
    }
    return;
}

undefined4 iic_read(undefined4 param_1, undefined4 param_2, undefined4 param_3)

{
    int iVar1;
    undefined4 uVar2;
    char local_1808[2048];
    undefined1 auStack_1008[4096];

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0015f97c);
    if (iVar1 == 0) {
        uVar2 = i2c_read(param_1, param_2, param_3);
        pthread_mutex_unlock((pthread_mutex_t *)&DAT_0015f97c);
    } else {
        builtin_strncpy(local_1808, "failed to i2c lock\n", 0x14);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_iic.c",
             0xb9, "iic_read", 8, 0x79, 100, auStack_1008);
        uVar2 = 0xfffffffc;
    }
    return uVar2;
}

undefined4 iic_write(undefined4 param_1, undefined4 param_2, undefined4 param_3)

{
    int iVar1;
    undefined4 uVar2;
    char local_1808[2048];
    undefined1 auStack_1008[4096];

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0015f97c);
    if (iVar1 == 0) {
        uVar2 = i2c_write(param_1, param_2, param_3);
        pthread_mutex_unlock((pthread_mutex_t *)&DAT_0015f97c);
    } else {
        builtin_strncpy(local_1808, "failed to i2c lock\n", 0x14);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_iic.c",
             0xb9, "iic_write", 9, 0x8e, 100, auStack_1008);
        uVar2 = 0xfffffffc;
    }
    return uVar2;
}

uint iic_read_reg(undefined4 param_1, char *param_2, int param_3, int param_4,
                  uint param_5)

{
    int iVar1;
    char local_1814[2048];
    undefined1 auStack_1014[4099];
    char local_11;
    int local_10;
    uint local_c;

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0015f97c);
    if (iVar1 == 0) {
        local_10 = 0;
        for (local_c = 0; local_c < param_5; local_c = local_c + 1) {
            local_11 = *param_2 + (char)local_c;
            local_10 = i2c_write(param_1, &local_11, param_3);
            if (param_3 == local_10) {
                local_10 = i2c_read(param_1, param_4 + local_c, param_3);
            } else {
                builtin_strncpy(local_1814, "failed to write i2c reg\n", 0x18);
                local_1814[0x18] = 0;
                V_LOCK();
                logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_iic.c",
                     0xb9, "iic_read_reg", 0xc, 0xaf, 100, auStack_1014);
            }
        }
        pthread_mutex_unlock((pthread_mutex_t *)&DAT_0015f97c);
    } else {
        builtin_strncpy(local_1814, "failed to i2c lock\n", 0x14);
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_iic.c",
             0xb9, "iic_read_reg", 0xc, 0xa4, 100, auStack_1014);
        param_5 = 0xfffffffc;
    }
    return param_5;
}

size_t iic_write_reg(undefined4 param_1, undefined1 *param_2, int param_3,
                     void *param_4, size_t param_5)

{
    int iVar1;
    char local_1814[2048];
    undefined1 auStack_1014[4096];
    undefined1 *local_14;

    local_14 = (undefined1 *)0x0;
    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0015f97c);
    if (iVar1 == 0) {
        if (param_3 == 1) {
            if ((param_4 == (void *)0x0) || (param_5 == 0)) {
                builtin_strncpy(local_1814, "bad register data size\n", 0x18);
                V_LOCK();
                logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_iic.c",
                     0xb9, "iic_write_reg", 0xd, 0xd4, 0x50, auStack_1014);
                param_5 = 0xffffffff;
            } else {
                local_14 = (undefined1 *)malloc(param_5 + 1);
                *local_14 = *param_2;
                memcpy(local_14 + 1, param_4, param_5);
                iVar1 = i2c_write(param_1, local_14, param_5 + 1);
                if (param_5 + 1 != iVar1) {
                    builtin_strncpy(local_1814, "failed to write i2c reg\n",
                                    0x18);
                    local_1814[0x18] = 0;
                    V_LOCK();
                    logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/platform/cv183x/cv183x_iic.c",
                         0xb9, "iic_write_reg", 0xd, 0xdd, 100, auStack_1014);
                }
                if (local_14 != (undefined1 *)0x0) {
                    free(local_14);
                }
                pthread_mutex_unlock((pthread_mutex_t *)&DAT_0015f97c);
            }
        } else {
            builtin_strncpy(local_1814, "bad register bytes\n", 0x14);
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_iic.c",
                 0xb9, "iic_write_reg", 0xd, 0xcf, 0x50, auStack_1014);
            param_5 = 0xffffffff;
        }
    } else {
        builtin_strncpy(local_1814, "failed to i2c lock\n", 0x14);
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_iic.c",
             0xb9, "iic_write_reg", 0xd, 0xc9, 100, auStack_1014);
        param_5 = 0xfffffffc;
    }
    return param_5;
}

undefined4 bitmain_power_on(void)

{
    int iVar1;
    undefined4 uVar2;

    iVar1 = is_gpio_exist(DAT_001505e8);
    if (iVar1 == 0) {
        gpio_export(DAT_001505e8);
        gpio_direction(DAT_001505e8, 1);
    }
    uVar2 = gpio_write(DAT_001505e8, 1);
    return uVar2;
}

undefined4 bitmain_power_off(void)

{
    int iVar1;
    undefined4 uVar2;

    iVar1 = is_gpio_exist(DAT_001505e8);
    if (iVar1 == 0) {
        gpio_export(DAT_001505e8);
        gpio_direction(DAT_001505e8, 1);
    }
    uVar2 = gpio_write(DAT_001505e8, 0);
    return uVar2;
}

void set_bitmain_power_gpio_port(undefined4 param_1)

{
    DAT_001505e8 = param_1;
    return;
}

int pwm_init(uint param_1, undefined4 param_2)

{
    int iVar1;
    char local_1808[8];
    undefined4 local_1800;
    char acStack_17fc[16];
    undefined2 local_17ec;
    undefined1 auStack_1008[4096];

    if (platform_inited == 0) {
        builtin_strncpy(local_1808, "please i", 8);
        local_1800._0_1_ = 'n';
        local_1800._1_1_ = 'i';
        local_1800._2_1_ = 't';
        local_1800._3_1_ = ' ';
        builtin_strncpy(acStack_17fc, "platform first!!", 0x10);
        local_17ec = 10;
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_pwm.c",
             0xb9, "pwm_init", 8, 0x17, 100, auStack_1008);
        iVar1 = -1;
    } else if (param_1 < 2) {
        *(undefined4 *)(&DAT_0015f994 + param_1 * 0xc) = param_2;
        (&DAT_0015f99c)[param_1 * 0xc] = 1;
        iVar1 = param_1 + 1;
    } else {
        builtin_strncpy(local_1808, "bad para", 8);
        local_1800 = CONCAT13(local_1800._3_1_, 0xa6d);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_pwm.c",
             0xb9, "pwm_init", 8, 0x1c, 100, auStack_1008);
        iVar1 = -3;
    }
    return iVar1;
}

void pwm_uninit(int param_1)

{
    char local_1808[8];
    undefined2 local_1800;
    undefined1 local_17fe;
    undefined1 auStack_1008[4096];

    if (param_1 + -1 < 2) {
        (&DAT_0015f998)[(param_1 + -1) * 3] = 0;
        *(undefined4 *)(&DAT_0015f994 + (param_1 + -1) * 0xc) =
            (&DAT_0015f998)[(param_1 + -1) * 3];
        (&DAT_0015f99c)[(param_1 + -1) * 0xc] =
            (char)*(undefined4 *)(&DAT_0015f994 + (param_1 + -1) * 0xc);
    } else {
        builtin_strncpy(local_1808, "bad para", 8);
        local_1800 = 0xa6d;
        local_17fe = 0;
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_pwm.c",
             0xb9, "pwm_uninit", 10, 0x28, 100, auStack_1008);
    }
    return;
}

undefined4 pwm_set(int param_1, uint param_2)

{
    uint uVar1;
    char local_188c[8];
    undefined2 local_1884;
    undefined1 local_1882;
    undefined1 auStack_108c[4096];
    char acStack_8c[128];
    undefined4 local_c;

    local_c = 0xfffffffb;
    if (param_1 + -1 < 2) {
        if (param_1 == 1) {
            if (99 < param_2) {
                param_2 = 100;
            }
            uVar1 = (param_2 * 100000) / 100;
            DAT_0015f998 = param_2;
            sprintf(acStack_8c, "echo 0 > %s/enable",
                    "/sys/class/pwm/pwmchip8/pwm0");
            system(acStack_8c);
            sprintf(acStack_8c, "echo %u > %s/period", "time",
                    "/sys/class/pwm/pwmchip8/pwm0");
            system(acStack_8c);
            sprintf(acStack_8c, "echo %u > %s/duty_cycle", uVar1,
                    "/sys/class/pwm/pwmchip8/pwm0");
            system(acStack_8c);
            sprintf(acStack_8c, "echo 1 > %s/enable",
                    "/sys/class/pwm/pwmchip8/pwm0");
            system(acStack_8c);
            sprintf(acStack_8c, "echo 0 > %s/enable",
                    "/sys/class/pwm/pwmchip8/pwm1");
            system(acStack_8c);
            sprintf(acStack_8c, "echo %u > %s/period", "time",
                    "/sys/class/pwm/pwmchip8/pwm1");
            system(acStack_8c);
            sprintf(acStack_8c, "echo %u > %s/duty_cycle", uVar1,
                    "/sys/class/pwm/pwmchip8/pwm1");
            system(acStack_8c);
            sprintf(acStack_8c, "echo 1 > %s/enable",
                    "/sys/class/pwm/pwmchip8/pwm1");
            system(acStack_8c);
            local_c = 0;
        } else {
            snprintf(local_188c, 0x800, "pwm type %d not supported\n",
                     param_1 + -1);
            V_LOCK();
            logfmt_raw(auStack_108c, 0x1000, 0, local_188c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_pwm.c",
                 0xb9, "pwm_set", 7, 0x58, 100, auStack_108c);
        }
    } else {
        builtin_strncpy(local_188c, "bad para", 8);
        local_1884 = 0xa6d;
        local_1882 = 0;
        V_LOCK();
        logfmt_raw(auStack_108c, 0x1000, 0, local_188c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_pwm.c",
             0xb9, "pwm_set", 7, 0x3b, 100, auStack_108c);
        local_c = 0xfffffffd;
    }
    return local_c;
}

undefined4 pwm_get(int param_1, undefined4 *param_2)

{
    char local_180c[8];
    undefined2 local_1804;
    undefined1 local_1802;
    undefined1 auStack_100c[4096];
    undefined4 local_c;

    local_c = 0xfffffffb;
    if (param_1 + -1 < 2) {
        if (param_1 == 1) {
            *param_2 = DAT_0015f998;
            snprintf(local_180c, 0x800, "val of fpga = 0x%x\n", *param_2);
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_pwm.c",
                 0xb9, "pwm_get", 7, 0x71, 0x14, auStack_100c);
        }
    } else {
        builtin_strncpy(local_180c, "bad para", 8);
        local_1804 = 0xa6d;
        local_1802 = 0;
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_pwm.c",
             0xb9, "pwm_get", 7, 0x6a, 100, auStack_100c);
        local_c = 0xfffffffd;
    }
    return local_c;
}

undefined4 FUN_0009a3ec(void)

{
    int iVar1;
    undefined4 local_24;
    undefined4 local_20;
    undefined4 local_1c;
    int local_18;
    undefined4 *local_14;
    undefined4 *local_10;
    int local_c;

    prctl(0xf, &DAT_0013775c);
    while (DAT_0015f9cc != 0) {
        iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0015f9ac);
        if (iVar1 == 0) {
            local_10 = (undefined4 *)new_iterator_c_map(DAT_0015f9c4);
            local_c = (*(code *)*local_10)(local_10);
            while (local_c != 0) {
                local_14 = (undefined4 *)(*(code *)local_10[2])(local_c);
                local_18 = local_10[5];
                if (local_14[1] == 0) {
                    gpio_write(
                        *(undefined4 *)**(undefined4 **)(local_18 + 0x10),
                        local_14[2] & 0xff);
                    local_14[2] = (uint)(local_14[2] != 1);
                    local_14[1] = *local_14;
                }
                local_14[1] = local_14[1] + -200;
                local_14[1] = local_14[1];
                local_24 = *local_14;
                local_20 = local_14[1];
                local_1c = local_14[2];
                (*(code *)local_10[1])(local_10, &local_24, 0xc);
                free(local_14);
                local_c = (*(code *)*local_10)(local_10);
            }
            delete_iterator_c_map(local_10);
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_0015f9ac);
        }
        usleep(200000);
    }
    return 0;
}

undefined4 FUN_0009a5fc(uint param_1)

{
    int iVar1;
    undefined4 local_c;

    local_c = 0;
    if (param_1 == 2) {
        iVar1 = hal_led_green_addr();
        if (iVar1 < 0) {
            local_c = 0;
        } else {
            local_c = hal_led_green_addr();
        }
    } else if (param_1 < 3) {
        if (param_1 == 1) {
            iVar1 = hal_led_red_addr();
            if (iVar1 < 0) {
                local_c = 0;
            } else {
                local_c = hal_led_red_addr();
            }
        }
    } else if (param_1 == 0x100) {
        iVar1 = hal_key_reset_addr();
        if (iVar1 < 0) {
            local_c = 0;
        } else {
            local_c = hal_key_reset_addr();
        }
    } else if (param_1 == 0x101) {
        iVar1 = hal_key_ipreport_addr();
        if (iVar1 < 0) {
            local_c = 0;
        } else {
            local_c = hal_key_ipreport_addr();
        }
    }
    return local_c;
}

undefined4 FUN_0009a6fc(int param_1)

{
    int iVar1;
    char acStack_180c[2048];
    undefined1 auStack_100c[4096];
    undefined4 local_c;

    local_c = 0x103;
    iVar1 = hal_key_reset_addr();
    if (param_1 == iVar1) {
        local_c = 0x100;
    } else {
        iVar1 = hal_key_ipreport_addr();
        if (param_1 == iVar1) {
            local_c = 0x101;
        } else {
            snprintf(acStack_180c, 0x800, "unmaped port = %d\n", param_1);
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_ui.c",
                 0xb8, "convert_port_to_ui_type", 0x17, 0x7c, 100,
                 auStack_100c);
        }
    }
    return local_c;
}

void FUN_0009a828(undefined4 param_1, char param_2)

{
    char acStack_1810[2048];
    undefined1 auStack_1010[4096];
    int local_10;
    int local_c;

    local_10 = FUN_0009a6fc(param_1);
    if (local_10 == 0x103) {
        snprintf(acStack_1810, 0x800, "gpio port %d is not a supported key\n",
                 param_1);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, acStack_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_ui.c",
             0xb8, "gpio_key_callback", 0x11, 0x86, 0x50, auStack_1010);
    } else {
        for (local_c = 0; local_c < 5; local_c = local_c + 1) {
            if (*(int *)(&DAT_0015f9d4 + local_c * 4) != 0) {
                (**(code **)(&DAT_0015f9d4 + local_c * 4))(local_10,
                                                           param_2 != '\0');
            }
        }
    }
    return;
}

undefined4 ui_init(void)

{
    undefined4 uVar1;
    int local_c;

    if (DAT_0015f9c8 == 0) {
        uVar1 = FUN_0009a5fc(1);
        gpio_export(uVar1);
        uVar1 = FUN_0009a5fc(1);
        gpio_direction(uVar1, 1);
        uVar1 = FUN_0009a5fc(2);
        gpio_export(uVar1);
        uVar1 = FUN_0009a5fc(2);
        gpio_direction(uVar1, 1);
        uVar1 = FUN_0009a5fc(0x100);
        gpio_export(uVar1);
        uVar1 = FUN_0009a5fc(0x101);
        gpio_export(uVar1);
        uVar1 = FUN_0009a5fc(0x100);
        gpio_reg_callback(uVar1, FUN_0009a828);
        uVar1 = FUN_0009a5fc(0x101);
        gpio_reg_callback(uVar1, FUN_0009a828);
        pthread_mutex_init((pthread_mutex_t *)&DAT_0015f9ac,
                           (pthread_mutexattr_t *)0x0);
        for (local_c = 0; local_c < 5; local_c = local_c + 1) {
            *(undefined4 *)(&DAT_0015f9d4 + local_c * 4) = 0;
        }
        DAT_0015f9c4 = new_c_map(&LAB_0009a5c4, 0, 0);
        DAT_0015f9cc = 1;
        pthread_create(&DAT_0015f9d0, (pthread_attr_t *)0x0, FUN_0009a3ec,
                       (void *)0x0);
        DAT_0015f9c8 = 1;
    }
    return 0;
}

void ui_uninit(void)

{
    undefined4 uVar1;

    if (DAT_0015f9c8 != 0) {
        DAT_0015f9cc = 0;
        pthread_join(DAT_0015f9d0, (void **)0x0);
        delete_c_map(DAT_0015f9c4);
        pthread_mutex_destroy((pthread_mutex_t *)&DAT_0015f9ac);
        uVar1 = FUN_0009a5fc(0x100);
        gpio_unreg_callback(uVar1, FUN_0009a828);
        uVar1 = FUN_0009a5fc(0x101);
        gpio_unreg_callback(uVar1, FUN_0009a828);
        uVar1 = FUN_0009a5fc(1);
        gpio_unexport(uVar1);
        uVar1 = FUN_0009a5fc(2);
        gpio_unexport(uVar1);
        uVar1 = FUN_0009a5fc(0x100);
        gpio_unexport(uVar1);
        uVar1 = FUN_0009a5fc(0x101);
        gpio_unexport(uVar1);
        DAT_0015f9c8 = 0;
    }
    return;
}

void FUN_0009ac3c(undefined4 param_1, int param_2)

{
    int iVar1;
    undefined4 local_180c;
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    if ((param_2 != 0) &&
        (local_180c = param_1, iVar1 = exists_c_map(param_2, &local_180c),
         iVar1 == 1)) {
        snprintf(acStack_1808, 0x800, "remove %d from flicker list\n",
                 local_180c);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_ui.c",
             0xb8, "remove_port_form_gpio_map", 0x19, 199, 0x14, auStack_1008);
        remove_c_map(param_2, &local_180c);
    }
    return;
}

void FUN_0009ad70(undefined4 param_1, undefined4 param_2, int param_3)

{
    int iVar1;
    undefined4 local_181c[2];
    char acStack_1814[2048];
    undefined1 auStack_1014[4096];
    undefined4 local_14;
    undefined4 local_10;
    undefined4 local_c;

    if (param_3 != 0) {
        local_181c[0] = param_1;
        iVar1 = exists_c_map(param_3, local_181c);
        if (iVar1 == 0) {
            snprintf(acStack_1814, 0x800,
                     "add %d to flicker map with interval %d\n", local_181c[0],
                     param_2);
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0, acStack_1814);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_ui.c",
                 0xb8, "add_port_to_gpio_map", 0x14, 0xda, 0x14, auStack_1014);
            local_10 = 0;
            local_c = 1;
            local_14 = param_2;
            insert_c_map(param_3, local_181c, 4, &local_14, 0xc);
        } else {
            snprintf(acStack_1814, 0x800, "port %d already exist in map\n",
                     local_181c[0]);
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0, acStack_1814);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_ui.c",
                 0xb8, "add_port_to_gpio_map", 0x14, 0xe0, 0x14, auStack_1014);
        }
    }
    return;
}

void FUN_0009afa4(int param_1, undefined4 param_2, int param_3)

{
    char acStack_1824[2048];
    undefined1 auStack_1024[4096];
    undefined4 local_24;
    undefined4 local_20;
    undefined4 local_1c;
    undefined4 *local_18;
    int local_14;
    undefined4 *local_10;
    int local_c;

    if (param_3 != 0) {
        local_10 = (undefined4 *)new_iterator_c_map(param_3);
        local_c = (*(code *)*local_10)(local_10);
        while (local_c != 0) {
            local_14 = local_10[5];
            if (param_1 == *(int *)**(undefined4 **)(local_14 + 0x10)) {
                local_18 = (undefined4 *)(*(code *)local_10[2])(local_c);
                local_20 = 0;
                local_1c = 1;
                local_24 = param_2;
                (*(code *)local_10[1])(local_10, &local_24, 0xc);
                snprintf(acStack_1824, 0x800,
                         "update the freq interval of port[%d] from %d to %d\n",
                         param_1, *local_18, param_2);
                V_LOCK();
                logfmt_raw(auStack_1024, 0x1000, 0, acStack_1824);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_ui.c",
                     0xb8, "update_filcker_freq", 0x13, 0xf5, 0x14,
                     auStack_1024);
                free(local_18);
                break;
            }
            local_c = (*(code *)*local_10)(local_10);
        }
        delete_iterator_c_map(local_10);
    }
    return;
}

undefined4 FUN_0009b198(undefined4 param_1, int param_2)

{
    int iVar1;
    char local_1810[20];
    undefined2 local_17fc;
    undefined1 local_17fa;
    undefined1 auStack_1010[4096];
    undefined4 local_10;
    int local_c;

    local_10 = 0xffffffff;
    local_c = FUN_0009a5fc(param_1);
    if (local_c == 0) {
        builtin_strncpy(local_1810, "unsuported gpio port", 0x14);
        local_17fc = 10;
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_ui.c",
             0xb8, "gpio_ctrl_ui", 0xc, 0x10c, 100, auStack_1010);
        local_10 = 0xffffffff;
    } else {
        snprintf(local_1810, 0x800, "ui type = %d, port = %d, status = %d\n",
                 param_1, local_c, param_2);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_ui.c",
             0xb8, "gpio_ctrl_ui", 0xc, 0x10f, 0x14, auStack_1010);
        iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0015f9ac);
        if (iVar1 == 0) {
            if (param_2 == 1) {
                FUN_0009ac3c(local_c, DAT_0015f9c4);
                local_10 = gpio_write(local_c, 0);
            } else if (param_2 == 0) {
                FUN_0009ac3c(local_c, DAT_0015f9c4);
                local_10 = gpio_write(local_c, 1);
            } else if (param_2 == 2) {
                FUN_0009ad70(local_c, 200, DAT_0015f9c4);
            } else {
                builtin_strncpy(local_1810, "unsuported led statu", 0x14);
                local_17fc = 0xa73;
                local_17fa = 0;
                V_LOCK();
                logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_ui.c",
                     0xb8, "gpio_ctrl_ui", 0xc, 0x123, 100, auStack_1010);
                local_10 = 0xfffffffe;
            }
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_0015f9ac);
        } else {
            builtin_strncpy(local_1810, "failed to api lock\n", 0x14);
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_ui.c",
                 0xb8, "gpio_ctrl_ui", 0xc, 0x112, 100, auStack_1010);
            local_10 = 0xffffffff;
        }
    }
    return local_10;
}

undefined4 FUN_0009b59c(undefined4 param_1, int param_2)

{
    undefined4 uVar1;
    char local_180c[20];
    uint local_17f8;
    char acStack_17f4[4];
    undefined2 local_17f0;
    undefined1 local_17ee;
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = FUN_0009a5fc(param_1);
    if (local_c == 0) {
        builtin_strncpy(local_180c, "unsuported led port\n", 0x14);
        local_17f8 = local_17f8 & 0xffffff00;
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_ui.c",
             0xb8, "gpio_set_led_filker_freq", 0x18, 0x138, 100, auStack_100c);
        uVar1 = 0xffffffff;
    } else if (param_2 == 200) {
        builtin_strncpy(local_180c, "interval is same wit", 0x14);
        local_17f8._0_1_ = 'h';
        local_17f8._1_1_ = ' ';
        local_17f8._2_1_ = 'd';
        local_17f8._3_1_ = 'e';
        builtin_strncpy(acStack_17f4, "faul", 4);
        local_17f0 = 0xa74;
        local_17ee = 0;
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_ui.c",
             0xb8, "gpio_set_led_filker_freq", 0x18, 0x13d, 0x50, auStack_100c);
        uVar1 = 0;
    } else {
        FUN_0009afa4(local_c, param_2, DAT_0015f9c4);
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 red_led_on(void)

{
    undefined4 uVar1;

    uVar1 = FUN_0009b198(1, 0);
    return uVar1;
}

undefined4 red_led_off(void)

{
    undefined4 uVar1;

    uVar1 = FUN_0009b198(1, 1);
    return uVar1;
}

undefined4 red_led_flicker(void)

{
    undefined4 uVar1;

    uVar1 = FUN_0009b198(1, 2);
    return uVar1;
}

undefined4 green_led_on(void)

{
    undefined4 uVar1;

    uVar1 = FUN_0009b198(2, 0);
    return uVar1;
}

undefined4 green_led_off(void)

{
    undefined4 uVar1;

    uVar1 = FUN_0009b198(2, 1);
    return uVar1;
}

undefined4 green_led_flicker(void)

{
    undefined4 uVar1;

    uVar1 = FUN_0009b198(2, 2);
    return uVar1;
}

undefined4 beeper_on(void)

{
    undefined4 uVar1;

    uVar1 = FUN_0009b198(0x10, 0);
    return uVar1;
}

undefined4 beeper_off(void)

{
    undefined4 uVar1;

    uVar1 = FUN_0009b198(0x10, 1);
    return uVar1;
}

undefined4 beeper_flicker(void)

{
    undefined4 uVar1;

    uVar1 = FUN_0009b198(0x10, 2);
    return uVar1;
}

undefined4 reg_key_callback(undefined4 param_1)

{
    int iVar1;
    char local_1810[2048];
    undefined1 auStack_1010[4096];
    int local_10;
    undefined4 local_c;

    local_10 = 0;
    local_c = 0;
    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0015f9ac);
    if (iVar1 == 0) {
        for (local_10 = 0; local_10 < 5; local_10 = local_10 + 1) {
            if (*(int *)(&DAT_0015f9d4 + local_10 * 4) == 0) {
                *(undefined4 *)(&DAT_0015f9d4 + local_10 * 4) = param_1;
                break;
            }
        }
        if (4 < local_10) {
            local_c = 0xfffffffe;
            builtin_strncpy(local_1810, "no more listener available\n", 0x1c);
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_ui.c",
                 0xb8, "reg_key_callback", 0x10, 0x194, 100, auStack_1010);
        }
        pthread_mutex_unlock((pthread_mutex_t *)&DAT_0015f9ac);
    } else {
        builtin_strncpy(local_1810, "failed to api lock\n", 0x14);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_ui.c",
             0xb8, "reg_key_callback", 0x10, 0x186, 100, auStack_1010);
        local_c = 0xffffffff;
    }
    return local_c;
}

undefined4 unreg_key_callback(int param_1)

{
    int iVar1;
    undefined4 uVar2;
    char local_180c[2048];
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0015f9ac);
    if (iVar1 == 0) {
        for (local_c = 0; local_c < 5; local_c = local_c + 1) {
            if (param_1 == *(int *)(&DAT_0015f9d4 + local_c * 4)) {
                *(undefined4 *)(&DAT_0015f9d4 + local_c * 4) = 0;
                break;
            }
        }
        if (4 < local_c) {
            builtin_strncpy(local_180c, "listener not registered before\n",
                            0x20);
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_ui.c",
                 0xb8, "unreg_key_callback", 0x12, 0x1b4, 0x50, auStack_100c);
        }
        pthread_mutex_unlock((pthread_mutex_t *)&DAT_0015f9ac);
        uVar2 = 0;
    } else {
        builtin_strncpy(local_180c, "failed to api lock\n", 0x14);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_ui.c",
             0xb8, "unreg_key_callback", 0x12, 0x1a7, 100, auStack_100c);
        uVar2 = 0xffffffff;
    }
    return uVar2;
}

undefined4 lcd_show_result(char param_1, undefined4 param_2, undefined4 param_3)

{
    int iVar1;
    char local_180c[2048];
    undefined1 auStack_100c[4096];
    undefined4 local_c;

    local_c = 0xffffffff;
    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0015f9ac);
    if (iVar1 == 0) {
        if (DAT_001505ec < 0) {
            DAT_001505ec = lcd_init(lcd_path);
            lcd_clear(DAT_001505ec);
        }
        if (DAT_001505ec < 1) {
            snprintf(local_180c, 0x800, "failed to init %s\n", lcd_path);
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_ui.c",
                 0xb8, "lcd_show_result", 0xf, 0x1d6, 100, auStack_100c);
            local_c = 0xffffffff;
        } else {
            local_c = lcd_write(DAT_001505ec, (int)param_1, param_2, param_3);
        }
        pthread_mutex_unlock((pthread_mutex_t *)&DAT_0015f9ac);
    } else {
        builtin_strncpy(local_180c, "failed to api lock\n", 0x14);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_ui.c",
             0xb8, "lcd_show_result", 0xf, 0x1c8, 100, auStack_100c);
        local_c = 0xfffffffc;
    }
    return local_c;
}

void lcd_clear_result(void)

{
    int iVar1;
    char local_1808[2048];
    undefined1 auStack_1008[4096];

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0015f9ac);
    if (iVar1 != 0) {
        builtin_strncpy(local_1808, "failed to api lock\n", 0x14);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_ui.c",
             0xb8, "lcd_clear_result", 0x10, 0x1e4, 100, auStack_1008);
    }
    if (0 < DAT_001505ec) {
        lcd_clear(DAT_001505ec);
    }
    pthread_mutex_unlock((pthread_mutex_t *)&DAT_0015f9ac);
    return;
}

undefined4 hal_led_red_addr(void)

{
    undefined4 uVar1;

    uVar1 = DAT_00150758;
    if (DAT_001505f4 == 0) {
        uVar1 = 0xffffffff;
    }
    return uVar1;
}

undefined4 hal_led_green_addr(void)

{
    undefined4 uVar1;

    uVar1 = DAT_0015075c;
    if (DAT_001505f4 == 0) {
        uVar1 = 0xffffffff;
    }
    return uVar1;
}

undefined4 hal_key_reset_addr(void)

{
    undefined4 uVar1;

    uVar1 = DAT_00150760;
    if (DAT_001505f4 == 0) {
        uVar1 = 0xffffffff;
    }
    return uVar1;
}

undefined4 hal_key_ipreport_addr(void)

{
    undefined4 uVar1;

    uVar1 = DAT_00150764;
    if (DAT_001505f4 == 0) {
        uVar1 = 0xffffffff;
    }
    return uVar1;
}

undefined4 hal_chain_uart_addr(int param_1)

{
    undefined4 uVar1;
    int local_c;

    if (DAT_001505f4 == 0) {
        uVar1 = 0xffffffff;
    } else {
        for (local_c = 0; local_c < 0x10; local_c = local_c + 1) {
            if (param_1 == *(int *)(&DAT_001505f8 + local_c * 0x10)) {
                return *(undefined4 *)(&DAT_001505fc + local_c * 0x10);
            }
        }
        uVar1 = 0xfffffffe;
    }
    return uVar1;
}

undefined4 hal_chain_plug_addr(int param_1)

{
    undefined4 uVar1;
    int local_c;

    if (DAT_001505f4 == 0) {
        uVar1 = 0xffffffff;
    } else {
        for (local_c = 0; local_c < 0x10; local_c = local_c + 1) {
            if (param_1 == *(int *)(&DAT_001505f8 + local_c * 0x10)) {
                return *(undefined4 *)(&DAT_00150600 + local_c * 0x10);
            }
        }
        uVar1 = 0xfffffffe;
    }
    return uVar1;
}

undefined4 hal_chain_reset_addr(int param_1)

{
    undefined4 uVar1;
    int local_c;

    if (DAT_001505f4 == 0) {
        uVar1 = 0xffffffff;
    } else {
        for (local_c = 0; local_c < 0x10; local_c = local_c + 1) {
            if (param_1 == *(int *)(&DAT_001505f8 + local_c * 0x10)) {
                return *(undefined4 *)(&DAT_00150604 + local_c * 0x10);
            }
        }
        uVar1 = 0xfffffffe;
    }
    return uVar1;
}

int hal_chain_max_num(void)

{
    int local_c;

    if (DAT_001505f4 == 0) {
        local_c = -1;
    } else {
        for (local_c = 0;
             (local_c < 0x10 &&
              ((((*(int *)(&DAT_001505f8 + local_c * 0x10) != -1 ||
                  (*(int *)(&DAT_001505fc + local_c * 0x10) != -1)) ||
                 (*(int *)(&DAT_00150600 + local_c * 0x10) != -1)) ||
                (*(int *)(&DAT_00150604 + local_c * 0x10) != -1))));
             local_c = local_c + 1) {
        }
    }
    return local_c;
}

undefined4 hal_fan_addr(int param_1)

{
    undefined4 uVar1;
    int local_c;

    if (DAT_001505f4 == 0) {
        uVar1 = 0xffffffff;
    } else {
        for (local_c = 0; local_c < 8; local_c = local_c + 1) {
            if (param_1 == *(int *)(&DAT_001506f8 + local_c * 0xc)) {
                return *(undefined4 *)(&DAT_001506fc + local_c * 0xc);
            }
        }
        uVar1 = 0xfffffffe;
    }
    return uVar1;
}

undefined4 hal_fan_max_speed(int param_1)

{
    int local_c;

    if (DAT_001505f4 != 0) {
        for (local_c = 0; local_c < 8; local_c = local_c + 1) {
            if (param_1 == *(int *)(&DAT_001506f8 + local_c * 0xc)) {
                return *(undefined4 *)(&DAT_00150700 + local_c * 0xc);
            }
        }
    }
    return 0xffffffff;
}

int hal_fan_number(void)

{
    int local_10;
    int local_c;

    local_c = 0;
    if (DAT_001505f4 == 0) {
        local_c = -1;
    } else {
        for (local_10 = 0; local_10 < 8; local_10 = local_10 + 1) {
            if (*(int *)(&DAT_001506f8 + local_10 * 0xc) != -1) {
                local_c = local_c + 1;
            }
        }
    }
    return local_c;
}

int eeprom_open(uint param_1)

{
    int iVar1;
    char acStack_1814[2048];
    undefined1 auStack_1014[4096];
    uint local_14;
    undefined2 local_10;
    undefined1 local_e;
    undefined1 local_d;
    undefined4 local_c;

    local_c = 0;
    if (param_1 < 0x10) {
        if ((*(int *)(&DAT_0015f9e8 + param_1 * 8) == 0) ||
            (*(int *)(&DAT_0015f9ec + param_1 * 8) == 0)) {
            local_10 = 0;
            local_e = 10;
            local_d = (undefined1)param_1;
            local_14 = param_1;
            iVar1 = iic_init(&local_14);
            if (-1 < iVar1) {
                *(int *)(&DAT_0015f9e8 + param_1 * 8) = iVar1;
                *(undefined4 *)(&DAT_0015f9ec + param_1 * 8) = 1;
            }
        } else {
            iVar1 = *(int *)(&DAT_0015f9e8 + param_1 * 8);
        }
    } else {
        snprintf(acStack_1814, 0x800, "%s: Bad eeprom param, input chain is %d",
                 "eeprom_open", param_1);
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, acStack_1814);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "eeprom_open", 0xb, 0x32, 100, auStack_1014);
        iVar1 = -0x7ffffeff;
    }
    return iVar1;
}

void eeprom_close(uint param_1)

{
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    if (param_1 < 0x10) {
        if ((*(int *)(&DAT_0015f9e8 + param_1 * 8) != 0) ||
            (*(int *)(&DAT_0015f9ec + param_1 * 8) != 0)) {
            iic_uninit(*(undefined4 *)(&DAT_0015f9e8 + param_1 * 8));
            *(undefined4 *)(&DAT_0015f9e8 + param_1 * 8) = 0;
            *(undefined4 *)(&DAT_0015f9ec + param_1 * 8) = 0;
        }
    } else {
        snprintf(acStack_1808, 0x800, "%s: Bad eeprom param, input chain is %d",
                 "eeprom_close", param_1);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "eeprom_close", 0xc, 0x4a, 100, auStack_1008);
    }
    return;
}

int eeprom_write(uint param_1, char param_2, int param_3, uint param_4)

{
    int iVar1;
    char acStack_1814[2048];
    undefined1 auStack_1014[4099];
    byte local_11;
    uint local_10;
    int local_c;

    local_c = 0;
    local_10 = 0;
    if (param_1 < 0x10) {
        if ((*(int *)(&DAT_0015f9ec + param_1 * 8) == 0) &&
            (local_c = eeprom_open(param_1), local_c < 0)) {
            snprintf(
                acStack_1814, 0x800,
                "%s: auto exec eeprom_open, but chain %d open eeprom failed",
                "eeprom_write", param_1);
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0, acStack_1814);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_write", 0xc, 0x60, 100, auStack_1014);
            return local_c;
        }
        for (local_10 = 0; local_10 < param_4; local_10 = local_10 + 1) {
            local_11 = (char)local_10 + param_2;
            local_c =
                iic_write_reg(*(undefined4 *)(&DAT_0015f9e8 + param_1 * 8),
                              &local_11, 1, param_3 + local_10, 1);
            if (local_c != 1) {
                snprintf(acStack_1814, 0x800,
                         "fail to write eeprom by iic, chain:%d, addr: %d",
                         param_1, (uint)local_11);
                V_LOCK();
                logfmt_raw(auStack_1014, 0x1000, 0, acStack_1814);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/eeprom/bitmain_eeprom.c",
                     0xb4, "eeprom_write", 0xc, 0x74, 100, auStack_1014);
                return -0x7fffff00;
            }
            local_c = 1;
        }
        sleep(1);
        iVar1 = 0;
    } else {
        snprintf(acStack_1814, 0x800, "%s: Bad eeprom param, input chain is %d",
                 "eeprom_write", param_1);
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, acStack_1814);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "eeprom_write", 0xc, 0x5b, 100, auStack_1014);
        iVar1 = -0x7ffffeff;
    }
    return iVar1;
}

int eeprom_read(uint param_1, char param_2, int param_3, uint param_4)

{
    int iVar1;
    char local_1814[16];
    undefined2 local_1804;
    undefined1 auStack_1014[4099];
    byte local_11;
    uint local_10;
    int local_c;

    local_c = 0;
    local_10 = 0;
    if (param_1 < 0x10) {
        if ((*(int *)(&DAT_0015f9ec + param_1 * 8) == 0) &&
            (local_c = eeprom_open(param_1), local_c < 0)) {
            snprintf(
                local_1814, 0x800,
                "%s: auto exec eeprom_open, but chain %d open eeprom failed",
                "eeprom_read", param_1);
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_read", 0xb, 0x88, 100, auStack_1014);
            return local_c;
        }
        builtin_strncpy(local_1814, "no use at24c512c", 0x10);
        local_1804 = 0x21;
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "eeprom_read", 0xb, 0x98, 0x14, auStack_1014);
        for (local_10 = 0; local_10 < param_4; local_10 = local_10 + 1) {
            local_11 = (char)local_10 + param_2;
            local_c = iic_read_reg(*(undefined4 *)(&DAT_0015f9e8 + param_1 * 8),
                                   &local_11, 1, param_3 + local_10, 1);
            if (local_c != 1) {
                snprintf(local_1814, 0x800,
                         "fail to read eeprom by iic, chain: %d, addr: %d",
                         param_1, (uint)local_11);
                V_LOCK();
                logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/eeprom/bitmain_eeprom.c",
                     0xb4, "eeprom_read", 0xb, 0x9e, 100, auStack_1014);
                return -0x7fffff00;
            }
            local_c = 1;
        }
        usleep(500000);
        iVar1 = 0;
    } else {
        snprintf(local_1814, 0x800, "%s: Bad eeprom param, input chain is %d",
                 "eeprom_read", param_1);
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "eeprom_read", 0xb, 0x83, 100, auStack_1014);
        iVar1 = -0x7ffffeff;
    }
    return iVar1;
}

void FUN_0009d164(void)

{
    int iVar1;
    byte local_9;

    if (DAT_0015fa68 != (void *)0x0) {
        for (local_9 = 0; (int)(uint)local_9 < DAT_0015faac;
             local_9 = local_9 + 1) {
            iVar1 = *(int *)(&DAT_0015fa6c + (uint)local_9 * 4);
            if (*(int *)((int)DAT_0015fa68 + iVar1 * 4) != 0) {
                free(*(void **)((int)DAT_0015fa68 + iVar1 * 4));
                *(undefined4 *)((int)DAT_0015fa68 + iVar1 * 4) = 0;
            }
        }
        free(DAT_0015fa68);
        DAT_0015fa68 = (void *)0x0;
    }
    return;
}

undefined4 FUN_0009d24c(void)

{
    void *pvVar1;
    void *pvVar2;
    char local_1818[2048];
    undefined1 auStack_1018[4096];
    int local_18;
    byte local_11;

    if ((DAT_0015fa68 == (void *)0x0) &&
        (DAT_0015fa68 = calloc(1, 0x54), DAT_0015fa68 == (void *)0x0)) {
        builtin_strncpy(local_1818, "No memory for configuraion.", 0x1c);
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "_alloc_memory", 0xd, 0xca, 100, auStack_1018);
    LAB_0009d494:
        FUN_0009d164();
        return 0xffffffff;
    }
    local_11 = 0;
    do {
        pvVar1 = DAT_0015fa68;
        if (DAT_0015faac <= (int)(uint)local_11) {
            return 0;
        }
        local_18 = *(int *)(&DAT_0015fa6c + (uint)local_11 * 4);
        if (*(int *)((int)DAT_0015fa68 + local_18 * 4) == 0) {
            pvVar2 = calloc(1, 0xcc);
            *(void **)((int)pvVar1 + local_18 * 4) = pvVar2;
            if (*(int *)((int)DAT_0015fa68 + local_18 * 4) == 0) {
                snprintf(local_1818, 0x800,
                         "No memory for configuraion for chain %d.", local_18);
                V_LOCK();
                logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/eeprom/bitmain_eeprom.c",
                     0xb4, "_alloc_memory", 0xd, 0xd7, 100, auStack_1018);
                goto LAB_0009d494;
            }
        }
        local_11 = local_11 + 1;
    } while (true);
}

undefined1 FUN_0009d4a8(undefined4 param_1, int param_2)

{
    char acStack_180c[2048];
    undefined1 auStack_100c[4097];
    undefined1 local_b;
    byte local_a;
    byte local_9;

    local_a = 0;
    local_9 = 0;
    local_b = 0;
    local_a = BM_CRC5(param_1, (*(byte *)(param_2 + 1) - 1) * 8);
    if (*(char *)(param_2 + 2) == '\x03') {
        local_9 = *(byte *)(param_2 + 0x3c);
    } else if (*(char *)(param_2 + 2) == '\x04') {
        local_9 = *(byte *)(param_2 + 0xc4);
    }
    if (local_a == local_9) {
        local_b = 1;
    } else {
        snprintf(acStack_180c, 0x800,
                 "Fixture CRC check fail. store_crc = 0x%x, len = 0x%x, crc = "
                 "0x%x\n",
                 (uint)local_9, (uint) * (byte *)(param_2 + 1), (uint)local_a);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "_is_fixture_crc_pass", 0x14, 0xf6, 100, auStack_100c);
    }
    return local_b;
}

undefined4 eeprom_verify_fixture_crc(undefined4 param_1, undefined4 param_2)

{
    int iVar1;
    undefined4 uVar2;

    iVar1 = FUN_0009d4a8(param_1, param_2);
    if (iVar1 == 0) {
        uVar2 = 0xffffffff;
    } else {
        uVar2 = 0;
    }
    return uVar2;
}

undefined4 FUN_0009d6a8(byte *param_1, void *param_2)

{
    undefined4 uVar1;
    char acStack_191c[2048];
    undefined1 auStack_111c[4096];
    undefined1 auStack_11c[256];
    uint local_1c;
    size_t local_18;
    size_t local_14;
    uint local_10;
    byte local_a;
    byte local_9;

    memset(auStack_11c, 0, 0x100);
    local_9 = *param_1 & 0xf;
    local_a = *param_1 >> 4;
    local_1c = (uint)param_1[1];
    local_18 = 2;
    local_14 = local_1c - 2;
    local_10 = local_1c;
    if (((local_1c == 0) || ((int)local_14 < 0)) || (0x100 < local_1c)) {
        snprintf(acStack_191c, 0x800,
                 "EEPROM info error! fixture_len:%d, "
                 "fixture_without_header_len:%d, fixture_actual_len:%d",
                 local_1c, local_14, local_1c);
        V_LOCK();
        logfmt_raw(auStack_111c, 0x1000, 0, acStack_191c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "decode_eeprom_fixture_info", 0x1a, 0x117, 100,
             auStack_111c);
        uVar1 = 0xffffffff;
    } else if ((local_9 == 1) && (local_a == 1)) {
        memcpy(auStack_11c, param_1 + 2, local_14);
        data_dec(auStack_11c, local_14, local_a, local_9);
        memcpy(param_2, param_1, local_18);
        memcpy((void *)((int)param_2 + local_18), auStack_11c, local_14);
        uVar1 = 0;
    } else {
        snprintf(acStack_191c, 0x800,
                 "EEPROM eeprom_key_version or eeprom_encryption_algorithm "
                 "error! eeprom_key_version:%d, eeprom_encryption_algorithm:%d",
                 (uint)local_9, (uint)local_a);
        V_LOCK();
        logfmt_raw(auStack_111c, 0x1000, 0, acStack_191c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "decode_eeprom_fixture_info", 0x1a, 0x11d, 100,
             auStack_111c);
        uVar1 = 0xffffffff;
    }
    return uVar1;
}

undefined4 FUN_0009d9ac(byte *param_1, void *param_2)

{
    undefined4 uVar1;
    char acStack_191c[2048];
    undefined1 auStack_111c[4096];
    undefined1 auStack_11c[256];
    uint local_1c;
    size_t local_18;
    size_t local_14;
    uint local_10;
    byte local_a;
    byte local_9;

    memset(auStack_11c, 0, 0x100);
    local_9 = *param_1 & 0xf;
    local_a = *param_1 >> 4;
    local_1c = (uint)param_1[1];
    local_18 = 2;
    local_14 = local_1c - 2;
    local_10 = local_1c;
    if (((local_1c == 0) || ((int)local_14 < 0)) || (0x100 < local_1c)) {
        snprintf(acStack_191c, 0x800,
                 "EEPROM info error! fixture_len:%d, "
                 "fixture_without_header_len:%d, fixture_actual_len:%d",
                 local_1c, local_14, local_1c);
        V_LOCK();
        logfmt_raw(auStack_111c, 0x1000, 0, acStack_191c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "encode_eeprom_fixture_info", 0x1a, 0x140, 100,
             auStack_111c);
        uVar1 = 0xffffffff;
    } else if ((local_9 == 1) && (local_a == 1)) {
        memcpy(auStack_11c, param_1 + 2, local_14);
        data_enc(auStack_11c, local_14, local_a, local_9);
        memcpy(param_2, param_1, local_18);
        memcpy((void *)((int)param_2 + local_18), auStack_11c, local_14);
        uVar1 = 0;
    } else {
        snprintf(acStack_191c, 0x800,
                 "EEPROM eeprom_key_version or eeprom_encryption_algorithm "
                 "error! eeprom_key_version:%d, eeprom_encryption_algorithm:%d",
                 (uint)local_9, (uint)local_a);
        V_LOCK();
        logfmt_raw(auStack_111c, 0x1000, 0, acStack_191c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "encode_eeprom_fixture_info", 0x1a, 0x146, 100,
             auStack_111c);
        uVar1 = 0xffffffff;
    }
    return uVar1;
}

undefined4 eeprom_decode_fixture_info(undefined4 param_1, undefined4 param_2)

{
    undefined4 uVar1;

    uVar1 = FUN_0009d6a8(param_1, param_2);
    return uVar1;
}

char init_eeprom_fmt_info(undefined1 *param_1, char param_2)

{
    char local_180c[24];
    undefined2 local_17f4;
    undefined1 auStack_100c[4099];
    char local_9;

    local_9 = '\x01';
    *param_1 = 0;
    param_1[1] = 1;
    param_1[2] = 2;
    param_1[3] = 3;
    param_1[4] = 0x14;
    param_1[5] = 0x16;
    param_1[6] = 0x23;
    param_1[7] = 0x24;
    param_1[8] = 0x2d;
    if ((param_2 == '\x03') || (param_2 == '\x04')) {
        param_1[9] = 0x4d;
        param_1[10] = 0x4e;
        param_1[0xb] = 0x52;
        param_1[0xc] = 0x53;
        param_1[0xd] = 0x54;
        param_1[0xe] = 0x55;
        param_1[0xf] = 0x56;
        param_1[0x10] = 0x57;
        param_1[0x11] = 0x58;
        param_1[0x12] = 0x5a;
        param_1[0x13] = 0x5c;
        param_1[0x14] = 0x5e;
        param_1[0x15] = 0x60;
        param_1[0x16] = 0x61;
        param_1[0x17] = 0x62;
        param_1[0x18] = 99;
        param_1[0x19] = 100;
        param_1[0x1c] = 0x71;
        param_1[0x1d] = 0x72;
        param_1[0x1e] = 0x74;
        param_1[0x1f] = 0xf4;
        param_1[0x20] = 0xf6;
        param_1[0x21] = 0xf9;
    } else {
        local_9 = '\0';
    }
    param_1[0x22] = 1;
    param_1[0x23] = 1;
    param_1[0x24] = 1;
    param_1[0x25] = 0x11;
    param_1[0x26] = 2;
    param_1[0x27] = 0xd;
    param_1[0x28] = 1;
    param_1[0x2a] = 0x20;
    if ((param_2 == '\x03') || (param_2 == '\x04')) {
        param_1[0x29] = 9;
    } else {
        local_9 = '\0';
    }
    param_1[0x2b] = 1;
    param_1[0x2c] = 4;
    param_1[0x2d] = 1;
    param_1[0x2e] = 1;
    param_1[0x2f] = 1;
    param_1[0x30] = 1;
    param_1[0x31] = 1;
    param_1[0x32] = 1;
    param_1[0x33] = 2;
    param_1[0x34] = 2;
    param_1[0x35] = 2;
    param_1[0x36] = 2;
    param_1[0x37] = 1;
    param_1[0x38] = 1;
    param_1[0x39] = 1;
    param_1[0x3a] = 1;
    param_1[0x3b] = 8;
    param_1[0x3c] = 1;
    param_1[0x3d] = 2;
    param_1[0x3e] = 0x80;
    param_1[0x3f] = 2;
    param_1[0x40] = 3;
    param_1[0x41] = 1;
    if (local_9 != '\x01') {
        builtin_strncpy(local_180c, "This FMT is not supporte", 0x18);
        local_17f4 = 100;
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "init_eeprom_fmt_info", 0x14, 0x1ce, 100, auStack_100c);
    }
    return local_9;
}

void eeprom_dump_fixture(byte *param_1)

{
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    snprintf(acStack_1808, 0x800, "%-30s : 0x%04x", "key_version",
             *param_1 & 0xf);
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1d5, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : 0x%04x", "algorithm_code",
             ((uint)*param_1 << 0x18) >> 0x1c);
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1d6, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : 0x%04x", "fixture_info_len");
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1d7, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : 0x%04x", "fixture_standard");
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1d8, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : 0x%04x", "test_standard");
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1d9, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : %s", "chip_technology");
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1da, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : 0x%02x", "fixture_fmt_version");
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1db, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : %s", &DAT_00137e80,
             *(undefined4 *)(param_1 + 3));
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1dd, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : 0x%02x-%02x", &DAT_00137e84);
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1de, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : 0x%02x-%02x", &DAT_00137e9c);
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1df, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : %u", "hash_board_voltage",
             (uint) * (ushort *)(param_1 + 0x27));
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1e0, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : %u", "hash_board_freq");
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1e1, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : %.2f", "nonce_response_rate",
             (double)*(float *)(param_1 + 0x2b));
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1e2, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : %u", "inlet_temperature",
             (uint)param_1[0x2f]);
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1e3, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : %u", "outlet_temperature");
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1e4, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : 0x%02x-%02x", "asic sensor");
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1e5, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : 0x%02x-%02x-%02x-%02x",
             "asic sensor addr", (uint) * *(byte **)(param_1 + 0x19),
             (uint) * (byte *)(*(int *)(param_1 + 0x19) + 1),
             (uint) * (byte *)(*(int *)(param_1 + 0x19) + 2),
             (uint) * (byte *)(*(int *)(param_1 + 0x19) + 3));
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1e6, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : 0x%02x-%02x", "pic sensor",
             ((uint)param_1[0x1d] << 0x18) >> 0x1f, param_1[0x1d] & 0x7f);
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1e7, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : 0x%02x", "pic sensor addr",
             (uint)param_1[0x1e]);
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1e8, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : bin%d", "chip_bin");
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1e9, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : %s", &DAT_00137f94);
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1ea, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : %s", "chip_die",
             *(undefined4 *)(param_1 + 7));
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1eb, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : %s", "chip_marking");
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1ec, 100, auStack_1008);
    snprintf(acStack_1808, 0x800, "%-30s : P%d", "phy_seq_level");
    V_LOCK();
    logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/eeprom/bitmain_eeprom.c",
        0xb4, "eeprom_dump_fixture", 0x13, 0x1ed, 100, auStack_1008);
    return;
}

undefined1 FUN_0009f374(byte *param_1, byte *param_2)

{
    char cVar1;
    void *pvVar2;
    char local_1864[12];
    undefined4 local_1858;
    char local_1854[4];
    undefined4 local_1850;
    undefined4 local_184c;
    char acStack_1848[4];
    undefined2 local_1844;
    undefined1 local_1842;
    undefined1 auStack_1064[4096];
    undefined8 local_64;
    undefined8 uStack_5c;
    ushort local_52;
    ushort local_50;
    ushort local_4e;
    undefined1 auStack_4c[3];
    byte local_49;
    byte local_48;
    byte local_47;
    byte local_46;
    byte local_45;
    byte local_43;
    byte local_42;
    byte local_41;
    byte local_40;
    byte local_3f;
    byte local_3e;
    byte local_3d;
    byte local_3c;
    byte local_3b;
    byte local_3a;
    byte local_39;
    byte local_38;
    byte local_37;
    byte local_36;
    byte local_35;
    byte local_34;
    byte local_33;
    byte local_32;
    byte local_30;
    byte local_2f;
    byte local_2e;
    byte local_2d;
    byte local_2b;
    byte local_27;
    byte local_26;
    byte local_25;
    byte local_23;
    byte local_20;
    byte local_19;
    byte local_18;
    byte local_17;
    byte local_16;
    byte local_11;
    byte local_f;
    byte local_e;
    byte local_d;
    undefined1 local_9;

    local_9 = 1;
    *param_2 = *param_2 & 0xf | *param_1 & 0xf0;
    *param_2 = *param_2 & 0xf0 | *param_1 & 0xf;
    param_2[1] = param_1[1];
    param_2[2] = param_1[2];
    cVar1 = init_eeprom_fmt_info(auStack_4c, param_2[2]);
    if (cVar1 == '\x01') {
        pvVar2 = calloc(local_27 + 1, 1);
        *(void **)(param_2 + 3) = pvVar2;
        if (*(int *)(param_2 + 3) == 0) {
            builtin_strncpy(local_1864, "Decode SN OO", 0xc);
            local_1858._0_2_ = 0x4d;
            V_LOCK();
            logfmt_raw(auStack_1064, 0x1000, 0, local_1864);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_buf_to_layout", 0x14, 0x20b, 100, auStack_1064);
            local_9 = 0;
        }
        memcpy(*(void **)(param_2 + 3), param_1 + local_49, (uint)local_27);
        pvVar2 = calloc(local_26 + 1, 1);
        *(void **)(param_2 + 7) = pvVar2;
        if (*(int *)(param_2 + 7) == 0) {
            builtin_strncpy(local_1864, "Decode Chip ", 0xc);
            local_1858._0_1_ = 'D';
            local_1858._1_1_ = 'i';
            local_1858._2_1_ = 'e';
            local_1858._3_1_ = ' ';
            builtin_strncpy(local_1854, "OOM", 4);
            V_LOCK();
            logfmt_raw(auStack_1064, 0x1000, 0, local_1864);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_buf_to_layout", 0x14, 0x214, 100, auStack_1064);
            local_9 = 0;
        }
        memcpy(*(void **)(param_2 + 7), param_1 + local_48, (uint)local_26);
        pvVar2 = calloc(local_25 + 1, 1);
        *(void **)(param_2 + 0xb) = pvVar2;
        if (*(int *)(param_2 + 0xb) == 0) {
            builtin_strncpy(local_1864, "Decode Chip ", 0xc);
            local_1858._0_1_ = 'M';
            local_1858._1_1_ = 'a';
            local_1858._2_1_ = 'r';
            local_1858._3_1_ = 'k';
            builtin_strncpy(local_1854, "ing ", 4);
            local_1850._0_1_ = 'O';
            local_1850._1_1_ = 'O';
            local_1850._2_1_ = 'M';
            local_1850._3_1_ = '\0';
            V_LOCK();
            logfmt_raw(auStack_1064, 0x1000, 0, local_1864);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_buf_to_layout", 0x14, 0x21d, 100, auStack_1064);
            local_9 = 0;
        }
        memcpy(*(void **)(param_2 + 0xb), param_1 + local_47, (uint)local_25);
        param_2[0xf] = param_1[local_46];
        if ((param_2[2] == 1) || (param_2[2] == 2)) {
            local_64 = 0;
            uStack_5c = 0;
            pvVar2 = calloc(local_23 + 6, 1);
            *(void **)(param_2 + 0x10) = pvVar2;
            if (*(int *)(param_2 + 0x10) == 0) {
                builtin_strncpy(local_1864, "Decode Chip ", 0xc);
                local_1858._0_1_ = 'F';
                local_1858._1_1_ = 'T';
                local_1858._2_1_ = ' ';
                local_1858._3_1_ = 'P';
                builtin_strncpy(local_1854, "rogr", 4);
                local_1850._0_1_ = 'a';
                local_1850._1_1_ = 'm';
                local_1850._2_1_ = ' ';
                local_1850._3_1_ = 'V';
                local_184c._0_1_ = 'e';
                local_184c._1_1_ = 'r';
                local_184c._2_1_ = 's';
                local_184c._3_1_ = 'i';
                builtin_strncpy(acStack_1848, "on O", 4);
                local_1844 = 0x4d4f;
                local_1842 = 0;
                V_LOCK();
                logfmt_raw(auStack_1064, 0x1000, 0, local_1864);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/eeprom/bitmain_eeprom.c",
                     0xb4, "eeprom_buf_to_layout", 0x14, 0x22c, 100,
                     auStack_1064);
                local_9 = 0;
            }
            memcpy(&local_64, param_1 + local_45, (uint)local_23);
            snprintf(*(char **)(param_2 + 0x10), local_23 + 6, "F%dV%02dB%dC%d",
                     (uint)(byte)local_64, (uint)local_64._1_1_,
                     (uint)local_64._2_1_, (uint)local_64._3_1_);
        } else {
            pvVar2 = calloc(local_23 + 1, 1);
            *(void **)(param_2 + 0x10) = pvVar2;
            if (*(int *)(param_2 + 0x10) == 0) {
                builtin_strncpy(local_1864, "Decode Chip ", 0xc);
                local_1858._0_1_ = 'F';
                local_1858._1_1_ = 'T';
                local_1858._2_1_ = ' ';
                local_1858._3_1_ = 'P';
                builtin_strncpy(local_1854, "rogr", 4);
                local_1850._0_1_ = 'a';
                local_1850._1_1_ = 'm';
                local_1850._2_1_ = ' ';
                local_1850._3_1_ = 'V';
                local_184c._0_1_ = 'e';
                local_184c._1_1_ = 'r';
                local_184c._2_1_ = 's';
                local_184c._3_1_ = 'i';
                builtin_strncpy(acStack_1848, "on O", 4);
                local_1844 = 0x4d4f;
                local_1842 = 0;
                V_LOCK();
                logfmt_raw(auStack_1064, 0x1000, 0, local_1864);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/eeprom/bitmain_eeprom.c",
                     0xb4, "eeprom_buf_to_layout", 0x14, 0x237, 100,
                     auStack_1064);
                local_9 = 0;
            }
            memcpy(*(void **)(param_2 + 0x10), param_1 + local_45,
                   (uint)local_23);
        }
        param_2[0x18] = param_2[0x18] & 0x80 | param_1[local_43] & 0x7f;
        param_2[0x18] = param_2[0x18] & 0x7f | param_1[local_43] & 0x80;
        pvVar2 = calloc(local_20 + 1, 1);
        *(void **)(param_2 + 0x19) = pvVar2;
        if (*(int *)(param_2 + 0x19) == 0) {
            builtin_strncpy(local_1864, "Decode Chip ", 0xc);
            local_1858._0_1_ = 'F';
            local_1858._1_1_ = 'T';
            local_1858._2_1_ = ' ';
            local_1858._3_1_ = 'P';
            builtin_strncpy(local_1854, "rogr", 4);
            local_1850._0_1_ = 'a';
            local_1850._1_1_ = 'm';
            local_1850._2_1_ = ' ';
            local_1850._3_1_ = 'V';
            local_184c._0_1_ = 'e';
            local_184c._1_1_ = 'r';
            local_184c._2_1_ = 's';
            local_184c._3_1_ = 'i';
            builtin_strncpy(acStack_1848, "on O", 4);
            local_1844 = 0x4d4f;
            local_1842 = 0;
            V_LOCK();
            logfmt_raw(auStack_1064, 0x1000, 0, local_1864);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_buf_to_layout", 0x14, 0x245, 100, auStack_1064);
            local_9 = 0;
        }
        memcpy(*(void **)(param_2 + 0x19), param_1 + local_42, (uint)local_20);
        param_2[0x1d] = param_2[0x1d] & 0x80 | param_1[local_41] & 0x7f;
        param_2[0x1d] = param_2[0x1d] & 0x7f | param_1[local_41] & 0x80;
        param_2[0x1e] = param_1[local_40];
        param_2[0x1f] = param_1[local_3f];
        param_2[0x20] = param_1[local_3e];
        param_2[0x21] = param_1[local_3d];
        param_2[0x22] = param_1[local_3c];
        pvVar2 = calloc(local_19 + 1, 1);
        *(void **)(param_2 + 0x23) = pvVar2;
        if (*(int *)(param_2 + 0x23) == 0) {
            builtin_strncpy(local_1864, "Decode Chip ", 0xc);
            local_1858._0_1_ = 'T';
            local_1858._1_1_ = 'e';
            local_1858._2_1_ = 'c';
            local_1858._3_1_ = 'h';
            builtin_strncpy(local_1854, "nolo", 4);
            local_1850._0_1_ = 'g';
            local_1850._1_1_ = 'y';
            local_1850._2_1_ = ' ';
            local_1850._3_1_ = 'O';
            local_184c._0_3_ = 0x4d4f;
            V_LOCK();
            logfmt_raw(auStack_1064, 0x1000, 0, local_1864);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_buf_to_layout", 0x14, 0x25d, 100, auStack_1064);
            local_9 = 0;
        }
        memcpy(*(void **)(param_2 + 0x23), param_1 + local_3b, (uint)local_19);
        memcpy(&local_4e, param_1 + local_3a, (uint)local_18);
        *(ushort *)(param_2 + 0x27) = local_4e << 8 | local_4e >> 8;
        memcpy(&local_50, param_1 + local_39, (uint)local_17);
        *(ushort *)(param_2 + 0x29) = local_50 << 8 | local_50 >> 8;
        memcpy(&local_52, param_1 + local_38, (uint)local_16);
        *(float *)(param_2 + 0x2b) =
            (float)(ushort)(local_52 << 8 | local_52 >> 8) / 100.0;
        param_2[0x2f] = param_1[local_37];
        param_2[0x30] = param_1[local_36];
        param_2[0x31] = param_1[local_35];
        param_2[0x32] = param_1[local_34];
        pvVar2 = calloc(local_11 + 1, 1);
        *(void **)(param_2 + 0x33) = pvVar2;
        if (*(int *)(param_2 + 0x33) == 0) {
            builtin_strncpy(local_1864, "Decode miner", 0xc);
            local_1858._0_1_ = '_';
            local_1858._1_1_ = 't';
            local_1858._2_1_ = 'y';
            local_1858._3_1_ = 'p';
            builtin_strncpy(local_1854, "e OO", 4);
            local_1850._0_2_ = 0x4d;
            V_LOCK();
            logfmt_raw(auStack_1064, 0x1000, 0, local_1864);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_buf_to_layout", 0x14, 0x281, 100, auStack_1064);
            local_9 = 0;
        }
        memcpy(*(void **)(param_2 + 0x33), param_1 + local_33, (uint)local_11);
        param_2[0x37] = param_1[local_32];
        param_2[0x3c] = param_1[local_30];
        if (param_2[2] == 4) {
            memcpy(param_2 + 0x3d, param_1 + local_2f, (uint)local_f);
            memcpy(param_2 + 0x3f, param_1 + local_2e, (uint)local_e);
            memcpy(param_2 + 0xbf, param_1 + local_2d, (uint)local_d);
            param_2[0xc4] = param_1[local_2b];
        }
    } else {
        local_9 = 0;
    }
    return local_9;
}

undefined4 eeprom_trans_raw2layout(undefined4 param_1, undefined4 param_2)

{
    int iVar1;
    undefined4 uVar2;

    iVar1 = FUN_0009f374(param_1, param_2);
    if (iVar1 == 0) {
        uVar2 = 0xffffffff;
    } else {
        uVar2 = 0;
    }
    return uVar2;
}

undefined1 FUN_000a0414(byte *param_1, byte *param_2)

{
    char cVar1;
    byte bVar2;
    char local_186c[20];
    undefined4 local_1858;
    uint local_1854;
    char acStack_1850[4];
    undefined2 local_184c;
    undefined1 local_184a;
    undefined1 auStack_106c[4096];
    undefined8 local_6c;
    undefined8 uStack_64;
    short local_5a;
    ushort local_58;
    ushort local_56;
    undefined1 auStack_54[3];
    byte local_51;
    byte local_50;
    byte local_4f;
    byte local_4e;
    byte local_4d;
    byte local_4b;
    byte local_4a;
    byte local_49;
    byte local_48;
    byte local_47;
    byte local_46;
    byte local_45;
    byte local_44;
    byte local_43;
    byte local_42;
    byte local_41;
    byte local_40;
    byte local_3f;
    byte local_3e;
    byte local_3d;
    byte local_3c;
    byte local_3b;
    byte local_3a;
    byte local_38;
    byte local_2f;
    byte local_2e;
    byte local_2d;
    byte local_2b;
    byte local_28;
    byte local_21;
    byte local_20;
    byte local_1f;
    byte local_1e;
    byte local_19;
    undefined1 local_11;

    local_11 = 1;
    *param_1 = (byte)((((uint)*param_2 << 0x18) >> 0x1c) << 4) |
               (byte)(((uint)*param_2 << 0x1c) >> 0x1c);
    param_1[1] = param_2[1];
    param_1[2] = param_2[2];
    cVar1 = init_eeprom_fmt_info(auStack_54, param_2[2]);
    if (cVar1 == '\x01') {
        if (*(int *)(param_2 + 3) == 0) {
            builtin_strncpy(local_186c, "encode serial_number", 0x14);
            local_1858._0_1_ = ' ';
            local_1858._1_1_ = 'O';
            local_1858._2_1_ = 'O';
            local_1858._3_1_ = 'M';
            local_1854 = local_1854 & 0xffffff00;
            V_LOCK();
            logfmt_raw(auStack_106c, 0x1000, 0, local_186c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_layout_to_buf", 0x14, 0x2b5, 100, auStack_106c);
            local_11 = 0;
        }
        memcpy(param_1 + local_51, *(void **)(param_2 + 3), (uint)local_2f);
        if (*(int *)(param_2 + 7) == 0) {
            builtin_strncpy(local_186c, "encode chip_die OOM", 0x14);
            V_LOCK();
            logfmt_raw(auStack_106c, 0x1000, 0, local_186c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_layout_to_buf", 0x14, 700, 100, auStack_106c);
            local_11 = 0;
        }
        memcpy(param_1 + local_50, *(void **)(param_2 + 7), (uint)local_2e);
        if (*(int *)(param_2 + 0xb) == 0) {
            builtin_strncpy(local_186c, "encode chip_marking ", 0x14);
            local_1858._0_1_ = 'O';
            local_1858._1_1_ = 'O';
            local_1858._2_1_ = 'M';
            local_1858._3_1_ = '\0';
            V_LOCK();
            logfmt_raw(auStack_106c, 0x1000, 0, local_186c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_layout_to_buf", 0x14, 0x2c3, 100, auStack_106c);
            local_11 = 0;
        }
        memcpy(param_1 + local_4f, *(void **)(param_2 + 0xb), (uint)local_2d);
        param_1[local_4e] = param_2[0xf];
        if (*(int *)(param_2 + 0x10) == 0) {
            builtin_strncpy(local_186c, "encode Chip FT Progr", 0x14);
            local_1858._0_1_ = 'a';
            local_1858._1_1_ = 'm';
            local_1858._2_1_ = ' ';
            local_1858._3_1_ = 'V';
            local_1854._0_1_ = 'e';
            local_1854._1_1_ = 'r';
            local_1854._2_1_ = 's';
            local_1854._3_1_ = 'i';
            builtin_strncpy(acStack_1850, "on O", 4);
            local_184c = 0x4d4f;
            local_184a = 0;
            V_LOCK();
            logfmt_raw(auStack_106c, 0x1000, 0, local_186c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_layout_to_buf", 0x14, 0x2cd, 100, auStack_106c);
            local_11 = 0;
        }
        if ((param_2[2] == 1) || (param_2[2] == 2)) {
            local_6c = 0;
            uStack_64 = 0;
            __isoc99_sscanf(*(undefined4 *)(param_2 + 0x10), "F%dV%02dB%dC%d",
                            &local_6c, (int)&local_6c + 1, (int)&local_6c + 2,
                            (int)&local_6c + 3);
            memcpy(param_1 + local_4d, &local_6c, (uint)local_2b);
        } else {
            memcpy(param_1 + local_4d, *(void **)(param_2 + 0x10),
                   (uint)local_2b);
        }
        param_1[local_4b] =
            (byte)((((uint)param_2[0x18] << 0x18) >> 0x1f) << 7) |
            (byte)(((uint)param_2[0x18] << 0x19) >> 0x19);
        if (*(int *)(param_2 + 0x19) == 0) {
            builtin_strncpy(local_186c, "Decode asic_sensor_a", 0x14);
            local_1858._0_1_ = 'd';
            local_1858._1_1_ = 'd';
            local_1858._2_1_ = 'r';
            local_1858._3_1_ = ' ';
            local_1854._0_1_ = 'O';
            local_1854._1_1_ = 'O';
            local_1854._2_1_ = 'M';
            local_1854._3_1_ = '\0';
            V_LOCK();
            logfmt_raw(auStack_106c, 0x1000, 0, local_186c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_layout_to_buf", 0x14, 0x2e1, 100, auStack_106c);
            local_11 = 0;
        }
        memcpy(param_1 + local_4a, *(void **)(param_2 + 0x19), (uint)local_28);
        param_1[local_49] =
            (byte)((((uint)param_2[0x1d] << 0x18) >> 0x1f) << 7) |
            (byte)(((uint)param_2[0x1d] << 0x19) >> 0x19);
        param_1[local_48] = param_2[0x1e];
        param_1[local_47] = param_2[0x1f];
        param_1[local_46] = param_2[0x20];
        param_1[local_45] = param_2[0x21];
        param_1[local_44] = param_2[0x22];
        if (*(int *)(param_2 + 0x23) == 0) {
            builtin_strncpy(local_186c, "Decode Chip Technolo", 0x14);
            local_1858._0_1_ = 'g';
            local_1858._1_1_ = 'y';
            local_1858._2_1_ = ' ';
            local_1858._3_1_ = 'O';
            local_1854 = CONCAT13(local_1854._3_1_, 0x4d4f);
            V_LOCK();
            logfmt_raw(auStack_106c, 0x1000, 0, local_186c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_layout_to_buf", 0x14, 0x2f7, 100, auStack_106c);
            local_11 = 0;
        }
        memcpy(param_1 + local_43, *(void **)(param_2 + 0x23), (uint)local_21);
        local_56 =
            *(short *)(param_2 + 0x27) << 8 | *(ushort *)(param_2 + 0x27) >> 8;
        memcpy(param_1 + local_42, &local_56, (uint)local_20);
        local_58 =
            *(short *)(param_2 + 0x29) << 8 | *(ushort *)(param_2 + 0x29) >> 8;
        memcpy(param_1 + local_41, &local_58, (uint)local_1f);
        local_5a = (ushort)(0.0 < *(float *)(param_2 + 0x2b) * 100.0) *
                   (short)(int)(*(float *)(param_2 + 0x2b) * 100.0);
        memcpy(param_1 + local_40, &local_5a, (uint)local_1e);
        param_1[local_3f] = param_2[0x2f];
        param_1[local_3e] = param_2[0x30];
        param_1[local_3d] = param_2[0x31];
        param_1[local_3c] = param_2[0x32];
        if (*(int *)(param_2 + 0x33) == 0) {
            builtin_strncpy(local_186c, "Decode miner_type OO", 0x14);
            local_1858._0_2_ = 0x4d;
            V_LOCK();
            logfmt_raw(auStack_106c, 0x1000, 0, local_186c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_layout_to_buf", 0x14, 0x317, 100, auStack_106c);
            local_11 = 0;
        }
        memcpy(param_1 + local_3b, *(void **)(param_2 + 0x33), (uint)local_19);
        param_1[local_3a] = param_2[0x37];
        bVar2 = BM_CRC5(param_1, (param_2[1] - 1) * 8);
        param_1[local_38] = bVar2;
    } else {
        local_11 = 0;
    }
    return local_11;
}

undefined *add_eeprom_device(undefined4 param_1)

{
    int iVar1;

    iVar1 = DAT_0015faac * 4;
    DAT_0015faac = DAT_0015faac + 1;
    *(undefined4 *)(&DAT_0015fa6c + iVar1) = param_1;
    return &DAT_0015fa6c;
}

int eeprom_load_one_chain(int param_1, int param_2)

{
    int iVar1;
    char acStack_1a14[2048];
    undefined1 auStack_1214[4096];
    undefined1 auStack_214[256];
    undefined1 auStack_114[256];
    undefined4 local_14;
    int local_10;
    int local_c;

    local_10 = 0;
    local_c = 3;
    memset(auStack_114, 0, 0x100);
    memset(auStack_214, 0, 0x100);
    local_14 = *(undefined4 *)(param_2 + param_1 * 4);
    do {
        local_10 = eeprom_read(param_1, 0, auStack_114, 0x100);
        if (local_10 != 0) {
            snprintf(acStack_1a14, 0x800,
                     "Read configuration fail for chain %d.", param_1);
            V_LOCK();
            logfmt_raw(auStack_1214, 0x1000, 0, acStack_1a14);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_load_one_chain", 0x15, 0x336, 100, auStack_1214);
            return local_10;
        }
        iVar1 = FUN_0009d6a8(auStack_114, auStack_214);
        if (iVar1 == 0)
            break;
        snprintf(acStack_1a14, 0x800, "Data decode fail for chain %d.",
                 param_1);
        V_LOCK();
        logfmt_raw(auStack_1214, 0x1000, 0, acStack_1a14);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "eeprom_load_one_chain", 0x15, 0x344, 100, auStack_1214);
        usleep(500000);
        local_c = local_c + -1;
    } while (local_c != 0);
    if (((local_c == 0) ||
         (iVar1 = FUN_0009f374(auStack_214, local_14), iVar1 == 0)) ||
        (iVar1 = FUN_0009d4a8(auStack_214, local_14), iVar1 == 0)) {
        *(undefined1 *)(param_2 + param_1 + 0x40) = 0;
        snprintf(acStack_1a14, 0x800, "Data load fail for chain %d.", param_1);
        V_LOCK();
        logfmt_raw(auStack_1214, 0x1000, 0, acStack_1a14);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "eeprom_load_one_chain", 0x15, 0x355, 100, auStack_1214);
        local_10 = -1;
    } else {
        *(undefined1 *)(param_2 + param_1 + 0x40) = 1;
    }
    return local_10;
}

int eeprom_rewrite_one_chain(int param_1, int param_2, int param_3, int param_4)

{
    int iVar1;
    char acStack_1b14[2048];
    undefined1 auStack_1314[4096];
    undefined1 auStack_314[256];
    undefined1 auStack_214[256];
    undefined1 auStack_114[256];
    int local_14;
    int local_10;
    int local_c;

    local_10 = 0;
    local_c = 3;
    memset(auStack_114, 0, 0x100);
    memset(auStack_214, 0, 0x100);
    memset(auStack_314, 0, 0x100);
    local_14 = *(int *)(param_2 + param_1 * 4);
    do {
        local_10 = eeprom_read(param_1, 0, auStack_114, 0x100);
        if (local_10 != 0) {
            snprintf(acStack_1b14, 0x800,
                     "Read configuration fail for chain %d.", param_1);
            V_LOCK();
            logfmt_raw(auStack_1314, 0x1000, 0, acStack_1b14);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_rewrite_one_chain", 0x18, 0x36a, 100,
                 auStack_1314);
            return local_10;
        }
        iVar1 = FUN_0009d6a8(auStack_114, auStack_214);
        if (iVar1 == 0)
            break;
        snprintf(acStack_1b14, 0x800, "Data decode fail for chain %d.",
                 param_1);
        V_LOCK();
        logfmt_raw(auStack_1314, 0x1000, 0, acStack_1b14);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "eeprom_rewrite_one_chain", 0x18, 0x378, 100, auStack_1314);
        usleep(500000);
        local_c = local_c + -1;
    } while (local_c != 0);
    if (((local_c == 0) ||
         (iVar1 = FUN_0009f374(auStack_214, local_14), iVar1 == 0)) ||
        (iVar1 = FUN_0009d4a8(auStack_214, local_14), iVar1 == 0)) {
        *(undefined1 *)(param_2 + param_1 + 0x40) = 0;
        snprintf(acStack_1b14, 0x800, "Data load fail for chain %d.", param_1);
        V_LOCK();
        logfmt_raw(auStack_1314, 0x1000, 0, acStack_1b14);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "eeprom_rewrite_one_chain", 0x18, 0x389, 100, auStack_1314);
        local_10 = -1;
    } else {
        *(undefined1 *)(param_2 + param_1 + 0x40) = 1;
        snprintf(acStack_1b14, 0x800,
                 "chain[%d], modify voltage from %d to %d, freq from %d to %d",
                 param_1, (uint) * (ushort *)(local_14 + 0x27),
                 (uint) * (ushort *)(local_14 + 0x27) + param_3,
                 (uint) * (ushort *)(local_14 + 0x29),
                 (uint) * (ushort *)(local_14 + 0x29) + param_4);
        V_LOCK();
        logfmt_raw(auStack_1314, 0x1000, 0, acStack_1b14);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "eeprom_rewrite_one_chain", 0x18, 0x38f, 100, auStack_1314);
        *(short *)(local_14 + 0x27) =
            *(short *)(local_14 + 0x27) + (short)param_3;
        *(short *)(local_14 + 0x29) =
            *(short *)(local_14 + 0x29) + (short)param_4;
        FUN_000a0414(auStack_214, local_14);
        iVar1 = FUN_0009d9ac(auStack_214, auStack_314);
        if (iVar1 == 0) {
            local_c = 3;
            do {
                eeprom_write(param_1, 0, auStack_314,
                             *(undefined1 *)(local_14 + 1));
                memset(auStack_114, 0, 0x100);
                local_10 = eeprom_read(param_1, 0, auStack_114, 0x100);
                if (local_10 == 0) {
                    iVar1 = FUN_0009d6a8(auStack_114, auStack_214);
                    if (iVar1 == 0) {
                        iVar1 = FUN_0009f374(auStack_214, local_14);
                        if ((iVar1 != 0) &&
                            (iVar1 = FUN_0009d4a8(auStack_214, local_14),
                             iVar1 != 0)) {
                            *(undefined1 *)(param_2 + param_1 + 0x40) = 1;
                            return 0;
                        }
                        *(undefined1 *)(param_2 + param_1 + 0x40) = 0;
                        local_10 = -1;
                        snprintf(acStack_1b14, 0x800,
                                 "Data load fail for chain %d.", param_1);
                        V_LOCK();
                        logfmt_raw(auStack_1314, 0x1000, 0, acStack_1b14);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/device/"
                             "hal/eeprom/bitmain_eeprom.c",
                             0xb4, "eeprom_rewrite_one_chain", 0x18, 0x3be, 100,
                             auStack_1314);
                    } else {
                        snprintf(acStack_1b14, 0x800,
                                 "Data decode fail for chain %d.", param_1);
                        V_LOCK();
                        logfmt_raw(auStack_1314, 0x1000, 0, acStack_1b14);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/device/"
                             "hal/eeprom/bitmain_eeprom.c",
                             0xb4, "eeprom_rewrite_one_chain", 0x18, 0x3af, 100,
                             auStack_1314);
                        usleep(500000);
                    }
                } else {
                    snprintf(acStack_1b14, 0x800,
                             "Read configuration fail for chain %d.", param_1);
                    V_LOCK();
                    logfmt_raw(auStack_1314, 0x1000, 0, acStack_1b14);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/eeprom/bitmain_eeprom.c",
                         0xb4, "eeprom_rewrite_one_chain", 0x18, 0x3a1, 100,
                         auStack_1314);
                }
                local_c = local_c + -1;
            } while (local_c != 0);
        } else {
            local_10 = -1;
        }
    }
    return local_10;
}

uint eeprom_vol_freq_override(undefined4 param_1, undefined4 param_2)

{
    int iVar1;
    uint uVar2;
    uint local_10;
    byte local_9;

    local_10 = 0;
    if ((DAT_0015fa68 == 0) && (iVar1 = FUN_0009d24c(), iVar1 != 0)) {
        local_10 = 0xffffffff;
    } else {
        for (local_9 = 0; (int)(uint)local_9 < DAT_0015faac;
             local_9 = local_9 + 1) {
            uVar2 = eeprom_rewrite_one_chain(
                *(undefined4 *)(&DAT_0015fa6c + (uint)local_9 * 4),
                DAT_0015fa68, param_1, param_2);
            local_10 = local_10 | uVar2;
        }
        if (local_10 == 0) {
            *(undefined1 *)(DAT_0015fa68 + 0x50) = 1;
        }
    }
    return local_10;
}

uint eeprom_load(void)

{
    int iVar1;
    uint uVar2;
    uint local_10;
    byte local_9;

    local_10 = 0;
    if (DAT_0015fa68 == 0) {
        iVar1 = FUN_0009d24c();
        if (iVar1 != 0) {
            return 0xffffffff;
        }
    } else if (*(char *)(DAT_0015fa68 + 0x50) != '\0') {
        return 0;
    }
    for (local_9 = 0; (int)(uint)local_9 < DAT_0015faac;
         local_9 = local_9 + 1) {
        uVar2 = eeprom_load_one_chain(
            *(undefined4 *)(&DAT_0015fa6c + (uint)local_9 * 4), DAT_0015fa68);
        local_10 = local_10 | uVar2;
    }
    if (local_10 == 0) {
        *(undefined1 *)(DAT_0015fa68 + 0x50) = 1;
    }
    return local_10;
}

undefined4 eeprom_get_voltage(int param_1, uint *param_2)

{
    undefined4 uVar1;
    char local_180c[2048];
    undefined1 auStack_100c[4096];
    uint local_c;

    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(local_180c, 0x800, "No work mode voltage, chain = %d.",
                 param_1);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "eeprom_get_voltage", 0x12, 0x409, 100, auStack_100c);
        uVar1 = 0xffffffff;
    } else {
        local_c =
            (uint) * (ushort *)(*(int *)(DAT_0015fa68 + param_1 * 4) + 0x27);
        if (param_2 == (uint *)0x0) {
            builtin_strncpy(local_180c, "voltage level not match", 0x18);
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_get_voltage", 0x12, 0x414, 100, auStack_100c);
            uVar1 = 0xfffffffe;
        } else {
            *param_2 = local_c;
            uVar1 = 0;
        }
    }
    return uVar1;
}

uint eeprom_get_max_voltage(void)

{
    char acStack_1810[2048];
    undefined1 auStack_1010[4096];
    uint local_10;
    int local_c;

    local_10 = 0;
    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(acStack_1810, 0x800, "%s: eeprom is not ready",
                 "eeprom_get_max_voltage");
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, acStack_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "eeprom_get_max_voltage", 0x16, 0x41e, 100, auStack_1010);
        local_10 = 0xffffffff;
    } else {
        for (local_c = 0; local_c < DAT_0015faac; local_c = local_c + 1) {
            if (local_10 <
                *(ushort *)(*(int *)(DAT_0015fa68 +
                                     *(int *)(&DAT_0015fa6c + local_c * 4) *
                                         4) +
                            0x27)) {
                local_10 =
                    (uint) *
                    (ushort *)(*(int *)(DAT_0015fa68 +
                                        *(int *)(&DAT_0015fa6c + local_c * 4) *
                                            4) +
                               0x27);
            }
        }
    }
    return local_10;
}

undefined4 eeprom_get_PT2_freq(int param_1, uint *param_2)

{
    undefined4 uVar1;
    char local_180c[2048];
    undefined1 auStack_100c[4096];
    uint local_c;

    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(local_180c, 0x800, "No work mode freq, chain = %d.", param_1);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "eeprom_get_PT2_freq", 0x13, 0x430, 100, auStack_100c);
        uVar1 = 0xffffffff;
    } else {
        local_c =
            (uint) * (ushort *)(*(int *)(DAT_0015fa68 + param_1 * 4) + 0x29);
        if (param_2 == (uint *)0x0) {
            builtin_strncpy(local_180c, "freq level not match", 0x14);
            local_180c[0x14] = 0;
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "eeprom_get_PT2_freq", 0x13, 0x43b, 100, auStack_100c);
            uVar1 = 0xfffffffe;
        } else {
            *param_2 = local_c;
            uVar1 = 0;
        }
    }
    return uVar1;
}

uint eeprom_get_min_freq(void)

{
    char acStack_1810[2048];
    undefined1 auStack_1010[4096];
    uint local_10;
    int local_c;

    local_10 = 0xffff;
    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(acStack_1810, 0x800, "%s: g_eeprom_data is not ready",
                 "eeprom_get_min_freq");
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, acStack_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "eeprom_get_min_freq", 0x13, 0x445, 100, auStack_1010);
        local_10 = 0xffffffff;
    } else {
        for (local_c = 0; local_c < DAT_0015faac; local_c = local_c + 1) {
            if (*(ushort *)(*(int *)(DAT_0015fa68 +
                                     *(int *)(&DAT_0015fa6c + local_c * 4) *
                                         4) +
                            0x29) < local_10) {
                local_10 =
                    (uint) *
                    (ushort *)(*(int *)(DAT_0015fa68 +
                                        *(int *)(&DAT_0015fa6c + local_c * 4) *
                                            4) +
                               0x29);
            }
        }
    }
    return local_10;
}

undefined4 eeprom_get_fmt_version(int param_1, undefined1 *param_2)

{
    undefined4 uVar1;
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(acStack_1808, 0x800, "%s: g_eeprom_data is not ready",
                 "eeprom_get_fmt_version");
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "eeprom_get_fmt_version", 0x16, 0x455, 100, auStack_1008);
        uVar1 = 0xffffffff;
    } else {
        *param_2 = *(undefined1 *)(*(int *)(DAT_0015fa68 + param_1 * 4) + 2);
        uVar1 = 0;
    }
    return uVar1;
}

undefined1 is_eeprom_loaded(void)

{
    undefined1 uVar1;
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(acStack_1808, 0x800, "%s: g_eeprom_data is not ready",
                 "is_eeprom_loaded");
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "is_eeprom_loaded", 0x10, 0x461, 0x14, auStack_1008);
        uVar1 = 0;
    } else {
        uVar1 = *(undefined1 *)(DAT_0015fa68 + 0x50);
    }
    return uVar1;
}

undefined4 FUN_000a28e4(int param_1)

{
    undefined4 uVar1;
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(acStack_1808, 0x800,
                 "%s: g_eeprom_data is not ready, chain = %d.",
                 "get_chip_marking", param_1);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "get_chip_marking", 0x10, 0x479, 100, auStack_1008);
        uVar1 = 0;
    } else {
        uVar1 = *(undefined4 *)(*(int *)(DAT_0015fa68 + param_1 * 4) + 0xb);
    }
    return uVar1;
}

undefined1 FUN_000a29fc(int param_1)

{
    undefined1 uVar1;
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(acStack_1808, 0x800,
                 "%s: g_eeprom_data is not ready, chain = %d.", "get_chip_bin",
                 param_1);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "get_chip_bin", 0xc, 0x483, 100, auStack_1008);
        uVar1 = 0xff;
    } else {
        uVar1 = *(undefined1 *)(*(int *)(DAT_0015fa68 + param_1 * 4) + 0xf);
    }
    return uVar1;
}

undefined4 FUN_000a2b14(int param_1)

{
    undefined4 uVar1;
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(acStack_1808, 0x800,
                 "%s: g_eeprom_data is not ready, chain = %d.", "get_chip_ft",
                 param_1);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "get_chip_ft", 0xb, 0x48d, 100, auStack_1008);
        uVar1 = 0;
    } else {
        uVar1 = *(undefined4 *)(*(int *)(DAT_0015fa68 + param_1 * 4) + 0x10);
    }
    return uVar1;
}

undefined1 FUN_000a2c2c(int param_1)

{
    undefined1 uVar1;
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(acStack_1808, 0x800,
                 "%s: g_eeprom_data is not ready, chain = %d.",
                 "get_test_standard_code", param_1);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "get_test_standard_code", 0x16, 0x497, 100, auStack_1008);
        uVar1 = 0xff;
    } else {
        uVar1 = *(undefined1 *)(*(int *)(DAT_0015fa68 + param_1 * 4) + 0x32);
    }
    return uVar1;
}

undefined4 FUN_000a2d44(int param_1)

{
    undefined4 uVar1;
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(acStack_1808, 0x800,
                 "%s: g_eeprom_data is not ready, chain = %d.", "get_chip_sn",
                 param_1);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "get_chip_sn", 0xb, 0x4a1, 100, auStack_1008);
        uVar1 = 0;
    } else {
        uVar1 = *(undefined4 *)(*(int *)(DAT_0015fa68 + param_1 * 4) + 3);
    }
    return uVar1;
}

undefined4 FUN_000a2e5c(int param_1, char *param_2)

{
    undefined4 uVar1;
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(acStack_1808, 0x800,
                 "%s: g_eeprom_data is not ready, chain = %d.",
                 "get_pcb_version", param_1);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "get_pcb_version", 0xf, 0x4ab, 100, auStack_1008);
        uVar1 = 0xff;
    } else {
        sprintf(param_2, "%x%02x",
                (uint) * (byte *)(*(int *)(DAT_0015fa68 + param_1 * 4) + 0x1f),
                (uint) * (byte *)(*(int *)(DAT_0015fa68 + param_1 * 4) + 0x20));
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 FUN_000a2fd0(int param_1, char *param_2)

{
    undefined4 uVar1;
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(acStack_1808, 0x800,
                 "%s: g_eeprom_data is not ready, chain = %d.",
                 "get_bom_version", param_1);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "get_bom_version", 0xf, 0x4b6, 100, auStack_1008);
        uVar1 = 0xff;
    } else {
        sprintf(param_2, "%x%x",
                (uint) * (byte *)(*(int *)(DAT_0015fa68 + param_1 * 4) + 0x21),
                (uint) * (byte *)(*(int *)(DAT_0015fa68 + param_1 * 4) + 0x22));
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 FUN_000a3144(int param_1, void *param_2)

{
    size_t __n;
    void *__src;
    char acStack_1810[2048];
    undefined1 auStack_1010[4100];

    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(acStack_1810, 0x800,
                 "%s: g_eeprom_data is not ready, chain = %d.",
                 "get_miner_type", param_1);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, acStack_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "get_miner_type", 0xe, 0x4c2, 100, auStack_1010);
    } else {
        __src = *(void **)(*(int *)(DAT_0015fa68 + param_1 * 4) + 0x33);
        __n = strlen(*(char **)(*(int *)(DAT_0015fa68 + param_1 * 4) + 0x33));
        memcpy(param_2, __src, __n);
    }
    return 0;
}

undefined1 FUN_000a32ac(int param_1)

{
    undefined1 uVar1;
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(acStack_1808, 0x800,
                 "%s: g_eeprom_data is not ready, chain = %d.",
                 "get_phy_seq_level", param_1);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "get_phy_seq_level", 0x11, 0x4ce, 100, auStack_1008);
        uVar1 = 0xff;
    } else {
        uVar1 = *(undefined1 *)(*(int *)(DAT_0015fa68 + param_1 * 4) + 0x37);
    }
    return uVar1;
}

undefined4 api_get_eeprom_nonce_response_rate(int param_1, undefined4 *param_2)

{
    undefined4 uVar1;
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(acStack_1808, 0x800,
                 "%s: g_eeprom_data is not ready, chain = %d.",
                 "api_get_eeprom_nonce_response_rate",
                 *(undefined4 *)(&DAT_0015fa6c + param_1 * 4));
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "api_get_eeprom_nonce_response_rate", 0x22, 0x4d8, 100,
             auStack_1008);
        uVar1 = 0xffffffff;
    } else if (param_2 == (undefined4 *)0x0) {
        snprintf(acStack_1808, 0x800,
                 "%s: chain = %d nonce response rate in eeprom is invalid",
                 "api_get_eeprom_nonce_response_rate",
                 *(undefined4 *)(&DAT_0015fa6c + param_1 * 4));
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "api_get_eeprom_nonce_response_rate", 0x22, 0x4e1, 100,
             auStack_1008);
        uVar1 = 0xfffffffe;
    } else {
        *param_2 = *(
            undefined4 *)(*(int *)(DAT_0015fa68 +
                                   *(int *)(&DAT_0015fa6c + param_1 * 4) * 4) +
                          0x2b);
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 api_get_eeprom_PT2_freq(int param_1)

{
    undefined4 local_c;

    local_c = 0;
    eeprom_get_PT2_freq(*(undefined4 *)(&DAT_0015fa6c + param_1 * 4), &local_c);
    return local_c;
}

int api_get_eeprom_sweep_freq(int param_1)

{
    int iVar1;
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(acStack_1808, 0x800, "%s: g_eeprom_data is not ready",
                 "api_get_eeprom_sweep_freq");
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "api_get_eeprom_sweep_freq", 0x19, 0x4f1, 0x14,
             auStack_1008);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, "get eeprom sweep freq fail");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "api_get_eeprom_sweep_freq", 0x19, 0x4f2, 0x3c,
             auStack_1008);
        iVar1 = 0;
    } else {
        V_LOCK();
        logfmt_raw(
            auStack_1008, 0x1000, 0, "get eeprom sweep freq: %hu",
            *(undefined2 *)(*(int *)(DAT_0015fa68 +
                                     *(int *)(&DAT_0015fa6c + param_1 * 4) *
                                         4) +
                            0xbf));
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "api_get_eeprom_sweep_freq", 0x19, 0x4f6, 0x14,
             auStack_1008);
        iVar1 = (int)*(
            short *)(*(int *)(DAT_0015fa68 +
                              *(int *)(&DAT_0015fa6c + param_1 * 4) * 4) +
                     0xbf);
    }
    return iVar1;
}

undefined4 api_get_eeprom_voltage(int param_1)

{
    undefined4 local_c;

    local_c = 0;
    eeprom_get_voltage(*(undefined4 *)(&DAT_0015fa6c + param_1 * 4), &local_c);
    return local_c;
}

undefined4 api_get_eeprom_chip_marking(int param_1)

{
    undefined4 uVar1;

    uVar1 = FUN_000a28e4(*(undefined4 *)(&DAT_0015fa6c + param_1 * 4));
    return uVar1;
}

undefined4 api_get_eeprom_chip_bin(int param_1)

{
    undefined4 uVar1;

    uVar1 = FUN_000a29fc(*(undefined4 *)(&DAT_0015fa6c + param_1 * 4));
    return uVar1;
}

undefined4 api_get_eeprom_chip_ft(int param_1)

{
    undefined4 uVar1;

    uVar1 = FUN_000a2b14(*(undefined4 *)(&DAT_0015fa6c + param_1 * 4));
    return uVar1;
}

undefined4 api_get_eeprom_test_standard_code(int param_1)

{
    undefined4 uVar1;

    uVar1 = FUN_000a2c2c(*(undefined4 *)(&DAT_0015fa6c + param_1 * 4));
    return uVar1;
}

undefined4 api_get_eeprom_chip_sn(int param_1)

{
    undefined4 uVar1;

    uVar1 = FUN_000a2d44(*(undefined4 *)(&DAT_0015fa6c + param_1 * 4));
    return uVar1;
}

undefined4 api_get_eeprom_miner_type(int param_1, undefined4 param_2)

{
    undefined4 uVar1;

    uVar1 = FUN_000a3144(*(undefined4 *)(&DAT_0015fa6c + param_1 * 4), param_2);
    return uVar1;
}

uint api_get_eeprom_chain_load_state(int param_1)

{
    uint uVar1;
    char acStack_1808[2048];
    undefined1 auStack_1008[4096];

    if (DAT_0015fa68 == 0) {
        snprintf(acStack_1808, 0x800,
                 "%s: g_eeprom_data is not ready, chain = %d.",
                 "api_get_eeprom_chain_load_state",
                 *(undefined4 *)(&DAT_0015fa6c + param_1 * 4));
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, acStack_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "api_get_eeprom_chain_load_state", 0x1f, 0x531, 100,
             auStack_1008);
        uVar1 = 0xffffffff;
    } else {
        uVar1 = (uint) * (byte *)(DAT_0015fa68 +
                                  *(int *)(&DAT_0015fa6c + param_1 * 4) + 0x40);
    }
    return uVar1;
}

undefined4 api_get_eeprom_pcb_version(int param_1, undefined4 param_2)

{
    undefined4 uVar1;

    uVar1 = FUN_000a2e5c(*(undefined4 *)(&DAT_0015fa6c + param_1 * 4), param_2);
    return uVar1;
}

undefined4 api_get_eeprom_bom_version(int param_1, undefined4 param_2)

{
    undefined4 uVar1;

    uVar1 = FUN_000a2fd0(*(undefined4 *)(&DAT_0015fa6c + param_1 * 4), param_2);
    return uVar1;
}

undefined4 api_get_eeprom_phy_seq_level(int param_1)

{
    undefined4 uVar1;

    uVar1 = FUN_000a32ac(*(undefined4 *)(&DAT_0015fa6c + param_1 * 4));
    return uVar1;
}

undefined1 api_get_eeprom_fmt_version(int param_1)

{
    int iVar1;
    undefined1 local_9;

    local_9 = 0;
    iVar1 = eeprom_get_fmt_version(*(undefined4 *)(&DAT_0015fa6c + param_1 * 4),
                                   &local_9);
    if (iVar1 != 0) {
        local_9 = 0;
    }
    return local_9;
}

undefined4 api_get_eeprom_asic_freqs(int param_1, void *param_2, float *param_3)

{
    undefined4 uVar1;
    char acStack_1a14[2048];
    undefined1 auStack_1214[4096];
    float afStack_214[128];
    ushort local_12;
    float local_10;
    uint local_c;

    if ((DAT_0015fa68 == 0) || (*(char *)(DAT_0015fa68 + 0x50) == '\0')) {
        snprintf(acStack_1a14, 0x800,
                 "%s: g_eeprom_data is not ready, chain = %d.\n",
                 "api_get_eeprom_asic_freqs",
                 *(undefined4 *)(&DAT_0015fa6c + param_1 * 4));
        V_LOCK();
        logfmt_raw(auStack_1214, 0x1000, 0, acStack_1a14);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/eeprom/"
             "bitmain_eeprom.c",
             0xb4, "api_get_eeprom_asic_freqs", 0x19, 0x55b, 100, auStack_1214);
        uVar1 = 0xffffffff;
    } else {
        local_12 =
            *(ushort *)(*(int *)(DAT_0015fa68 +
                                 *(int *)(&DAT_0015fa6c + param_1 * 4) * 4) +
                        0x29);
        local_10 =
            (float)*(
                ushort *)(*(int *)(DAT_0015fa68 +
                                   *(int *)(&DAT_0015fa6c + param_1 * 4) * 4) +
                          0x3d) *
            0.01;
        for (local_c = 0; local_c < 0x80; local_c = local_c + 1) {
            afStack_214[local_c] =
                (float)local_12 +
                (float)*(
                    byte *)(*(int *)(DAT_0015fa68 +
                                     *(int *)(&DAT_0015fa6c + param_1 * 4) *
                                         4) +
                            local_c + 0x3f) *
                    local_10;
        }
        if ((param_2 == (void *)0x0) || (param_3 == (float *)0x0)) {
            snprintf(acStack_1a14, 0x800, "%s: sweep_freqs is NULL %d\n",
                     "api_get_eeprom_asic_freqs",
                     *(undefined4 *)(&DAT_0015fa6c + param_1 * 4));
            V_LOCK();
            logfmt_raw(auStack_1214, 0x1000, 0, acStack_1a14);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/eeprom/bitmain_eeprom.c",
                 0xb4, "api_get_eeprom_asic_freqs", 0x19, 0x56e, 100,
                 auStack_1214);
            uVar1 = 0xfffffffe;
        } else {
            *param_3 = local_10;
            memcpy(param_2, afStack_214, 0x200);
            uVar1 = 0;
        }
    }
    return uVar1;
}

uint FUN_000a3f88(uint param_1)

{
    return param_1 << 0x18 | (param_1 >> 8 & 0xff) << 0x10 |
           (param_1 >> 0x10 & 0xff) << 8 | param_1 >> 0x18;
}

undefined8 FUN_000a3fb0(uint param_1, uint param_2)

{
    return CONCAT44(param_1 << 0x18 | (param_1 >> 8 & 0xff) << 0x10 |
                        (param_1 >> 0x10 & 0xff) << 8 | param_1 >> 0x18,
                    param_2 << 0x18 | (param_2 >> 8 & 0xff) << 0x10 |
                        (param_2 >> 0x10 & 0xff) << 8 | param_2 >> 0x18);
}

int FUN_000a3ff4(char *param_1, char *param_2, uint param_3)

{
    char local_1814[2048];
    undefined1 auStack_1014[4096];
    uint local_14;
    ushort local_10;
    ushort local_e;
    int local_c;

    local_c = 0;
    if (((param_1 == (char *)0x0) || (param_2 == (char *)0x0)) ||
        (param_3 == 0)) {
        local_c = -0x7ffffcff;
    } else {
        local_e = 0;
        for (local_14 = 2; local_14 < param_3 - 2; local_14 = local_14 + 1) {
            local_e = (byte)param_2[local_14] + local_e;
        }
        local_10 = (ushort)(byte)param_2[param_3 - 1] * 0x100 +
                   (ushort)(byte)param_2[param_3 - 2];
        if (local_e == local_10) {
            if (((*param_1 != *param_2) || (param_1[1] != param_2[1])) ||
                ((param_1[3] != param_2[3] ||
                  (param_3 != (byte)param_2[2] + 2)))) {
                builtin_strncpy(local_1814, "power reply the bad data", 0x18);
                local_1814[0x18] = 0;
                V_LOCK();
                logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/power/bitmain_power_APW9.c",
                     0xb7, "check_read_back_data", 0x14, 0x84, 0x14,
                     auStack_1014);
                local_c = -0x7ffffd00;
            }
        } else {
            snprintf(local_1814, 0x800,
                     "power reply the bad crc, crc = 0x%04x, crc_read = 0x%04x",
                     (uint)local_e, (uint)local_10);
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "check_read_back_data", 0x14, 0x7e, 0x14, auStack_1014);
            local_c = -0x7ffffd00;
        }
        if (local_c != 0) {
            for (local_14 = 0; local_14 < param_3; local_14 = local_14 + 1) {
                snprintf(local_1814, 0x800, "read_back_data[%d] = 0x%02x",
                         local_14, (uint)(byte)param_2[local_14]);
                V_LOCK();
                logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/power/bitmain_power_APW9.c",
                     0xb7, "check_read_back_data", 0x14, 0x8a, 0x14,
                     auStack_1014);
            }
        }
    }
    return local_c;
}

int FUN_000a4484(int param_1, uint param_2, undefined1 *param_3, uint param_4)

{
    undefined1 uVar1;
    char acStack_1818[2048];
    undefined1 auStack_1018[4098];
    undefined1 local_16;
    undefined1 local_15;
    undefined1 *local_14;
    int local_10;
    byte local_a;
    byte local_9;

    local_9 = 0;
    local_a = 0;
    local_10 = 0;
    local_15 = 0x11;
    local_16 = 0x10;
    pthread_mutex_lock((pthread_mutex_t *)power_mutex);
    if (DAT_0015fba8 != '\x01') {
        i2c_sim_send_cmd(local_16, 0, 1, local_15, 4);
        DAT_0015fba8 = '\x01';
    }
    for (local_a = 0; local_a < 3; local_a = local_a + 1) {
        for (local_9 = 0; local_9 < param_2; local_9 = local_9 + 1) {
            i2c_sim_send_cmd(local_16, 0, 1, local_15,
                             *(undefined1 *)(param_1 + (uint)local_9));
        }
        usleep(400000);
        local_14 = param_3;
        for (local_9 = 0; local_9 < param_4; local_9 = local_9 + 1) {
            uVar1 = i2c_sim_send_cmd(local_16, 1, 0, local_15, 0);
            *local_14 = uVar1;
            local_14 = local_14 + 1;
        }
        usleep(100000);
        local_10 = FUN_000a3ff4(param_1, param_3, param_4);
        if (local_10 == 0)
            break;
        snprintf(acStack_1818, 0x800,
                 "Send power cmd(0x%02x) failed, retry %d\n",
                 (uint) * (byte *)(param_1 + 3), (uint)local_a);
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, acStack_1818);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/power/"
             "bitmain_power_APW9.c",
             0xb7, "exec_i2c_sim_cmd", 0x10, 0xb9, 0x14, auStack_1018);
    }
    pthread_mutex_unlock((pthread_mutex_t *)power_mutex);
    return local_10;
}

undefined4 is_power_status_with_64bits(void)

{
    undefined4 uVar1;

    if (DAT_0015fad8 == 0xc1) {
        uVar1 = 1;
    } else if (DAT_0015fad8 == 0xc2) {
        uVar1 = 1;
    } else {
        uVar1 = 0;
    }
    return uVar1;
}

int FUN_000a47d0(undefined4 param_1, int param_2, uint param_3, int param_4,
                 uint param_5)

{
    char acStack_1814[2048];
    undefined1 auStack_1014[4099];
    undefined1 local_11;
    int local_10;
    byte local_a;
    byte local_9;

    local_9 = 0;
    local_a = 0;
    local_10 = 0;
    local_11 = 0;
    pthread_mutex_lock((pthread_mutex_t *)power_mutex);
    for (local_a = 0; local_a < 3; local_a = local_a + 1) {
        for (local_9 = 0; local_9 < param_3; local_9 = local_9 + 1) {
            iic_write_reg(param_1, &local_11, 1, param_2 + (uint)local_9, 1);
        }
        usleep(400000);
        for (local_9 = 0; local_9 < param_5; local_9 = local_9 + 1) {
            iic_read_reg(param_1, &local_11, 1, param_4 + (uint)local_9, 1);
        }
        usleep(100000);
        local_10 = FUN_000a3ff4(param_2, param_4, param_5);
        if (local_10 == 0)
            break;
        snprintf(acStack_1814, 0x800, "Send power cmd(0x%02x) failed, retry %d",
                 (uint) * (byte *)(param_2 + 3), (uint)local_a);
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, acStack_1814);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/power/"
             "bitmain_power_APW9.c",
             0xb7, "exec_power_cmd", 0xe, 0xf6, 0x14, auStack_1014);
    }
    pthread_mutex_unlock((pthread_mutex_t *)power_mutex);
    return local_10;
}

uint FUN_000a4a58(int param_1)

{
    int iVar1;
    char local_1828[2048];
    undefined1 auStack_1028[4096];
    undefined4 local_28;
    undefined2 local_24;
    undefined8 local_20;
    undefined4 local_18;
    undefined2 local_12;
    undefined4 local_10;
    undefined1 local_b;
    undefined1 local_a;
    undefined1 local_9;

    local_10 = 0x80000300;
    local_b = 4;
    local_a = 1;
    local_20 = 0;
    local_28 = 0;
    local_24 = 0;
    local_18 = 0xffffffff;
    local_12 = 5;
    /* WARNING: Ignoring partial resolution of indirect */
    local_28._0_1_ = 0x55;
    /* WARNING: Ignoring partial resolution of indirect */
    local_24._0_1_ = 5;
    local_9 = 6;
    if (param_1 == 0xff) {
        iVar1 = FUN_000a4484(&local_28, 6, &local_20, 8);
        if (iVar1 != 0) {
            builtin_strncpy(local_1828, "get power version failed", 0x18);
            local_1828[0x18] = 0;
            V_LOCK();
            logfmt_raw(auStack_1028, 0x1000, 0, local_1828);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_get_power_fw_version", 0x1d, 0x10f, 100,
                 auStack_1028);
            return 0x80000300;
        }
    } else {
        iVar1 = FUN_000a47d0(param_1, &local_28, 6, &local_20, 8);
        if (iVar1 != 0) {
            builtin_strncpy(local_1828, "get power version failed", 0x18);
            local_1828[0x18] = 0;
            V_LOCK();
            logfmt_raw(auStack_1028, 0x1000, 0, local_1828);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_get_power_fw_version", 0x1d, 0x115, 100,
                 auStack_1028);
            return 0x80000300;
        }
    }
    return (uint)local_20._4_2_;
}

uint FUN_000a4d8c(int param_1)

{
    int iVar1;
    char local_1828[2048];
    undefined1 auStack_1028[4096];
    undefined4 local_28;
    undefined2 local_24;
    undefined8 local_20;
    undefined4 local_18;
    undefined2 local_12;
    undefined4 local_10;
    undefined1 local_b;
    undefined1 local_a;
    undefined1 local_9;

    local_10 = 0x80000300;
    local_b = 4;
    local_a = 2;
    local_20 = 0;
    local_28 = 0;
    local_24 = 0;
    local_18 = 0xffffffff;
    local_12 = 6;
    /* WARNING: Ignoring partial resolution of indirect */
    local_28._0_1_ = 0x55;
    /* WARNING: Ignoring partial resolution of indirect */
    local_24._0_1_ = 6;
    local_9 = 6;
    if (param_1 == 0xff) {
        iVar1 = FUN_000a4484(&local_28, 6, &local_20, 8);
        if (iVar1 != 0) {
            builtin_strncpy(local_1828, "get power version failed", 0x18);
            local_1828[0x18] = 0;
            V_LOCK();
            logfmt_raw(auStack_1028, 0x1000, 0, local_1828);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_get_power_version", 0x1a, 0x13c, 100,
                 auStack_1028);
            return 0x80000300;
        }
    } else {
        iVar1 = FUN_000a47d0(param_1, &local_28, 6, &local_20, 8);
        if (iVar1 != 0) {
            builtin_strncpy(local_1828, "get power version failed", 0x18);
            local_1828[0x18] = 0;
            V_LOCK();
            logfmt_raw(auStack_1028, 0x1000, 0, local_1828);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_get_power_version", 0x1a, 0x142, 100,
                 auStack_1028);
            return 0x80000300;
        }
    }
    return (uint)local_20._4_2_;
}

uint FUN_000a50c0(int param_1)

{
    int iVar1;
    char local_1820[24];
    undefined2 local_1808;
    undefined1 local_1806;
    undefined1 auStack_1020[4096];
    undefined8 local_20;
    undefined4 local_18;
    undefined2 local_14;
    undefined2 local_12;
    undefined1 local_f;
    undefined1 local_e;
    undefined1 local_d;
    undefined4 local_c;

    local_f = 4;
    local_e = 3;
    local_18 = 0;
    local_14 = 0;
    local_20 = 0;
    local_c = 0x80000300;
    local_12 = 7;
    /* WARNING: Ignoring partial resolution of indirect */
    local_18._0_1_ = 0x55;
    /* WARNING: Ignoring partial resolution of indirect */
    local_14._0_1_ = 7;
    local_d = 6;
    if (param_1 == 0xff) {
        iVar1 = FUN_000a4484(&local_18, 6, &local_20, 8);
        if (iVar1 != 0) {
            builtin_strncpy(local_1820, "get AD conversion N fail", 0x18);
            local_1808 = 0x6465;
            local_1806 = 0;
            V_LOCK();
            logfmt_raw(auStack_1020, 0x1000, 0, local_1820);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_get_AD_conversion_N", 0x1c, 0x178, 100,
                 auStack_1020);
            return 0x80000300;
        }
    } else {
        iVar1 = FUN_000a47d0(param_1, &local_18, 6, &local_20, 8);
        if (iVar1 != 0) {
            builtin_strncpy(local_1820, "get AD conversion N fail", 0x18);
            local_1808 = 0x6465;
            local_1806 = 0;
            V_LOCK();
            logfmt_raw(auStack_1020, 0x1000, 0, local_1820);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_get_AD_conversion_N", 0x1c, 0x17e, 100,
                 auStack_1020);
            return 0x80000300;
        }
    }
    return (uint)local_20._4_2_;
}

uint FUN_000a53fc(int param_1, byte param_2)

{
    int iVar1;
    char local_1824[24];
    undefined2 local_180c;
    undefined1 local_180a;
    undefined1 auStack_1024[4096];
    undefined8 local_24;
    undefined8 local_1c;
    short local_12;
    undefined1 local_f;
    undefined1 local_e;
    undefined1 local_d;
    undefined4 local_c;

    local_f = 6;
    local_e = 0x83;
    local_1c = 0;
    local_24 = 0;
    local_c = 0x80000300;
    local_12 = param_2 + 0x89;
    /* WARNING: Ignoring partial resolution of indirect */
    local_1c._0_1_ = 0x55;
    local_d = 8;
    if (param_1 == 0xff) {
        iVar1 = FUN_000a4484(&local_1c, 8, &local_24, 8);
        if (iVar1 != 0) {
            builtin_strncpy(local_1824, "set DA conversion N fail", 0x18);
            local_180c = 0x6465;
            local_180a = 0;
            V_LOCK();
            logfmt_raw(auStack_1024, 0x1000, 0, local_1824);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_set_DA_conversion_N", 0x1c, 0x1a4, 100,
                 auStack_1024);
            return 0x80000300;
        }
    } else {
        iVar1 = FUN_000a47d0(param_1, &local_1c, 8, &local_24, 8);
        if (iVar1 != 0) {
            builtin_strncpy(local_1824, "set DA conversion N fail", 0x18);
            local_180c = 0x6465;
            local_180a = 0;
            V_LOCK();
            logfmt_raw(auStack_1024, 0x1000, 0, local_1824);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_set_DA_conversion_N", 0x1c, 0x1aa, 100,
                 auStack_1024);
            return 0x80000300;
        }
    }
    return (uint)local_24._4_2_;
}

undefined4 FUN_000a579c(undefined4 param_1)

{
    undefined4 uVar1;

    uVar1 = FUN_000a4d8c(param_1);
    return uVar1;
}

uint FUN_000a57d4(int param_1)

{
    int iVar1;
    char local_1820[2048];
    undefined1 auStack_1020[4096];
    undefined8 local_20;
    undefined4 local_18;
    undefined2 local_14;
    undefined2 local_12;
    undefined1 local_f;
    undefined1 local_e;
    undefined1 local_d;
    undefined4 local_c;

    local_f = 4;
    local_e = 4;
    local_18 = 0;
    local_14 = 0;
    local_20 = 0;
    local_c = 0x80000300;
    local_12 = 8;
    /* WARNING: Ignoring partial resolution of indirect */
    local_18._0_1_ = 0x55;
    /* WARNING: Ignoring partial resolution of indirect */
    local_14._0_1_ = 8;
    local_d = 6;
    if (param_1 == 0xff) {
        iVar1 = FUN_000a4484(&local_18, 6, &local_20, 8);
        if (iVar1 != 0) {
            builtin_strncpy(local_1820, "get sample N failed", 0x14);
            V_LOCK();
            logfmt_raw(auStack_1020, 0x1000, 0, local_1820);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_get_sample_N", 0x15, 0x1db, 100, auStack_1020);
            return 0x80000300;
        }
    } else {
        iVar1 = FUN_000a47d0(param_1, &local_18, 6, &local_20, 8);
        if (iVar1 != 0) {
            builtin_strncpy(local_1820, "get sample N failed", 0x14);
            V_LOCK();
            logfmt_raw(auStack_1020, 0x1000, 0, local_1820);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_get_sample_N", 0x15, 0x1e1, 100, auStack_1020);
            return 0x80000300;
        }
    }
    return (uint)local_20._4_2_;
}

uint FUN_000a5af0(int param_1, byte param_2)

{
    int iVar1;
    char local_1824[2048];
    undefined1 auStack_1024[4096];
    undefined8 local_24;
    undefined8 local_1c;
    short local_12;
    undefined1 local_f;
    undefined1 local_e;
    undefined1 local_d;
    undefined4 local_c;

    local_f = 6;
    local_e = 0x81;
    local_1c = 0;
    local_24 = 0;
    local_c = 0x80000300;
    local_12 = param_2 + 0x87;
    /* WARNING: Ignoring partial resolution of indirect */
    local_1c._0_1_ = 0x55;
    local_d = 8;
    if (param_1 == 0xff) {
        iVar1 = FUN_000a4484(&local_1c, 8, &local_24, 8);
        if (iVar1 != 0) {
            builtin_strncpy(local_1824, "set watchdog failed", 0x14);
            V_LOCK();
            logfmt_raw(auStack_1024, 0x1000, 0, local_1824);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_set_watchdog", 0x15, 0x200, 100, auStack_1024);
            return 0x80000300;
        }
    } else {
        iVar1 = FUN_000a47d0(param_1, &local_1c, 8, &local_24, 8);
        if (iVar1 != 0) {
            builtin_strncpy(local_1824, "set watchdog failed", 0x14);
            V_LOCK();
            logfmt_raw(auStack_1024, 0x1000, 0, local_1824);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_set_watchdog", 0x15, 0x206, 100, auStack_1024);
            return 0x80000300;
        }
    }
    return (uint)local_24._4_2_;
}

uint FUN_000a5e70(int param_1)

{
    int iVar1;
    char local_1820[2048];
    undefined1 auStack_1020[4096];
    undefined8 local_20;
    undefined4 local_18;
    undefined2 local_14;
    undefined2 local_12;
    undefined1 local_f;
    undefined1 local_e;
    undefined1 local_d;
    undefined4 local_c;

    local_f = 4;
    local_e = 10;
    local_18 = 0;
    local_14 = 0;
    local_20 = 0;
    local_c = 0x80000300;
    local_12 = 0xe;
    /* WARNING: Ignoring partial resolution of indirect */
    local_18._0_1_ = 0x55;
    /* WARNING: Ignoring partial resolution of indirect */
    local_14._0_1_ = 0xe;
    local_d = 6;
    if (param_1 == 0xff) {
        iVar1 = FUN_000a4484(&local_18, 6, &local_20, 8);
        if (iVar1 != 0) {
            builtin_strncpy(local_1820, "get power status failed", 0x18);
            V_LOCK();
            logfmt_raw(auStack_1020, 0x1000, 0, local_1820);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_get_power_status", 0x19, 0x223, 100,
                 auStack_1020);
            return 0x80000300;
        }
    } else {
        iVar1 = FUN_000a47d0(param_1, &local_18, 6, &local_20, 8);
        if (iVar1 != 0) {
            builtin_strncpy(local_1820, "get power status failed", 0x18);
            V_LOCK();
            logfmt_raw(auStack_1020, 0x1000, 0, local_1820);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_get_power_status", 0x19, 0x229, 100,
                 auStack_1020);
            return 0x80000300;
        }
    }
    return (uint)local_20._4_2_;
}

undefined4 FUN_000a618c(int param_1)

{
    undefined4 local_10;

    if (DAT_0015fad8 < 0x78) {
        if ((0x74 < DAT_0015fad8) || (DAT_0015fad8 == 0x71)) {
            local_10 = SUB84((double)(longlong)param_1 * 0.015876, 0);
            return local_10;
        }
        if (DAT_0015fad8 == 0x73) {
        LAB_000a6210:
            local_10 = SUB84((double)(longlong)param_1 * 0.018957, 0);
            return local_10;
        }
    } else {
        if (DAT_0015fad8 == 0x78)
            goto LAB_000a6210;
        if (DAT_0015fad8 - 0xc1 < 2) {
            local_10 = SUB84((double)(longlong)param_1 * 0.003965, 0);
            return local_10;
        }
    }
    return 0;
}

undefined4 bitmain_get_sample_voltage(void)

{
    undefined4 uVar1;
    char local_180c[24];
    undefined2 local_17f4;
    undefined1 local_17f2;
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    if ((DAT_0015fad4 == 0) && (local_c = bitmain_power_open(), local_c < 0)) {
        snprintf(local_180c, 0x800,
                 "%s: auto exec bitmain_power_open, but open power failed",
                 "bitmain_get_sample_voltage");
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/power/"
             "bitmain_power_APW9.c",
             0xb7, "bitmain_get_sample_voltage", 0x1a, 0x250, 100,
             auStack_100c);
        return SUB84((double)(longlong)local_c, 0);
    }
    local_c = FUN_000a57d4(DAT_0015fad0);
    if (local_c < 0) {
        builtin_strncpy(local_180c, "can not get sample volta", 0x18);
        local_17f4 = 0x6567;
        local_17f2 = 0;
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/power/"
             "bitmain_power_APW9.c",
             0xb7, "bitmain_get_sample_voltage", 0x1a, 0x254, 100,
             auStack_100c);
        uVar1 = SUB84((double)(longlong)local_c, 0);
    } else {
        uVar1 = FUN_000a618c(local_c);
    }
    return uVar1;
}

uint FUN_000a6474(int param_1)

{
    int iVar1;
    char local_1828[2048];
    undefined1 auStack_1028[4096];
    undefined4 local_28;
    byte bStack_24;
    byte bStack_23;
    byte bStack_22;
    byte bStack_21;
    undefined6 uStack_20;
    undefined4 local_18;
    undefined2 local_14;
    undefined2 local_12;
    undefined1 local_f;
    undefined1 local_e;
    undefined1 local_d;
    undefined4 local_c;

    local_f = 4;
    local_e = 10;
    local_18 = 0;
    local_14 = 0;
    local_28 = 0;
    bStack_24 = 0;
    bStack_23 = 0;
    bStack_22 = 0;
    bStack_21 = 0;
    uStack_20 = 0;
    local_c = 0x80000300;
    local_12 = 0xe;
    /* WARNING: Ignoring partial resolution of indirect */
    local_18._0_1_ = 0x55;
    /* WARNING: Ignoring partial resolution of indirect */
    local_14._0_1_ = 0xe;
    local_d = 6;
    if (param_1 == 0xff) {
        iVar1 = FUN_000a4484(&local_18, 6, &local_28, 0xe);
        if (iVar1 != 0) {
            builtin_strncpy(local_1828, "get power status failed\n", 0x18);
            local_1828[0x18] = 0;
            V_LOCK();
            logfmt_raw(auStack_1028, 0x1000, 0, local_1828);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_get_power_status_32bits", 0x20, 0x26e, 100,
                 auStack_1028);
            return 0x80000300;
        }
    } else {
        iVar1 = FUN_000a47d0(param_1, &local_18, 6, &local_28, 0xe);
        if (iVar1 != 0) {
            builtin_strncpy(local_1828, "get power status failed\n", 0x18);
            local_1828[0x18] = 0;
            V_LOCK();
            logfmt_raw(auStack_1028, 0x1000, 0, local_1828);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_get_power_status_32bits", 0x20, 0x274, 100,
                 auStack_1028);
            return 0x80000300;
        }
    }
    return (uint)bStack_21 << 0x18 | (uint)bStack_22 << 0x10 |
           (uint)bStack_23 << 8 | (uint)bStack_24;
}

int bitmain_get_power_status(void)

{
    int iVar1;
    char local_180c[24];
    undefined2 local_17f4;
    undefined1 local_17f2;
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    if ((DAT_0015fad4 == 0) && (local_c = bitmain_power_open(), local_c < 0)) {
        snprintf(local_180c, 0x800,
                 "%s: auto exec bitmain_power_open, but open power failed",
                 "bitmain_get_power_status");
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/power/"
             "bitmain_power_APW9.c",
             0xb7, "bitmain_get_power_status", 0x18, 0x282, 100, auStack_100c);
    } else {
        iVar1 = is_power_status_with_64bits();
        if (iVar1 == 0) {
            local_c = FUN_000a5e70(DAT_0015fad0);
        } else {
            local_c = FUN_000a6474(DAT_0015fad0);
        }
        if (local_c == -0x7ffffd00) {
            builtin_strncpy(local_180c, "can nont get power statu", 0x18);
            local_17f4 = 0xa73;
            local_17f2 = 0;
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "bitmain_get_power_status", 0x18, 0x28d, 100,
                 auStack_100c);
        }
    }
    return local_c;
}

int bitmain_set_watchdog(char param_1)

{
    char local_180c[2048];
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    if ((DAT_0015fad4 == 0) && (local_c = bitmain_power_open(), local_c < 0)) {
        snprintf(local_180c, 0x800,
                 "%s: auto exec bitmain_power_open, but open power failed",
                 "bitmain_set_watchdog");
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/power/"
             "bitmain_power_APW9.c",
             0xb7, "bitmain_set_watchdog", 0x14, 0x295, 100, auStack_100c);
    } else {
        if (param_1 == '\x01') {
            local_c = FUN_000a5af0(DAT_0015fad0, 1);
        } else {
            local_c = FUN_000a5af0(DAT_0015fad0, 0);
        }
        if (local_c < 0) {
            builtin_strncpy(local_180c, "can nont set power watchdog", 0x1c);
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "bitmain_set_watchdog", 0x14, 0x2a1, 100, auStack_100c);
        }
    }
    return local_c;
}

int bitmain_power_open(void)

{
    int iVar1;
    char local_1818[44];
    undefined2 local_17ec;
    undefined1 auStack_1018[4096];
    undefined4 local_18;
    undefined2 local_14;
    undefined1 local_12;
    undefined1 local_11;
    undefined4 local_10;
    int local_c;

    local_c = 0;
    local_10 = 0;
    if ((DAT_0015fad0 == 0) || (iVar1 = DAT_0015fad0, DAT_0015fad4 == 0)) {
        local_18 = 0;
        local_14 = 1;
        local_12 = 2;
        local_11 = 0;
        pthread_mutex_lock((pthread_mutex_t *)power_mutex);
        local_c = iic_init(&local_18);
        pthread_mutex_unlock((pthread_mutex_t *)power_mutex);
        iVar1 = local_c;
        if (-1 < local_c) {
            DAT_0015fad0 = local_c;
            DAT_0015fad4 = 1;
            memset(&DAT_0015fae8, 0, 0xc0);
            sleep(2);
            local_c = bitmain_power_version();
            if (local_c < 0) {
                builtin_strncpy(local_1818,
                                "power open power_version < 0 will close powe",
                                0x2c);
                local_17ec = 0x72;
                V_LOCK();
                logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/power/bitmain_power_APW9.c",
                     0xb7, "bitmain_power_open", 0x12, 0x2c2, 0x28,
                     auStack_1018);
                bitmain_power_close();
                iVar1 = local_c;
            } else {
                DAT_0015fad8 = local_c;
                snprintf(local_1818, 0x800, "power open power_version = 0x%x",
                         local_c);
                V_LOCK();
                logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/power/bitmain_power_APW9.c",
                     0xb7, "bitmain_power_open", 0x12, 0x2c7, 0x28,
                     auStack_1018);
                if ((DAT_0015fad8 == 0xc1) || (DAT_0015fad8 == 0xc2)) {
                    local_10 = FUN_000a4a58(DAT_0015fad0);
                    snprintf(local_1818, 0x800, "power fw_version = 0x%x",
                             local_10);
                    V_LOCK();
                    logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/power/bitmain_power_APW9.c",
                         0xb7, "bitmain_power_open", 0x12, 0x2cb, 0x28,
                         auStack_1018);
                    DAT_0015fadc = local_10;
                }
                iVar1 = 0;
            }
        }
    }
    return iVar1;
}

undefined4 bitmain_power_close(void)

{
    char local_1808[2048];
    undefined1 auStack_1008[4096];

    if ((DAT_0015fad0 == 0) || (DAT_0015fad4 == 0)) {
        pthread_mutex_lock((pthread_mutex_t *)power_mutex);
        builtin_strncpy(local_1808, "bitmain power close ===========", 0x20);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/power/"
             "bitmain_power_APW9.c",
             0xb7, "bitmain_power_close", 0x13, 0x2d8, 0x28, auStack_1008);
        iic_uninit(DAT_0015fad0);
        DAT_0015fad4 = 0;
        DAT_0015fad8 = 0;
        memset(&DAT_0015fae8, 0, 0xc0);
        pthread_mutex_unlock((pthread_mutex_t *)power_mutex);
    }
    return 0;
}

int bitmain_power_fw_version(void)

{
    char acStack_180c[2048];
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    if ((DAT_0015fad4 == 0) && (local_c = bitmain_power_open(), local_c < 0)) {
        snprintf(acStack_180c, 0x800,
                 "%s: auto exec bitmain_power_open, but open power failed",
                 "bitmain_power_fw_version");
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/power/"
             "bitmain_power_APW9.c",
             0xb7, "bitmain_power_fw_version", 0x18, 0x2e6, 100, auStack_100c);
        return local_c;
    }
    DAT_0015fadc = FUN_000a4a58(DAT_0015fad0);
    return DAT_0015fadc;
}

int bitmain_power_version(void)

{
    char acStack_180c[2048];
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    if ((DAT_0015fad4 == 0) && (local_c = bitmain_power_open(), local_c < 0)) {
        snprintf(acStack_180c, 0x800,
                 "%s: auto exec bitmain_power_open, but open power failed",
                 "bitmain_power_version");
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/power/"
             "bitmain_power_APW9.c",
             0xb7, "bitmain_power_version", 0x15, 0x2f1, 100, auStack_100c);
    } else {
        local_c = FUN_000a579c(DAT_0015fad0);
        if (0 < local_c) {
            DAT_0015fad8 = local_c;
        }
    }
    return local_c;
}

undefined4 bitmain_get_voltage(void)

{
    undefined4 uVar1;
    char local_180c[2048];
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    if ((DAT_0015fad4 == 0) && (local_c = bitmain_power_open(), local_c < 0)) {
        snprintf(local_180c, 0x800,
                 "%s: auto exec bitmain_power_open, but open power failed",
                 "bitmain_get_voltage");
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/power/"
             "bitmain_power_APW9.c",
             0xb7, "bitmain_get_voltage", 0x13, 0x2fc, 100, auStack_100c);
        return SUB84((double)(longlong)local_c, 0);
    }
    local_c = FUN_000a50c0(DAT_0015fad0);
    if (local_c < 0) {
        builtin_strncpy(local_180c, "can nont get voltage", 0x14);
        local_180c[0x14] = 0;
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/power/"
             "bitmain_power_APW9.c",
             0xb7, "bitmain_get_voltage", 0x13, 0x300, 100, auStack_100c);
        uVar1 = SUB84((double)(longlong)local_c, 0);
    } else {
        uVar1 = bitmain_convert_N_to_V(local_c);
    }
    return uVar1;
}

int bitmain_set_voltage(undefined4 param_1)

{
    int iVar1;
    char acStack_1810[2048];
    undefined1 auStack_1010[4096];
    int local_10;
    uint local_c;

    local_10 = 0;
    local_c = 0;
    if ((DAT_0015fad4 == 0) &&
        (local_10 = bitmain_power_open(), local_10 < 0)) {
        snprintf(acStack_1810, 0x800,
                 "%s: auto exec bitmain_power_open, but open power failed",
                 "bitmain_set_voltage");
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, acStack_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/power/"
             "bitmain_power_APW9.c",
             0xb7, "bitmain_set_voltage", 0x13, 0x30c, 100, auStack_1010);
        return local_10;
    }
    local_c = bitmain_convert_V_to_N(param_1);
    if (((int)local_c < 0) || (0xff < (int)local_c)) {
        iVar1 = -0x7ffffcff;
    } else {
        iVar1 = FUN_000a53fc(DAT_0015fad0, local_c & 0xff);
    }
    return iVar1;
}

int bitmain_set_voltage_by_n(undefined1 param_1)

{
    int iVar1;
    char acStack_180c[2048];
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    if ((DAT_0015fad4 == 0) && (local_c = bitmain_power_open(), local_c < 0)) {
        snprintf(acStack_180c, 0x800,
                 "%s: auto exec bitmain_power_open, but open power failed",
                 "bitmain_set_voltage_by_n");
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/power/"
             "bitmain_power_APW9.c",
             0xb7, "bitmain_set_voltage_by_n", 0x18, 0x319, 100, auStack_100c);
        return local_c;
    }
    iVar1 = FUN_000a53fc(DAT_0015fad0, param_1);
    return iVar1;
}

undefined4 bitmain_convert_N_to_V_calibration(int param_1)

{
    int local_14;
    double local_10;

    local_10 = 0.0;
    if (DAT_0015fafc < 2) {
        local_10._0_4_ = 0;
    } else {
        for (local_14 = 0; local_14 < DAT_0015fafc + -1;
             local_14 = local_14 + 1) {
            if ((((int)(uint)(byte)(&DAT_0015fb00)[local_14] <= param_1) &&
                 (param_1 < (int)(uint)(byte)(&DAT_0015fb01)[local_14])) ||
                ((param_1 < (int)(uint)(byte)(&DAT_0015fb00)[local_14] &&
                  ((int)(uint)(byte)(&DAT_0015fb01)[local_14] <= param_1)))) {
                local_10 =
                    (double)(longlong)(int)(param_1 -
                                            (uint)(byte)(&DAT_0015fb00)
                                                [local_14]) *
                        ((*(double *)(&DAT_0015fae8 + (local_14 + 0xe) * 2) -
                          *(double *)(&DAT_0015fae8 + (local_14 + 0xd) * 2)) /
                         (double)(longlong)(int)((uint)(byte)(&DAT_0015fb01)
                                                     [local_14] -
                                                 (uint)(byte)(&DAT_0015fb00)
                                                     [local_14])) +
                    *(double *)(&DAT_0015fae8 + (local_14 + 0xd) * 2);
            }
        }
    }
    return local_10._0_4_;
}

int FUN_000a7928(void)

{
    double in_d0;
    double dVar1;
    int iVar2;
    int local_c;

    if (1 < DAT_0015fafc) {
        for (local_c = 0; local_c < DAT_0015fafc + -1; local_c = local_c + 1) {
            if (((*(double *)(&DAT_0015fae8 + (local_c + 0xd) * 2) - 0.001 <
                  in_d0) &&
                 (in_d0 <
                  *(double *)(&DAT_0015fae8 + (local_c + 0xe) * 2) + 0.001)) ||
                ((in_d0 < *(double *)(&DAT_0015fae8 + (local_c + 0xd) * 2) +
                              0.001 &&
                  (*(double *)(&DAT_0015fae8 + (local_c + 0xe) * 2) - 0.001 <
                   in_d0)))) {
                dVar1 = round(
                    (in_d0 - *(double *)(&DAT_0015fae8 + (local_c + 0xd) * 2)) *
                        ((double)(longlong)(int)((uint)(byte)(&DAT_0015fb01)
                                                     [local_c] -
                                                 (uint)(byte)(&DAT_0015fb00)
                                                     [local_c]) /
                         (*(double *)(&DAT_0015fae8 + (local_c + 0xe) * 2) -
                          *(double *)(&DAT_0015fae8 + (local_c + 0xd) * 2))) +
                    (double)(byte)(&DAT_0015fb00)[local_c]);
                iVar2 = (int)(longlong)dVar1;
                if ((-1 < iVar2) && (iVar2 < 0x100)) {
                    return iVar2;
                }
                return -1;
            }
        }
    }
    return -1;
}

undefined4 bitmain_convert_V_to_N(void)

{
    double in_d0;
    undefined4 local_c;

    switch (DAT_0015fad8) {
    case 0x22:
        local_c = (undefined4)(longlong)(1215.89444 - in_d0 * 59.931507);
        break;
    default:
        local_c = 0xffffffff;
        break;
    case 0x41:
        local_c = (undefined4)(longlong)(765.411764 - in_d0 * 35.833333);
        break;
    case 0x42:
        local_c = (undefined4)(longlong)(765.411764 - in_d0 * 35.833333);
        break;
    case 0x43:
        local_c = (undefined4)(longlong)(933.240365 - in_d0 * 59.806034);
        break;
    case 0x61:
        local_c = (undefined4)(longlong)(1144.502262 - in_d0 * 52.243589);
        break;
    case 0x62:
    case 100:
    case 0x65:
    case 0x66:
        local_c = (undefined4)(longlong)(0.0 - in_d0);
        break;
    case 0x6a:
        local_c = (undefined4)(longlong)(1133.0 - in_d0 * 70.83);
        break;
    case 0x71:
    case 0x75:
        local_c = (undefined4)(longlong)(1190.935338 - in_d0 * 78.742588);
        break;
    case 0x72:
    case 0x77:
        local_c = (undefined4)(longlong)(1190.935338 - in_d0 * 78.742588);
        break;
    case 0x73:
    case 0x78:
        local_c = (undefined4)(longlong)(1280.577821 - in_d0 * 73.979365);
        break;
    case 0x74:
    case 0x76:
        local_c = (undefined4)(longlong)(1156.107585 - in_d0 * 76.090494);
        break;
    case 0xc1:
    case 0xc2:
        if ((DAT_0015fadc == 0x80000300) || ((DAT_0015fadc & 0xff) < 4)) {
            local_c = (undefined4)(longlong)(1275.0 - in_d0 * 85.0);
        } else {
            local_c = (undefined4)(longlong)(1083.75 - in_d0 * 70.83333333333);
        }
    }
    return local_c;
}

undefined4 bitmain_convert_N_to_V(int param_1)

{
    undefined4 extraout_s1;
    undefined4 local_10;

    local_10 = bitmain_convert_N_to_V_calibration(0xffffffff);
    if ((double)CONCAT44(extraout_s1, local_10) <= 0.0) {
        switch (DAT_0015fad8) {
        case 0x41:
            local_10 =
                SUB84((765.411764 - (double)(longlong)param_1) / 35.833333, 0);
            break;
        case 0x42:
            local_10 =
                SUB84((765.411764 - (double)(longlong)param_1) / 35.833333, 0);
            break;
        case 0x43:
            local_10 =
                SUB84((933.240365 - (double)(longlong)param_1) / 59.806034, 0);
            break;
        default:
            local_10 = 0;
            break;
        case 0x61:
            local_10 =
                SUB84((1144.502262 - (double)(longlong)param_1) / 52.243589, 0);
            break;
        case 0x71:
        case 0x75:
            local_10 =
                SUB84((1190.935338 - (double)(longlong)param_1) / 78.742588, 0);
            break;
        case 0x72:
            local_10 =
                SUB84((1190.935338 - (double)(longlong)param_1) / 78.742588, 0);
            break;
        case 0x73:
        case 0x78:
            local_10 =
                SUB84((1280.577821 - (double)(longlong)param_1) / 73.979365, 0);
            break;
        case 0x74:
        case 0x76:
            local_10 =
                SUB84((1156.107585 - (double)(longlong)param_1) / 76.090494, 0);
        }
    }
    return local_10;
}

int bitmain_power_read(byte param_1, int param_2, byte param_3)

{
    int iVar1;
    char local_1854[24];
    undefined2 local_183c;
    undefined1 local_183a;
    undefined1 auStack_1054[4096];
    byte local_54[52];
    undefined8 local_20;
    int local_18;
    undefined1 local_12;
    undefined1 local_11;
    int local_10;
    short local_c;
    byte local_9;

    local_18 = 0;
    local_12 = 6;
    local_11 = 6;
    local_20 = 0;
    local_54[0] = 0;
    local_54[1] = 0;
    local_54[2] = 0;
    local_54[3] = 0;
    local_54[4] = 0;
    local_54[5] = 0;
    local_54[6] = 0;
    local_54[7] = 0;
    local_54[8] = 0;
    local_54[9] = 0;
    local_54[10] = 0;
    local_54[0xb] = 0;
    local_54[0xc] = 0;
    local_54[0xd] = 0;
    local_54[0xe] = 0;
    local_54[0xf] = 0;
    local_54[0x10] = 0;
    local_54[0x11] = 0;
    local_54[0x12] = 0;
    local_54[0x13] = 0;
    local_54[0x14] = 0;
    local_54[0x15] = 0;
    local_54[0x16] = 0;
    local_54[0x17] = 0;
    local_54[0x18] = 0;
    local_54[0x19] = 0;
    local_54[0x1a] = 0;
    local_54[0x1b] = 0;
    local_54[0x1c] = 0;
    local_54[0x1d] = 0;
    local_54[0x1e] = 0;
    local_54[0x1f] = 0;
    local_54[0x20] = 0;
    local_54[0x21] = 0;
    local_54[0x22] = 0;
    local_54[0x23] = 0;
    local_54[0x24] = 0;
    local_54[0x25] = 0;
    local_54[0x26] = 0;
    local_54[0x27] = 0;
    local_54[0x28] = 0;
    local_54[0x29] = 0;
    local_54[0x2a] = 0;
    local_54[0x2b] = 0;
    local_54[0x2c] = 0;
    local_54[0x2d] = 0;
    local_54[0x2e] = 0;
    local_54[0x2f] = 0;
    local_54[0x30] = 0;
    local_54[0x31] = 0;
    local_10 = 5;
    local_c = param_1 + 0xc + (ushort)param_3;
    /* WARNING: Ignoring partial resolution of indirect */
    local_20._0_1_ = 0x55;
    local_9 = 8;
    if ((DAT_0015fad4 == 0) &&
        (local_18 = bitmain_power_open(), local_18 < 0)) {
        snprintf(local_1854, 0x800,
                 "%s: auto exec bitmain_power_open, but open power failed",
                 "bitmain_power_read");
        V_LOCK();
        logfmt_raw(auStack_1054, 0x1000, 0, local_1854);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/power/"
             "bitmain_power_APW9.c",
             0xb7, "bitmain_power_read", 0x12, 0x3d0, 100, auStack_1054);
    } else {
        if (DAT_0015fad0 == 0xff) {
            iVar1 = FUN_000a4484(&local_20, 8, local_54, 0x32);
            if (iVar1 != 0) {
                builtin_strncpy(local_1854, "get power version failed", 0x18);
                local_183c = (ushort)local_183c._1_1_ << 8;
                V_LOCK();
                logfmt_raw(auStack_1054, 0x1000, 0, local_1854);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/power/bitmain_power_APW9.c",
                     0xb7, "bitmain_power_read", 0x12, 0x3d4, 100,
                     auStack_1054);
                return -0x7ffffd00;
            }
        } else {
            iVar1 =
                FUN_000a47d0(DAT_0015fad0, &local_20, 8, local_54, param_3 + 7);
            if (iVar1 != 0) {
                builtin_strncpy(local_1854, "set DA conversion N fail", 0x18);
                local_183c = 0x6465;
                local_183a = 0;
                V_LOCK();
                logfmt_raw(auStack_1054, 0x1000, 0, local_1854);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/power/bitmain_power_APW9.c",
                     0xb7, "bitmain_power_read", 0x12, 0x3da, 100,
                     auStack_1054);
                return -0x7ffffd00;
            }
        }
        for (local_9 = 0; (uint)local_9 < param_3 + 7; local_9 = local_9 + 1) {
            snprintf(local_1854, 0x800, "read_back_data[%d]: %02X",
                     (uint)local_9, (uint)local_54[local_9]);
            V_LOCK();
            logfmt_raw(auStack_1054, 0x1000, 0, local_1854);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "bitmain_power_read", 0x12, 0x3e2, 100, auStack_1054);
        }
        for (local_9 = 0; iVar1 = local_10, local_9 < param_3;
             local_9 = local_9 + 1) {
            local_10 = local_10 + 1;
            *(byte *)(param_2 + (uint)local_9) = local_54[iVar1];
            snprintf(local_1854, 0x800, "buf[%d]: %02X", (uint)local_9,
                     (uint) * (byte *)(param_2 + (uint)local_9));
            V_LOCK();
            logfmt_raw(auStack_1054, 0x1000, 0, local_1854);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "bitmain_power_read", 0x12, 999, 100, auStack_1054);
        }
    }
    return local_18;
}

undefined4 is_power_protocal_v2(void)

{
    undefined4 uVar1;

    if ((((DAT_0015fad8 == 0x62) || (DAT_0015fad8 == 100)) ||
         (DAT_0015fad8 == 0x65)) ||
        (DAT_0015fad8 == 0x66)) {
        uVar1 = 1;
    } else {
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 FUN_000a8b08(int param_1, uint param_2, undefined4 param_3,
                        undefined4 param_4, uint param_5)

{
    int extraout_r2;
    undefined4 uVar1;
    longlong lVar2;
    undefined4 local_68;
    undefined4 uStack_64;
    uint local_60;
    char acStack_56[70];
    uint local_10;
    uint local_c;

    lVar2 = CONCAT44(param_4, param_3);
    acStack_56[2] = '\0';
    acStack_56[3] = '\0';
    acStack_56[4] = '\0';
    acStack_56[5] = '\0';
    acStack_56[6] = '\0';
    acStack_56[7] = '\0';
    acStack_56[8] = '\0';
    acStack_56[9] = '\0';
    acStack_56[10] = '\0';
    acStack_56[0xb] = '\0';
    acStack_56[0xc] = '\0';
    acStack_56[0xd] = '\0';
    acStack_56[0xe] = '\0';
    acStack_56[0xf] = '\0';
    acStack_56[0x10] = '\0';
    acStack_56[0x11] = '\0';
    acStack_56[0x12] = '\0';
    acStack_56[0x13] = '\0';
    acStack_56[0x14] = '\0';
    acStack_56[0x15] = '\0';
    acStack_56[0x16] = '\0';
    acStack_56[0x17] = '\0';
    acStack_56[0x18] = '\0';
    acStack_56[0x19] = '\0';
    acStack_56[0x1a] = '\0';
    acStack_56[0x1b] = '\0';
    acStack_56[0x1c] = '\0';
    acStack_56[0x1d] = '\0';
    acStack_56[0x1e] = '\0';
    acStack_56[0x1f] = '\0';
    acStack_56[0x20] = '\0';
    acStack_56[0x21] = '\0';
    acStack_56[0x22] = '\0';
    acStack_56[0x23] = '\0';
    acStack_56[0x24] = '\0';
    acStack_56[0x25] = '\0';
    acStack_56[0x26] = '\0';
    acStack_56[0x27] = '\0';
    acStack_56[0x28] = '\0';
    acStack_56[0x29] = '\0';
    acStack_56[0x2a] = '\0';
    acStack_56[0x2b] = '\0';
    acStack_56[0x2c] = '\0';
    acStack_56[0x2d] = '\0';
    acStack_56[0x2e] = '\0';
    acStack_56[0x2f] = '\0';
    acStack_56[0x30] = '\0';
    acStack_56[0x31] = '\0';
    acStack_56[0x32] = '\0';
    acStack_56[0x33] = '\0';
    acStack_56[0x34] = '\0';
    acStack_56[0x35] = '\0';
    acStack_56[0x36] = '\0';
    acStack_56[0x37] = '\0';
    acStack_56[0x38] = '\0';
    acStack_56[0x39] = '\0';
    acStack_56[0x3a] = '\0';
    acStack_56[0x3b] = '\0';
    acStack_56[0x3c] = '\0';
    acStack_56[0x3d] = '\0';
    acStack_56[0x3e] = '\0';
    acStack_56[0x3f] = '\0';
    acStack_56[0x40] = '\0';
    acStack_56[0x41] = '\0';
    acStack_56[0x42] = '\0';
    if ((((int)param_5 < 2) || (0x24 < param_5)) || (param_2 == 0)) {
        uVar1 = 0;
    } else {
        local_60 = param_2;
        if (0x41 < param_2) {
            local_60 = 0x41;
        }
        for (local_c = 0; uStack_64 = (undefined4)((ulonglong)lVar2 >> 0x20),
            local_68 = (undefined4)lVar2, local_c < local_60 - 1;
             local_c = local_c + 1) {
            FUN_000ccdfc(local_68, uStack_64, param_5, (int)param_5 >> 0x1f);
            acStack_56[local_c + 2] =
                "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_bitmain_get_miner_power"
                    [extraout_r2];
            lVar2 = FUN_000ccdfc(local_68, uStack_64, param_5,
                                 (int)param_5 >> 0x1f);
        }
        if (lVar2 == 0) {
            for (local_10 = 0; local_10 < local_60 - 1;
                 local_10 = local_10 + 1) {
                *(char *)(param_1 + local_10) = acStack_56[local_60 - local_10];
            }
            *(undefined1 *)(param_1 + (local_60 - 1)) = 0;
            uVar1 = 1;
        } else {
            uVar1 = 0;
        }
    }
    return uVar1;
}

uint FUN_000a8cc4(int param_1)

{
    int iVar1;
    char local_1820[2048];
    undefined1 auStack_1020[4096];
    undefined8 local_20;
    undefined4 local_18;
    undefined2 local_14;
    undefined2 local_12;
    undefined1 local_f;
    undefined1 local_e;
    undefined1 local_d;
    undefined4 local_c;

    local_f = 4;
    local_e = 8;
    local_18 = 0;
    local_14 = 0;
    local_20 = 0;
    local_c = 0x80000300;
    local_12 = 0xc;
    /* WARNING: Ignoring partial resolution of indirect */
    local_18._0_1_ = 0x55;
    /* WARNING: Ignoring partial resolution of indirect */
    local_14._0_1_ = 0xc;
    local_d = 6;
    if (param_1 == 0xff) {
        iVar1 = FUN_000a4484(&local_18, 6, &local_20, 8);
        if (iVar1 != 0) {
            builtin_strncpy(local_1820, "get power status failed\n", 0x18);
            local_1820[0x18] = 0;
            V_LOCK();
            logfmt_raw(auStack_1020, 0x1000, 0, local_1820);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_get_miner_power", 0x18, 0x426, 100,
                 auStack_1020);
            return 0x80000300;
        }
    } else {
        iVar1 = FUN_000a47d0(param_1, &local_18, 6, &local_20, 8);
        if (iVar1 != 0) {
            builtin_strncpy(local_1820, "get power status failed\n", 0x18);
            local_1820[0x18] = 0;
            V_LOCK();
            logfmt_raw(auStack_1020, 0x1000, 0, local_1820);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "_bitmain_get_miner_power", 0x18, 0x42c, 100,
                 auStack_1020);
            return 0x80000300;
        }
    }
    return (uint)local_20._4_2_;
}

undefined4 FUN_000a8fe8(void)

{
    undefined4 uVar1;

    if ((DAT_0015fad8 == 0xc1) || (DAT_0015fad8 == 0xc2)) {
        uVar1 = 1;
    } else {
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 FUN_000a9034(int param_1, int param_2)

{
    undefined4 uVar1;
    double dVar2;
    undefined4 local_c;

    if ((param_2 < 2) || (0x100 < param_2)) {
        uVar1 = 0;
    } else {
        for (local_c = 0; local_c < param_2; local_c = local_c + 1) {
            dVar2 = round((double)(longlong)local_c *
                          (255.0 / (double)(longlong)(param_2 + -1)));
            *(char *)(param_1 + local_c) =
                (0.0 < dVar2) * (char)(longlong)dVar2;
        }
        uVar1 = 1;
    }
    return uVar1;
}

undefined4 FUN_000a9108(int param_1)

{
    undefined4 local_10;

    switch (DAT_0015fad8) {
    case 0x22:
        local_10 =
            SUB84((1215.89444 - (double)(longlong)param_1) / 59.931507, 0);
        break;
    default:
        local_10 = 0;
        break;
    case 0x41:
        local_10 =
            SUB84((765.411764 - (double)(longlong)param_1) / 35.833333, 0);
        break;
    case 0x42:
        local_10 =
            SUB84((765.411764 - (double)(longlong)param_1) / 35.833333, 0);
        break;
    case 0x43:
        local_10 =
            SUB84((933.240365 - (double)(longlong)param_1) / 59.806034, 0);
        break;
    case 0x61:
        local_10 =
            SUB84((1144.502262 - (double)(longlong)param_1) / 52.243589, 0);
        break;
    case 0x62:
    case 100:
    case 0x65:
    case 0x66:
        local_10 = SUB84((double)(longlong)-param_1, 0);
        break;
    case 0x71:
    case 0x75:
        local_10 =
            SUB84((1190.935338 - (double)(longlong)param_1) / 78.742588, 0);
        break;
    case 0x72:
    case 0x77:
        local_10 =
            SUB84((1190.935338 - (double)(longlong)param_1) / 78.742588, 0);
        break;
    case 0x73:
    case 0x78:
        local_10 =
            SUB84((1280.577821 - (double)(longlong)param_1) / 73.979365, 0);
        break;
    case 0x74:
    case 0x76:
        local_10 =
            SUB84((1156.107585 - (double)(longlong)param_1) / 76.090494, 0);
        break;
    case 0xc1:
        if ((DAT_0015fadc == 0x80000300) || ((DAT_0015fadc & 0xff) < 4)) {
            local_10 = SUB84((double)(longlong)(0x4fb - param_1) / 85.0, 0);
        } else {
            local_10 = SUB84(
                (1083.75 - (double)(longlong)param_1) / 70.83333333333, 0);
        }
    }
    return local_10;
}

undefined1 FUN_000a9658(ushort param_1)

{
    uint uVar1;

    uVar1 = (uint)param_1;
    if (uVar1 != 0x6a) {
        if (0x6a < uVar1) {
            if (0x78 < uVar1) {
                if (1 < uVar1 - 0xc1) {
                    return 0xff;
                }
                return 0;
            }
            if (((uVar1 < 0x75) && (uVar1 != 0x71)) && (uVar1 != 0x73)) {
                return 0xff;
            }
            return 0x40;
        }
        if (uVar1 != 0x62) {
            if (uVar1 < 99) {
                if (uVar1 != 0x1a) {
                    if (uVar1 != 0x41) {
                        return 0xff;
                    }
                    return 0x40;
                }
            } else if (2 < uVar1 - 100) {
                return 0xff;
            }
        }
    }
    return 0;
}

/* WARNING: Restarted to delay deadcode elimination for space: ram */

undefined4 get_power_voltage_calibration_data(void)

{
    char cVar1;
    int iVar2;
    undefined4 uVar3;
    uint uVar4;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;
    char local_18a8[2048];
    undefined1 auStack_10a8[4096];
    undefined4 local_a8;
    undefined4 local_a4;
    undefined2 uStack_a0;
    undefined2 uStack_9e;
    undefined4 uStack_9c;
    undefined2 local_98;
    undefined4 local_94;
    undefined8 local_90;
    byte local_74[8];
    undefined4 local_6c;
    byte local_68;
    byte local_67;
    char acStack_66[14];
    byte local_58;
    byte local_57;
    byte local_56;
    byte local_55;
    undefined4 *local_54;
    char *local_50;
    int local_4c;
    int local_48;
    uint local_44;
    ushort local_3e;
    undefined4 local_3c;
    undefined4 local_38;
    uint uStack_34;
    byte local_29;
    short local_28;
    short local_26;
    int local_24;
    int local_20;
    uint local_1c;
    uint local_18;
    char local_11;

    local_11 = FUN_000a9658(DAT_0015fad8 & 0xffff);
    if (local_11 == -1) {
        uVar3 = 0xffffffff;
    } else {
        iVar2 = is_power_protocal_v2();
        if (iVar2 == 0) {
            iVar2 = bitmain_power_read(local_11, local_74, 0x20);
            if (iVar2 == 0) {
                builtin_strncpy(local_18a8, "power calibration data:", 0x18);
                V_LOCK();
                logfmt_raw(auStack_10a8, 0x1000, 0, local_18a8);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/power/bitmain_power_APW9.c",
                     0xb7, "get_power_voltage_calibration_data", 0x22, 0x4c5,
                     100, auStack_10a8);
                for (local_24 = 0; local_24 < 0x20; local_24 = local_24 + 4) {
                    snprintf(local_18a8, 0x800, "%2X %2X %2X %2X  ",
                             (uint)local_74[local_24],
                             (uint)local_74[local_24 + 1],
                             (uint)local_74[local_24 + 2],
                             (uint)local_74[local_24 + 3]);
                    V_LOCK();
                    logfmt_raw(auStack_10a8, 0x1000, 0, local_18a8);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/power/bitmain_power_APW9.c",
                         0xb7, "get_power_voltage_calibration_data", 0x22,
                         0x4c7, 100, auStack_10a8);
                }
                local_26 = (ushort)local_56 * 0x100 + (ushort)local_55;
                local_28 = POWER_CRC16(local_74, 0x1e);
                if (local_26 == local_28) {
                    local_29 = local_74[0];
                    memcpy(&local_90, local_74, 8);
                    local_94 = local_6c;
                    local_90 =
                        FUN_000a3fb0((undefined4)local_90, local_90._4_4_);
                    local_94 = FUN_000a3f88(local_94);
                    uStack_34 = local_90._4_4_ & 0x1ffffff;
                    local_38 = (undefined4)local_90;
                    local_a8 = 0;
                    local_a4 = 0;
                    uStack_a0 = 0;
                    uStack_9e = 0;
                    uStack_9c = 0;
                    local_98 = 0;
                    local_3c = local_94;
                    FUN_000a8b08(&local_a8, 0xc, (undefined4)local_90,
                                 uStack_34, 0x24);
                    FUN_000a8b08((int)&uStack_9e + 1, 7, local_3c, 0, 0x24);
                    DAT_0015faf0 = CONCAT22(uStack_9e, uStack_a0);
                    DAT_0015fae8 = local_a8;
                    DAT_0015faec = local_a4;
                    DAT_0015faf4 = uStack_9c;
                    DAT_0015faf8 = local_98;
                    local_3e = (ushort)local_58 * 0x100 + (ushort)local_57;
                    local_44 = local_3e / 0x174;
                    uVar4 = local_3e / 0x1f;
                    local_48 =
                        ((local_3e - uVar4 >> 1) + uVar4 >> 4 & 0xffff) % 0xc +
                        1;
                    uVar4 = (uint)local_3e;
                    local_4c =
                        (uVar4 +
                             ((uVar4 - uVar4 / 0x1f >> 1) + uVar4 / 0x1f >> 4) *
                                 -0x1f &
                         0xffff) +
                        1;
                    DAT_0015fba0 = local_44 * 10000 + local_48 * 100 + local_4c;
                    local_50 = acStack_66;
                    local_20 = (int)(short)((ushort)local_68 * 0x100 +
                                            (ushort)local_67);
                    for (local_1c = 0;
                         (local_1c < 0xe && (local_50[local_1c] != -0x80));
                         local_1c = local_1c + 1) {
                    }
                    local_54 = &DAT_0015fae8;
                    DAT_0015fafc = local_1c + 1;
                    cVar1 = FUN_000a9034(&DAT_0015fb00, DAT_0015fafc);
                    if (cVar1 == '\x01') {
                        uVar3 = FUN_000a9108(*(undefined1 *)(local_54 + 6));
                        *(double *)(local_54 + 0x1a) =
                            (double)CONCAT44(extraout_s1, uVar3) +
                            (double)(longlong)local_20 / 1000.0;
                        for (local_18 = 0; local_18 < local_1c;
                             local_18 = local_18 + 1) {
                            local_20 = local_20 + local_50[local_18];
                            uVar3 = FUN_000a9108(*(
                                undefined1 *)((int)local_54 + local_18 + 0x19));
                            *(double *)(local_54 + (local_18 + 0xe) * 2) =
                                (double)CONCAT44(extraout_s1_00, uVar3) +
                                (double)(longlong)local_20 / 1000.0;
                        }
                        uVar3 = 0;
                    } else {
                        uVar3 = 0xffffffff;
                    }
                } else {
                    builtin_strncpy(local_18a8, "calibration data crc err",
                                    0x18);
                    local_18a8[0x18] = 0;
                    V_LOCK();
                    logfmt_raw(auStack_10a8, 0x1000, 0, local_18a8);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/power/bitmain_power_APW9.c",
                         0xb7, "get_power_voltage_calibration_data", 0x22,
                         0x4d0, 100, auStack_10a8);
                    uVar3 = 0xffffffff;
                }
            } else {
                uVar3 = 0xffffffff;
            }
        } else {
            V_LOCK();
            logfmt_raw(auStack_10a8, 0x1000, 0,
                       "%s power protocal not support!",
                       "get_power_voltage_calibration_data");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "get_power_voltage_calibration_data", 0x22, 0x4ba, 100,
                 auStack_10a8);
            uVar3 = 0xffffffff;
        }
    }
    return uVar3;
}

int bitmain_get_miner_power(void)

{
    char cVar1;
    int iVar2;
    char acStack_180c[2048];
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    if ((DAT_0015fad4 == 0) && (local_c = bitmain_power_open(), local_c < 0)) {
        snprintf(acStack_180c, 0x800,
                 "%s: auto exec bitmain_power_open, but open power failed",
                 "bitmain_get_miner_power");
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/power/"
             "bitmain_power_APW9.c",
             0xb7, "bitmain_get_miner_power", 0x17, 0x509, 100, auStack_100c);
    } else {
        iVar2 = is_power_protocal_v2();
        if (iVar2 == 0) {
            cVar1 = FUN_000a8fe8();
            if (cVar1 == '\x01') {
                local_c = FUN_000a8cc4(DAT_0015fad0);
                if (local_c == -0x7ffffd00) {
                    snprintf(acStack_180c, 0x800,
                             "can nont get power ret = 0x%x\n", 0x80000300);
                    V_LOCK();
                    logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/power/bitmain_power_APW9.c",
                         0xb7, "bitmain_get_miner_power", 0x17, 0x514, 100,
                         auStack_100c);
                    local_c = -1;
                }
            } else {
                local_c = -1;
            }
        } else {
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0,
                       "%s power protocal not support!",
                       "bitmain_get_miner_power");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/power/bitmain_power_APW9.c",
                 0xb7, "bitmain_get_miner_power", 0x17, 0x50b, 100,
                 auStack_100c);
            local_c = -1;
        }
    }
    return local_c;
}

int tsensor_open(uint param_1, int param_2, byte param_3)

{
    int iVar1;
    char acStack_181c[2048];
    undefined1 auStack_101c[4096];
    uint local_1c;
    undefined2 local_18;
    byte local_16;
    byte local_15;
    int local_14;
    byte local_d;
    uint local_c;

    local_14 = -0x7ffff9ff;
    if (param_1 < 0x10) {
        if (param_3 < 8) {
            for (local_d = 0; local_d < param_3; local_d = local_d + 1) {
                local_c = FUN_000ab0ec(
                    param_1, *(undefined1 *)(param_2 + (uint)local_d));
                if (local_c == 0x80000600) {
                    local_18 = 0;
                    local_16 =
                        (byte)(*(byte *)(param_2 + (uint)local_d) + param_1 >>
                               3) &
                        0xf;
                    local_15 =
                        *(char *)(param_2 + (uint)local_d) + (char)param_1 & 7;
                    local_1c = param_1;
                    local_14 = iic_init(&local_1c);
                    if (local_14 < 0) {
                        snprintf(acStack_181c, 0x800,
                                 " open T-sensor error, chain is %d,slave addr "
                                 "is %d",
                                 param_1,
                                 (uint) * (byte *)(param_2 + (uint)local_d));
                        V_LOCK();
                        logfmt_raw(auStack_101c, 0x1000, 0, acStack_181c);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/device/"
                             "hal/tsensor/bitmain_tsensor.c",
                             0xb6, "tsensor_open", 0xc, 0x4b, 100,
                             auStack_101c);
                        return local_14;
                    }
                    local_c = (uint)(byte)(&DAT_0015fbac)[param_1 * 0x44];
                    (&DAT_0015fbac)[param_1 * 0x44] =
                        (&DAT_0015fbac)[param_1 * 0x44] + 1;
                    (&DAT_0015fbb0)[local_c * 8 + param_1 * 0x44] =
                        *(undefined1 *)(param_2 + (uint)local_d);
                    *(int *)(&DAT_0015fbb4 + local_c * 8 + param_1 * 0x44) =
                        local_14;
                }
            }
            iVar1 = 0;
        } else {
            snprintf(acStack_181c, 0x800,
                     " Bad T-sensor param, input num is %d", (uint)param_3);
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0, acStack_181c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/tsensor/bitmain_tsensor.c",
                 0xb6, "tsensor_open", 0xc, 0x38, 100, auStack_101c);
            iVar1 = -0x7ffff9ff;
        }
    } else {
        snprintf(acStack_181c, 0x800, " Bad T-sensor param, input chain is %d",
                 param_1);
        V_LOCK();
        logfmt_raw(auStack_101c, 0x1000, 0, acStack_181c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/tsensor/"
             "bitmain_tsensor.c",
             0xb6, "tsensor_open", 0xc, 0x37, 100, auStack_101c);
        iVar1 = -0x7ffff9ff;
    }
    return iVar1;
}

undefined4 tsensor_close(uint param_1)

{
    undefined4 uVar1;
    undefined4 extraout_r3;
    char acStack_180c[2048];
    undefined1 auStack_100c[4099];
    byte local_9;

    if (param_1 < 0x10) {
        for (local_9 = 0; local_9 < (byte)(&DAT_0015fbac)[param_1 * 0x44];
             local_9 = local_9 + 1) {
            if (*(int *)(&DAT_0015fbb4 + (uint)local_9 * 8 + param_1 * 0x44) !=
                0) {
                iic_uninit(*(undefined4 *)(&DAT_0015fbb4 + (uint)local_9 * 8 +
                                           param_1 * 0x44));
            }
        }
        memset(&DAT_0015fbac + param_1 * 0x44, 0, 0x44);
        uVar1 = extraout_r3;
    } else {
        snprintf(acStack_180c, 0x800, " Bad T-sensor param, input chain is %d",
                 param_1);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/tsensor/"
             "bitmain_tsensor.c",
             0xb6, "tsensor_close", 0xd, 0x5b, 100, auStack_100c);
        uVar1 = 0x80000601;
    }
    return uVar1;
}

uint tsensor_write(uint param_1, byte param_2, char param_3, int param_4,
                   uint param_5)

{
    byte local_1825;
    uint local_1824;
    char acStack_181c[2048];
    undefined1 auStack_101c[4099];
    byte local_19;
    uint local_18;
    undefined4 local_14;
    uint local_10;
    int local_c;

    local_10 = 0;
    local_18 = 0;
    local_14 = 0;
    local_1825 = param_2;
    local_1824 = param_1;
    if (0xf < param_1) {
        snprintf(acStack_181c, 0x800, " Bad T-sensor param, input chain is %d",
                 param_1);
        V_LOCK();
        logfmt_raw(auStack_101c, 0x1000, 0, acStack_181c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/tsensor/"
             "bitmain_tsensor.c",
             0xb6, "tsensor_write", 0xd, 0x70, 100, auStack_101c);
        return 0x80000601;
    }
    local_c = FUN_000ab0ec(param_1, param_2);
    if (local_c == -0x7ffffa00) {
        local_10 = tsensor_open(local_1824, &local_1825, 1);
        if ((int)local_10 < 0) {
            snprintf(acStack_181c, 0x800,
                     " auto exec tsensor_open, but chain %d,slave_addr %d open "
                     "failed",
                     local_1824, (uint)local_1825);
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0, acStack_181c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/tsensor/bitmain_tsensor.c",
                 0xb6, "tsensor_write", 0xd, 0x79, 100, auStack_101c);
            return local_10;
        }
        local_c = FUN_000ab0ec(local_1824, local_1825);
        if (local_c == -0x7ffffa00) {
            snprintf(acStack_181c, 0x800,
                     " auto exec tsensor_open, but chain %d,slave_addr %d open "
                     "failed",
                     local_1824, (uint)local_1825);
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0, acStack_181c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/tsensor/bitmain_tsensor.c",
                 0xb6, "tsensor_write", 0xd, 0x80, 100, auStack_101c);
            return local_10;
        }
    }
    local_18 = 0;
    while (true) {
        if (param_5 <= local_18) {
            return param_5;
        }
        local_19 = (char)local_18 + param_3;
        local_10 = iic_write_reg(
            *(undefined4 *)(&DAT_0015fbb4 + local_c * 8 + local_1824 * 0x44),
            &local_19, 1, param_4 + local_18, 1);
        if (local_10 != 1)
            break;
        local_18 = local_18 + 1;
        local_10 = 1;
    }
    snprintf(acStack_181c, 0x800,
             "fail to write tsensor by iic, chain:%d, slave: %d, addr: %d",
             local_1824, (uint)local_1825, (uint)local_19);
    V_LOCK();
    logfmt_raw(auStack_101c, 0x1000, 0, acStack_181c);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/tsensor/bitmain_tsensor.c",
        0xb6, "tsensor_write", 0xd, 0x8c, 100, auStack_101c);
    return 0x80000600;
}

int tsensor_read(uint param_1, byte param_2, byte param_3, undefined4 param_4,
                 int param_5)

{
    byte local_181e;
    byte local_181d;
    uint local_181c;
    char acStack_1814[2048];
    undefined1 auStack_1014[4096];
    undefined4 local_14;
    int local_10;
    int local_c;

    local_10 = 0;
    local_14 = 0;
    local_181e = param_3;
    local_181d = param_2;
    local_181c = param_1;
    if (0xf < param_1) {
        snprintf(acStack_1814, 0x800, " Bad T-sensor param, input chain is %d",
                 param_1);
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, acStack_1814);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/tsensor/"
             "bitmain_tsensor.c",
             0xb6, "tsensor_read", 0xc, 0x9b, 100, auStack_1014);
        return -0x7ffff9ff;
    }
    local_c = FUN_000ab0ec(param_1, param_2);
    if (local_c == -0x7ffffa00) {
        local_10 = tsensor_open(local_181c, &local_181d, 1);
        if (local_10 < 0) {
            snprintf(acStack_1814, 0x800,
                     " auto exec tsensor_open, but chain %d,slave_addr %d open "
                     "failed",
                     local_181c, (uint)local_181d);
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0, acStack_1814);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/tsensor/bitmain_tsensor.c",
                 0xb6, "tsensor_read", 0xc, 0xa4, 100, auStack_1014);
            return local_10;
        }
        local_c = FUN_000ab0ec(local_181c, local_181d);
        if (local_c == -0x7ffffa00) {
            snprintf(acStack_1814, 0x800,
                     " auto exec tsensor_open, but chain %d,slave_addr %d open "
                     "failed",
                     local_181c, (uint)local_181d);
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0, acStack_1814);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/tsensor/bitmain_tsensor.c",
                 0xb6, "tsensor_read", 0xc, 0xab, 100, auStack_1014);
            return local_10;
        }
    }
    local_10 = iic_read_reg(
        *(undefined4 *)(&DAT_0015fbb4 + local_c * 8 + local_181c * 0x44),
        &local_181e, 2, param_4, param_5);
    if (param_5 != local_10) {
        snprintf(acStack_1814, 0x800,
                 "fail to read tsensor by iic, chain: %d, slave: %d, addr: %d",
                 local_181c, (uint)local_181d, (uint)local_181e);
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, acStack_1814);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/tsensor/"
             "bitmain_tsensor.c",
             0xb6, "tsensor_read", 0xc, 0xc4, 100, auStack_1014);
        local_10 = -0x7ffffa00;
    }
    return local_10;
}

uint FUN_000ab0ec(uint param_1, char param_2)

{
    uint uVar1;
    char acStack_180c[2048];
    undefined1 auStack_100c[4099];
    byte local_9;

    if (param_1 < 0x10) {
        if ((&DAT_0015fbac)[param_1 * 0x44] == '\0') {
            uVar1 = 0x80000600;
        } else {
            for (local_9 = 0; local_9 < (byte)(&DAT_0015fbac)[param_1 * 0x44];
                 local_9 = local_9 + 1) {
                if (param_2 ==
                    (&DAT_0015fbb0)[(uint)local_9 * 8 + param_1 * 0x44]) {
                    return (uint)local_9;
                }
            }
            uVar1 = 0x80000600;
        }
    } else {
        snprintf(acStack_180c, 0x800, " Bad T-sensor param, input chain is %d",
                 param_1);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/tsensor/"
             "bitmain_tsensor.c",
             0xb6, "find_index", 10, 0xd0, 100, auStack_100c);
        uVar1 = 0x80000601;
    }
    return uVar1;
}

undefined4 FUN_000ab2bc(undefined4 param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4)

{
    V_INT(param_1, "chain", param_3, param_4);
    return param_1;
}

void FUN_000ab2f0(undefined4 param_1, undefined4 param_2, undefined4 param_3,
                  undefined4 param_4)

{
    check_and_print_uart_debug_log(param_1, param_2, param_3, param_4, 1);
    return;
}

void FUN_000ab334(undefined4 param_1, undefined4 param_2, undefined4 param_3,
                  undefined4 param_4)

{
    check_and_print_uart_debug_log(param_1, param_2, param_3, param_4, 0);
    return;
}

undefined4 send_work(int param_1)

{
    long lVar1;
    undefined1 auStack_1014[4096];
    void *local_14;
    char *local_10;
    int local_c;

    local_c = param_1;
    local_10 = (char *)calloc(1, 0x40);
    snprintf(local_10, 0x40, "%.10s_%d", "send_work",
             *(undefined4 *)(local_c + 0xf8));
    V_LOCK();
    lVar1 = syscall(0xe0);
    logfmt_raw(auStack_1014, 0x1000, 0, "%s on pid %ld", local_10, lVar1);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/backend/backend_base.c",
         0xa0, "send_work", 9, 0x3a, 0x28, auStack_1014);
    prctl(0xf, local_10);
    local_14 = calloc(1, *(size_t *)(local_c + 0x33c));
    while (true) {
        memset(local_14, 0, *(size_t *)(local_c + 0x33c));
        queue_dequeue(*(undefined4 *)(local_c + 0x358), local_14, 1);
        if (*(char *)(local_c + 0x3fe) != '\0')
            break;
        push_work_base(local_c, local_14);
    }
    *(undefined1 *)(local_c + 0x3fe) = 0;
    free(local_14);
    return 0;
}

undefined4 platform_check_repeat_nonce(int param_1, int param_2, void *param_3)

{
    int iVar1;
    undefined4 uVar2;
    undefined1 auStack_1050[4096];
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    void *local_2c;
    void *local_28;
    void *local_24;
    int local_20;
    int local_1c;
    size_t local_18;
    uint local_14;

    local_18 = *(size_t *)(param_1 + 0x344);
    local_1c = local_18 * param_2 * 2;
    local_20 = local_1c + local_18;
    iVar1 = memcmp((void *)(*(int *)(param_1 + 0x1e8) + local_1c), param_3,
                   local_18);
    if ((iVar1 == 0) ||
        (iVar1 = memcmp((void *)(*(int *)(param_1 + 0x1e8) + local_20), param_3,
                        local_18),
         iVar1 == 0)) {
        local_24 = calloc(local_18 * 2 + 1, 1);
        local_28 = calloc(local_18 * 2 + 1, 1);
        local_2c = calloc(local_18 * 2 + 1, 1);
        if (((local_24 != (void *)0x0) && (local_28 != (void *)0x0)) &&
            (local_2c != (void *)0x0)) {
            local_14 = 0;
            while (true) {
                if (local_18 <= local_14)
                    break;
                sprintf((char *)((int)local_24 + local_14 * 2), "%02x",
                        (uint) * (byte *)((int)param_3 + local_14));
                sprintf((char *)((int)local_28 + local_14 * 2), "%02x",
                        (uint) * (byte *)(*(int *)(param_1 + 0x1e8) + local_1c +
                                          local_14));
                sprintf((char *)((int)local_2c + local_14 * 2), "%02x",
                        (uint) * (byte *)(*(int *)(param_1 + 0x1e8) + local_20 +
                                          local_14));
                local_14 = local_14 + 1;
            }
            V_LOCK();
            FUN_000ab2bc(&local_50, &local_50, *(int *)(param_1 + 0xfc),
                         *(int *)(param_1 + 0xfc) >> 0x1f);
            logfmt_raw(auStack_1050, 0x1000, 0, uStack_34, local_50, uStack_4c,
                       uStack_48, uStack_44, local_40, uStack_3c, uStack_38,
                       uStack_34, "asic %d repeat nonce %s %s %s", param_2,
                       local_24, local_28, local_2c);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/backend_base.c",
                0xa0, "platform_check_repeat_nonce", 0x1b, 0x5d, 0x14,
                auStack_1050);
        }
        if (local_2c != (void *)0x0) {
            free(local_2c);
        }
        if (local_28 != (void *)0x0) {
            free(local_28);
        }
        if (local_24 != (void *)0x0) {
            free(local_24);
        }
        uVar2 = 4;
    } else {
        memcpy((void *)(*(int *)(param_1 + 0x1e8) + local_20),
               (void *)(*(int *)(param_1 + 0x1e8) + local_1c), local_18);
        memcpy((void *)(*(int *)(param_1 + 0x1e8) + local_1c), param_3,
               local_18);
        uVar2 = 0;
    }
    return uVar2;
}

undefined4 scanhash(int param_1)

{
    char cVar1;
    long lVar2;
    int iVar3;
    int *piVar4;
    uint *puVar5;
    uint uVar6;
    uint uVar7;
    undefined1 auStack_124c[4099];
    char local_249;
    int local_248;
    int local_244;
    char local_240[512];
    uint local_40;
    uint local_3c;
    int local_38;
    void *local_34;
    void *local_30;
    undefined4 local_2c;
    char *local_28;
    int local_24;
    uint local_20;
    uint local_1c;
    uint local_18;
    uint local_14;

    local_24 = param_1;
    local_28 = (char *)calloc(1, 0x40);
    snprintf(local_28, 0x40, "%.10s_%d", "scanhash",
             *(undefined4 *)(local_24 + 0xf8));
    V_LOCK();
    lVar2 = syscall(0xe0);
    logfmt_raw(auStack_124c, 0x1000, 0, "%s on pid %ld", local_28, lVar2);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/backend/backend_base.c",
         0xa0, "scanhash", 8, 0x6e, 0x28, auStack_124c);
    prctl(0xf, local_28);
    local_2c = *(undefined4 *)(local_24 + 0x35c);
    memset(local_240, 0, 0x200);
    local_30 = calloc(1, *(size_t *)(local_24 + 0x340));
    local_34 = calloc(1, *(size_t *)(local_24 + 0x344));
    local_20 = 0;
    local_1c = 1;
    local_18 = 0;
    local_14 = 1;
    do {
        memset(local_240, 0, 0x200);
        queue_dequeue(local_2c, local_240, 1);
        if (*(char *)(local_24 + 0x3fc) != '\0') {
            *(undefined1 *)(local_24 + 0x3fc) = 0;
        LAB_000ac1c8:
            free(local_30);
            free(local_34);
            return 0;
        }
        while (true) {
            while (local_240[0] != -0x56) {
                queue_dequeue(local_2c, local_240, 1);
                FUN_000ab334(local_24 + 0x478, 1, local_240,
                             *(undefined4 *)(local_24 + 0xfc));
                if (*(char *)(local_24 + 0x3fc) != '\0') {
                    *(undefined1 *)(local_24 + 0x3fc) = 0;
                    goto LAB_000ac1c8;
                }
            }
            queue_dequeue(local_2c, local_240 + 1, 1);
            if (*(char *)(local_24 + 0x3fc) != '\0') {
                *(undefined1 *)(local_24 + 0x3fc) = 0;
                goto LAB_000ac1c8;
            }
            if (local_240[1] == 'U')
                break;
            local_240[0] = local_240[1];
            FUN_000ab334(local_24 + 0x478, 2, local_240,
                         *(undefined4 *)(local_24 + 0xfc));
        }
        queue_dequeue(local_2c, local_240 + 2, *(int *)(local_24 + 0x354) + -2);
        local_38 = (**(code **)(local_24 + 0xb0))(local_240);
        queue_dequeue(local_2c, local_240 + *(int *)(local_24 + 0x354),
                      local_38);
        FUN_000ab334(local_24 + 0x478, *(int *)(local_24 + 0x354) + local_38,
                     local_240, *(undefined4 *)(local_24 + 0xfc));
        if (*(char *)(local_24 + 0x3fc) != '\0') {
            *(undefined1 *)(local_24 + 0x3fc) = 0;
            goto LAB_000ac1c8;
        }
        memset(local_30, 0, *(size_t *)(local_24 + 0x340));
        local_244 = 0;
        local_248 = 0;
        local_249 = '\0';
        local_3c = (**(code **)(local_24 + 0x48))(local_24, local_240, local_30,
                                                  &local_249, local_34,
                                                  &local_244, &local_248);
        if (local_3c == 100) {
            cVar1 = queue_enqueue(*(undefined4 *)(local_24 + 0x364), local_240,
                                  local_38 + 3);
            if ((cVar1 != '\x01') &&
                (local_20 = local_20 + 1, local_1c <= local_20)) {
                V_LOCK();
                logfmt_raw(auStack_124c, 0x1000, 0,
                           "chain[%d], queue_enqueue of "
                           "__low_priority_resp_packet_queue is false",
                           *(undefined4 *)(local_24 + 0xfc));
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "backend_base.c",
                     0xa0, "scanhash", 8, 0xdc, 0x28, auStack_124c);
                V_LOCK();
                logfmt_raw(auStack_124c, 0x1000, 0,
                           "low_priority_enqueue_fail_cnt = %d, "
                           "low_priority_enqueue_fail_limit = %d",
                           local_20, local_1c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "backend_base.c",
                     0xa0, "scanhash", 8, 0xdd, 0x28, auStack_124c);
                local_1c = local_1c * 10;
                if (9999999 < local_1c) {
                    local_1c = 10000000;
                }
                local_20 = 0;
            }
        } else if (local_3c < 0x65) {
            if ((local_3c == 0) && (*(char *)(local_24 + 0x102) == '\x01')) {
                if ((*(char *)(local_24 + local_248 + 0x218) == '\x01') ||
                    ((local_249 == '\0' || (iVar3 = platform_check_repeat_nonce(
                                                local_24, local_244, local_34),
                                            iVar3 == 0)))) {
                    local_40 =
                        (**(code **)(local_24 + 0x4c))(local_24, local_30);
                    if (local_40 < 6) {
                        iVar3 = *(int *)(local_24 + 0x1c8) + local_244 * 0x30;
                        puVar5 = (uint *)(iVar3 + local_40 * 8);
                        uVar6 = *puVar5;
                        uVar7 = puVar5[1];
                        piVar4 = (int *)(iVar3 + local_40 * 8);
                        *piVar4 = uVar6 + 1;
                        piVar4[1] = uVar7 + (0xfffffffe < uVar6);
                        if (local_40 < 2) {
                            piVar4 = (int *)(*(int *)(local_24 + 0x1e0) +
                                             local_244 * 4);
                            *piVar4 = *piVar4 + 1;
                            uVar6 = *(uint *)(local_24 + 0x1c0);
                            *(uint *)(local_24 + 0x1c0) = uVar6 + 1;
                            *(uint *)(local_24 + 0x1c4) =
                                *(int *)(local_24 + 0x1c4) +
                                (uint)(0xfffffffe < uVar6);
                            puVar5 =
                                (uint *)(local_24 + (local_248 + 0x47) * 8);
                            uVar6 = *puVar5;
                            uVar7 = puVar5[1];
                            piVar4 = (int *)(local_24 + (local_248 + 0x47) * 8);
                            *piVar4 = uVar6 + 1;
                            piVar4[1] = uVar7 + (0xfffffffe < uVar6);
                            if ((((local_40 == 0) &&
                                  (*(char *)(local_24 + local_248 + 0x218) !=
                                   '\x01')) &&
                                 (cVar1 = queue_enqueue(
                                      *(undefined4 *)(*(int *)(local_24 +
                                                               0x3ec) +
                                                      0x360),
                                      local_30, 1),
                                  cVar1 != '\x01')) &&
                                (local_18 = local_18 + 1,
                                 local_14 <= local_18)) {
                                V_LOCK();
                                logfmt_raw(auStack_124c, 0x1000, 0,
                                           "chain[%d], queue_enqueue of "
                                           "__nonce_retrieve_queue is false",
                                           *(undefined4 *)(local_24 + 0xfc));
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/backend/"
                                     "backend_base.c",
                                     0xa0, "scanhash", 8, 0xc3, 0x28,
                                     auStack_124c);
                                V_LOCK();
                                logfmt_raw(auStack_124c, 0x1000, 0,
                                           "nonce_enqueue_fail_cnt = %d, "
                                           "nonce_enqueue_fail_limit = %d",
                                           local_18, local_14);
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/backend/"
                                     "backend_base.c",
                                     0xa0, "scanhash", 8, 0xc4, 0x28,
                                     auStack_124c);
                                local_14 = local_14 * 10;
                                if (9999999 < local_14) {
                                    local_14 = 10000000;
                                }
                                local_18 = 0;
                            }
                        }
                    }
                } else {
                    iVar3 = *(int *)(local_24 + 0x1c8) + local_244 * 0x30;
                    uVar6 = *(uint *)(iVar3 + 0x20);
                    *(uint *)(iVar3 + 0x20) = uVar6 + 1;
                    *(uint *)(iVar3 + 0x24) =
                        *(int *)(iVar3 + 0x24) + (uint)(0xfffffffe < uVar6);
                }
            }
        } else if (local_3c == 0x65) {
            iVar3 = *(int *)(local_24 + 0x1c8);
            uVar6 = *(uint *)(iVar3 + 0x28);
            *(uint *)(iVar3 + 0x28) = uVar6 + 1;
            *(uint *)(iVar3 + 0x2c) =
                *(int *)(iVar3 + 0x2c) + (uint)(0xfffffffe < uVar6);
        }
    } while (true);
}

undefined4 get_response(int param_1)

{
    char cVar1;
    long lVar2;
    int iVar3;
    undefined1 auStack_112c[4096];
    undefined1 auStack_12c[256];
    size_t local_2c;
    int local_28;
    uint local_24;
    uint local_20;
    int local_1c;
    uint local_18;
    uint local_14;
    int local_10;
    char *local_c;

    local_10 = param_1;
    local_c = (char *)calloc(1, 0x40);
    snprintf(local_c, 0x40, "%.10s_%d", "get_response",
             *(undefined4 *)(local_10 + 0xf8));
    V_LOCK();
    lVar2 = syscall(0xe0);
    logfmt_raw(auStack_112c, 0x1000, 0, "%s on pid %ld", local_c, lVar2);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/backend/backend_base.c",
         0xa0, "get_response", 0xc, 0xf8, 0x28, auStack_112c);
    prctl(0xf, local_c);
    memset(auStack_12c, 0, 0x100);
    local_24 = 0x40;
    local_20 = 0x40;
    local_28 = 0;
    local_1c = 0;
    local_18 = 0;
    local_14 = 1;
    while (true) {
        iVar3 = dev_ctrl();
        local_2c = (**(code **)(iVar3 + 0x3c))(*(undefined4 *)(local_10 + 0xf8),
                                               auStack_12c, 0x100);
        if (*(char *)(local_10 + 0x3fd) != '\0')
            break;
        if ((int)local_2c < 1) {
            usleep(local_20);
            local_20 = local_20 << 1;
            if (999 < local_20) {
                local_20 = 1000;
            }
        } else {
            local_28 = queue_element_num(*(undefined4 *)(local_10 + 0x35c));
            if (local_28 < 0x4001) {
                cVar1 = queue_enqueue(*(undefined4 *)(local_10 + 0x35c),
                                      auStack_12c, local_2c);
                if ((cVar1 != '\x01') &&
                    (local_18 = local_18 + 1, local_14 <= local_18)) {
                    V_LOCK();
                    logfmt_raw(auStack_112c, 0x1000, 0,
                               "chain[%d], queue_enqueue of "
                               "__resp_packet_queue is false",
                               *(undefined4 *)(local_10 + 0xfc));
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/backend_base.c",
                         0xa0, "get_response", 0xc, 0x119, 0x28, auStack_112c);
                    V_LOCK();
                    logfmt_raw(auStack_112c, 0x1000, 0,
                               "enqueue_fail_cnt = %d, enqueue_fail_limit = %d",
                               local_18, local_14);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/backend_base.c",
                         0xa0, "get_response", 0xc, 0x11a, 0x28, auStack_112c);
                    local_14 = local_14 * 10;
                    if (9999999 < local_14) {
                        local_14 = 10000000;
                    }
                    local_18 = 0;
                }
                local_20 = local_24;
                memset(auStack_12c, 0, local_2c);
            } else {
                if (local_1c == 0) {
                    V_LOCK();
                    logfmt_raw(auStack_112c, 0x1000, 0,
                               "chain[%d], queue_element_num reach limit, pls "
                               "check runtime->__resp_packet_queue",
                               *(undefined4 *)(local_10 + 0xfc));
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/backend_base.c",
                         0xa0, "get_response", 0xc, 0x10b, 0x28, auStack_112c);
                    local_1c = 1;
                }
                usleep(local_24);
            }
        }
    }
    *(undefined1 *)(local_10 + 0x3fd) = 0;
    return 0;
}

undefined4 backend_exit_base(int param_1)

{
    int iVar1;
    void *pvStack_18;
    int local_14;
    int local_10;
    int local_c;

    *(undefined1 *)(param_1 + 0x101) = 0;
    *(undefined1 *)(param_1 + 0x102) = 0;
    *(undefined1 *)(param_1 + 0x100) = 0;
    (**(code **)(param_1 + 0x3c))(param_1);
    if (*(int *)(param_1 + 0x54) != 0) {
        (**(code **)(param_1 + 0x54))(param_1);
    }
    *(undefined1 *)(param_1 + 0x3fc) = 1;
    *(undefined1 *)(param_1 + 0x3fd) = 1;
    *(undefined1 *)(param_1 + 0x3fe) = 1;
    queue_force_wakeup(*(undefined4 *)(param_1 + 0x35c));
    queue_force_wakeup(*(undefined4 *)(param_1 + 0x360));
    queue_force_wakeup(*(undefined4 *)(param_1 + 0x364));
    queue_force_wakeup(*(undefined4 *)(param_1 + 0x358));
    for (local_c = 0; local_c < *(int *)(param_1 + 1000);
         local_c = local_c + 1) {
        queue_force_wakeup(*(undefined4 *)(param_1 + (local_c + 0xda) * 4));
    }
    pthread_join(*(pthread_t *)(param_1 + 0x3f4), &pvStack_18);
    pthread_join(*(pthread_t *)(param_1 + 0x3f0), &pvStack_18);
    pthread_join(*(pthread_t *)(param_1 + 0x3f8), &pvStack_18);
    pthread_mutex_destroy((pthread_mutex_t *)(param_1 + 0x400));
    pthread_mutex_destroy((pthread_mutex_t *)(param_1 + 0x418));
    pthread_mutex_destroy((pthread_mutex_t *)(param_1 + 0x430));
    queue_free(*(undefined4 *)(param_1 + 0x35c));
    queue_free(*(undefined4 *)(param_1 + 0x360));
    queue_free(*(undefined4 *)(param_1 + 0x364));
    queue_free(*(undefined4 *)(param_1 + 0x358));
    for (local_10 = 0; local_10 < *(int *)(param_1 + 1000);
         local_10 = local_10 + 1) {
        queue_free(*(undefined4 *)(param_1 + (local_10 + 0xda) * 4));
    }
    free(*(void **)(param_1 + 0x1ec));
    free(*(void **)(param_1 + 0x1e0));
    free(*(void **)(param_1 + 0x1e8));
    free(*(void **)(param_1 + 0x1c8));
    for (local_14 = 0; local_14 < *(int *)(param_1 + 0x150);
         local_14 = local_14 + 1) {
        pthread_mutex_destroy((pthread_mutex_t *)(*(int *)(param_1 + 0x210) +
                                                  local_14 * 0x2c + 0x14));
    }
    free(*(void **)(param_1 + 0x210));
    if (*(int *)(param_1 + 0x350) != 0) {
        free(*(void **)(param_1 + 0x204));
    }
    *(undefined4 *)(param_1 + 0x208) = 0;
    *(undefined4 *)(param_1 + 0x1ac) = 0xffffffff;
    *(undefined8 *)(param_1 + 0x1b8) = 0;
    *(undefined8 *)(param_1 + 0x1c0) = 0;
    *(undefined4 *)(param_1 + 0x3ec) = 0;
    iVar1 = dev_ctrl();
    (**(code **)(iVar1 + 0x1c))(*(undefined4 *)(param_1 + 0xf8));
    return 0;
}

undefined4 async_push_work_base(int param_1, undefined4 param_2)

{
    queue_enqueue(*(undefined4 *)(param_1 + 0x358), param_2, 1);
    return 0;
}

undefined4 set_frequency_by_temp_single_base(void)

{
    return 0x6a;
}

undefined4 update_temp_bias_freq_base(void)

{
    return 0x6a;
}

undefined4 set_frequency_automatic_single_base(void)

{
    return 1;
}

undefined4 get_chip_temperature_str_base(int param_1, undefined1 *param_2,
                                         uint param_3)

{
    int iVar1;
    int local_10;
    int local_c;

    *param_2 = 0;
    local_c = 0;
    if (3999 < param_3) {
        param_3 = 4000;
    }
    for (local_10 = 0; local_10 < *(int *)(param_1 + 0x150);
         local_10 = local_10 + 1) {
        iVar1 = snprintf(
            param_2 + local_c, param_3 - local_c, "%d ",
            *(undefined4 *)(*(int *)(param_1 + 0x210) + local_10 * 0x2c));
        local_c = local_c + iVar1;
    }
    return 0;
}

undefined4 set_frequency_single_base(void)

{
    return 0x6a;
}

undefined4 push_work_base(int param_1, undefined4 param_2)

{
    int iVar1;
    uint uVar2;
    undefined4 uVar3;
    undefined1 auStack_101c[4096];
    uint local_1c;
    int local_18;
    void *local_14;

    if ((*(char *)(param_1 + 0x102) == '\x01') ||
        (*(char *)(param_1 + 0x101) == '\x01')) {
        local_14 = calloc(1, *(size_t *)(param_1 + 0x348));
        local_1c = 0;
        (**(code **)(param_1 + 0x44))(param_1, param_2, local_14, &local_1c);
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x430));
        do {
            iVar1 = dev_ctrl();
            uVar2 =
                (**(code **)(iVar1 + 0x44))(*(undefined4 *)(param_1 + 0xf8));
        } while (uVar2 < local_1c);
        iVar1 = dev_ctrl();
        local_18 = (**(code **)(iVar1 + 0x34))(*(undefined4 *)(param_1 + 0xf8),
                                               local_14, local_1c);
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x430));
        FUN_000ab2f0(param_1 + 0x4c0, local_1c, local_14,
                     *(undefined4 *)(param_1 + 0xfc));
        if (local_18 < 1) {
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0,
                       "device %d push work failed,errcode %d",
                       *(undefined4 *)(param_1 + 0xf8), local_18);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/backend/backend_base.c",
                0xa0, "push_work_base", 0xe, 0x1b0, 100, auStack_101c);
        } else {
            uVar2 = *(uint *)(param_1 + 0x1b8);
            *(uint *)(param_1 + 0x1b8) = uVar2 + 1;
            *(uint *)(param_1 + 0x1bc) =
                *(int *)(param_1 + 0x1bc) + (uint)(0xfffffffe < uVar2);
        }
        free(local_14);
        uVar3 = 0;
    } else {
        uVar3 = 0x67;
    }
    return uVar3;
}

undefined4 pop_ans_base(int param_1, undefined4 param_2)

{
    queue_dequeue(*(undefined4 *)(*(int *)(param_1 + 0x3ec) + 0x360), param_2,
                  1);
    return 0;
}

undefined4 try_pop_ans_base(int param_1, undefined4 param_2)

{
    undefined4 uVar1;

    uVar1 = queue_try_dequeue(
        *(undefined4 *)(*(int *)(param_1 + 0x3ec) + 0x360), param_2, 1);
    return uVar1;
}

undefined4 backend_init_base(void *param_1)

{
    int iVar1;
    undefined4 uVar2;
    void *pvVar3;
    int local_10;
    int local_c;

    iVar1 = dev_ctrl();
    uVar2 = (**(code **)(iVar1 + 0x30))(*(undefined4 *)((int)param_1 + 0xf8));
    *(undefined4 *)((int)param_1 + 0xfc) = uVar2;
    iVar1 = dev_ctrl();
    (**(code **)(iVar1 + 0x2c))(*(undefined4 *)((int)param_1 + 0xf8));
    iVar1 = dev_ctrl();
    (**(code **)(iVar1 + 4))(*(undefined4 *)((int)param_1 + 0xf8));
    uVar2 = queue_new(1, 0);
    *(undefined4 *)((int)param_1 + 0x35c) = uVar2;
    uVar2 = queue_new(*(undefined4 *)((int)param_1 + 0x340), 0);
    *(undefined4 *)((int)param_1 + 0x360) = uVar2;
    uVar2 = queue_new(1, 0);
    *(undefined4 *)((int)param_1 + 0x364) = uVar2;
    local_c = 0;
    while (true) {
        if (*(int *)((int)param_1 + 1000) <= local_c)
            break;
        uVar2 = queue_new(1, 0);
        *(undefined4 *)((int)param_1 + (local_c + 0xda) * 4) = uVar2;
        local_c = local_c + 1;
    }
    uVar2 = queue_new(*(undefined4 *)((int)param_1 + 0x33c), 0);
    *(undefined4 *)((int)param_1 + 0x358) = uVar2;
    pthread_mutex_init((pthread_mutex_t *)((int)param_1 + 0x400),
                       (pthread_mutexattr_t *)0x0);
    pthread_mutex_init((pthread_mutex_t *)((int)param_1 + 0x418),
                       (pthread_mutexattr_t *)0x0);
    pthread_mutex_init((pthread_mutex_t *)((int)param_1 + 0x430),
                       (pthread_mutexattr_t *)0x0);
    pvVar3 = calloc(*(size_t *)((int)param_1 + 0x150), 1);
    *(void **)((int)param_1 + 0x1ec) = pvVar3;
    pvVar3 = calloc(*(size_t *)((int)param_1 + 0x150), 4);
    *(void **)((int)param_1 + 0x1e0) = pvVar3;
    pvVar3 = calloc(*(size_t *)((int)param_1 + 0x150),
                    *(int *)((int)param_1 + 0x344) << 1);
    *(void **)((int)param_1 + 0x1e8) = pvVar3;
    pvVar3 = calloc(*(size_t *)((int)param_1 + 0x150), 0x30);
    *(void **)((int)param_1 + 0x1c8) = pvVar3;
    pvVar3 = calloc(*(size_t *)((int)param_1 + 0x150), 0x2c);
    *(void **)((int)param_1 + 0x210) = pvVar3;
    for (local_10 = 0; local_10 < *(int *)((int)param_1 + 0x150);
         local_10 = local_10 + 1) {
        pthread_mutex_init((pthread_mutex_t *)(*(int *)((int)param_1 + 0x210) +
                                               local_10 * 0x2c + 0x14),
                           (pthread_mutexattr_t *)0x0);
    }
    *(undefined8 *)((int)param_1 + 0x1b8) = 0;
    *(undefined8 *)((int)param_1 + 0x1c0) = 0;
    *(undefined4 *)((int)param_1 + 0x1ac) = 0xffffffff;
    *(undefined1 *)((int)param_1 + 0x1cc) = 0;
    *(undefined4 *)((int)param_1 + 0x1d8) = 0;
    *(undefined4 *)((int)param_1 + 0x1dc) = 0;
    *(undefined4 *)((int)param_1 + 0x1f0) = 0;
    *(undefined4 *)((int)param_1 + 0x200) = 0;
    if (*(int *)((int)param_1 + 0x350) != 0) {
        pvVar3 = calloc(*(size_t *)((int)param_1 + 0x150),
                        *(size_t *)((int)param_1 + 0x350));
        *(void **)((int)param_1 + 0x204) = pvVar3;
    }
    *(undefined4 *)((int)param_1 + 0x208) = 0;
    memset((void *)((int)param_1 + 0x238), 0, 0x100);
    *(undefined1 *)((int)param_1 + 0x3fc) = 0;
    *(undefined1 *)((int)param_1 + 0x3fd) = 0;
    *(undefined1 *)((int)param_1 + 0x3fe) = 0;
    if (*(int *)((int)param_1 + 0x3ec) == 0) {
        *(void **)((int)param_1 + 0x3ec) = param_1;
    }
    if (*(int *)((int)param_1 + 0x50) != 0) {
        (**(code **)((int)param_1 + 0x50))(param_1);
    }
    pthread_create((pthread_t *)((int)param_1 + 0x3f4), (pthread_attr_t *)0x0,
                   get_response, param_1);
    pthread_create((pthread_t *)((int)param_1 + 0x3f0), (pthread_attr_t *)0x0,
                   scanhash, param_1);
    pthread_create((pthread_t *)((int)param_1 + 0x3f8), (pthread_attr_t *)0x0,
                   send_work, param_1);
    *(undefined1 *)((int)param_1 + 0x100) = 1;
    return 0;
}

undefined4 reset_base(int param_1)

{
    int iVar1;

    (**(code **)(param_1 + 0x3c))(param_1);
    iVar1 = dev_ctrl();
    (**(code **)(iVar1 + 0x2c))(*(undefined4 *)(param_1 + 0xf8));
    queue_clear(*(undefined4 *)(param_1 + 0x35c));
    *(undefined8 *)(param_1 + 0x1b8) = 0;
    *(undefined8 *)(param_1 + 0x1c0) = 0;
    *(undefined4 *)(param_1 + 0x208) = 0;
    memset(*(void **)(param_1 + 0x204), 0,
           *(int *)(param_1 + 0x350) * *(int *)(param_1 + 0x150));
    return 0;
}

undefined4 dhash_mining_start_base(int param_1)

{
    *(undefined1 *)(param_1 + 0x102) = 1;
    return 0;
}

undefined4 dhash_mining_stop_base(int param_1)

{
    (**(code **)(param_1 + 4))(param_1);
    *(undefined1 *)(param_1 + 0x101) = 0;
    *(undefined1 *)(param_1 + 0x102) = 0;
    return 0;
}

undefined4 dhash_mining_reset_base(int param_1)

{
    int iVar1;
    undefined1 auStack_1030[4096];
    undefined4 local_30;
    undefined4 uStack_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    undefined4 local_20;
    undefined4 uStack_1c;
    undefined4 uStack_18;
    undefined4 uStack_14;

    V_LOCK();
    FUN_000ab2bc(&local_30, &local_30, *(int *)(param_1 + 0xfc),
                 *(int *)(param_1 + 0xfc) >> 0x1f);
    logfmt_raw(auStack_1030, 0x1000, 0, uStack_14, local_30, uStack_2c,
               uStack_28, uStack_24, local_20, uStack_1c, uStack_18, uStack_14,
               "dhash mining reset!");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/backend/backend_base.c",
         0xa0, "dhash_mining_reset_base", 0x17, 0x238, 0x50, auStack_1030);
    (**(code **)(param_1 + 4))(param_1);
    *(undefined1 *)(param_1 + 0x101) = 0;
    *(undefined1 *)(param_1 + 0x102) = 0;
    iVar1 = dev_ctrl();
    (**(code **)(iVar1 + 0x1c))(*(undefined4 *)(param_1 + 0xf8));
    sleep(10);
    iVar1 = dev_ctrl();
    (**(code **)(iVar1 + 0x18))(*(undefined4 *)(param_1 + 0xf8),
                                *(undefined4 *)(param_1 + 0x454),
                                *(undefined4 *)(param_1 + 0x468));
    sleep(1);
    iVar1 = dev_ctrl();
    (**(code **)(iVar1 + 0x2c))(*(undefined4 *)(param_1 + 0xf8));
    iVar1 = dev_ctrl();
    (**(code **)(iVar1 + 4))(*(undefined4 *)(param_1 + 0xf8));
    (**(code **)(param_1 + 0x10))(param_1);
    return 0;
}

undefined4 set_chipaddr_base(int param_1, int param_2, int param_3)

{
    byte bVar1;
    undefined4 uVar2;
    undefined1 local_14;
    undefined1 uStack_13;
    undefined1 uStack_12;
    byte bStack_11;
    undefined1 local_10;
    undefined1 uStack_f;
    byte local_e;
    int local_c;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        (**(code **)(param_1 + 0x108))(param_1);
        usleep(20000);
        uStack_f = 0;
        local_e = 0;
        local_14 = 0x55;
        uStack_13 = 0xaa;
        uStack_12 = 0x40;
        bStack_11 = 5;
        for (local_c = 0; local_c < param_3; local_c = local_c + 1) {
            local_10 = *(undefined1 *)(param_2 + local_c);
            bVar1 = BM_CRC5(&uStack_12, (bStack_11 - 1) * 8);
            local_e = local_e & 0xe0 | bVar1 & 0x1f;
            send_command_packet(param_1, &local_14, 7);
            usleep(20000);
        }
        uVar2 = 0;
    } else {
        uVar2 = 4;
    }
    return uVar2;
}

undefined4 set_inactive_base(int param_1)

{
    byte bVar1;
    undefined4 uVar2;
    undefined1 local_10;
    undefined1 uStack_f;
    undefined1 uStack_e;
    undefined1 uStack_d;
    undefined2 uStack_c;
    byte local_a;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        uStack_c = 0;
        local_a = 0;
        local_10 = 0x55;
        uStack_f = 0xaa;
        uStack_e = 0x53;
        uStack_d = 5;
        bVar1 = BM_CRC5(&uStack_e, 0x20);
        local_a = local_a & 0xe0 | bVar1 & 0x1f;
        send_command_packet(param_1, &local_10, 7);
        uVar2 = 0;
    } else {
        uVar2 = 4;
    }
    return uVar2;
}

undefined4 set_chip_reg_base(int param_1, undefined4 *param_2)

{
    byte bVar1;
    undefined4 uVar2;
    undefined1 local_14;
    undefined1 uStack_13;
    byte bStack_12;
    byte bStack_11;
    undefined1 uStack_10;
    undefined1 uStack_f;
    undefined2 uStack_e;
    undefined2 uStack_c;
    byte local_a;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        uStack_e = 0;
        uStack_c = 0;
        local_a = 0;
        local_14 = 0x55;
        uStack_13 = 0xaa;
        bStack_12 = (*(byte *)(param_2 + 2) & 1) << 4 | 0x41;
        bStack_11 = 9;
        uStack_10 = *(undefined1 *)((int)param_2 + 9);
        uStack_f = (undefined1) * (undefined2 *)((int)param_2 + 10);
        uVar2 = reverse_byte_order_32(*param_2);
        uStack_e = (undefined2)uVar2;
        uStack_c = (undefined2)((uint)uVar2 >> 0x10);
        bVar1 = BM_CRC5(&bStack_12, (bStack_11 - 1) * 8);
        local_a = local_a & 0xe0 | bVar1 & 0x1f;
        send_command_packet(param_1, &local_14, 0xb);
        uVar2 = 0;
    } else {
        uVar2 = 4;
    }
    return uVar2;
}

undefined4 sync_get_status_unclear_base(int param_1, int param_2, int param_3,
                                        int *param_4, undefined4 param_5,
                                        undefined4 param_6)

{
    int iVar1;
    uint uVar2;
    int extraout_r2;
    uint uVar3;
    undefined4 local_2c;
    int local_28;
    char local_24;
    char local_23;
    undefined4 local_22;
    undefined1 local_1e;
    byte local_1d;
    byte local_1b;
    undefined4 local_18;
    int local_14;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        local_14 = 0;
        local_18 = 0;
        FUN_000ccdfc(param_5, param_6, 1000, 0);
        local_28 = extraout_r2 * 1000000;
        local_2c = FUN_000ccdfc(param_5, param_6, 1000, 0);
        while (local_14 < param_2) {
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_24, 10, &local_2c);
            if (iVar1 == 0x6e) {
                local_18 = 3;
                break;
            }
            if ((local_24 != -0x56) || (local_23 != 'U')) {
                local_18 = 1;
                break;
            }
            uVar3 = (uint)local_1b;
            uVar2 = BM_CRC5(&local_22, 0x3b);
            if ((uVar3 & 0x1f) == uVar2) {
                *(undefined1 *)(param_3 + local_14 * 0xc + 4) = local_1e;
                *(ushort *)(param_3 + local_14 * 0xc + 6) = (ushort)local_1d;
                *(undefined4 *)(param_3 + local_14 * 0xc) = local_22;
                local_14 = local_14 + 1;
            } else {
                local_18 = 2;
            }
        }
        *param_4 = local_14;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_18 = 4;
    }
    return local_18;
}

undefined4 sync_get_dag_base(int param_1, int param_2, int param_3,
                             int *param_4, undefined4 param_5,
                             undefined4 param_6)

{
    ushort uVar1;
    int iVar2;
    undefined4 uVar3;
    int extraout_r2;
    undefined4 uVar4;
    undefined4 *puVar5;
    undefined4 uVar6;
    ushort *puVar7;
    undefined1 auStack_1074[4096];
    undefined4 local_74;
    int local_70;
    char local_6c;
    char local_6b;
    undefined1 uStack_6a;
    undefined1 local_69;
    undefined4 local_68;
    ushort local_64[2];
    undefined4 auStack_60[15];
    ushort local_24;
    ushort local_22;
    undefined4 local_20;
    int local_1c;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        queue_clear(*(undefined4 *)(param_1 + 0x364));
        local_1c = 0;
        local_20 = 0;
        FUN_000ccdfc(param_5, param_6, 1000, 0);
        local_70 = extraout_r2 * 1000000;
        local_74 = FUN_000ccdfc(param_5, param_6, 1000, 0);
        while (local_1c < param_2) {
            iVar2 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_6c, 0x4a, &local_74);
            if (iVar2 == 0x6e) {
                local_20 = 3;
                break;
            }
            V_LOCK();
            logfmt_raw(auStack_1074, 0x1000, 0,
                       "[DAG] header:%02x%02x chip_addr:%02x", local_6c,
                       local_6b, local_69);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "chip_reg_io_base.c",
                 0xa4, "sync_get_dag_base", 0x11, 0xf1, 0x14, auStack_1074);
            if ((local_6c != -0x56) || (local_6b != 'U')) {
                local_20 = 1;
                break;
            }
            uVar1 = BM_CRC16(&uStack_6a, 0x46);
            local_22 = uVar1 >> 8 | uVar1 << 8;
            if (local_22 == local_24) {
                *(undefined1 *)(param_3 + local_1c * 0x4c + 4) = local_69;
                iVar2 = local_1c * 0x4c;
                uVar3 = reverse_byte_order_32(local_68);
                *(undefined4 *)(param_3 + iVar2) = uVar3;
                puVar5 = (undefined4 *)(param_3 + local_1c * 0x4c + 10);
                puVar7 = local_64;
                do {
                    uVar3 = *(undefined4 *)(puVar7 + 2);
                    uVar4 = *(undefined4 *)(puVar7 + 4);
                    uVar6 = *(undefined4 *)(puVar7 + 6);
                    *puVar5 = *(undefined4 *)puVar7;
                    puVar5[1] = uVar3;
                    puVar5[2] = uVar4;
                    puVar5[3] = uVar6;
                    puVar7 = puVar7 + 8;
                    puVar5 = puVar5 + 4;
                } while (puVar7 != &local_24);
                local_1c = local_1c + 1;
            } else {
                local_20 = 2;
            }
        }
        *param_4 = local_1c;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_20 = 4;
    }
    return local_20;
}

undefined4 sync_get_dag_node_rvn(int param_1, int param_2, int param_3,
                                 int *param_4, undefined4 param_5,
                                 undefined4 param_6)

{
    ushort uVar1;
    int iVar2;
    undefined4 uVar3;
    int extraout_r2;
    undefined1 auStack_1130[4096];
    undefined4 local_130;
    int local_12c;
    char local_128;
    char local_127;
    undefined1 auStack_126[2];
    undefined1 local_124;
    undefined4 local_123;
    undefined1 auStack_11f[256];
    ushort local_1f;
    ushort local_1a;
    undefined4 local_18;
    int local_14;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        queue_clear(*(undefined4 *)(param_1 + 0x364));
        local_14 = 0;
        local_18 = 0;
        FUN_000ccdfc(param_5, param_6, 1000, 0);
        local_12c = extraout_r2 * 1000000;
        local_130 = FUN_000ccdfc(param_5, param_6, 1000, 0);
        while (local_14 < param_2) {
            iVar2 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_128, 0x10b, &local_130);
            if (iVar2 == 0x6e) {
                local_18 = 3;
                break;
            }
            V_LOCK();
            logfmt_raw(auStack_1130, 0x1000, 0,
                       "[DAG] header:%02x%02x chip_addr:%02x", local_128,
                       local_127, local_124);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "chip_reg_io_base.c",
                 0xa4, "sync_get_dag_node_rvn", 0x15, 299, 0x14, auStack_1130);
            if ((local_128 != -0x56) || (local_127 != 'U')) {
                local_18 = 1;
                break;
            }
            uVar1 = BM_CRC16(auStack_126, 0x107);
            local_1a = uVar1 >> 8 | uVar1 << 8;
            if (local_1a == local_1f) {
                *(undefined1 *)(param_3 + local_14 * 0x10c + 2) = local_124;
                iVar2 = local_14 * 0x10c;
                uVar3 = reverse_byte_order_32(local_123);
                *(undefined4 *)(param_3 + iVar2 + 4) = uVar3;
                memcpy((void *)(param_3 + local_14 * 0x10c + 8), auStack_11f,
                       0x40);
                local_14 = local_14 + 1;
            } else {
                local_18 = 2;
            }
        }
        *param_4 = local_14;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_18 = 4;
    }
    return local_18;
}

undefined4 sync_get_chip_reg_base(int param_1, int param_2, undefined4 param_3,
                                  undefined4 param_4, undefined4 param_5,
                                  undefined4 param_6, undefined4 param_7,
                                  undefined4 param_8)

{
    byte bVar1;
    undefined4 uVar2;
    undefined4 local_24;
    undefined1 local_18;
    undefined1 uStack_17;
    byte abStack_16[3];
    undefined1 local_13;
    byte local_12;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        local_12 = 0;
        local_18 = 0x55;
        uStack_17 = 0xaa;
        abStack_16[0] = (*(byte *)(param_2 + 8) & 1) << 4 | 0x42;
        abStack_16[1] = 5;
        abStack_16[2] = *(undefined1 *)(param_2 + 9);
        local_13 = (undefined1) * (undefined2 *)(param_2 + 10);
        bVar1 = BM_CRC5(abStack_16, 0x20);
        local_12 = local_12 & 0xe0 | bVar1 & 0x1f;
        send_command_packet(param_1, &local_18, 7);
        local_24 = param_3;
        if (*(char *)(param_2 + 8) != '\x01') {
            local_24 = 1;
        }
        uVar2 = (**(code **)(param_1 + 0x11c))(param_1, local_24, param_4,
                                               param_5, param_7, param_8);
    } else {
        uVar2 = 4;
    }
    return uVar2;
}

undefined4 sync_get_dag_node_base(int param_1, int param_2, undefined4 param_3,
                                  undefined4 param_4, undefined4 param_5,
                                  undefined4 param_6, undefined4 param_7,
                                  undefined4 param_8)

{
    byte bVar1;
    undefined4 uVar2;
    uint uVar3;
    uint uVar4;
    undefined4 local_2c;
    undefined1 local_1c;
    undefined1 uStack_1b;
    byte bStack_1a;
    byte bStack_19;
    uint uStack_18;
    undefined1 uStack_14;
    byte local_13;
    void *local_10;
    size_t local_c;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        uStack_14 = 0;
        local_13 = 0;
        local_1c = 0x55;
        uStack_1b = 0xaa;
        bStack_1a = (*(byte *)(param_2 + 8) & 1) << 4 | 0x46;
        bStack_19 = 8;
        uStack_18 = (uint) * (byte *)(param_2 + 9);
        uVar2 = reverse_byte_order_32(*(undefined4 *)(param_2 + 4));
        uStack_18._1_3_ = (undefined3)uVar2;
        uStack_14 = (undefined1)((uint)uVar2 >> 0x18);
        uVar3 = bStack_19 - 1;
        uVar4 = uVar3 & 3;
        if ((int)uVar3 < 1) {
            uVar4 = -(-uVar3 & 3);
        }
        local_c = (uint)bStack_19 + (3 - uVar4);
        local_10 = calloc(local_c, 1);
        memset(local_10, 0, local_c);
        memcpy(local_10, &bStack_1a, bStack_19 - 1);
        bVar1 = BM_CRC5(local_10, local_c << 3);
        local_13 = local_13 & 0xe0 | bVar1 & 0x1f;
        free(local_10);
        send_command_packet(param_1, &local_1c, 10);
        local_2c = param_3;
        if (*(char *)(param_2 + 8) != '\x01') {
            local_2c = 1;
        }
        uVar2 = sync_get_dag_base(param_1, local_2c, param_4, param_5, param_7,
                                  param_8);
    } else {
        uVar2 = 4;
    }
    return uVar2;
}

undefined4 set_core_reg_base(int param_1, undefined4 *param_2)

{
    byte bVar1;
    undefined4 uVar2;
    undefined1 local_14;
    undefined1 uStack_13;
    byte bStack_12;
    byte bStack_11;
    undefined1 uStack_10;
    undefined1 uStack_f;
    undefined1 uStack_e;
    undefined4 uStack_d;
    byte local_9;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        uStack_d = 0;
        local_9 = 0;
        local_14 = 0x55;
        uStack_13 = 0xaa;
        bStack_12 = (*(byte *)(param_2 + 2) & 1) << 4 | 0x44;
        bStack_11 = 10;
        uStack_10 = *(undefined1 *)((int)param_2 + 9);
        uStack_f = (undefined1) * (undefined2 *)((int)param_2 + 10);
        uStack_e = *(undefined1 *)(param_2 + 3);
        uStack_d = reverse_byte_order_32(*param_2);
        bVar1 = BM_CRC5(&bStack_12, (bStack_11 - 1) * 8);
        local_9 = local_9 & 0xe0 | bVar1 & 0x1f;
        send_command_packet(param_1, &local_14, 0xc);
        uVar2 = 0;
    } else {
        uVar2 = 4;
    }
    return uVar2;
}

undefined4 set_core_reg_rvn(int param_1, undefined4 *param_2)

{
    byte bVar1;
    undefined2 uVar2;
    undefined4 uVar3;
    undefined1 local_18;
    undefined1 uStack_17;
    byte bStack_16;
    byte bStack_15;
    undefined1 uStack_14;
    undefined1 uStack_13;
    undefined1 uStack_12;
    undefined1 uStack_11;
    undefined1 local_10;
    undefined4 local_f;
    byte local_b;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        uStack_13 = 0;
        uStack_12 = 0;
        uStack_11 = 0;
        local_10 = 0;
        local_f = 0;
        local_b = 0;
        local_18 = 0x55;
        uStack_17 = 0xaa;
        bStack_16 = (*(byte *)(param_2 + 2) & 1) << 4 | 0x44;
        bStack_15 = 0xc;
        uStack_14 = *(undefined1 *)((int)param_2 + 9);
        uVar2 = reverse_byte_order_16(*(ushort *)((int)param_2 + 10) & 0xfff);
        uStack_13 = (undefined1)uVar2;
        uStack_12 = (undefined1)((ushort)uVar2 >> 8);
        uStack_11 = *(undefined1 *)(param_2 + 3);
        local_10 = *(undefined1 *)((int)param_2 + 0xd);
        local_f = reverse_byte_order_32(*param_2);
        bVar1 = BM_CRC5(&bStack_16, (bStack_15 - 1) * 8);
        local_b = local_b & 0xe0 | bVar1 & 0x1f;
        send_command_packet(param_1, &local_18, 0xe);
        uVar3 = 0;
    } else {
        uVar3 = 4;
    }
    return uVar3;
}

undefined4 set_core_reg_base_9(int param_1, undefined4 *param_2)

{
    byte bVar1;
    undefined4 uVar2;
    undefined1 local_14;
    undefined1 uStack_13;
    byte abStack_12[3];
    undefined1 uStack_f;
    undefined1 uStack_e;
    undefined1 uStack_d;
    undefined1 local_c;
    undefined1 local_b;
    byte local_a;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        local_a = 0;
        local_14 = 0x55;
        uStack_13 = 0xaa;
        abStack_12[0] = (*(byte *)(param_2 + 2) & 1) << 4 | 0x44;
        abStack_12[1] = 9;
        abStack_12[2] = *(undefined1 *)((int)param_2 + 9);
        uStack_f = (undefined1) * (undefined2 *)((int)param_2 + 10);
        uStack_e = *(undefined1 *)(param_2 + 3);
        uStack_d = (undefined1)((uint)*param_2 >> 0x10);
        local_c = (undefined1)((uint)*param_2 >> 8);
        local_b = (undefined1)*param_2;
        bVar1 = BM_CRC5(abStack_12, 0x40);
        local_a = local_a & 0xe0 | bVar1 & 0x1f;
        send_command_packet(param_1, &local_14, 0xb);
        uVar2 = 0;
    } else {
        uVar2 = 4;
    }
    return uVar2;
}

undefined4 sync_get_core_reg_base_3(int param_1, int param_2, int param_3,
                                    int param_4, int *param_5,
                                    undefined4 param_6, undefined4 param_7,
                                    undefined4 param_8)

{
    byte bVar1;
    int iVar2;
    uint uVar3;
    int extraout_r2;
    uint uVar4;
    int local_1044;
    undefined1 auStack_1034[4096];
    undefined4 local_34;
    int local_30;
    char local_2c;
    char local_2b;
    undefined1 local_2a;
    byte local_29;
    byte local_28;
    byte local_27;
    undefined1 local_26;
    byte local_25;
    byte local_24;
    undefined4 local_20;
    undefined1 uStack_1c;
    undefined1 uStack_1b;
    undefined1 uStack_1a;
    byte bStack_19;
    undefined4 local_18;
    int local_14;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        local_20._0_3_ =
            CONCAT12((*(byte *)(param_2 + 8) & 1) << 4 | 5, 0xaa55);
        local_20._0_3_ = (uint3)local_20 | 0x400000;
        local_20 = CONCAT13(6, (uint3)local_20);
        _local_20 = CONCAT16(
            *(undefined1 *)(param_2 + 0xc),
            CONCAT15((char)*(undefined2 *)(param_2 + 10),
                     CONCAT14(*(undefined1 *)(param_2 + 9), local_20)));
        bStack_19 = 0;
        bVar1 = BM_CRC5((int)&local_20 + 2, ((local_20 >> 0x18) - 1) * 8);
        _local_20 = CONCAT17(bStack_19 & 0xe0 | bVar1 & 0x1f, _local_20);
        local_1044 = param_3;
        if ((*(char *)(param_2 + 8) != '\x01') &&
            (*(char *)(param_2 + 0xc) != -1)) {
            local_1044 = 1;
        }
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        queue_clear(*(undefined4 *)(param_1 + 0x364));
        send_command_packet(param_1, &local_20, 8);
        local_14 = 0;
        local_18 = 0;
        FUN_000ccdfc(param_7, param_8, 1000, 0);
        local_30 = extraout_r2 * 1000000;
        local_34 = FUN_000ccdfc(param_7, param_8, 1000, 0);
        while (local_14 < local_1044) {
            iVar2 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_2c, 9, &local_34);
            if (iVar2 == 0x6e) {
                local_18 = 3;
                break;
            }
            V_LOCK();
            logfmt_raw(auStack_1034, 0x1000, 0,
                       "core reg: %02x %02x chip addr %02x reg addr %02x reg "
                       "value %02x%02x%02x",
                       local_2c, local_2b, local_26, local_25, local_29,
                       local_28, local_27);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "chip_reg_io_base.c",
                 0xa4, "sync_get_core_reg_base_3", 0x18, 0x25a, 0x14,
                 auStack_1034);
            if (((local_2c != -0x56) || (local_2b != 'U')) ||
                ((local_24 & 0x40) == 0)) {
                local_18 = 1;
                break;
            }
            uVar4 = (uint)local_24;
            uVar3 = BM_CRC5(&local_2a, 0x33);
            if ((uVar4 & 0x1f) == uVar3) {
                *(undefined1 *)(param_4 + local_14 * 0xc + 4) = local_26;
                *(ushort *)(param_4 + local_14 * 0xc + 6) = (ushort)local_25;
                *(undefined1 *)(param_4 + local_14 * 0xc + 8) = local_2a;
                *(uint *)(param_4 + local_14 * 0xc) = (uint)local_27 << 0x18 |
                                                      (uint)local_28 << 0x10 |
                                                      (uint)local_29;
                local_14 = local_14 + 1;
            } else {
                local_18 = 2;
            }
        }
        *param_5 = local_14;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_18 = 4;
    }
    return local_18;
}

undefined4 sync_get_core_reg_rvn(int param_1, int param_2, int param_3,
                                 int param_4, int *param_5, undefined4 param_6,
                                 undefined4 param_7, undefined4 param_8)

{
    byte bVar1;
    int iVar2;
    uint uVar3;
    int extraout_r2;
    uint uVar4;
    int local_44;
    undefined4 local_38;
    int local_34;
    char local_30;
    char local_2f;
    char local_2e;
    undefined1 local_2d;
    undefined4 local_2c;
    undefined1 local_28;
    undefined2 local_27;
    byte local_25;
    undefined1 local_24;
    undefined1 uStack_23;
    byte bStack_22;
    byte bStack_21;
    undefined1 uStack_20;
    undefined2 uStack_1f;
    undefined1 uStack_1d;
    undefined1 local_1c;
    byte local_1b;
    undefined4 local_18;
    int local_14;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        uStack_1f = 0;
        uStack_1d = 0;
        local_1c = 0;
        local_1b = 0;
        local_24 = 0x55;
        uStack_23 = 0xaa;
        bStack_22 = (*(byte *)(param_2 + 8) & 1) << 4 | 0x45;
        bStack_21 = 8;
        uStack_20 = *(undefined1 *)(param_2 + 9);
        uStack_1f = reverse_byte_order_16(*(ushort *)(param_2 + 10) & 0xfff);
        uStack_1d = *(undefined1 *)(param_2 + 0xc);
        local_1c = 0x3f;
        bVar1 = BM_CRC5(&bStack_22, (bStack_21 - 1) * 8);
        local_1b = local_1b & 0xe0 | bVar1 & 0x1f;
        local_44 = param_3;
        if ((*(char *)(param_2 + 8) != '\x01') &&
            (*(char *)(param_2 + 0xc) != -1)) {
            local_44 = 1;
        }
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        queue_clear(*(undefined4 *)(param_1 + 0x364));
        send_command_packet(param_1, &local_24, 10);
        local_14 = 0;
        local_18 = 0;
        FUN_000ccdfc(param_7, param_8, 1000, 0);
        local_34 = extraout_r2 * 1000000;
        local_38 = FUN_000ccdfc(param_7, param_8, 1000, 0);
        while (local_14 < local_44) {
            iVar2 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_30, 0xc, &local_38);
            if (iVar2 == 0x6e) {
                local_18 = 3;
                break;
            }
            if ((((local_30 != -0x56) || (local_2f != 'U')) ||
                 (local_2e != '\n')) ||
                ((local_25 & 0x40) != 0)) {
                local_18 = 1;
                break;
            }
            uVar4 = (uint)local_25;
            uVar3 = BM_CRC5(&local_2e, 0x4b);
            if ((uVar4 & 0x1f) == uVar3) {
                *(undefined1 *)(param_4 + local_14 * 0xc + 4) = local_28;
                *(undefined2 *)(param_4 + local_14 * 0xc + 6) = local_27;
                *(undefined1 *)(param_4 + local_14 * 0xc + 8) = local_2d;
                *(undefined4 *)(param_4 + local_14 * 0xc) = local_2c;
                local_14 = local_14 + 1;
            } else {
                local_18 = 2;
            }
        }
        *param_5 = local_14;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_18 = 4;
    }
    return local_18;
}

undefined4 sync_get_core_reg_base(int param_1, int param_2, int param_3,
                                  int param_4, int *param_5, undefined4 param_6,
                                  undefined4 param_7, undefined4 param_8)

{
    byte bVar1;
    int iVar2;
    uint uVar3;
    int extraout_r2;
    uint uVar4;
    int local_44;
    undefined4 local_34;
    int local_30;
    char local_2c;
    char local_2b;
    char local_2a;
    undefined1 local_29;
    undefined4 local_28;
    undefined1 local_24;
    byte local_23;
    byte local_22;
    undefined4 local_20;
    undefined1 uStack_1c;
    undefined1 uStack_1b;
    undefined1 uStack_1a;
    byte bStack_19;
    undefined4 local_18;
    int local_14;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        local_20._0_3_ =
            CONCAT12((*(byte *)(param_2 + 8) & 1) << 4 | 5, 0xaa55);
        local_20._0_3_ = (uint3)local_20 | 0x400000;
        local_20 = CONCAT13(6, (uint3)local_20);
        _local_20 = CONCAT16(
            *(undefined1 *)(param_2 + 0xc),
            CONCAT15((char)*(undefined2 *)(param_2 + 10),
                     CONCAT14(*(undefined1 *)(param_2 + 9), local_20)));
        bStack_19 = 0;
        bVar1 = BM_CRC5((int)&local_20 + 2, ((local_20 >> 0x18) - 1) * 8);
        _local_20 = CONCAT17(bStack_19 & 0xe0 | bVar1 & 0x1f, _local_20);
        local_44 = param_3;
        if ((*(char *)(param_2 + 8) != '\x01') &&
            (*(char *)(param_2 + 0xc) != -1)) {
            local_44 = 1;
        }
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        queue_clear(*(undefined4 *)(param_1 + 0x364));
        send_command_packet(param_1, &local_20, 8);
        local_14 = 0;
        local_18 = 0;
        FUN_000ccdfc(param_7, param_8, 1000, 0);
        local_30 = extraout_r2 * 1000000;
        local_34 = FUN_000ccdfc(param_7, param_8, 1000, 0);
        while (local_14 < local_44) {
            iVar2 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_2c, 0xb, &local_34);
            if (iVar2 == 0x6e) {
                local_18 = 3;
                break;
            }
            if ((((local_2c != -0x56) || (local_2b != 'U')) ||
                 (local_2a != '\t')) ||
                ((local_22 & 0x40) == 0)) {
                local_18 = 1;
                break;
            }
            uVar4 = (uint)local_22;
            uVar3 = BM_CRC5(&local_2a, 0x43);
            if ((uVar4 & 0x1f) == uVar3) {
                *(undefined1 *)(param_4 + local_14 * 0xc + 4) = local_24;
                *(ushort *)(param_4 + local_14 * 0xc + 6) = (ushort)local_23;
                *(undefined1 *)(param_4 + local_14 * 0xc + 8) = local_29;
                *(undefined4 *)(param_4 + local_14 * 0xc) = local_28;
                local_14 = local_14 + 1;
            } else {
                local_18 = 2;
            }
        }
        *param_5 = local_14;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_18 = 4;
    }
    return local_18;
}

undefined4 sync_get_status_base2(int param_1, int param_2, int param_3,
                                 int *param_4, undefined4 param_5,
                                 undefined4 param_6)

{
    int iVar1;
    uint uVar2;
    int extraout_r2;
    uint uVar3;
    undefined4 local_2c;
    int local_28;
    char local_24;
    char local_23;
    byte local_22;
    undefined1 local_21;
    byte local_20;
    undefined4 local_1f;
    byte local_1b;
    undefined4 local_18;
    int local_14;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        queue_clear(*(undefined4 *)(param_1 + 0x364));
        local_14 = 0;
        local_18 = 0;
        FUN_000ccdfc(param_5, param_6, 1000, 0);
        local_28 = extraout_r2 * 1000000;
        local_2c = FUN_000ccdfc(param_5, param_6, 1000, 0);
        while (local_14 < param_2) {
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_24, 10, &local_2c);
            if (iVar1 == 0x6e) {
                local_18 = 3;
                break;
            }
            if ((((local_24 != -0x56) || (local_23 != 'U')) ||
                 ((local_22 & 0xf) != 0)) ||
                ((local_22 & 0xe0) != 0)) {
                local_18 = 1;
                break;
            }
            uVar3 = (uint)local_1b;
            uVar2 = BM_CRC5(&local_22, 0x38);
            if ((uVar3 & 0x1f) == uVar2) {
                *(undefined1 *)(param_3 + local_14 * 0xc + 4) = local_21;
                *(ushort *)(param_3 + local_14 * 0xc + 6) = (ushort)local_20;
                *(undefined4 *)(param_3 + local_14 * 0xc) = local_1f;
                local_14 = local_14 + 1;
            } else {
                local_18 = 2;
            }
        }
        *param_4 = local_14;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_18 = 4;
    }
    return local_18;
}

undefined4 sync_get_chip_reg_rvn(int param_1, int param_2, undefined4 param_3,
                                 undefined4 param_4, undefined4 param_5,
                                 undefined4 param_6, undefined4 param_7,
                                 undefined4 param_8)

{
    byte bVar1;
    undefined4 uVar2;
    undefined4 local_1c;
    undefined1 local_10;
    undefined1 uStack_f;
    byte abStack_e[3];
    undefined1 local_b;
    byte local_a;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        local_a = 0;
        local_10 = 0x55;
        uStack_f = 0xaa;
        abStack_e[0] = (*(byte *)(param_2 + 8) & 1) << 4 | 0x42;
        abStack_e[1] = 5;
        abStack_e[2] = *(undefined1 *)(param_2 + 9);
        local_b = (undefined1) * (undefined2 *)(param_2 + 10);
        bVar1 = BM_CRC5(abStack_e, 0x20);
        local_a = local_a & 0xe0 | bVar1 & 0x1f;
        send_command_packet(param_1, &local_10, 7);
        local_1c = param_3;
        if (*(char *)(param_2 + 8) != '\x01') {
            local_1c = 1;
        }
        uVar2 = sync_get_status_base4(param_1, local_1c, param_4, param_5,
                                      param_7, param_8);
    } else {
        uVar2 = 4;
    }
    return uVar2;
}

undefined4 sync_get_chip_reg_base2(int param_1, int param_2, undefined4 param_3,
                                   undefined4 param_4, undefined4 param_5,
                                   undefined4 param_6, undefined4 param_7,
                                   undefined4 param_8)

{
    byte bVar1;
    undefined4 uVar2;
    undefined4 local_1c;
    undefined1 local_10;
    undefined1 uStack_f;
    byte abStack_e[3];
    undefined1 local_b;
    byte local_a;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        local_a = 0;
        local_10 = 0x55;
        uStack_f = 0xaa;
        abStack_e[0] = (*(byte *)(param_2 + 8) & 1) << 4 | 0x42;
        abStack_e[1] = 5;
        abStack_e[2] = *(undefined1 *)(param_2 + 9);
        local_b = (undefined1) * (undefined2 *)(param_2 + 10);
        bVar1 = BM_CRC5(abStack_e, 0x20);
        local_a = local_a & 0xe0 | bVar1 & 0x1f;
        send_command_packet(param_1, &local_10, 7);
        local_1c = param_3;
        if (*(char *)(param_2 + 8) != '\x01') {
            local_1c = 1;
        }
        uVar2 = sync_get_status_base2(param_1, local_1c, param_4, param_5,
                                      param_7, param_8);
    } else {
        uVar2 = 4;
    }
    return uVar2;
}

undefined4 sync_get_chip_reg_base3(int param_1, int param_2, int param_3,
                                   int param_4, int *param_5,
                                   undefined4 param_6, undefined4 param_7,
                                   undefined4 param_8)

{
    byte bVar1;
    int iVar2;
    uint uVar3;
    int extraout_r2;
    uint uVar4;
    int local_44;
    undefined4 local_34;
    int local_30;
    char local_2c;
    char local_2b;
    char local_2a;
    undefined4 local_29;
    undefined1 local_25;
    byte local_24;
    byte local_23;
    undefined1 local_20;
    undefined1 uStack_1f;
    byte abStack_1e[3];
    undefined1 local_1b;
    byte local_1a;
    undefined4 local_18;
    int local_14;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        local_1a = 0;
        local_20 = 0x55;
        uStack_1f = 0xaa;
        abStack_1e[0] = (*(byte *)(param_2 + 8) & 1) << 4 | 0x42;
        abStack_1e[1] = 5;
        abStack_1e[2] = *(undefined1 *)(param_2 + 9);
        local_1b = (undefined1) * (undefined2 *)(param_2 + 10);
        bVar1 = BM_CRC5(abStack_1e, 0x20);
        local_1a = local_1a & 0xe0 | bVar1 & 0x1f;
        queue_clear(*(undefined4 *)(param_1 + 0x364));
        send_command_packet(param_1, &local_20, 7);
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        local_44 = param_3;
        if (*(char *)(param_2 + 8) != '\x01') {
            local_44 = 1;
        }
        local_14 = 0;
        local_18 = 0;
        FUN_000ccdfc(param_7, param_8, 1000, 0);
        local_30 = extraout_r2 * 1000000;
        local_34 = FUN_000ccdfc(param_7, param_8, 1000, 0);
        while (local_14 < local_44) {
            iVar2 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_2c, 10, &local_34);
            if (iVar2 == 0x6e) {
                local_18 = 3;
                break;
            }
            if (((local_2c != -0x56) || (local_2b != 'U')) ||
                (local_2a != '\b')) {
                local_18 = 1;
                break;
            }
            uVar4 = (uint)local_23;
            uVar3 = BM_CRC5(&local_2a, 0x3b);
            if ((uVar4 & 0x1f) == uVar3) {
                *(undefined1 *)(param_4 + local_14 * 0xc + 4) = local_25;
                *(ushort *)(param_4 + local_14 * 0xc + 6) = (ushort)local_24;
                *(undefined4 *)(param_4 + local_14 * 0xc) = local_29;
                local_14 = local_14 + 1;
            } else {
                local_18 = 2;
            }
        }
        *param_5 = local_14;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_18 = 4;
    }
    return local_18;
}

undefined4 sync_get_status_base4(int param_1, int param_2, int param_3,
                                 int *param_4, undefined4 param_5,
                                 undefined4 param_6)

{
    int iVar1;
    uint uVar2;
    int extraout_r2;
    uint uVar3;
    undefined4 local_2c;
    int local_28;
    char local_24;
    char local_23;
    char local_22;
    undefined4 local_21;
    undefined1 local_1d;
    byte local_1c;
    byte local_1b;
    undefined4 local_18;
    int local_14;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        queue_clear(*(undefined4 *)(param_1 + 0x364));
        local_14 = 0;
        local_18 = 0;
        FUN_000ccdfc(param_5, param_6, 1000, 0);
        local_28 = extraout_r2 * 1000000;
        local_2c = FUN_000ccdfc(param_5, param_6, 1000, 0);
        while (local_14 < param_2) {
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_24, 10, &local_2c);
            if (iVar1 == 0x6e) {
                local_18 = 3;
                break;
            }
            if (((local_24 != -0x56) || (local_23 != 'U')) ||
                (local_22 != '\b')) {
                local_18 = 1;
                break;
            }
            uVar3 = (uint)local_1b;
            uVar2 = BM_CRC5(&local_22, 0x3b);
            if ((uVar3 & 0x1f) == uVar2) {
                *(undefined1 *)(param_3 + local_14 * 0xc + 4) = local_1d;
                *(ushort *)(param_3 + local_14 * 0xc + 6) = (ushort)local_1c;
                *(undefined4 *)(param_3 + local_14 * 0xc) = local_21;
                local_14 = local_14 + 1;
            } else {
                local_18 = 2;
            }
        }
        *param_4 = local_14;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_18 = 4;
    }
    return local_18;
}

undefined4 set_core_reg_base2(int param_1, undefined4 *param_2)

{
    byte bVar1;
    undefined4 uVar2;
    uint uVar3;
    uint uVar4;
    undefined1 local_20;
    undefined1 uStack_1f;
    byte bStack_1e;
    byte bStack_1d;
    undefined1 uStack_1c;
    undefined1 uStack_1b;
    undefined2 uStack_1a;
    undefined4 local_18;
    byte local_14;
    void *local_10;
    size_t local_c;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        uStack_1a = 0;
        local_18 = 0;
        local_14 = 0;
        local_20 = 0x55;
        uStack_1f = 0xaa;
        bStack_1e = (*(byte *)(param_2 + 2) & 1) << 4 | 0x44;
        bStack_1d = 0xb;
        uStack_1c = *(undefined1 *)((int)param_2 + 9);
        uStack_1b = *(undefined1 *)(param_2 + 3);
        uStack_1a = reverse_byte_order_16(*(undefined2 *)((int)param_2 + 10));
        local_18 = reverse_byte_order_32(*param_2);
        uVar3 = bStack_1d - 1;
        uVar4 = uVar3 & 3;
        if ((int)uVar3 < 1) {
            uVar4 = -(-uVar3 & 3);
        }
        local_c = (bStack_1d - 1) + uVar4;
        local_10 = calloc(local_c, 1);
        memset(local_10, 0, local_c);
        memcpy(local_10, &bStack_1e, bStack_1d - 1);
        bVar1 = BM_CRC5(local_10, local_c << 3);
        local_14 = local_14 & 0xe0 | bVar1 & 0x1f;
        free(local_10);
        send_command_packet(param_1, &local_20, 0xd);
        uVar2 = 0;
    } else {
        uVar2 = 4;
    }
    return uVar2;
}

undefined4 sync_get_core_reg_base2(int param_1, int param_2, int param_3,
                                   int param_4, int *param_5,
                                   undefined4 param_6, undefined4 param_7,
                                   undefined4 param_8)

{
    byte bVar1;
    int iVar2;
    int extraout_r2;
    uint uVar3;
    uint uVar4;
    int local_4c;
    undefined4 local_40;
    int local_3c;
    char local_38;
    char local_37;
    byte local_36;
    undefined1 local_35;
    undefined1 local_34;
    undefined2 local_33;
    undefined4 local_31;
    byte local_2d;
    undefined1 local_2c;
    undefined1 uStack_2b;
    byte bStack_2a;
    byte bStack_29;
    undefined1 uStack_28;
    undefined1 uStack_27;
    undefined2 uStack_26;
    byte local_24;
    void *local_20;
    size_t local_1c;
    undefined4 local_18;
    int local_14;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        uStack_26 = 0;
        local_24 = 0;
        local_2c = 0x55;
        uStack_2b = 0xaa;
        bStack_2a = (*(byte *)(param_2 + 8) & 1) << 4 | 0x45;
        bStack_29 = 7;
        uStack_28 = *(undefined1 *)(param_2 + 9);
        uStack_27 = *(undefined1 *)(param_2 + 0xc);
        uStack_26 = reverse_byte_order_16(*(undefined2 *)(param_2 + 10));
        uVar3 = bStack_29 - 1;
        uVar4 = uVar3 & 3;
        if ((int)uVar3 < 1) {
            uVar4 = -(-uVar3 & 3);
        }
        local_1c = (bStack_29 - 1) + uVar4;
        local_20 = calloc(local_1c, 1);
        memset(local_20, 0, local_1c);
        memcpy(local_20, &bStack_2a, bStack_29 - 1);
        bVar1 = BM_CRC5(local_20, local_1c << 3);
        local_24 = local_24 & 0xe0 | bVar1 & 0x1f;
        free(local_20);
        local_4c = param_3;
        if ((*(char *)(param_2 + 8) != '\x01') &&
            (*(char *)(param_2 + 0xc) != -1)) {
            local_4c = 1;
        }
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        queue_clear(*(undefined4 *)(param_1 + 0x364));
        send_command_packet(param_1, &local_2c, 9);
        local_14 = 0;
        local_18 = 0;
        FUN_000ccdfc(param_7, param_8, 1000, 0);
        local_3c = extraout_r2 * 1000000;
        local_40 = FUN_000ccdfc(param_7, param_8, 1000, 0);
        while (local_14 < local_4c) {
            iVar2 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_38, 0xc, &local_40);
            if (iVar2 == 0x6e) {
                local_18 = 3;
                break;
            }
            if ((((local_38 != -0x56) || (local_37 != 'U')) ||
                 ((local_36 & 0xf) != 1)) ||
                ((local_36 & 0xe0) != 0)) {
                local_18 = 1;
                break;
            }
            uVar3 = (uint)local_2d;
            uVar4 = BM_CRC5(&local_36, 0x48);
            if ((uVar3 & 0x1f) == uVar4) {
                *(undefined1 *)(param_4 + local_14 * 0xc + 4) = local_35;
                *(undefined2 *)(param_4 + local_14 * 0xc + 6) = local_33;
                *(undefined1 *)(param_4 + local_14 * 0xc + 8) = local_34;
                *(undefined4 *)(param_4 + local_14 * 0xc) = local_31;
                local_14 = local_14 + 1;
            } else {
                local_18 = 2;
            }
        }
        *param_5 = local_14;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_18 = 4;
    }
    return local_18;
}

uint set_core_enable_base(int param_1, uint *param_2, __useconds_t param_3)

{
    uint uVar1;
    undefined1 auStack_1014[4096];
    int local_14;
    uint local_10;
    uint local_c;

    local_10 = *param_2;
    local_c = 0;
    while (true) {
        if ((int)(uint) * (byte *)((int)param_2 + 0xd) <= (int)local_c) {
            return local_c;
        }
        if ((local_c & 0x1f) == 0) {
            *param_2 = 0xffffffff;
            if (local_10 != 0) {
                *param_2 = 0;
            }
            uVar1 = local_c + 0x1f;
            if (-1 < (int)local_c) {
                uVar1 = local_c;
            }
            *(short *)((int)param_2 + 10) =
                *(short *)((int)param_2 + 10) + (short)((int)uVar1 >> 5) * 4;
        }
        *(char *)(param_2 + 3) = (char)local_c;
        if (local_10 == 0) {
            *param_2 = *param_2 << 1;
        } else {
            uVar1 = local_c & 0x1f;
            if ((int)local_c < 1) {
                uVar1 = -(-local_c & 0x1f);
            }
            *param_2 = *param_2 | 1 << (uVar1 & 0xff);
        }
        local_14 = (**(code **)(param_1 + 0x114))(param_1, param_2);
        if (local_14 < 0)
            break;
        usleep(param_3);
        local_c = local_c + 1;
    }
    V_LOCK();
    logfmt_raw(auStack_1014, 0x1000, 0, "%s failed, reg:%02x, core_id:%d",
               "set_core_enable_base", *(undefined2 *)((int)param_2 + 10),
               local_c);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/backend/chip_reg_io_base.c",
         0xa4, "set_core_enable_base", 0x14, 0x504, 100, auStack_1014);
    return 0xffffffff;
}

undefined4 set_core_enable_base2(int param_1, int param_2, __useconds_t param_3)

{
    uint uVar1;
    undefined1 auStack_1028[4096];
    undefined1 auStack_28[12];
    undefined4 local_1c;
    int local_18;
    uint local_14;

    puts("set_core_enable_base2");
    local_14 = 0;
    while (true) {
        if ((int)(uint) * (byte *)(param_2 + 0xd) <= (int)local_14) {
            return 0;
        }
        if ((local_14 & 0x1f) == 0) {
            uVar1 = local_14 + 0x1f;
            if (-1 < (int)local_14) {
                uVar1 = local_14;
            }
            *(short *)(param_2 + 10) =
                *(short *)(param_2 + 10) + (short)((int)uVar1 >> 5);
        }
        if (1 < *(byte *)(param_2 + 0xd)) {
            *(char *)(param_2 + 0xc) = (char)local_14;
        }
        local_18 = (**(code **)(param_1 + 0x114))(param_1, param_2);
        if (local_18 < 0)
            break;
        usleep(param_3);
        local_1c = 0;
        (**(code **)(param_1 + 300))(param_1, param_2, 1, auStack_28,
                                     &local_1c);
        local_14 = local_14 + 1;
    }
    V_LOCK();
    logfmt_raw(auStack_1028, 0x1000, 0, "%s failed, reg:%02x, core_id:%d",
               "set_core_enable_base2", *(undefined2 *)(param_2 + 10),
               local_14);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/backend/chip_reg_io_base.c",
         0xa4, "set_core_enable_base2", 0x15, 0x517, 100, auStack_1028);
    return 3;
}

undefined4 sync_get_status_base(int param_1, int param_2, int param_3,
                                int *param_4, undefined4 param_5,
                                undefined4 param_6)

{
    int iVar1;
    uint uVar2;
    int extraout_r2;
    uint uVar3;
    undefined1 auStack_102c[4096];
    undefined4 local_2c;
    int local_28;
    char local_24;
    char local_23;
    char local_22;
    undefined4 local_21;
    undefined1 local_1d;
    byte local_1c;
    byte local_1b;
    undefined4 local_18;
    int local_14;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        queue_clear(*(undefined4 *)(param_1 + 0x364));
        local_14 = 0;
        local_18 = 0;
        FUN_000ccdfc(param_5, param_6, 1000, 0);
        local_28 = extraout_r2 * 1000000;
        local_2c = FUN_000ccdfc(param_5, param_6, 1000, 0);
        while (local_14 < param_2) {
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_24, 10, &local_2c);
            if (iVar1 == 0x6e) {
                local_18 = 3;
                break;
            }
            V_LOCK();
            logfmt_raw(
                auStack_102c, 0x1000, 0,
                "header:%02x%02x chip_addr:%02x, reg value:%08x, reg addr:%02x",
                local_24, local_23, local_1d, local_21, local_1c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "chip_reg_io_base.c",
                 0xa4, "sync_get_status_base", 0x14, 0x547, 0x14, auStack_102c);
            if ((((local_24 != -0x56) || (local_23 != 'U')) ||
                 (local_22 != '\b')) ||
                (((local_1b & 0x40) != 0 || ((local_1b & 0x40) != 0)))) {
                local_18 = 1;
                break;
            }
            uVar3 = (uint)local_1b;
            uVar2 = BM_CRC5(&local_22, 0x3b);
            if ((uVar3 & 0x1f) == uVar2) {
                *(undefined1 *)(param_3 + local_14 * 0xc + 4) = local_1d;
                *(ushort *)(param_3 + local_14 * 0xc + 6) = (ushort)local_1c;
                *(undefined4 *)(param_3 + local_14 * 0xc) = local_21;
                local_14 = local_14 + 1;
            } else {
                local_18 = 2;
            }
        }
        *param_4 = local_14;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_18 = 4;
    }
    return local_18;
}

undefined4 sync_get_status_base3(int param_1, int param_2, int param_3,
                                 int *param_4, undefined4 param_5,
                                 undefined4 param_6)

{
    int iVar1;
    uint uVar2;
    int extraout_r2;
    uint uVar3;
    undefined1 auStack_102c[4096];
    undefined4 local_2c;
    int local_28;
    char local_24;
    char local_23;
    byte local_22;
    undefined4 local_21;
    undefined1 local_1d;
    byte local_1c;
    undefined4 local_18;
    int local_14;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        queue_clear(*(undefined4 *)(param_1 + 0x364));
        local_14 = 0;
        local_18 = 0;
        FUN_000ccdfc(param_5, param_6, 1000, 0);
        local_28 = extraout_r2 * 1000000;
        local_2c = FUN_000ccdfc(param_5, param_6, 1000, 0);
        while (local_14 < param_2) {
            iVar1 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_24, 9, &local_2c);
            if (iVar1 == 0x6e) {
                local_18 = 3;
                break;
            }
            V_LOCK();
            logfmt_raw(
                auStack_102c, 0x1000, 0,
                "header:%02x%02x chip_addr:%02x, reg value:%08x, reg addr:%02x",
                local_24, local_23, local_1d, local_21, local_22);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "chip_reg_io_base.c",
                 0xa4, "sync_get_status_base3", 0x15, 0x58b, 0x14,
                 auStack_102c);
            if ((local_24 != -0x56) || (local_23 != 'U')) {
                local_18 = 1;
                break;
            }
            uVar3 = (uint)local_1c;
            uVar2 = BM_CRC5(&local_22, 0x33);
            if ((uVar3 & 0x1f) == uVar2) {
                *(undefined1 *)(param_3 + local_14 * 0xc + 4) = local_1d;
                *(ushort *)(param_3 + local_14 * 0xc + 6) = (ushort)local_22;
                *(undefined4 *)(param_3 + local_14 * 0xc) = local_21;
                local_14 = local_14 + 1;
            } else {
                local_18 = 2;
            }
        }
        *param_4 = local_14;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_18 = 4;
    }
    return local_18;
}

undefined4 sync_get_core_reg_base3(int param_1, int param_2, int param_3,
                                   int param_4, int *param_5,
                                   undefined4 param_6, undefined4 param_7,
                                   undefined4 param_8)

{
    byte bVar1;
    int iVar2;
    uint uVar3;
    int extraout_r2;
    uint uVar4;
    int local_44;
    undefined4 local_34;
    int local_30;
    char local_2c;
    char local_2b;
    char local_2a;
    undefined1 local_29;
    byte local_28;
    byte local_27;
    byte local_26;
    undefined1 local_25;
    byte local_24;
    byte local_23;
    undefined4 local_20;
    undefined1 uStack_1c;
    undefined1 uStack_1b;
    undefined1 uStack_1a;
    byte bStack_19;
    undefined4 local_18;
    int local_14;

    if (*(char *)(param_1 + 0x100) == '\x01') {
        local_20._0_3_ =
            CONCAT12((*(byte *)(param_2 + 8) & 1) << 4 | 5, 0xaa55);
        local_20._0_3_ = (uint3)local_20 | 0x400000;
        local_20 = CONCAT13(6, (uint3)local_20);
        _local_20 = CONCAT16(
            *(undefined1 *)(param_2 + 0xc),
            CONCAT15((char)*(undefined2 *)(param_2 + 10),
                     CONCAT14(*(undefined1 *)(param_2 + 9), local_20)));
        bStack_19 = 0;
        bVar1 = BM_CRC5((int)&local_20 + 2, ((local_20 >> 0x18) - 1) * 8);
        _local_20 = CONCAT17(bStack_19 & 0xe0 | bVar1 & 0x1f, _local_20);
        local_44 = param_3;
        if ((*(char *)(param_2 + 8) != '\x01') &&
            (*(char *)(param_2 + 0xc) != -1)) {
            local_44 = 1;
        }
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x400));
        queue_clear(*(undefined4 *)(param_1 + 0x364));
        send_command_packet(param_1, &local_20, 8);
        local_14 = 0;
        local_18 = 0;
        FUN_000ccdfc(param_7, param_8, 1000, 0);
        local_30 = extraout_r2 * 1000000;
        local_34 = FUN_000ccdfc(param_7, param_8, 1000, 0);
        while (local_14 < local_44) {
            iVar2 = queue_dequeue_for(*(undefined4 *)(param_1 + 0x364),
                                      &local_2c, 10, &local_34);
            if (iVar2 == 0x6e) {
                local_18 = 3;
                break;
            }
            if ((((local_2c != -0x56) || (local_2b != 'U')) ||
                 (local_2a != '\b')) ||
                (((local_23 & 0x40) == 0 || ((local_23 & 0x80) != 0)))) {
                local_18 = 1;
                break;
            }
            uVar4 = (uint)local_23;
            uVar3 = BM_CRC5(&local_2a, 0x3b);
            if ((uVar4 & 0x1f) == uVar3) {
                *(undefined1 *)(param_4 + local_14 * 0xc + 4) = local_25;
                *(ushort *)(param_4 + local_14 * 0xc + 6) = (ushort)local_24;
                *(undefined1 *)(param_4 + local_14 * 0xc + 8) = local_29;
                *(uint *)(param_4 + local_14 * 0xc) = (uint)local_28 << 0x10 |
                                                      (uint)local_27 << 8 |
                                                      (uint)local_26;
                local_14 = local_14 + 1;
            } else {
                local_18 = 2;
            }
        }
        *param_5 = local_14;
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x400));
    } else {
        local_18 = 4;
    }
    return local_18;
}

undefined4 get_fake_regio_runtime(int param_1)

{
    void *pvVar1;
    int iVar2;
    undefined4 uVar3;

    if (*(int *)(&DAT_0015fff0 + param_1 * 4) == 0) {
        pvVar1 = calloc(1, 0x510);
        *(void **)(&DAT_0015fff0 + param_1 * 4) = pvVar1;
        *(int *)(*(int *)(&DAT_0015fff0 + param_1 * 4) + 0xf8) = param_1;
        iVar2 = dev_ctrl();
        (**(code **)(iVar2 + 4))(param_1);
        pthread_mutex_init(
            (pthread_mutex_t *)(*(int *)(&DAT_0015fff0 + param_1 * 4) + 0x400),
            (pthread_mutexattr_t *)0x0);
        pthread_mutex_init(
            (pthread_mutex_t *)(*(int *)(&DAT_0015fff0 + param_1 * 4) + 0x418),
            (pthread_mutexattr_t *)0x0);
        iVar2 = *(int *)(&DAT_0015fff0 + param_1 * 4);
        uVar3 = queue_new(1, 0);
        *(undefined4 *)(iVar2 + 0x364) = uVar3;
        *(undefined4 *)(*(int *)(&DAT_0015fff0 + param_1 * 4) + 0x35c) =
            *(undefined4 *)(*(int *)(&DAT_0015fff0 + param_1 * 4) + 0x364);
        *(code **)(*(int *)(&DAT_0015fff0 + param_1 * 4) + 0x104) =
            set_chipaddr_base;
        *(code **)(*(int *)(&DAT_0015fff0 + param_1 * 4) + 0x108) =
            set_inactive_base;
        *(code **)(*(int *)(&DAT_0015fff0 + param_1 * 4) + 0x10c) =
            set_chip_reg_base;
        *(code **)(*(int *)(&DAT_0015fff0 + param_1 * 4) + 0x110) =
            set_core_reg_base;
        *(code **)(*(int *)(&DAT_0015fff0 + param_1 * 4) + 0x120) =
            sync_get_chip_reg_base;
        *(code **)(*(int *)(&DAT_0015fff0 + param_1 * 4) + 300) =
            sync_get_core_reg_base;
        *(undefined1 *)(*(int *)(&DAT_0015fff0 + param_1 * 4) + 0x100) = 1;
    }
    return *(undefined4 *)(&DAT_0015fff0 + param_1 * 4);
}

undefined4 set_chipaddr_by_id(int param_1, undefined4 param_2,
                              undefined4 param_3)

{
    undefined4 uVar1;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    local_24 = 0;
    local_14 = param_1;
    local_10 = param_1;
    local_18 = get_all_created_runtime(&local_24);
    local_1c = 0;
    do {
        if (local_24 <= local_1c) {
            local_20 = 0;
        LAB_000b12c8:
            if (local_20 == 0) {
                local_20 = get_fake_regio_runtime(local_10);
            }
            local_c = local_20;
            uVar1 = (**(code **)(local_20 + 0x104))(local_20, param_2, param_3);
            return uVar1;
        }
        if (local_14 == *(int *)(*(int *)(local_18 + local_1c * 4) + 0xf8)) {
            local_20 = *(int *)(local_18 + local_1c * 4);
            goto LAB_000b12c8;
        }
        local_1c = local_1c + 1;
    } while (true);
}

undefined4 set_inactive_by_id(int param_1)

{
    undefined4 uVar1;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    local_24 = 0;
    local_14 = param_1;
    local_10 = param_1;
    local_18 = get_all_created_runtime(&local_24);
    local_1c = 0;
    do {
        if (local_24 <= local_1c) {
            local_20 = 0;
        LAB_000b13b4:
            if (local_20 == 0) {
                local_20 = get_fake_regio_runtime(local_10);
            }
            local_c = local_20;
            uVar1 = (**(code **)(local_20 + 0x108))(local_20);
            return uVar1;
        }
        if (local_14 == *(int *)(*(int *)(local_18 + local_1c * 4) + 0xf8)) {
            local_20 = *(int *)(local_18 + local_1c * 4);
            goto LAB_000b13b4;
        }
        local_1c = local_1c + 1;
    } while (true);
}

undefined4 set_chip_reg_by_id(int param_1, undefined4 param_2)

{
    undefined4 uVar1;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    local_24 = 0;
    local_14 = param_1;
    local_10 = param_1;
    local_18 = get_all_created_runtime(&local_24);
    local_1c = 0;
    do {
        if (local_24 <= local_1c) {
            local_20 = 0;
        LAB_000b149c:
            if (local_20 == 0) {
                local_20 = get_fake_regio_runtime(local_10);
            }
            local_c = local_20;
            uVar1 = (**(code **)(local_20 + 0x10c))(local_20, param_2);
            return uVar1;
        }
        if (local_14 == *(int *)(*(int *)(local_18 + local_1c * 4) + 0xf8)) {
            local_20 = *(int *)(local_18 + local_1c * 4);
            goto LAB_000b149c;
        }
        local_1c = local_1c + 1;
    } while (true);
}

undefined4 set_core_reg_by_id(int param_1, undefined4 param_2)

{
    undefined4 uVar1;
    int local_24;
    int local_20;
    int local_1c;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    local_24 = 0;
    local_14 = param_1;
    local_10 = param_1;
    local_18 = get_all_created_runtime(&local_24);
    local_1c = 0;
    do {
        if (local_24 <= local_1c) {
            local_20 = 0;
        LAB_000b1588:
            if (local_20 == 0) {
                local_20 = get_fake_regio_runtime(local_10);
            }
            local_c = local_20;
            uVar1 = (**(code **)(local_20 + 0x110))(local_20, param_2);
            return uVar1;
        }
        if (local_14 == *(int *)(*(int *)(local_18 + local_1c * 4) + 0xf8)) {
            local_20 = *(int *)(local_18 + local_1c * 4);
            goto LAB_000b1588;
        }
        local_1c = local_1c + 1;
    } while (true);
}

undefined4 sync_get_chip_reg_by_id(int param_1, undefined4 param_2,
                                   undefined4 param_3, undefined4 param_4,
                                   undefined4 param_5)

{
    int local_30;
    void *local_2c;
    int local_28;
    int local_24;
    int local_20;
    int local_1c;
    undefined4 local_18;
    void *local_14;

    local_30 = 0;
    local_20 = param_1;
    local_1c = param_1;
    local_24 = get_all_created_runtime(&local_30);
    local_28 = 0;
    do {
        if (local_30 <= local_28) {
            local_2c = (void *)0x0;
        LAB_000b167c:
            if (local_2c == (void *)0x0) {
                local_2c = (void *)get_fake_regio_runtime(local_1c);
            }
            local_14 = local_2c;
            if (*(int *)((int)local_2c + 0x35c) ==
                *(int *)((int)local_2c + 0x364)) {
                pthread_create((pthread_t *)((int)local_2c + 0x3f4),
                               (pthread_attr_t *)0x0, get_response, local_2c);
            }
            local_18 = (**(code **)((int)local_14 + 0x120))(
                local_14, param_2, param_3, param_4, param_5);
            if (*(int *)((int)local_14 + 0x35c) ==
                *(int *)((int)local_14 + 0x364)) {
                *(undefined1 *)((int)local_14 + 0x3fd) = 1;
                pthread_join(*(pthread_t *)((int)local_14 + 0x3f4),
                             (void **)0x0);
            }
            return local_18;
        }
        if (local_20 == *(int *)(*(int *)(local_24 + local_28 * 4) + 0xf8)) {
            local_2c = *(void **)(local_24 + local_28 * 4);
            goto LAB_000b167c;
        }
        local_28 = local_28 + 1;
    } while (true);
}

undefined4 sync_get_core_reg_by_id(int param_1, undefined4 param_2,
                                   undefined4 param_3, undefined4 param_4,
                                   undefined4 param_5)

{
    int local_30;
    void *local_2c;
    int local_28;
    int local_24;
    int local_20;
    int local_1c;
    undefined4 local_18;
    void *local_14;

    local_30 = 0;
    local_20 = param_1;
    local_1c = param_1;
    local_24 = get_all_created_runtime(&local_30);
    local_28 = 0;
    do {
        if (local_30 <= local_28) {
            local_2c = (void *)0x0;
        LAB_000b17f8:
            if (local_2c == (void *)0x0) {
                local_2c = (void *)get_fake_regio_runtime(local_1c);
            }
            local_14 = local_2c;
            if (*(int *)((int)local_2c + 0x35c) ==
                *(int *)((int)local_2c + 0x364)) {
                pthread_create((pthread_t *)((int)local_2c + 0x3f4),
                               (pthread_attr_t *)0x0, get_response, local_2c);
            }
            local_18 = (**(code **)((int)local_14 + 300))(
                local_14, param_2, param_3, param_4, param_5);
            if (*(int *)((int)local_14 + 0x35c) ==
                *(int *)((int)local_14 + 0x364)) {
                *(undefined1 *)((int)local_14 + 0x3fd) = 1;
                pthread_join(*(pthread_t *)((int)local_14 + 0x3f4),
                             (void **)0x0);
            }
            return local_18;
        }
        if (local_20 == *(int *)(*(int *)(local_24 + local_28 * 4) + 0xf8)) {
            local_2c = *(void **)(local_24 + local_28 * 4);
            goto LAB_000b17f8;
        }
        local_28 = local_28 + 1;
    } while (true);
}

uint FUN_000b18c8(uint param_1)

{
    return param_1 << 0x18 | (param_1 >> 8 & 0xff) << 0x10 |
           (param_1 >> 0x10 & 0xff) << 8 | param_1 >> 0x18;
}

void FUN_000b18f0(undefined4 param_1, undefined4 param_2, undefined4 param_3,
                  undefined4 param_4)

{
    check_and_print_uart_debug_log(param_1, param_2, param_3, param_4, 1);
    return;
}

ushort reverse_byte_order_16(ushort param_1)

{
    return param_1 << 8 | param_1 >> 8;
}

undefined4 reverse_byte_order_32(undefined4 param_1)

{
    undefined4 uVar1;

    uVar1 = FUN_000b18c8(param_1);
    return uVar1;
}

int send_command_packet(int param_1, undefined4 param_2, uint param_3)

{
    int iVar1;
    uint uVar2;
    undefined1 auStack_100c[4096];
    int local_c;

    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x418));
    local_c = 0;
    while (true) {
        iVar1 = dev_ctrl();
        uVar2 = (**(code **)(iVar1 + 0x40))(*(undefined4 *)(param_1 + 0xf8));
        if (param_3 <= uVar2)
            break;
        usleep(10000);
    }
    iVar1 = dev_ctrl();
    local_c = (**(code **)(iVar1 + 0x38))(*(undefined4 *)(param_1 + 0xf8),
                                          param_2, param_3);
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x418));
    FUN_000b18f0(param_1 + 0x4c0, param_3, param_2,
                 *(undefined4 *)(param_1 + 0xfc));
    if (local_c < 1) {
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0,
                   "device %d send cmd failed, errcode %d ",
                   *(undefined4 *)(param_1 + 0xf8), local_c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/chip_reg_io_interface.c",
             0xa9, "send_command_packet", 0x13, 0x2e, 100, auStack_100c);
    }
    return local_c;
}

undefined4 convert_offset_to_chain_id(int param_1)

{
    return *(undefined4 *)(g_chain_info + param_1 * 8);
}

undefined4 scan_miner_device_hal(void)

{
    return total_chain;
}

undefined4 dev_init_hal(int param_1)

{
    int iVar1;
    undefined4 uVar2;
    undefined1 auStack_1018[4099];
    undefined1 local_15;
    int local_14;
    uint local_10;
    uint local_c;

    iVar1 = platform_init();
    if (iVar1 == 0) {
        total_chain = 0;
        local_c = get_hash_on_plug();
        for (local_10 = 0; local_10 < 0x10; local_10 = local_10 + 1) {
            if ((local_c >> (local_10 & 0xff) & 1) != 0) {
                *(uint *)(g_chain_info + total_chain * 8) = local_10;
                g_chain_info[total_chain * 8 + 4] = 1;
                V_LOCK();
                logfmt_raw(auStack_1018, 0x1000, 0, "chain_offset %d, chain %d",
                           total_chain,
                           *(undefined4 *)(g_chain_info + total_chain * 8));
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/platform_device_hal.c",
                     0xae, "dev_init_hal", 0xc, 0x45, 0x3c, auStack_1018);
                iVar1 = platform_is_pic_mcu_en();
                if (iVar1 != 0) {
                    iVar1 = open_pic(local_10 & 0xff);
                    if (iVar1 < 0) {
                        V_LOCK();
                        logfmt_raw(
                            auStack_1018, 0x1000, 0,
                            "chain_offset %d, chain %d, open pic error!",
                            total_chain,
                            *(undefined4 *)(g_chain_info + total_chain * 8));
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/device/"
                             "platform_device_hal.c",
                             0xae, "dev_init_hal", 0xc, 0x49, 100,
                             auStack_1018);
                        return 0xffffffff;
                    }
                    pic1704_reset(local_10 & 0xff);
                    usleep(300000);
                    pic1704_jump_to_app(local_10 & 0xff);
                    usleep(300000);
                    local_14 = pic1704_get_sw_version(
                        *(uint *)(g_chain_info + total_chain * 8) & 0xff,
                        &local_15);
                    if (local_14 == 0) {
                        V_LOCK();
                        logfmt_raw(
                            auStack_1018, 0x1000, 0,
                            "chain_offset %d, chain %d, get_sw_version error!",
                            total_chain,
                            *(undefined4 *)(g_chain_info + total_chain * 8));
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/device/"
                             "platform_device_hal.c",
                             0xae, "dev_init_hal", 0xc, 0x54, 100,
                             auStack_1018);
                        return 0xffffffff;
                    }
                    V_LOCK();
                    logfmt_raw(auStack_1018, 0x1000, 0,
                               "chain_offset %d, chain %d, pic firmware verion "
                               "= 0x%02x",
                               total_chain,
                               *(undefined4 *)(g_chain_info + total_chain * 8),
                               local_15);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/platform_device_hal.c",
                         0xae, "dev_init_hal", 0xc, 0x5a, 0x3c, auStack_1018);
                }
                total_chain = total_chain + 1;
            }
        }
        if (param_1 != total_chain) {
            set_miner_6060info_board_num_less_than_design_err(1);
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0,
                       "phyiscal chain num = %d, total chain num = %d", param_1,
                       total_chain);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/platform_device_hal.c",
                 0xae, "dev_init_hal", 0xc, 99, 100, auStack_1018);
        }
        fpga_reset();
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, "reset fpga");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/"
             "platform_device_hal.c",
             0xae, "dev_init_hal", 0xc, 0x67, 0x14, auStack_1018);
        enable_bypass_mode();
        dev_config_hal(&WORD_0001c200);
        uVar2 = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, "platform init failed!");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/"
             "platform_device_hal.c",
             0xae, "dev_init_hal", 0xc, 0x3b, 100, auStack_1018);
        uVar2 = 0xffffffff;
    }
    return uVar2;
}

undefined4 dev_init_hal_pcba(void)

{
    int iVar1;
    undefined4 uVar2;
    undefined1 auStack_1010[4096];
    uint local_10;
    uint local_c;

    iVar1 = platform_init();
    if (iVar1 == 0) {
        total_chain = 0;
        local_10 = get_hash_on_plug();
        printf("plug_on_status: %x\n", local_10);
        for (local_c = 0; local_c < 0x10; local_c = local_c + 1) {
            if ((local_10 >> (local_c & 0xff) & 1) != 0) {
                *(uint *)(g_chain_info + total_chain * 8) = local_c;
                g_chain_info[total_chain * 8 + 4] = 1;
                printf("chain_offset %d, chain %d\n", total_chain,
                       *(undefined4 *)(g_chain_info + total_chain * 8));
                total_chain = total_chain + 1;
            }
        }
        enable_bypass_mode();
        dev_config_hal(&WORD_0001c200);
        uVar2 = 0;
    } else {
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, "platform init failed!");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/"
             "platform_device_hal.c",
             0xae, "dev_init_hal_pcba", 0x11, 0x74, 100, auStack_1010);
        uVar2 = 0xffffffff;
    }
    return uVar2;
}

undefined4 dev_init_pic_for_one_chain(int param_1)

{
    int iVar1;
    undefined1 auStack_1008[4096];

    iVar1 = platform_is_pic_mcu_en();
    if (iVar1 != 0) {
        if (g_chain_info[param_1 * 8 + 4] != '\x01') {
            printf("Chain offset %d is invalid\n", param_1);
            return 0xffffffff;
        }
        iVar1 = open_pic(*(uint *)(g_chain_info + param_1 * 8) & 0xff);
        if (iVar1 < 0) {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       "chain offset %d, id %d, open pic error!\n", param_1,
                       *(undefined4 *)(g_chain_info + param_1 * 8));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/platform_device_hal.c",
                 0xae, "dev_init_pic_for_one_chain", 0x1a, 0x93, 100,
                 auStack_1008);
            return 0xffffffff;
        }
        iVar1 = pic1704_reset(*(uint *)(g_chain_info + param_1 * 8) & 0xff);
        if (iVar1 == 0) {
            printf("chain offset %d, id %d, reset pic error!\n", param_1,
                   *(undefined4 *)(g_chain_info + param_1 * 8));
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0, "Sweep error string = J%d:5.",
                       *(undefined4 *)(g_chain_info + param_1 * 8));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/platform_device_hal.c",
                 0xae, "dev_init_pic_for_one_chain", 0x1a, 0x99, 100,
                 auStack_1008);
            return 0xffffffff;
        }
        usleep(300000);
        iVar1 =
            pic1704_jump_to_app(*(uint *)(g_chain_info + param_1 * 8) & 0xff);
        if (iVar1 == 0) {
            printf("chain offset %d, id %d, pic jump to app error!\n", param_1,
                   *(undefined4 *)(g_chain_info + param_1 * 8));
            return 0xffffffff;
        }
        usleep(300000);
    }
    return 0;
}

undefined4 sub_dev_init_hal(uint param_1)

{
    if (total_chain <= param_1) {
        puts("warning: get pcie fd error");
    }
    return *(undefined4 *)(g_chain_info + param_1 * 8);
}

undefined1 dev_is_valid_hal(int param_1)

{
    return g_chain_info[param_1 * 8 + 4];
}

void set_dev_invalid_hal(int param_1)

{
    g_chain_info[param_1 * 8 + 4] = 0;
    total_chain = total_chain + -1;
    return;
}

undefined4 dev_config_hal(word *param_1)

{
    int local_1c;
    undefined4 local_18;
    int local_14;
    int local_10;
    undefined4 local_c;

    local_14 = get_all_created_runtime(&local_1c);
    if (param_1 == (word *)0x17d784) {
    LAB_000b2834:
        local_c = 1;
    } else {
        if ((int)param_1 < 0x17d785) {
            if (param_1 == (word *)0x70800) {
                local_c = 6;
                goto LAB_000b2870;
            }
            if ((int)param_1 < 0x70801) {
                if (param_1 == &WORD_0001c200) {
                    local_c = 0x1a;
                    goto LAB_000b2870;
                }
            } else {
                if (param_1 == (word *)&UNK_000e1000) {
                    local_c = 2;
                    goto LAB_000b2870;
                }
                if (param_1 == (word *)0x16e360)
                    goto LAB_000b2834;
            }
        } else {
            if (param_1 == (word *)0x5f5e10) {
                local_c = 3;
                goto LAB_000b2870;
            }
            if ((int)param_1 < 0x5f5e11) {
                if ((param_1 == (word *)0x2dc6c0) ||
                    (param_1 == (word *)0x2faf08)) {
                    local_c = 0;
                    goto LAB_000b2870;
                }
            } else {
                if (param_1 == (word *)0xbebc20) {
                    local_c = 4;
                    goto LAB_000b2870;
                }
                if (param_1 == (word *)0x17d7840) {
                    local_c = 5;
                    goto LAB_000b2870;
                }
            }
        }
        local_c = 0x1a;
    }
LAB_000b2870:
    printf("%s: set zynq bt8d %d\n", "dev_config_hal", local_c);
    local_18 = local_c;
    for (local_10 = 0; local_10 < local_1c; local_10 = local_10 + 1) {
        uart_set_config(
            *(undefined4 *)(*(int *)(local_14 + local_10 * 4) + 0xfc), 0,
            &local_18, 4);
    }
    usleep(100000);
    return 0;
}

undefined4 dev_config_one_chain_baud(uint param_1, word *param_2)

{
    undefined1 auStack_14[4];
    uint local_10;
    int local_c;

    uart_get_config(0, 0, &local_10, auStack_14);
    printf("%s: get zynq bt8d %08x\n", "dev_config_one_chain_baud", local_10);
    if (param_2 == (word *)0x17d784) {
    LAB_000b2a4c:
        local_c = 1;
    } else {
        if ((int)param_2 < 0x17d785) {
            if (param_2 == (word *)0x70800) {
                local_c = 6;
                goto LAB_000b2a88;
            }
            if ((int)param_2 < 0x70801) {
                if (param_2 == &WORD_0001c200) {
                    local_c = 0x1a;
                    goto LAB_000b2a88;
                }
            } else {
                if (param_2 == (word *)&UNK_000e1000) {
                    local_c = 2;
                    goto LAB_000b2a88;
                }
                if (param_2 == (word *)0x16e360)
                    goto LAB_000b2a4c;
            }
        } else {
            if (param_2 == (word *)0x5f5e10) {
                local_c = 3;
                goto LAB_000b2a88;
            }
            if ((int)param_2 < 0x5f5e11) {
                if ((param_2 == (word *)0x2dc6c0) ||
                    (param_2 == (word *)0x2faf08)) {
                    local_c = 0;
                    goto LAB_000b2a88;
                }
            } else {
                if (param_2 == (word *)0xbebc20) {
                    local_c = 4;
                    goto LAB_000b2a88;
                }
                if (param_2 == (word *)0x17d7840) {
                    local_c = 5;
                    goto LAB_000b2a88;
                }
            }
        }
        local_c = 0x1a;
    }
LAB_000b2a88:
    printf("%s: set zynq bt8d %d\n", "dev_config_one_chain_baud", local_c);
    local_10 = local_c << ((param_1 & 0x1f) << 3) |
               local_10 & ~(0x3f << ((param_1 & 0x1f) << 3));
    uart_set_config(param_1, 0, &local_10, 4);
    usleep(100000);
    uart_get_config(0, 0, &local_10, auStack_14);
    printf("%s: after set baud, get zynq bt8d %08x\n",
           "dev_config_one_chain_baud", local_10);
    return 0;
}

void dump_log_hal(undefined4 param_1, undefined4 param_2, int param_3,
                  int param_4)

{
    int local_c;

    printf("%s[%d] ", param_1, param_2);
    for (local_c = 0; local_c < param_4; local_c = local_c + 1) {
        printf("%02x ", (uint) * (byte *)(param_3 + local_c));
    }
    putchar(10);
    return;
}

int dev_send_work_cmd_hal(int param_1, int param_2, uint param_3)

{
    int iVar1;
    int local_10;
    uint local_c;

    local_10 = 0;
    for (local_c = 0; local_c < param_3 >> 7; local_c = local_c + 1) {
        iVar1 = uart_send(*(undefined4 *)(g_chain_info + param_1 * 8),
                          param_2 + local_c * 0x80, 0x80);
        local_10 = local_10 + iVar1;
    }
    iVar1 = uart_send(*(undefined4 *)(g_chain_info + param_1 * 8),
                      param_2 + local_c * 0x80, param_3 & 0x7f);
    return local_10 + iVar1;
}

undefined4 dev_send_reg_cmd_hal(int param_1, undefined4 param_2,
                                undefined4 param_3)

{
    undefined4 uVar1;

    uVar1 = uart_send(*(undefined4 *)(g_chain_info + param_1 * 8), param_2,
                      param_3);
    return uVar1;
}

undefined4 dev_read_nonce_reg_data_hal(int param_1, undefined4 param_2,
                                       undefined4 param_3)

{
    undefined4 uVar1;

    uVar1 = uart_receive(*(undefined4 *)(g_chain_info + param_1 * 8), param_2,
                         param_3, 0);
    return uVar1;
}

undefined4 dev_get_nonce_reg_fifo_size_hal(void)

{
    return 0;
}

undefined4 dev_get_reg_fifo_capacity_hal(void)

{
    return 0x10000;
}

undefined4 dev_get_work_fifo_capacity_hal(void)

{
    return 0x10000;
}

undefined4 dev_dma_rw_dispatcher_hal(void)

{
    return 0;
}

undefined4 dev_exit_hal(void)

{
    uart_uninit();
    fpga_uninit();
    platform_uninit();
    return 0;
}

undefined4 power_on_hal(int param_1, undefined2 param_2, int param_3)

{
    int iVar1;
    undefined1 auStack_1014[4096];
    undefined4 local_14;
    undefined4 local_10;
    int local_c;

    local_c = 0;
    local_10 = 0;
    local_14 = 2;
    iVar1 = platform_is_pic_mcu_en();
    if (iVar1 != 0) {
        iVar1 = pic1704_reset(*(uint *)(g_chain_info + param_1 * 8) & 0xff);
        local_c = local_c + iVar1;
        usleep(300000);
        iVar1 =
            pic1704_jump_to_app(*(uint *)(g_chain_info + param_1 * 8) & 0xff);
        local_c = iVar1 + local_c;
        usleep(300000);
    }
    if ((param_3 == 0) && (iVar1 = platform_is_pic_mcu_en(), iVar1 != 0)) {
        set_chain_isl_voltage(*(undefined4 *)(g_chain_info + param_1 * 8),
                              param_2);
    }
    iVar1 = platform_is_pic_mcu_en();
    if (iVar1 != 0) {
        iVar1 = pic1704_enable_disable_dc_dc(
            *(uint *)(g_chain_info + param_1 * 8) & 0xff, 1);
        local_c = local_c + iVar1;
        if (local_c != 3) {
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0,
                       "chain %d, pic init failed, err:%d!!!",
                       *(undefined4 *)(g_chain_info + param_1 * 8), local_c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/platform_device_hal.c",
                 0xae, "power_on_hal", 0xc, 0x1cc, 100, auStack_1014);
            return 0xffffffff;
        }
    }
    sleep(1);
    return 0;
}

undefined4 power_off_hal(int param_1)

{
    int iVar1;

    iVar1 = platform_is_pic_mcu_en();
    if (iVar1 != 0) {
        pic1704_enable_disable_dc_dc(
            *(uint *)(g_chain_info + param_1 * 8) & 0xff, 0);
        usleep(300000);
    }
    return 0;
}

undefined4 hardreset_hal(int param_1)

{
    usleep(300000);
    chain_reset_low(*(undefined4 *)(g_chain_info + param_1 * 8));
    usleep(300000);
    chain_reset_high(*(undefined4 *)(g_chain_info + param_1 * 8));
    sleep(1);
    chain_reset_low(*(undefined4 *)(g_chain_info + param_1 * 8));
    usleep(300000);
    chain_reset_high(*(undefined4 *)(g_chain_info + param_1 * 8));
    return 0;
}

undefined4 chain_reset_high_hal(int param_1)

{
    chain_reset_high(*(undefined4 *)(g_chain_info + param_1 * 8));
    return 0;
}

undefined4 chain_reset_low_hal(int param_1)

{
    chain_reset_low(*(undefined4 *)(g_chain_info + param_1 * 8));
    return 0;
}

undefined4 softreset_hal(undefined4 param_1)

{
    int iVar1;
    undefined1 auStack_18[16];

    do {
        iVar1 = dev_read_nonce_reg_data_hal(param_1, auStack_18, 0x10);
    } while (iVar1 != -1);
    sleep(1);
    do {
        iVar1 = dev_read_nonce_reg_data_hal(param_1, auStack_18, 0x10);
    } while (iVar1 != -1);
    return 0;
}

int heartbeat_to_hal(int param_1)

{
    int iVar1;

    iVar1 = platform_is_pic_mcu_en();
    if (iVar1 != 0) {
        iVar1 =
            pic1704_heart_beat(*(uint *)(g_chain_info + param_1 * 8) & 0xff);
    }
    return iVar1;
}

int pic_operation_to_hal(int param_1, int param_2, uint param_3,
                         undefined4 param_4)

{
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = platform_is_pic_mcu_en();
    if (local_c != 0) {
        local_c = -1;
        if (param_2 == 0x33) {
            local_c = pic1704_write_flash(
                *(uint *)(g_chain_info + param_1 * 8) & 0xff, param_4,
                param_3 & 0xffff, param_3 >> 0x10);
            if (local_c != 1) {
                V_LOCK();
                logfmt_raw(auStack_100c, 0x1000, 0,
                           "chain %d, pic1704_write_flash failed!!!",
                           *(undefined4 *)(g_chain_info + param_1 * 8));
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/platform_device_hal.c",
                     0xae, "pic_operation_to_hal", 0x14, 0x22a, 100,
                     auStack_100c);
            }
        } else if ((param_2 == 0x34) &&
                   (local_c = pic1704_read_flash(
                        *(uint *)(g_chain_info + param_1 * 8) & 0xff, param_4,
                        param_3 & 0xffff, param_3 >> 0x10),
                    local_c != 1)) {
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0,
                       "chain %d, pic1704_read_flash failed!!!",
                       *(undefined4 *)(g_chain_info + param_1 * 8));
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/platform_device_hal.c",
                 0xae, "pic_operation_to_hal", 0x14, 0x232, 100, auStack_100c);
        }
    }
    return local_c;
}

undefined **dev_ctrl_hal(void)

{
    return &PTR_scan_miner_device_hal_00150bb8;
}

int *new_c_map(undefined4 param_1, undefined4 param_2, undefined4 param_3)

{
    int *piVar1;
    int iVar2;

    piVar1 = (int *)malloc(4);
    if (piVar1 == (int *)0x0) {
        piVar1 = (int *)0x0;
    } else {
        iVar2 = new_c_rb(param_1, param_2, param_3);
        *piVar1 = iVar2;
        if (*piVar1 == 0) {
            piVar1 = (int *)0x0;
        }
    }
    return piVar1;
}

undefined4 insert_c_map(undefined4 *param_1, undefined4 param_2,
                        undefined4 param_3, undefined4 param_4,
                        undefined4 param_5)

{
    undefined4 uVar1;

    if (param_1 == (undefined4 *)0x0) {
        uVar1 = 0x1f5;
    } else {
        uVar1 = insert_c_rb(*param_1, param_2, param_3, param_4, param_5);
    }
    return uVar1;
}

undefined4 exists_c_map(undefined4 *param_1, undefined4 param_2)

{
    int iVar1;
    undefined4 uVar2;

    if (param_1 == (undefined4 *)0x0) {
        uVar2 = 0;
    } else {
        iVar1 = find_c_rb(*param_1, param_2);
        if (iVar1 == 0) {
            uVar2 = 0;
        } else {
            uVar2 = 1;
        }
    }
    return uVar2;
}

undefined4 remove_c_map(undefined4 *param_1, undefined4 param_2)

{
    void *local_14;
    void *local_10;
    undefined4 local_c;

    local_c = 0;
    if (param_1 == (undefined4 *)0x0) {
        local_c = 0x1f5;
    } else {
        local_10 = (void *)remove_c_rb(*param_1, param_2);
        if (local_10 != (void *)0x0) {
            get_raw_clib_object(*(undefined4 *)((int)local_10 + 0x10),
                                &local_14);
            free(local_14);
            delete_clib_object(*(undefined4 *)((int)local_10 + 0x10));
            get_raw_clib_object(*(undefined4 *)((int)local_10 + 0x14),
                                &local_14);
            free(local_14);
            delete_clib_object(*(undefined4 *)((int)local_10 + 0x14));
            free(local_10);
        }
    }
    return local_c;
}

undefined4 find_c_map(undefined4 *param_1, undefined4 param_2,
                      undefined4 param_3)

{
    int iVar1;
    undefined4 uVar2;

    if (param_1 == (undefined4 *)0x0) {
        uVar2 = 0;
    } else {
        iVar1 = find_c_rb(*param_1, param_2);
        if (iVar1 == 0) {
            uVar2 = 0;
        } else {
            get_raw_clib_object(*(undefined4 *)(iVar1 + 0x14), param_3);
            uVar2 = 1;
        }
    }
    return uVar2;
}

undefined4 delete_c_map(undefined4 *param_1)

{
    undefined4 local_c;

    local_c = 0;
    if (param_1 != (undefined4 *)0x0) {
        local_c = delete_c_rb(*param_1);
        free(param_1);
    }
    return local_c;
}

undefined4 FUN_000b37f8(undefined4 *param_1)

{
    undefined4 uVar1;

    uVar1 = minimum_c_rb(*param_1, *(undefined4 *)*param_1);
    return uVar1;
}

undefined4 FUN_000b3838(int param_1)

{
    undefined4 uVar1;

    if (*(int *)(param_1 + 0x14) == 0) {
        uVar1 = FUN_000b37f8(*(undefined4 *)(param_1 + 0xc));
        *(undefined4 *)(param_1 + 0x14) = uVar1;
    } else {
        uVar1 = tree_successor(**(undefined4 **)(param_1 + 0xc),
                               *(undefined4 *)(param_1 + 0x14));
        *(undefined4 *)(param_1 + 0x14) = uVar1;
    }
    if (*(int *)(param_1 + 0x14) == 0) {
        uVar1 = 0;
    } else {
        uVar1 = *(undefined4 *)(*(int *)(param_1 + 0x14) + 0x14);
    }
    return uVar1;
}

undefined4 FUN_000b38dc(undefined4 param_1)

{
    undefined4 local_c;

    get_raw_clib_object(param_1, &local_c);
    return local_c;
}

void FUN_000b390c(int param_1, undefined4 param_2, undefined4 param_3)

{
    undefined4 local_10;
    int *local_c;

    local_c = *(int **)(param_1 + 0xc);
    if (*(int *)(*local_c + 0x20) != 0) {
        get_raw_clib_object(*(undefined4 *)(param_1 + 0x14), &local_10);
        (**(code **)(*local_c + 0x20))(local_10);
    }
    replace_raw_clib_object(*(undefined4 *)(*(int *)(param_1 + 0x14) + 0x14),
                            param_2, param_3);
    return;
}

undefined4 *new_iterator_c_map(undefined4 param_1)

{
    undefined4 *puVar1;

    puVar1 = (undefined4 *)malloc(0x18);
    *puVar1 = FUN_000b3838;
    puVar1[2] = FUN_000b38dc;
    puVar1[1] = FUN_000b390c;
    puVar1[3] = param_1;
    puVar1[4] = 0;
    puVar1[5] = 0;
    return puVar1;
}

void delete_iterator_c_map(void *param_1)

{
    free(param_1);
    return;
}

void FUN_000b3a44(undefined4 *param_1, undefined4 *param_2)

{
    int *piVar1;

    piVar1 = (int *)param_2[1];
    param_2[1] = *piVar1;
    if ((undefined4 *)*piVar1 != param_1 + 1) {
        *(undefined4 **)(*piVar1 + 8) = param_2;
    }
    if (piVar1 != param_1 + 1) {
        piVar1[2] = param_2[2];
    }
    if (param_2[2] == 0) {
        *param_1 = piVar1;
    } else if (param_2 == (undefined4 *)*(int *)param_2[2]) {
        *(int **)param_2[2] = piVar1;
    } else {
        *(int **)(param_2[2] + 4) = piVar1;
    }
    *piVar1 = (int)param_2;
    if (param_2 != param_1 + 1) {
        param_2[2] = piVar1;
    }
    return;
}

void FUN_000b3b58(int *param_1, int *param_2)

{
    int *piVar1;

    piVar1 = (int *)*param_2;
    *param_2 = piVar1[1];
    if ((int *)piVar1[1] != param_1 + 1) {
        *(int **)(piVar1[1] + 8) = param_2;
    }
    if (piVar1 != param_1 + 1) {
        piVar1[2] = param_2[2];
    }
    if (param_2[2] == 0) {
        *param_1 = (int)piVar1;
    } else if (param_2 == *(int **)(param_2[2] + 4)) {
        *(int **)(param_2[2] + 4) = piVar1;
    } else {
        *(int **)param_2[2] = piVar1;
    }
    piVar1[1] = (int)param_2;
    if (param_2 != param_1 + 1) {
        param_2[2] = (int)piVar1;
    }
    return;
}

int *new_c_rb(int param_1, int param_2, int param_3)

{
    int *__s;

    __s = (int *)malloc(0x28);
    if (__s == (int *)0x0) {
        __s = (int *)0x0;
    } else {
        memset(__s, 0, 0x28);
        __s[9] = param_1;
        __s[7] = param_2;
        __s[8] = param_3;
        *__s = (int)(__s + 1);
        __s[1] = (int)(__s + 1);
        __s[2] = (int)(__s + 1);
        __s[3] = 0;
        __s[4] = 0;
    }
    return __s;
}

void FUN_000b3d34(int *param_1, int param_2)

{
    int iVar1;
    undefined4 local_18;

    local_18 = param_2;
    while ((local_18 != *param_1 &&
            (*(int *)(*(int *)(local_18 + 8) + 0xc) == 1))) {
        if (*(int *)(local_18 + 8) == **(int **)(*(int *)(local_18 + 8) + 8)) {
            iVar1 = *(int *)(*(int *)(*(int *)(local_18 + 8) + 8) + 4);
            if (*(int *)(iVar1 + 0xc) == 1) {
                *(undefined4 *)(*(int *)(local_18 + 8) + 0xc) = 0;
                *(undefined4 *)(iVar1 + 0xc) = 0;
                *(undefined4 *)(*(int *)(*(int *)(local_18 + 8) + 8) + 0xc) = 1;
                local_18 = *(int *)(*(int *)(local_18 + 8) + 8);
            } else {
                if (local_18 == *(int *)(*(int *)(local_18 + 8) + 4)) {
                    local_18 = *(int *)(local_18 + 8);
                    FUN_000b3a44(param_1, local_18);
                }
                *(undefined4 *)(*(int *)(local_18 + 8) + 0xc) = 0;
                *(undefined4 *)(*(int *)(*(int *)(local_18 + 8) + 8) + 0xc) = 1;
                FUN_000b3b58(param_1,
                             *(undefined4 *)(*(int *)(local_18 + 8) + 8));
            }
        } else {
            iVar1 = **(int **)(*(int *)(local_18 + 8) + 8);
            if (*(int *)(iVar1 + 0xc) == 1) {
                *(undefined4 *)(*(int *)(local_18 + 8) + 0xc) = 0;
                *(undefined4 *)(iVar1 + 0xc) = 0;
                *(undefined4 *)(*(int *)(*(int *)(local_18 + 8) + 8) + 0xc) = 1;
                local_18 = *(int *)(*(int *)(local_18 + 8) + 8);
            } else {
                if (local_18 == **(int **)(local_18 + 8)) {
                    local_18 = *(int *)(local_18 + 8);
                    FUN_000b3b58(param_1, local_18);
                }
                *(undefined4 *)(*(int *)(local_18 + 8) + 0xc) = 0;
                *(undefined4 *)(*(int *)(*(int *)(local_18 + 8) + 8) + 0xc) = 1;
                FUN_000b3a44(param_1,
                             *(undefined4 *)(*(int *)(local_18 + 8) + 8));
            }
        }
    }
    *(undefined4 *)(*param_1 + 0xc) = 0;
    return;
}

undefined4 *find_c_rb(undefined4 *param_1, undefined4 param_2)

{
    void *local_14;
    int local_10;
    undefined4 *local_c;

    local_c = (undefined4 *)*param_1;
    while (local_c != param_1 + 1) {
        local_10 = 0;
        get_raw_clib_object(local_c[4], &local_14);
        local_10 = (*(code *)param_1[9])(param_2, local_14);
        free(local_14);
        if (local_10 == 0)
            break;
        if (local_10 < 0) {
            local_c = (undefined4 *)*local_c;
        } else {
            local_c = (undefined4 *)local_c[1];
        }
    }
    if (local_c == param_1 + 1) {
        local_c = (undefined4 *)0x0;
    }
    return local_c;
}

undefined4 insert_c_rb(undefined4 *param_1, undefined4 param_2,
                       undefined4 param_3, int param_4, undefined4 param_5)

{
    undefined4 uVar1;
    void *local_30;
    void *local_2c;
    void *local_28;
    void *local_24;
    int local_20;
    int local_1c;
    void *local_18;
    undefined4 local_14;
    undefined4 *local_10;
    undefined4 *local_c;

    local_14 = 0;
    local_18 = malloc(0x18);
    if (local_18 == (void *)0x0) {
        local_14 = 2;
    } else {
        *(undefined4 **)local_18 = param_1 + 1;
        *(undefined4 **)((int)local_18 + 4) = param_1 + 1;
        *(undefined4 *)((int)local_18 + 0xc) = 1;
        uVar1 = new_clib_object(param_2, param_3);
        *(undefined4 *)((int)local_18 + 0x10) = uVar1;
        if (param_4 == 0) {
            *(undefined4 *)((int)local_18 + 0x14) = 0;
        } else {
            uVar1 = new_clib_object(param_4, param_5);
            *(undefined4 *)((int)local_18 + 0x14) = uVar1;
        }
        local_c = (undefined4 *)*param_1;
        local_10 = (undefined4 *)0x0;
        while (local_c != param_1 + 1) {
            local_20 = 0;
            get_raw_clib_object(local_c[4], &local_24);
            get_raw_clib_object(*(undefined4 *)((int)local_18 + 0x10),
                                &local_28);
            local_20 = (*(code *)param_1[9])(local_28, local_24);
            free(local_24);
            free(local_28);
            if (local_20 == 0) {
                return 0x191;
            }
            local_10 = local_c;
            if (local_20 < 0) {
                local_c = (undefined4 *)*local_c;
            } else {
                local_c = (undefined4 *)local_c[1];
            }
        }
        *(undefined4 **)((int)local_18 + 8) = local_10;
        if (local_10 == (undefined4 *)0x0) {
            *param_1 = local_18;
        } else {
            local_1c = 0;
            get_raw_clib_object(local_10[4], &local_2c);
            get_raw_clib_object(*(undefined4 *)((int)local_18 + 0x10),
                                &local_30);
            local_1c = (*(code *)param_1[9])(local_30, local_2c);
            free(local_2c);
            free(local_30);
            if (local_1c < 0) {
                *local_10 = local_18;
            } else {
                local_10[1] = local_18;
            }
        }
        FUN_000b3d34(param_1, local_18);
        FUN_000b4c50(param_1);
    }
    return local_14;
}

void FUN_000b42bc(int *param_1, int param_2)

{
    int local_18;
    int *local_10;
    int *local_c;

    local_18 = param_2;
    while ((local_18 != *param_1 && (*(int *)(local_18 + 0xc) == 0))) {
        if (local_18 == **(int **)(local_18 + 8)) {
            local_c = *(int **)(*(int *)(local_18 + 8) + 4);
            if (local_c[3] == 1) {
                local_c[3] = 0;
                *(undefined4 *)(*(int *)(local_18 + 8) + 0xc) = 1;
                FUN_000b3a44(param_1, *(undefined4 *)(local_18 + 8));
                local_c = *(int **)(*(int *)(local_18 + 8) + 4);
            }
            if ((*(int *)(*local_c + 0xc) == 0) &&
                (*(int *)(local_c[1] + 0xc) == 0)) {
                local_c[3] = 1;
                local_18 = *(int *)(local_18 + 8);
            } else {
                if (*(int *)(local_c[1] + 0xc) == 0) {
                    *(undefined4 *)(*local_c + 0xc) = 0;
                    local_c[3] = 1;
                    FUN_000b3b58(param_1, local_c);
                    local_c = *(int **)(*(int *)(local_18 + 8) + 4);
                }
                local_c[3] = *(int *)(*(int *)(local_18 + 8) + 0xc);
                *(undefined4 *)(*(int *)(local_18 + 8) + 0xc) = 0;
                *(undefined4 *)(local_c[1] + 0xc) = 0;
                FUN_000b3a44(param_1, *(undefined4 *)(local_18 + 8));
                local_18 = *param_1;
            }
        } else {
            local_10 = (int *)**(int **)(local_18 + 8);
            if (local_10[3] == 1) {
                local_10[3] = 0;
                *(undefined4 *)(*(int *)(local_18 + 8) + 0xc) = 1;
                FUN_000b3b58(param_1, *(undefined4 *)(local_18 + 8));
                local_10 = (int *)**(undefined4 **)(local_18 + 8);
            }
            if ((*(int *)(local_10[1] + 0xc) == 0) &&
                (*(int *)(*local_10 + 0xc) == 0)) {
                local_10[3] = 1;
                local_18 = *(int *)(local_18 + 8);
            } else {
                if (*(int *)(*local_10 + 0xc) == 0) {
                    *(undefined4 *)(local_10[1] + 0xc) = 0;
                    local_10[3] = 1;
                    FUN_000b3a44(param_1, local_10);
                    local_10 = (int *)**(undefined4 **)(local_18 + 8);
                }
                local_10[3] = *(int *)(*(int *)(local_18 + 8) + 0xc);
                *(undefined4 *)(*(int *)(local_18 + 8) + 0xc) = 0;
                *(undefined4 *)(*local_10 + 0xc) = 0;
                FUN_000b3b58(param_1, *(undefined4 *)(local_18 + 8));
                local_18 = *param_1;
            }
        }
    }
    *(undefined4 *)(local_18 + 0xc) = 0;
    return;
}

int *FUN_000b45b4(int *param_1, int *param_2)

{
    int iVar1;
    int *local_10;
    int local_c;

    local_10 = param_2;
    if (((int *)*param_2 != param_1 + 1) &&
        ((int *)param_2[1] != param_1 + 1)) {
        for (local_10 = (int *)param_2[1]; (int *)*local_10 != param_1 + 1;
             local_10 = (int *)*local_10) {
        }
    }
    if ((int *)*local_10 == param_1 + 1) {
        local_c = local_10[1];
    } else {
        local_c = *local_10;
    }
    *(int *)(local_c + 8) = local_10[2];
    if (local_10[2] == 0) {
        *param_1 = local_c;
    } else if (local_10 == *(int **)local_10[2]) {
        *(int *)local_10[2] = local_c;
    } else {
        *(int *)(local_10[2] + 4) = local_c;
    }
    if (local_10 != param_2) {
        iVar1 = param_2[4];
        param_2[4] = local_10[4];
        local_10[4] = iVar1;
        iVar1 = param_2[5];
        param_2[5] = local_10[5];
        local_10[5] = iVar1;
    }
    if (local_10[3] == 0) {
        FUN_000b42bc(param_1, local_c);
    }
    FUN_000b4c50(param_1);
    return local_10;
}

undefined4 remove_c_rb(undefined4 *param_1, undefined4 param_2)

{
    undefined4 uVar1;
    void *local_14;
    int local_10;
    undefined4 *local_c;

    local_c = (undefined4 *)*param_1;
    while (local_c != param_1 + 1) {
        local_10 = 0;
        get_raw_clib_object(local_c[4], &local_14);
        local_10 = (*(code *)param_1[9])(param_2, local_14);
        free(local_14);
        if (local_10 == 0)
            break;
        if (local_10 < 0) {
            local_c = (undefined4 *)*local_c;
        } else {
            local_c = (undefined4 *)local_c[1];
        }
    }
    if (local_c == param_1 + 1) {
        uVar1 = 0;
    } else {
        uVar1 = FUN_000b45b4(param_1, local_c);
    }
    return uVar1;
}

void FUN_000b4874(int param_1, int param_2)

{
    undefined4 local_10;
    undefined4 local_c;

    if (*(int *)(param_1 + 0x1c) != 0) {
        get_raw_clib_object(*(undefined4 *)(param_2 + 0x10), &local_c);
        (**(code **)(param_1 + 0x1c))(local_c);
    }
    delete_clib_object(*(undefined4 *)(param_2 + 0x10));
    if (*(int *)(param_2 + 0x14) != 0) {
        if (*(int *)(param_1 + 0x20) != 0) {
            get_raw_clib_object(*(undefined4 *)(param_2 + 0x14), &local_10);
            (**(code **)(param_1 + 0x20))(local_10);
        }
        delete_clib_object(*(undefined4 *)(param_2 + 0x14));
    }
    return;
}

undefined4 delete_c_rb(undefined4 *param_1)

{
    int *local_c;

    local_c = (int *)*param_1;
    while (local_c != param_1 + 1) {
        if ((undefined4 *)*local_c == param_1 + 1) {
            if ((undefined4 *)local_c[1] == param_1 + 1) {
                FUN_000b4874(param_1, local_c);
                if (local_c[2] == 0) {
                    free(local_c);
                    local_c = param_1 + 1;
                } else {
                    local_c = (int *)local_c[2];
                    if ((undefined4 *)*local_c == param_1 + 1) {
                        if ((undefined4 *)local_c[1] != param_1 + 1) {
                            free((void *)local_c[1]);
                            local_c[1] = (int)(param_1 + 1);
                        }
                    } else {
                        free((void *)*local_c);
                        *local_c = (int)(param_1 + 1);
                    }
                }
            } else {
                local_c = (int *)local_c[1];
            }
        } else {
            local_c = (int *)*local_c;
        }
    }
    free(param_1);
    return 0;
}

int *minimum_c_rb(int param_1, int *param_2)

{
    undefined4 local_10;

    for (local_10 = param_2; *local_10 != param_1 + 4;
         local_10 = (int *)*local_10) {
    }
    return local_10;
}

int maximum_c_rb(int param_1, int param_2)

{
    undefined4 local_10;

    for (local_10 = param_2; *(int *)(local_10 + 4) != param_1 + 4;
         local_10 = *(int *)(local_10 + 4)) {
    }
    return local_10;
}

bool empty_c_rb(int *param_1)

{
    return (int *)*param_1 != param_1 + 1;
}

undefined4 *tree_successor(undefined4 *param_1, undefined4 *param_2)

{
    undefined4 *puVar1;
    undefined4 *local_18;
    undefined4 *local_c;

    if ((undefined4 *)param_2[1] == param_1 + 1) {
        puVar1 = (undefined4 *)maximum_c_rb(param_1, *param_1);
        if (param_2 == puVar1) {
            local_c = (undefined4 *)0x0;
        } else {
            local_18 = param_2;
            for (local_c = (undefined4 *)param_2[2];
                 (local_c != param_1 + 1 &&
                  (local_18 == (undefined4 *)local_c[1]));
                 local_c = (undefined4 *)local_c[2]) {
                local_18 = local_c;
            }
        }
    } else {
        local_c = (undefined4 *)minimum_c_rb(param_1, param_2[1]);
    }
    return local_c;
}

void FUN_000b4c50(undefined4 *param_1)

{
    FUN_000b4cbc(param_1, *param_1);
    FUN_000b4d1c(param_1, *param_1);
    FUN_000b4d88(param_1, *param_1);
    FUN_000b4df4(param_1, *param_1);
    return;
}

void FUN_000b4cbc(int param_1, undefined4 *param_2)

{
    if (param_2 != (undefined4 *)(param_1 + 4)) {
        FUN_000b4cbc(param_1, *param_2);
        FUN_000b4cbc(param_1, param_2[1]);
    }
    return;
}

void FUN_000b4d1c(void)

{
    return;
}

undefined4 FUN_000b4d40(int param_1, int param_2)

{
    undefined4 uVar1;

    if (param_2 == param_1 + 4) {
        uVar1 = 0;
    } else {
        uVar1 = *(undefined4 *)(param_2 + 0xc);
    }
    return uVar1;
}

void FUN_000b4d88(int param_1, undefined4 *param_2)

{
    FUN_000b4d40(param_1, param_2);
    if (param_2 != (undefined4 *)(param_1 + 4)) {
        FUN_000b4d88(param_1, *param_2);
        FUN_000b4d88(param_1, param_2[1]);
    }
    return;
}

void FUN_000b4df4(undefined4 param_1, undefined4 param_2)

{
    undefined4 local_c;

    local_c = 0xffffffff;
    FUN_000b4e30(param_1, param_2, 0, &local_c);
    return;
}

void FUN_000b4e30(int param_1, undefined4 *param_2, int param_3, int *param_4)

{
    int iVar1;
    int local_14;

    iVar1 = FUN_000b4d40(param_1, param_2);
    local_14 = param_3;
    if (iVar1 == 0) {
        local_14 = param_3 + 1;
    }
    if (param_2 == (undefined4 *)(param_1 + 4)) {
        if (*param_4 == -1) {
            *param_4 = local_14;
        }
    } else {
        FUN_000b4e30(param_1, *param_2, local_14, param_4);
        FUN_000b4e30(param_1, param_2[1], local_14, param_4);
    }
    return;
}

void clib_copy(void *param_1, void *param_2, size_t param_3)

{
    memcpy(param_1, param_2, param_3);
    return;
}

void clib_get(void *param_1, void *param_2, size_t param_3)

{
    memcpy(param_1, param_2, param_3);
    return;
}

int *new_clib_object(void *param_1, size_t param_2)

{
    int *__ptr;
    void *pvVar1;

    __ptr = (int *)malloc(8);
    if (__ptr == (int *)0x0) {
        __ptr = (int *)0x0;
    } else {
        __ptr[1] = param_2;
        pvVar1 = malloc(param_2);
        *__ptr = (int)pvVar1;
        if (*__ptr == 0) {
            free(__ptr);
            __ptr = (int *)0x0;
        } else {
            memcpy((void *)*__ptr, param_1, param_2);
        }
    }
    return __ptr;
}

undefined4 get_raw_clib_object(undefined4 *param_1, int *param_2)

{
    void *pvVar1;
    undefined4 uVar2;

    pvVar1 = malloc(param_1[1]);
    *param_2 = (int)pvVar1;
    if (*param_2 == 0) {
        uVar2 = 3;
    } else {
        memcpy((void *)*param_2, (void *)*param_1, param_1[1]);
        uVar2 = 0;
    }
    return uVar2;
}

void replace_raw_clib_object(undefined4 *param_1, void *param_2, size_t param_3)

{
    void *pvVar1;

    free((void *)*param_1);
    pvVar1 = malloc(param_3);
    *param_1 = pvVar1;
    memcpy((void *)*param_1, param_2, param_3);
    return;
}

void delete_clib_object(undefined4 *param_1)

{
    if (param_1 != (undefined4 *)0x0) {
        free((void *)*param_1);
        free(param_1);
    }
    return;
}

char *clib_strdup(char *param_1)

{
    char *pcVar1;

    pcVar1 = strdup(param_1);
    return pcVar1;
}

undefined4 FUN_000b5138(byte param_1, undefined4 param_2, undefined4 param_3)

{
    undefined4 uVar1;

    uVar1 = iic_write(*(undefined4 *)(g_bitmain_pic_state + (uint)param_1 * 8),
                      param_2, param_3);
    return uVar1;
}

undefined4 FUN_000b5184(byte param_1, undefined4 param_2, undefined4 param_3)

{
    undefined4 uVar1;

    uVar1 = iic_read(*(undefined4 *)(g_bitmain_pic_state + (uint)param_1 * 8),
                     param_2, param_3);
    return uVar1;
}

undefined4 FUN_000b51d0(undefined1 param_1, char param_2, byte param_3,
                        int param_4, int param_5)

{
    byte *pbVar1;
    int iVar2;
    undefined1 auStack_103c[4096];
    byte local_3c[16];
    undefined8 local_2c;
    undefined8 uStack_24;
    undefined2 local_1c;
    byte local_19;
    int local_18;
    int local_14;
    undefined4 local_10;
    byte local_b;
    short local_a;

    local_1c = 0xff;
    uStack_24 = 0;
    local_2c = 0xff;
    local_a = 0;
    local_3c[0] = 0;
    local_3c[1] = 0;
    local_3c[2] = 0;
    local_3c[3] = 0;
    local_3c[4] = 0;
    local_3c[5] = 0;
    local_3c[6] = 0;
    local_3c[7] = 0;
    local_3c[8] = 0;
    local_3c[9] = 0;
    local_3c[10] = 0;
    local_3c[0xb] = 0;
    local_3c[0xc] = 0;
    local_3c[0xd] = 0;
    local_3c[0xe] = 0;
    local_3c[0xf] = 0;
    local_18 = 0;
    local_14 = 0;
    local_b = (char)param_5 + 6;
    local_10 = 1;
    pthread_mutex_lock((pthread_mutex_t *)i2c_mutex_all);
    pbVar1 = local_3c + local_14;
    local_14 = local_14 + 1;
    *pbVar1 = 0x55;
    pbVar1 = local_3c + local_14;
    local_14 = local_14 + 1;
    *pbVar1 = 0xaa;
    pbVar1 = local_3c + local_14;
    local_14 = local_14 + 1;
    *pbVar1 = local_b;
    pbVar1 = local_3c + local_14;
    local_14 = local_14 + 1;
    *pbVar1 = 0x32;
    pbVar1 = local_3c + local_14;
    local_14 = local_14 + 1;
    *pbVar1 = param_2 << 1;
    iVar2 = local_14;
    local_14 = local_14 + 1;
    local_3c[iVar2] = param_3;
    for (local_19 = 0; iVar2 = local_14, (int)(uint)local_19 < param_5;
         local_19 = local_19 + 1) {
        local_14 = local_14 + 1;
        local_3c[iVar2] = *(byte *)(param_4 + (uint)local_19);
    }
    for (local_18 = 2; local_18 < param_5 + 6; local_18 = local_18 + 1) {
        local_a = (ushort)local_3c[local_18] + local_a;
    }
    local_1c._0_1_ = (byte)((ushort)local_a >> 8);
    local_1c._1_1_ = (byte)local_a;
    pbVar1 = local_3c + local_14;
    local_14 = local_14 + 1;
    *pbVar1 = (byte)local_1c;
    pbVar1 = local_3c + local_14;
    local_14 = local_14 + 1;
    *pbVar1 = local_1c._1_1_;
    iVar2 = FUN_000b5138(param_1, local_3c, local_14);
    if (local_14 == iVar2) {
        usleep(200000);
        memset(&local_2c, 0, 0x10);
        iVar2 = FUN_000b5184(param_1, &local_2c, 5);
        if (iVar2 == 5) {
            if ((local_2c._1_1_ != '2') || (local_2c._2_1_ != '\x01')) {
                V_LOCK();
                logfmt_raw(auStack_103c, 0x1000, 0,
                           "--- %s failed! read_back_data[0] = 0x%02x, "
                           "read_back_data[1] = 0x%02x, read_back_data[2] = "
                           "0x%02x, read_back_data[3] = 0x%02x",
                           "write_dc_dc", (undefined1)local_2c, local_2c._1_1_,
                           local_2c._2_1_, local_2c._3_1_);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/drv_pic/isl68127.c",
                     0xaf, "write_dc_dc", 0xb, 0x4b, 100, auStack_103c);
                local_10 = 0;
            }
        } else {
            V_LOCK();
            logfmt_raw(auStack_103c, 0x1000, 0, "%s read iic err",
                       "write_dc_dc");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/drv_pic/isl68127.c",
                 0xaf, "write_dc_dc", 0xb, 0x44, 100, auStack_103c);
        }
    } else {
        V_LOCK();
        logfmt_raw(auStack_103c, 0x1000, 0, "%s write iic err", "write_dc_dc");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "isl68127.c",
             0xaf, "write_dc_dc", 0xb, 0x3d, 100, auStack_103c);
    }
    pthread_mutex_unlock((pthread_mutex_t *)i2c_mutex_all);
    return local_10;
}

undefined4 FUN_000b56b8(undefined1 param_1, char param_2, byte param_3,
                        int param_4, int param_5)

{
    byte *pbVar1;
    int iVar2;
    undefined1 auStack_1034[4096];
    byte local_34[12];
    undefined8 local_28;
    undefined8 uStack_20;
    undefined2 local_18;
    byte local_15;
    undefined4 local_14;
    byte local_f;
    short local_e;
    int local_c;

    local_f = 7;
    local_18 = 0xff;
    uStack_20 = 0;
    local_28 = 0xff;
    local_e = 0;
    local_34[0] = 0;
    local_34[1] = 0;
    local_34[2] = 0;
    local_34[3] = 0;
    local_34[4] = 0;
    local_34[5] = 0;
    local_34[6] = 0;
    local_34[7] = 0;
    local_34[8] = 0;
    local_c = 0;
    local_14 = 1;
    pthread_mutex_lock((pthread_mutex_t *)i2c_mutex_all);
    pbVar1 = local_34 + local_c;
    local_c = local_c + 1;
    *pbVar1 = 0x55;
    pbVar1 = local_34 + local_c;
    local_c = local_c + 1;
    *pbVar1 = 0xaa;
    pbVar1 = local_34 + local_c;
    local_c = local_c + 1;
    *pbVar1 = local_f;
    pbVar1 = local_34 + local_c;
    local_c = local_c + 1;
    *pbVar1 = 0x32;
    pbVar1 = local_34 + local_c;
    local_c = local_c + 1;
    *pbVar1 = param_2 << 1 | 1;
    pbVar1 = local_34 + local_c;
    local_c = local_c + 1;
    *pbVar1 = param_3;
    iVar2 = local_c;
    local_c = local_c + 1;
    local_34[iVar2] = (byte)param_5;
    for (local_15 = 2; local_15 < local_f; local_15 = local_15 + 1) {
        local_e = (ushort)local_34[local_15] + local_e;
    }
    local_18._0_1_ = (byte)((ushort)local_e >> 8);
    local_18._1_1_ = (byte)local_e;
    pbVar1 = local_34 + local_c;
    local_c = local_c + 1;
    *pbVar1 = (byte)local_18;
    pbVar1 = local_34 + local_c;
    local_c = local_c + 1;
    *pbVar1 = local_18._1_1_;
    iVar2 = FUN_000b5138(param_1, local_34, local_c);
    if (local_c == iVar2) {
        usleep(200000);
        memset(&local_28, 0, 0x10);
        iVar2 = FUN_000b5184(param_1, &local_28, 5);
        if (iVar2 == 5) {
            if ((local_28._1_1_ == '2') && (local_28._2_1_ == '\x01')) {
                for (local_15 = 0; (int)(uint)local_15 < param_5;
                     local_15 = local_15 + 1) {
                    *(undefined1 *)(param_4 + (uint)local_15) =
                        *(undefined1 *)((int)&local_28 + local_15 + 3);
                }
                local_14 = 1;
            } else {
                V_LOCK();
                logfmt_raw(auStack_1034, 0x1000, 0,
                           "--- %s failed! read_back_data[0] = 0x%02x, "
                           "read_back_data[1] = 0x%02x, read_back_data[2] = "
                           "0x%02x, read_back_data[3] = 0x%02x",
                           "read_dc_dc", (undefined1)local_28, local_28._1_1_,
                           local_28._2_1_, local_28._3_1_);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/drv_pic/isl68127.c",
                     0xaf, "read_dc_dc", 10, 0x7d, 100, auStack_1034);
                local_14 = 0;
            }
        } else {
            V_LOCK();
            logfmt_raw(auStack_1034, 0x1000, 0, "%s read iic err",
                       "read_dc_dc");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/drv_pic/isl68127.c",
                 0xaf, "read_dc_dc", 10, 0x76, 100, auStack_1034);
        }
    } else {
        V_LOCK();
        logfmt_raw(auStack_1034, 0x1000, 0, "%s write iic err", "read_dc_dc");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "isl68127.c",
             0xaf, "read_dc_dc", 10, 0x6e, 100, auStack_1034);
    }
    pthread_mutex_unlock((pthread_mutex_t *)i2c_mutex_all);
    return local_14;
}

undefined4 FUN_000b5bbc(undefined4 param_1, undefined1 param_2,
                        undefined2 *param_3)

{
    undefined2 local_c[2];

    local_c[0] = 0;
    memset(local_c, 0, 2);
    FUN_000b56b8(param_1, param_2, 0x21, local_c, 2);
    *param_3 = local_c[0];
    return 1;
}

ushort FUN_000b5c4c(undefined4 param_1, undefined1 param_2, ushort param_3)

{
    undefined1 auStack_1014[4096];
    undefined1 local_14;
    undefined1 local_13;
    undefined1 local_11;
    ushort local_10;
    byte local_e;
    byte local_d;
    uint local_c;

    local_c = (uint)param_3;
    if ((0x3de < local_c) || (local_c < 0x32a)) {
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0,
                   "illegal voltage [%d, %d], set default voltage %d", 0x32a,
                   0x3de, 900);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "isl68127.c",
             0xaf, "ISL_set_voltage_dynamic", 0x17, 0x9a, 0x3c, auStack_1014);
        local_c = 900;
    }
    local_d = 0;
    local_e = 3;
    local_10 = 0;
    while (true) {
        local_11 = 0xff;
        FUN_000b51d0(param_1, param_2, 0, &local_11, 1);
        usleep(100000);
        local_14 = (undefined1)local_c;
        local_13 = (undefined1)(local_c >> 8);
        FUN_000b51d0(param_1, param_2, 0x21, &local_14, 2);
        usleep(200000);
        FUN_000b5bbc(param_1, param_2, &local_10);
        if (((int)(local_c - 10) < (int)(uint)local_10) &&
            ((int)(uint)local_10 < (int)(local_c + 10)))
            break;
        V_LOCK();
        logfmt_raw(auStack_1014, 0x1000, 0, "set vol %d,  %d, set again!",
                   local_c, local_10);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "isl68127.c",
             0xaf, "ISL_set_voltage_dynamic", 0x17, 0xb5, 0x3c, auStack_1014);
        usleep(200000);
        local_d = local_d + 1;
        if (local_e < local_d) {
            return local_10;
        }
    }
    return local_10;
}

undefined4 get_chain_isl_voltage(undefined4 param_1, int param_2, int param_3)

{
    undefined4 uVar1;
    undefined1 auStack_1010[4098];
    undefined2 local_e;
    uint local_c;

    if (param_3 < 3) {
        uVar1 = 0;
    } else {
        for (local_c = 0; local_c < 3; local_c = local_c + 1) {
            local_e = 0;
            FUN_000b5bbc(param_1, (&DAT_00139f44)[local_c], &local_e);
            *(undefined2 *)(param_2 + local_c * 2) = local_e;
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0,
                       "Get one chain ISL: domain addr = %x vol=%u",
                       (&DAT_00139f44)[local_c], local_e);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/drv_pic/isl68127.c",
                 0xaf, "get_chain_isl_voltage", 0x15, 0xca, 0x3c, auStack_1010);
        }
        uVar1 = 1;
    }
    return uVar1;
}

undefined4 set_chain_isl_voltage(undefined4 param_1, undefined2 param_2)

{
    undefined1 auStack_1010[4098];
    undefined2 local_e;
    uint local_c;

    for (local_c = 0; local_c < 3; local_c = local_c + 1) {
        local_e = FUN_000b5c4c(param_1, (&DAT_00139f44)[local_c], param_2);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0,
                   "Set one chain ISL: domain addr = %x set vol %d, get vol %d",
                   (&DAT_00139f44)[local_c], param_2, local_e);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/drv_pic/"
             "isl68127.c",
             0xaf, "set_chain_isl_voltage", 0x15, 0xd7, 0x3c, auStack_1010);
    }
    return 1;
}

void FUN_000b61c4(uint *param_1)

{
    char acStack_1810[2048];
    undefined1 auStack_1010[4096];
    uint local_10;
    uint local_c;

    if (param_1 != (uint *)0x0) {
        memcpy(acStack_1810,
               "==========================capability "
               "start==========================\n",
               0x46);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, acStack_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_common.c",
             0xbc, "platform_dump_capability", 0x18, 0x1a, 0x14, auStack_1010);
        snprintf(acStack_1810, 0x800, "board num = %d\n", *param_1);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, acStack_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_common.c",
             0xbc, "platform_dump_capability", 0x18, 0x1b, 0x14, auStack_1010);
        for (local_c = 0; local_c < *param_1; local_c = local_c + 1) {
            snprintf(acStack_1810, 0x800, "board id = %d, chain num = %d\n",
                     param_1[local_c * 0x12 + 1], param_1[local_c * 0x12 + 2]);
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0, acStack_1810);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_common.c",
                 0xbc, "platform_dump_capability", 0x18, 0x1e, 0x14,
                 auStack_1010);
            for (local_10 = 0; local_10 < param_1[local_c * 0x12 + 2];
                 local_10 = local_10 + 1) {
                snprintf(acStack_1810, 0x800, "\tchain id = %d\n",
                         param_1[local_c * 0x12 + local_10 + 3]);
                V_LOCK();
                logfmt_raw(auStack_1010, 0x1000, 0, acStack_1810);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_common.c",
                     0xbc, "platform_dump_capability", 0x18, 0x21, 0x14,
                     auStack_1010);
            }
        }
        memcpy(acStack_1810,
               "==========================capability "
               "end============================\n",
               0x46);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, acStack_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_common.c",
             0xbc, "platform_dump_capability", 0x18, 0x24, 0x14, auStack_1010);
    }
    return;
}

undefined4 platform_init(void)

{
    int iVar1;
    undefined4 uVar2;
    char local_181c[16];
    undefined2 local_180c;
    undefined1 auStack_101c[4099];
    char local_19;
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    if (platform_inited == 0) {
        iVar1 = fpga_init();
        if (iVar1 == 0) {
            iVar1 = gpio_init();
            if (iVar1 == 0) {
                memset(&DAT_001603f8, 0, 0x124);
                local_18 = hal_chain_max_num();
                local_14 = 0;
                while (true) {
                    if (local_18 <= local_14)
                        break;
                    local_10 = hal_chain_plug_addr(local_14);
                    if (local_10 < 0) {
                        snprintf(local_181c, 0x800,
                                 "fail to get socket for chain %d\n", local_14);
                        V_LOCK();
                        logfmt_raw(auStack_101c, 0x1000, 0, local_181c);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/device/"
                             "hal/platform/cv183x/cv183x_common.c",
                             0xbc, "platform_init", 0xd, 0x3f, 0x50,
                             auStack_101c);
                    } else {
                        gpio_export(local_10);
                        gpio_direction(local_10, 0);
                        local_c = hal_chain_reset_addr(local_14);
                        if (local_c < 0) {
                            snprintf(local_181c, 0x800,
                                     "fail to get reset for chain %d\n",
                                     local_14);
                            V_LOCK();
                            logfmt_raw(auStack_101c, 0x1000, 0, local_181c);
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/backend/"
                                 "device/hal/platform/cv183x/cv183x_common.c",
                                 0xbc, "platform_init", 0xd, 0x48, 0x50,
                                 auStack_101c);
                        } else {
                            gpio_export(local_c);
                            gpio_direction(local_c, 1);
                            local_19 = '\0';
                            gpio_read(local_10, &local_19);
                            if (local_19 == '\x01') {
                                *(int *)(&DAT_001603fc + DAT_001603f8 * 0x48) =
                                    local_14;
                                *(int *)(&DAT_001603fc +
                                         (DAT_001603f8 * 0x12 +
                                          *(int *)(&DAT_00160400 +
                                                   DAT_001603f8 * 0x48) +
                                          2) *
                                             4) = local_14;
                                *(int *)(&DAT_00160400 + DAT_001603f8 * 0x48) =
                                    *(int *)(&DAT_00160400 +
                                             DAT_001603f8 * 0x48) +
                                    1;
                                DAT_001603f8 = DAT_001603f8 + 1;
                            } else {
                                snprintf(local_181c, 0x800,
                                         "no board pluged in socket %d",
                                         local_10);
                                V_LOCK();
                                logfmt_raw(auStack_101c, 0x1000, 0, local_181c);
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/backend/"
                                     "device/hal/platform/cv183x/"
                                     "cv183x_common.c",
                                     0xbc, "platform_init", 0xd, 0x59, 0x50,
                                     auStack_101c);
                            }
                        }
                    }
                    local_14 = local_14 + 1;
                }
                FUN_000b61c4(&DAT_001603f8);
                platform_inited = 1;
                fan_init();
                uart_init();
                uVar2 = 0;
            } else {
                builtin_strncpy(local_181c, "gpio init failed", 0x10);
                local_180c = 10;
                V_LOCK();
                logfmt_raw(auStack_101c, 0x1000, 0, local_181c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_common.c",
                     0xbc, "platform_init", 0xd, 0x32, 100, auStack_101c);
                uVar2 = 0xfffffffe;
            }
        } else {
            builtin_strncpy(local_181c, "fpga init failed", 0x10);
            local_180c = 10;
            V_LOCK();
            logfmt_raw(auStack_101c, 0x1000, 0, local_181c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_common.c",
                 0xbc, "platform_init", 0xd, 0x2d, 100, auStack_101c);
            uVar2 = 0xffffffff;
        }
    } else {
        uVar2 = 0;
    }
    return uVar2;
}

void platform_uninit(void)

{
    char acStack_1818[2048];
    undefined1 auStack_1018[4096];
    int local_18;
    int local_14;
    int local_10;
    int local_c;

    if (platform_inited != 0) {
        local_10 = hal_chain_max_num();
        fpga_uninit();
        local_c = 0;
        while (true) {
            if (local_10 <= local_c)
                break;
            local_14 = hal_chain_plug_addr(local_c);
            if (local_14 < 0) {
                snprintf(acStack_1818, 0x800,
                         "fail to get socket for chain %d\n", local_c);
                V_LOCK();
                logfmt_raw(auStack_1018, 0x1000, 0, acStack_1818);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_common.c",
                     0xbc, "platform_uninit", 0xf, 0x70, 0x50, auStack_1018);
            } else {
                gpio_unexport(local_14);
                local_18 = hal_chain_reset_addr(local_c);
                if (local_18 < 0) {
                    snprintf(acStack_1818, 0x800,
                             "fail to get reset for chain %d\n", local_c);
                    V_LOCK();
                    logfmt_raw(auStack_1018, 0x1000, 0, acStack_1818);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/platform/cv183x/cv183x_common.c",
                         0xbc, "platform_uninit", 0xf, 0x78, 0x50,
                         auStack_1018);
                } else {
                    gpio_unexport(local_18);
                }
            }
            local_c = local_c + 1;
        }
        uart_uninit();
        fan_uninit();
        ui_uninit();
        gpio_uninit();
        platform_inited = 0;
    }
    return;
}

void get_system_capability(void *param_1)

{
    if (param_1 != (void *)0x0) {
        memcpy(param_1, &DAT_001603f8, 0x124);
    }
    return;
}

undefined4 FUN_000b6dc4(char *param_1, int param_2)

{
    int iVar1;
    undefined4 uVar2;
    char local_1830[8];
    undefined4 local_1828;
    undefined1 auStack_1030[4096];
    char acStack_30[18];
    undefined1 auStack_1e[14];
    int local_10;
    int local_c;

    local_c = 0;
    local_c = socket(2, 1, 0);
    if (local_c < 0) {
        builtin_strncpy(local_1830, "error so", 8);
        local_1828 = CONCAT13(local_1828._3_1_, 0x6b63);
        V_LOCK();
        logfmt_raw(auStack_1030, 0x1000, 0, local_1830);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_common.c",
             0xbc, "get_eth_mac", 0xb, 0x96, 100, auStack_1030);
        uVar2 = 0xffffffff;
    } else {
        strcpy(acStack_30, param_1);
        iVar1 = ioctl(local_c, 0x8927, acStack_30);
        if (iVar1 < 0) {
            builtin_strncpy(local_1830, "error io", 8);
            local_1828._0_1_ = 'c';
            local_1828._1_1_ = 't';
            local_1828._2_1_ = 'l';
            local_1828._3_1_ = '\0';
            V_LOCK();
            logfmt_raw(auStack_1030, 0x1000, 0, local_1830);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_common.c",
                 0xbc, "get_eth_mac", 0xb, 0x9c, 100, auStack_1030);
            close(local_c);
            uVar2 = 0xfffffffe;
        } else {
            for (local_10 = 0; local_10 < 6; local_10 = local_10 + 1) {
                *(undefined1 *)(param_2 + local_10) = auStack_1e[local_10];
            }
            close(local_c);
            uVar2 = 0;
        }
    }
    return uVar2;
}

undefined4 get_uuid(void *param_1)

{
    undefined4 uVar1;

    if (param_1 == (void *)0x0) {
        uVar1 = 0xffffffff;
    } else {
        memset(param_1, 0, 0x10);
        uVar1 = FUN_000b6dc4(&DAT_0013a400, param_1);
    }
    return uVar1;
}

undefined4 get_mac(int param_1)

{
    undefined4 uVar1;

    if (param_1 == 0) {
        uVar1 = 0xffffffff;
    } else {
        uVar1 = FUN_000b6dc4(&DAT_0013a400, param_1);
    }
    return uVar1;
}

void chain_reset_low(undefined4 param_1)

{
    char acStack_180c[2048];
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    local_c = hal_chain_reset_addr(param_1);
    if (local_c < 0) {
        snprintf(acStack_180c, 0x800, "bad chain id = %d\n", param_1);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_common.c",
             0xbc, "chain_reset_low", 0xf, 200, 100, auStack_100c);
    } else {
        gpio_write(local_c, 0);
    }
    return;
}

void chain_reset_high(undefined4 param_1)

{
    char acStack_180c[2048];
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    local_c = hal_chain_reset_addr(param_1);
    if (local_c < 0) {
        snprintf(acStack_180c, 0x800, "bad chain id = %d\n", param_1);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_common.c",
             0xbc, "chain_reset_high", 0x10, 0xd6, 100, auStack_100c);
    } else {
        gpio_write(local_c, 1);
    }
    return;
}

void chain_reset(undefined4 param_1)

{
    chain_reset_low(param_1);
    usleep(100000);
    chain_reset_high(param_1);
    return;
}

uint get_hash_on_plug(void)

{
    char local_181c[2048];
    undefined1 auStack_101c[4096];
    int local_1c;
    uint local_18;
    int local_14;
    uint local_10;
    int local_c;

    local_14 = 0;
    local_10 = 0;
    local_c = 0;
    local_1c = 0;
    if (platform_inited == 0) {
        builtin_strncpy(local_181c, "platform not inited", 0x14);
        V_LOCK();
        logfmt_raw(auStack_101c, 0x1000, 0, local_181c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_common.c",
             0xbc, "get_hash_on_plug", 0x10, 0xee, 100, auStack_101c);
        local_10 = 0;
    } else {
        local_14 = hal_chain_max_num();
        for (local_18 = 0; (int)local_18 < local_14; local_18 = local_18 + 1) {
            local_1c = 0;
            local_c = hal_chain_plug_addr(local_18);
            if (local_c < 0) {
                snprintf(local_181c, 0x800, "fail to get slot for chain %d",
                         local_18);
                V_LOCK();
                logfmt_raw(auStack_101c, 0x1000, 0, local_181c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_common.c",
                     0xbc, "get_hash_on_plug", 0x10, 0xf9, 0x50, auStack_101c);
            } else {
                gpio_export(local_c);
                gpio_direction(local_c, 0);
                gpio_read(local_c, &local_1c);
                local_10 = local_10 | local_1c << (local_18 & 0xff);
            }
        }
    }
    return local_10;
}

undefined4 enable_bypass_mode(void)

{
    return 0;
}

undefined4 FUN_000b7570(void)

{
    int iVar1;
    char acStack_182c[2048];
    undefined1 auStack_102c[4096];
    undefined4 local_2c;
    uint local_28;
    byte local_21;
    undefined4 local_20;
    undefined4 *local_1c;
    int local_18;
    undefined4 *local_14;
    int local_10;
    int local_c;

    local_c = 0;
    prctl(0xf, &DAT_0013a4d4);
    do {
        if (DAT_00160520 == 0) {
            return 0;
        }
        iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_00160540);
        if (iVar1 == 0) {
            local_14 = (undefined4 *)new_iterator_c_map(DAT_00160558);
            local_10 = (*(code *)*local_14)(local_14);
            while (local_10 != 0) {
                local_18 = local_14[5];
                local_1c = (undefined4 *)(*(code *)local_14[2])(local_10);
                local_20 = *(undefined4 *)**(undefined4 **)(local_18 + 0x10);
                local_21 = 0;
                local_c = gpio_read(local_20, &local_21);
                if (local_c != 0) {
                    snprintf(acStack_182c, 0x800, "failed to read gpio port %d",
                             local_20);
                    V_LOCK();
                    logfmt_raw(auStack_102c, 0x1000, 0, acStack_182c);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/platform/cv183x/cv183x_gpio.c",
                         0xba, "gpio_thread_function", 0x14, 0x3c, 0x14,
                         auStack_102c);
                    free(local_1c);
                    break;
                }
                if (local_1c[1] != (uint)local_21) {
                    snprintf(acStack_182c, 0x800,
                             "gpio port %d, last val = %d, new val = %d",
                             *(undefined4 *)**(undefined4 **)(local_18 + 0x10),
                             local_1c[1], (uint)local_21);
                    V_LOCK();
                    logfmt_raw(auStack_102c, 0x1000, 0, acStack_182c);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/platform/cv183x/cv183x_gpio.c",
                         0xba, "gpio_thread_function", 0x14, 0x42, 0x14,
                         auStack_102c);
                    (*(code *)*local_1c)(local_20, local_21);
                    local_2c = *local_1c;
                    local_28 = (uint)local_21;
                    (*(code *)local_14[1])(local_14, &local_2c, 8);
                }
                free(local_1c);
                local_10 = (*(code *)*local_14)(local_14);
            }
            delete_iterator_c_map(local_14);
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160540);
        }
        usleep(200000);
    } while (true);
}

undefined4 gpio_init(void)

{
    char local_1808[2048];
    undefined1 auStack_1008[4096];

    if (DAT_0016051c == 0) {
        pthread_mutex_init((pthread_mutex_t *)&DAT_00160540,
                           (pthread_mutexattr_t *)0x0);
        DAT_00160558 = new_c_map(&LAB_000b7538, 0, 0);
        pthread_mutex_init((pthread_mutex_t *)&DAT_00160528,
                           (pthread_mutexattr_t *)0x0);
        DAT_00160520 = 1;
        pthread_create(&DAT_00160524, (pthread_attr_t *)0x0, FUN_000b7570,
                       (void *)0x0);
        DAT_0016051c = 1;
    } else {
        builtin_strncpy(local_1808, "gpio re init", 0xc);
        local_1808[0xc] = 0;
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_gpio.c",
             0xba, "gpio_init", 9, 0x5c, 0x50, auStack_1008);
    }
    return 0;
}

void gpio_uninit(void)

{
    if (DAT_0016051c != 0) {
        DAT_00160520 = 0;
        pthread_join(DAT_00160524, (void **)0x0);
        pthread_mutex_destroy((pthread_mutex_t *)&DAT_00160540);
        delete_c_map(DAT_00160558);
        DAT_0016051c = 0;
        pthread_mutex_destroy((pthread_mutex_t *)&DAT_00160528);
    }
    return;
}

undefined4 gpio_reg_callback(undefined4 param_1, int param_2)

{
    int iVar1;
    undefined4 uVar2;
    undefined4 local_1814;
    char local_1810[8];
    undefined4 local_1808;
    char acStack_1804[2036];
    undefined1 auStack_1010[4096];
    int local_10[2];

    local_1814 = param_1;
    if (param_2 == 0) {
        builtin_strncpy(local_1810, "bad para", 8);
        local_1808 = CONCAT22(local_1808._2_2_, 0x6d);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_gpio.c",
             0xba, "gpio_reg_callback", 0x11, 0x8a, 100, auStack_1010);
        uVar2 = 0xffffffff;
    } else {
        iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_00160540);
        if (iVar1 == 0) {
            iVar1 = exists_c_map(DAT_00160558, &local_1814);
            if (iVar1 == 0) {
                snprintf(local_1810, 0x800, "add %d to callback map",
                         local_1814);
                V_LOCK();
                logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_gpio.c",
                     0xba, "gpio_reg_callback", 0x11, 0x95, 0x14, auStack_1010);
                local_10[1] = 0xffffffff;
                local_10[0] = param_2;
                insert_c_map(DAT_00160558, &local_1814, 4, local_10, 8);
            } else {
                snprintf(local_1810, 0x800,
                         "port %d already exist in callback map ", local_1814);
                V_LOCK();
                logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_gpio.c",
                     0xba, "gpio_reg_callback", 0x11, 0x9b, 0x14, auStack_1010);
            }
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160540);
            uVar2 = 0;
        } else {
            builtin_strncpy(local_1810, "fail to ", 8);
            local_1808._0_1_ = 'l';
            local_1808._1_1_ = 'o';
            local_1808._2_1_ = 'c';
            local_1808._3_1_ = 'k';
            builtin_strncpy(acStack_1804, " gpio ctrl mutex", 0x10);
            acStack_1804[0x10] = 0;
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_gpio.c",
                 0xba, "gpio_reg_callback", 0x11, 0x8f, 100, auStack_1010);
            uVar2 = 0xffffffff;
        }
    }
    return uVar2;
}

undefined4 gpio_unreg_callback(undefined4 param_1, int param_2)

{
    int iVar1;
    undefined4 uVar2;
    undefined4 local_180c;
    char local_1808[8];
    undefined4 local_1800;
    char acStack_17fc[16];
    uint local_17ec;
    char local_17e8[2016];
    undefined1 auStack_1008[4096];

    local_180c = param_1;
    if (param_2 == 0) {
        builtin_strncpy(local_1808, "bad para", 8);
        local_1800 = CONCAT22(local_1800._2_2_, 0x6d);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_gpio.c",
             0xba, "gpio_unreg_callback", 0x13, 0xad, 100, auStack_1008);
        uVar2 = 0xffffffff;
    } else {
        iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_00160540);
        if (iVar1 == 0) {
            iVar1 = exists_c_map(DAT_00160558, &local_180c);
            if (iVar1 == 1) {
                snprintf(local_1808, 0x800, "remove %d from callback list",
                         local_180c);
                V_LOCK();
                logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_gpio.c",
                     0xba, "gpio_unreg_callback", 0x13, 0xb8, 0x14,
                     auStack_1008);
                remove_c_map(DAT_00160558, &local_180c);
            } else {
                builtin_strncpy(local_1808, "callback", 8);
                local_1800._0_1_ = ' ';
                local_1800._1_1_ = 'f';
                local_1800._2_1_ = 'u';
                local_1800._3_1_ = 'n';
                builtin_strncpy(acStack_17fc, "ction not regist", 0x10);
                local_17ec._0_1_ = 'e';
                local_17ec._1_1_ = 'r';
                local_17ec._2_1_ = 'e';
                local_17ec._3_1_ = 'd';
                builtin_strncpy(local_17e8, " before", 8);
                V_LOCK();
                logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_gpio.c",
                     0xba, "gpio_unreg_callback", 0x13, 0xbd, 0x50,
                     auStack_1008);
            }
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160540);
            uVar2 = 0;
        } else {
            builtin_strncpy(local_1808, "fail to ", 8);
            local_1800._0_1_ = 'l';
            local_1800._1_1_ = 'o';
            local_1800._2_1_ = 'c';
            local_1800._3_1_ = 'k';
            builtin_strncpy(acStack_17fc, " gpio ctrl mutex", 0x10);
            local_17ec = local_17ec & 0xffffff00;
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_gpio.c",
                 0xba, "gpio_unreg_callback", 0x13, 0xb2, 100, auStack_1008);
            uVar2 = 0xffffffff;
        }
    }
    return uVar2;
}

undefined4 gpio_export(undefined4 param_1)

{
    int iVar1;
    ssize_t sVar2;
    undefined4 uVar3;
    char local_1850[16];
    undefined4 local_1840;
    char acStack_183c[12];
    undefined2 local_1830;
    undefined1 local_182e;
    undefined1 auStack_1050[4096];
    char acStack_50[64];
    int local_10;
    size_t local_c;

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_00160528);
    if (iVar1 == 0) {
        snprintf(acStack_50, 0x40, "/sys/class/gpio/gpio%d", param_1);
        iVar1 = access(acStack_50, 0);
        if (iVar1 == 0) {
            snprintf(local_1850, 0x800, "port %d already exported", param_1);
            V_LOCK();
            logfmt_raw(auStack_1050, 0x1000, 0, local_1850);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_gpio.c",
                 0xba, "gpio_export", 0xb, 0xd8, 0x28, auStack_1050);
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
            uVar3 = 0;
        } else {
            local_10 = open("/sys/class/gpio/export", 1);
            if (local_10 < 0) {
                builtin_strncpy(local_1850, "Failed to open e", 0x10);
                local_1840._0_1_ = 'x';
                local_1840._1_1_ = 'p';
                local_1840._2_1_ = 'o';
                local_1840._3_1_ = 'r';
                builtin_strncpy(acStack_183c, "t for writin", 0xc);
                local_1830 = 0x2167;
                local_182e = 0;
                V_LOCK();
                logfmt_raw(auStack_1050, 0x1000, 0, local_1850);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_gpio.c",
                     0xba, "gpio_export", 0xb, 0xe0, 100, auStack_1050);
                pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
                uVar3 = 0xfffffffe;
            } else {
                local_c = snprintf(acStack_50, 0x40, "%d", param_1);
                sVar2 = write(local_10, acStack_50, local_c);
                if (sVar2 < 0) {
                    snprintf(local_1850, 0x800, "Failed to export gpio %d!",
                             param_1);
                    V_LOCK();
                    logfmt_raw(auStack_1050, 0x1000, 0, local_1850);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/platform/cv183x/cv183x_gpio.c",
                         0xba, "gpio_export", 0xb, 0xe7, 100, auStack_1050);
                    close(local_10);
                    pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
                    uVar3 = 0xfffffffd;
                } else {
                    snprintf(local_1850, 0x800, "export gpio %d success",
                             param_1);
                    V_LOCK();
                    logfmt_raw(auStack_1050, 0x1000, 0, local_1850);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/platform/cv183x/cv183x_gpio.c",
                         0xba, "gpio_export", 0xb, 0xec, 0x14, auStack_1050);
                    close(local_10);
                    pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
                    uVar3 = 0;
                }
            }
        }
    } else {
        builtin_strncpy(local_1850, "failed to api lo", 0x10);
        local_1840 = CONCAT13(local_1840._3_1_, 0x6b63);
        V_LOCK();
        logfmt_raw(auStack_1050, 0x1000, 0, local_1850);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_gpio.c",
             0xba, "gpio_export", 0xb, 0xd1, 100, auStack_1050);
        uVar3 = 0xffffffff;
    }
    return uVar3;
}

undefined4 gpio_unexport(undefined4 param_1)

{
    int iVar1;
    ssize_t sVar2;
    undefined4 uVar3;
    char local_1850[16];
    undefined4 local_1840;
    char acStack_183c[2028];
    undefined1 auStack_1050[4096];
    char acStack_50[64];
    int local_10;
    size_t local_c;

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_00160528);
    if (iVar1 == 0) {
        snprintf(acStack_50, 0x40, "/sys/class/gpio/gpio%d", param_1);
        local_10 = access(acStack_50, 0);
        if (local_10 == 0) {
            local_10 = open("/sys/class/gpio/unexport", 1);
            if (local_10 < 0) {
                builtin_strncpy(local_1850, "Failed to open u", 0x10);
                local_1840._0_1_ = 'n';
                local_1840._1_1_ = 'e';
                local_1840._2_1_ = 'x';
                local_1840._3_1_ = 'p';
                builtin_strncpy(acStack_183c, "ort for writing!", 0x10);
                acStack_183c[0x10] = 0;
                V_LOCK();
                logfmt_raw(auStack_1050, 0x1000, 0, local_1850);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_gpio.c",
                     0xba, "gpio_unexport", 0xd, 0x10f, 100, auStack_1050);
                pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
                uVar3 = 0xfffffffe;
            } else {
                local_c = snprintf(acStack_50, 0x40, "%d", param_1);
                sVar2 = write(local_10, acStack_50, local_c);
                if (sVar2 < 0) {
                    snprintf(local_1850, 0x800, "Failed to unexport gpio %d!",
                             param_1);
                    V_LOCK();
                    logfmt_raw(auStack_1050, 0x1000, 0, local_1850);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/platform/cv183x/cv183x_gpio.c",
                         0xba, "gpio_unexport", 0xd, 0x116, 100, auStack_1050);
                    close(local_10);
                    pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
                    uVar3 = 0xfffffffe;
                } else {
                    snprintf(local_1850, 0x800, "unexport gpio %d success",
                             param_1);
                    V_LOCK();
                    logfmt_raw(auStack_1050, 0x1000, 0, local_1850);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/platform/cv183x/cv183x_gpio.c",
                         0xba, "gpio_unexport", 0xd, 0x11b, 0x14, auStack_1050);
                    close(local_10);
                    pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
                    uVar3 = 0;
                }
            }
        } else {
            snprintf(local_1850, 0x800, "port %d already unexported, ret = %d",
                     param_1, local_10);
            V_LOCK();
            logfmt_raw(auStack_1050, 0x1000, 0, local_1850);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_gpio.c",
                 0xba, "gpio_unexport", 0xd, 0x107, 0x50, auStack_1050);
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
            uVar3 = 0;
        }
    } else {
        builtin_strncpy(local_1850, "failed to api lo", 0x10);
        local_1840 = CONCAT13(local_1840._3_1_, 0x6b63);
        V_LOCK();
        logfmt_raw(auStack_1050, 0x1000, 0, local_1850);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_gpio.c",
             0xba, "gpio_unexport", 0xd, 0x100, 100, auStack_1050);
        uVar3 = 0xffffffff;
    }
    return uVar3;
}

undefined4 gpio_direction(undefined4 param_1, int param_2)

{
    int iVar1;
    ssize_t sVar2;
    undefined4 uVar3;
    size_t __n;
    char local_184c[16];
    undefined2 local_183c;
    undefined1 local_183a;
    undefined1 auStack_104c[4096];
    char acStack_4c[64];
    int local_c;

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_00160528);
    if (iVar1 == 0) {
        snprintf(acStack_4c, 0x40, "/sys/class/gpio/gpio%d/direction", param_1);
        local_c = open(acStack_4c, 1);
        if (local_c < 0) {
            snprintf(local_184c, 0x800,
                     "Failed to open gpio %d direction for writing!", param_1);
            V_LOCK();
            logfmt_raw(auStack_104c, 0x1000, 0, local_184c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_gpio.c",
                 0xba, "gpio_direction", 0xe, 0x137, 100, auStack_104c);
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
            uVar3 = 0xfffffffe;
        } else {
            if (param_2 == 0) {
                iVar1 = 0;
            } else {
                iVar1 = 3;
            }
            if (param_2 == 0) {
                __n = 2;
            } else {
                __n = 3;
            }
            sVar2 = write(local_c, &DAT_0013a9cc + iVar1, __n);
            if (sVar2 < 0) {
                if (param_2 == 0) {
                    iVar1 = 0;
                } else {
                    iVar1 = 3;
                }
                snprintf(local_184c, 0x800,
                         "Failed to set gpio %d direction %s !", param_1,
                         &DAT_0013a9cc + iVar1);
                V_LOCK();
                logfmt_raw(auStack_104c, 0x1000, 0, local_184c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_gpio.c",
                     0xba, "gpio_direction", 0xe, 0x13d, 100, auStack_104c);
                close(local_c);
                pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
                uVar3 = 0xfffffffd;
            } else {
                if (param_2 == 0) {
                    iVar1 = 0;
                } else {
                    iVar1 = 3;
                }
                snprintf(local_184c, 0x800, "set gpio %d direction %s success!",
                         param_1, &DAT_0013a9cc + iVar1);
                V_LOCK();
                logfmt_raw(auStack_104c, 0x1000, 0, local_184c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_gpio.c",
                     0xba, "gpio_direction", 0xe, 0x142, 0x14, auStack_104c);
                close(local_c);
                pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
                uVar3 = 0;
            }
        }
    } else {
        builtin_strncpy(local_184c, "failed to api lo", 0x10);
        local_183c = 0x6b63;
        local_183a = 0;
        V_LOCK();
        logfmt_raw(auStack_104c, 0x1000, 0, local_184c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_gpio.c",
             0xba, "gpio_direction", 0xe, 0x130, 100, auStack_104c);
        uVar3 = 0xffffffff;
    }
    return uVar3;
}

undefined4 gpio_read(undefined4 param_1, undefined1 *param_2)

{
    int iVar1;
    ssize_t sVar2;
    undefined4 uVar3;
    char local_1850[16];
    undefined4 local_1840;
    undefined2 local_183c;
    undefined1 auStack_1050[4096];
    char local_50[68];
    int local_c;

    local_50[0] = '\0';
    local_50[1] = '\0';
    local_50[2] = '\0';
    local_50[3] = '\0';
    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_00160528);
    if (iVar1 == 0) {
        snprintf(local_50 + 4, 0x40, "/sys/class/gpio/gpio%d/value", param_1);
        local_c = open(local_50 + 4, 0);
        if (local_c < 0) {
            snprintf(local_1850, 0x800,
                     "Failed to open gpio %d value for reading!", param_1);
            V_LOCK();
            logfmt_raw(auStack_1050, 0x1000, 0, local_1850);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_gpio.c",
                 0xba, "gpio_read", 9, 0x15e, 100, auStack_1050);
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
            uVar3 = 0xfffffffe;
        } else {
            sVar2 = read(local_c, local_50, 4);
            if (sVar2 < 0) {
                builtin_strncpy(local_1850, "Failed to read v", 0x10);
                local_1840._0_1_ = 'a';
                local_1840._1_1_ = 'l';
                local_1840._2_1_ = 'u';
                local_1840._3_1_ = 'e';
                local_183c = 0x21;
                V_LOCK();
                logfmt_raw(auStack_1050, 0x1000, 0, local_1850);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_gpio.c",
                     0xba, "gpio_read", 9, 0x164, 100, auStack_1050);
                close(local_c);
                pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
                uVar3 = 0xfffffffd;
            } else {
                close(local_c);
                pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
                iVar1 = atoi(local_50);
                *param_2 = (char)iVar1;
                uVar3 = 0;
            }
        }
    } else {
        builtin_strncpy(local_1850, "failed to api lo", 0x10);
        local_1840 = CONCAT13(local_1840._3_1_, 0x6b63);
        V_LOCK();
        logfmt_raw(auStack_1050, 0x1000, 0, local_1850);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_gpio.c",
             0xba, "gpio_read", 9, 0x157, 100, auStack_1050);
        uVar3 = 0xffffffff;
    }
    return uVar3;
}

undefined4 gpio_write(undefined4 param_1, char param_2)

{
    int iVar1;
    ssize_t sVar2;
    undefined4 uVar3;
    char local_184c[16];
    undefined2 local_183c;
    undefined1 local_183a;
    undefined1 auStack_104c[4096];
    char acStack_4c[64];
    int local_c;

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_00160528);
    if (iVar1 == 0) {
        snprintf(acStack_4c, 0x40, "/sys/class/gpio/gpio%d/value", param_1);
        local_c = open(acStack_4c, 1);
        if (local_c < 0) {
            snprintf(local_184c, 0x800,
                     "Failed to open gpio[%d] value for writing!", param_1);
            V_LOCK();
            logfmt_raw(auStack_104c, 0x1000, 0, local_184c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_gpio.c",
                 0xba, "gpio_write", 10, 0x186, 100, auStack_104c);
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
            uVar3 = 0xfffffffe;
        } else {
            sVar2 = write(local_c, &DAT_0013a9ec + (param_2 != '\0'), 1);
            if (sVar2 < 0) {
                snprintf(local_184c, 0x800, "Failed to write gpio[%d] value!",
                         param_1);
                V_LOCK();
                logfmt_raw(auStack_104c, 0x1000, 0, local_184c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_gpio.c",
                     0xba, "gpio_write", 10, 0x18c, 100, auStack_104c);
                close(local_c);
                pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
                uVar3 = 0xfffffffd;
            } else {
                close(local_c);
                pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
                uVar3 = 0;
            }
        }
    } else {
        builtin_strncpy(local_184c, "failed to api lo", 0x10);
        local_183c = 0x6b63;
        local_183a = 0;
        V_LOCK();
        logfmt_raw(auStack_104c, 0x1000, 0, local_184c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_gpio.c",
             0xba, "gpio_write", 10, 0x17f, 100, auStack_104c);
        uVar3 = 0xffffffff;
    }
    return uVar3;
}

undefined4 is_gpio_exist(undefined4 param_1)

{
    int iVar1;
    undefined4 uVar2;
    char local_1848[16];
    undefined2 local_1838;
    undefined1 local_1836;
    undefined1 auStack_1048[4096];
    char acStack_48[64];

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_00160528);
    if (iVar1 == 0) {
        snprintf(acStack_48, 0x40, "/sys/class/gpio/gpio%d", param_1);
        iVar1 = access(acStack_48, 0);
        if (iVar1 == 0) {
            snprintf(local_1848, 0x800, "port %d already exported", param_1);
            V_LOCK();
            logfmt_raw(auStack_1048, 0x1000, 0, local_1848);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_gpio.c",
                 0xba, "is_gpio_exist", 0xd, 0x1a2, 0x14, auStack_1048);
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
            uVar2 = 1;
        } else {
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160528);
            uVar2 = 0;
        }
    } else {
        builtin_strncpy(local_1848, "failed to api lo", 0x10);
        local_1838 = 0x6b63;
        local_1836 = 0;
        V_LOCK();
        logfmt_raw(auStack_1048, 0x1000, 0, local_1848);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_gpio.c",
             0xba, "is_gpio_exist", 0xd, 0x19b, 100, auStack_1048);
        uVar2 = 0xffffffff;
    }
    return uVar2;
}

int i2c_init(char *param_1)

{
    int iVar1;
    char local_1820[12];
    undefined4 local_1814;
    char local_1810[2032];
    int local_1020;
    int local_101c;
    char acStack_1014[4084];
    int local_20;
    void *local_1c;
    undefined4 *local_18;
    int local_14;
    int local_10;
    undefined4 local_c;

    local_c = 0xffffffff;
    local_10 = 1;
    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0016055c);
    if (iVar1 == 0) {
        if (DAT_00160578 == 0) {
            builtin_strncpy(local_1820, "init i2c map", 0xc);
            local_1814 = CONCAT22(local_1814._2_2_, 10);
            V_LOCK();
            logfmt_raw(&local_1020, 0x1000, 0, local_1820);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_i2c.c",
                 0xb9, "i2c_init", 8, 0x33, 0x14, &local_1020);
            DAT_00160574 = new_c_map(&LAB_000b9658, 0, 0);
        }
        local_18 = (undefined4 *)new_iterator_c_map(DAT_00160574);
        local_14 = (*(code *)*local_18)(local_18);
        while (local_14 != 0) {
            local_1c = (void *)(*(code *)local_18[2])(local_14);
            iVar1 = strncmp(param_1, (char *)((int)local_1c + 0xc), 0x100);
            if (iVar1 == 0) {
                snprintf(local_1820, 0x800, "%s has already opened\n", param_1);
                V_LOCK();
                logfmt_raw(&local_1020, 0x1000, 0, local_1820);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_i2c.c",
                     0xb9, "i2c_init", 8, 0x3e, 0x14, &local_1020);
                memset(&local_1020, 0, 0x10c);
                DAT_00160578 = DAT_00160578 + 1;
                local_101c = *(int *)((int)local_1c + 4);
                local_1020 = DAT_00160578;
                strncpy(acStack_1014, param_1, 0x100);
                insert_c_map(DAT_00160574, &DAT_00160578, 4, &local_1020,
                             0x10c);
                local_10 = 0;
                free(local_1c);
                break;
            }
            free(local_1c);
            local_14 = (*(code *)*local_18)(local_18);
        }
        delete_iterator_c_map(local_18);
        if (local_10 != 0) {
            local_20 = open(param_1, 0x802);
            if (local_20 < 0) {
                snprintf(local_1820, 0x800, "failed to open %s\n", param_1);
                V_LOCK();
                logfmt_raw(&local_1020, 0x1000, 0, local_1820);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_i2c.c",
                     0xb9, "i2c_init", 8, 0x50, 100, &local_1020);
                pthread_mutex_unlock((pthread_mutex_t *)&DAT_0016055c);
                return -1;
            }
            memset(&local_1020, 0, 0x10c);
            DAT_00160578 = DAT_00160578 + 1;
            local_101c = local_20;
            local_1020 = DAT_00160578;
            strncpy(acStack_1014, param_1, 0x100);
            insert_c_map(DAT_00160574, &DAT_00160578, 4, &local_1020, 0x10c);
        }
        pthread_mutex_unlock((pthread_mutex_t *)&DAT_0016055c);
        iVar1 = DAT_00160578;
    } else {
        builtin_strncpy(local_1820, "failed to i2", 0xc);
        local_1814._0_1_ = 'c';
        local_1814._1_1_ = ' ';
        local_1814._2_1_ = 'l';
        local_1814._3_1_ = 'o';
        builtin_strncpy(local_1810, "ck\n", 4);
        V_LOCK();
        logfmt_raw(&local_1020, 0x1000, 0, local_1820);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_i2c.c",
             0xb9, "i2c_init", 8, 0x2d, 100, &local_1020);
        iVar1 = -4;
    }
    return iVar1;
}

void i2c_uninit(undefined4 param_1)

{
    int iVar1;
    undefined4 local_182c[2];
    char local_1824[2048];
    undefined1 auStack_1024[4096];
    void *local_24;
    undefined4 *local_20;
    undefined4 *local_1c;
    void *local_18;
    int local_14;
    undefined4 local_10;
    int local_c;

    local_10 = 0;
    local_c = 1;
    local_24 = (void *)0x0;
    local_182c[0] = param_1;
    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0016055c);
    if (iVar1 == 0) {
        iVar1 = find_c_map(DAT_00160574, local_182c, &local_24);
        if (iVar1 == 1) {
            local_18 = local_24;
            remove_c_map(DAT_00160574, local_182c);
            local_1c = (undefined4 *)new_iterator_c_map(DAT_00160574);
            local_14 = (*(code *)*local_1c)(local_1c);
            while (local_14 != 0) {
                local_20 = (undefined4 *)(*(code *)local_1c[2])(local_14);
                iVar1 = strncmp((char *)((int)local_18 + 0xc),
                                (char *)(local_20 + 3), 0x100);
                if (iVar1 == 0) {
                    snprintf(local_1824, 0x800, "%s still open for %d\n",
                             (int)local_18 + 0xc, *local_20);
                    V_LOCK();
                    logfmt_raw(auStack_1024, 0x1000, 0, local_1824);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/platform/cv183x/cv183x_i2c.c",
                         0xb9, "i2c_uninit", 10, 0x77, 0x14, auStack_1024);
                    local_c = 0;
                    free(local_20);
                    break;
                }
                free(local_20);
                local_14 = (*(code *)*local_1c)(local_1c);
            }
            delete_iterator_c_map(local_1c);
        } else {
            local_c = 0;
            snprintf(local_1824, 0x800, "ctx(%d) not inited\n", local_182c[0]);
            V_LOCK();
            logfmt_raw(auStack_1024, 0x1000, 0, local_1824);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_i2c.c",
                 0xb9, "i2c_uninit", 10, 0x84, 0x50, auStack_1024);
        }
        if (local_c != 0) {
            close(*(int *)((int)local_24 + 4));
        }
        if (local_24 != (void *)0x0) {
            free(local_24);
        }
        pthread_mutex_unlock((pthread_mutex_t *)&DAT_0016055c);
    } else {
        builtin_strncpy(local_1824, "failed to i2c lock\n", 0x14);
        V_LOCK();
        logfmt_raw(auStack_1024, 0x1000, 0, local_1824);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_i2c.c",
             0xb9, "i2c_uninit", 10, 0x66, 100, auStack_1024);
    }
    return;
}

undefined4 i2c_read(undefined4 param_1, void *param_2, size_t param_3)

{
    int iVar1;
    size_t sVar2;
    undefined4 local_181c;
    char local_1818[2048];
    undefined1 auStack_1018[4096];
    void *local_18;
    undefined4 local_14;
    undefined4 local_10;
    void *local_c;

    local_14 = 0;
    local_181c = param_1;
    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0016055c);
    if (iVar1 == 0) {
        local_10 = 0;
        iVar1 = find_c_map(DAT_00160574, &local_181c, &local_18);
        if (iVar1 == 1) {
            local_c = local_18;
            snprintf(local_1818, 0x800, "i2c read path = %s, addr = %d\n",
                     (int)local_18 + 0xc, *(uint *)((int)local_18 + 8) >> 1);
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_i2c.c",
                 0xb9, "i2c_read", 8, 0xa7, 0x14, auStack_1018);
            iVar1 = ioctl(*(int *)((int)local_c + 4), 0x703,
                          *(uint *)((int)local_c + 8) >> 1);
            if (iVar1 < 0) {
                snprintf(local_1818, 0x800,
                         "read io ctrl for path = %s, addr = %d failed\n",
                         (int)local_c + 0xc, *(undefined4 *)((int)local_c + 8));
                V_LOCK();
                logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_i2c.c",
                     0xb9, "i2c_read", 8, 0xaa, 100, auStack_1018);
                free(local_18);
                pthread_mutex_unlock((pthread_mutex_t *)&DAT_0016055c);
                local_14 = 0xfffffffd;
            } else {
                sVar2 = read(*(int *)((int)local_c + 4), param_2, param_3);
                if (param_3 != sVar2) {
                    snprintf(local_1818, 0x800, "fail to read %d\n", param_3);
                    V_LOCK();
                    logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/platform/cv183x/cv183x_i2c.c",
                         0xb9, "i2c_read", 8, 0xb5, 100, auStack_1018);
                }
                free(local_18);
                pthread_mutex_unlock((pthread_mutex_t *)&DAT_0016055c);
            }
        } else {
            snprintf(local_1818, 0x800, "ctx %d not inited\n", local_181c);
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_i2c.c",
                 0xb9, "i2c_read", 8, 0xbc, 100, auStack_1018);
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_0016055c);
            local_14 = 0xfffffffc;
        }
    } else {
        builtin_strncpy(local_1818, "failed to i2c lock\n", 0x14);
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_i2c.c",
             0xb9, "i2c_read", 8, 0x9f, 100, auStack_1018);
        local_14 = 0xffffffff;
    }
    return local_14;
}

uint i2c_write(undefined4 param_1, int param_2, uint param_3)

{
    int iVar1;
    ssize_t sVar2;
    undefined4 local_181c;
    char local_1818[2048];
    undefined1 auStack_1018[4096];
    void *local_18;
    uint local_14;
    undefined4 local_10;
    void *local_c;

    local_14 = 0;
    local_181c = param_1;
    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0016055c);
    if (iVar1 == 0) {
        local_10 = 0;
        iVar1 = find_c_map(DAT_00160574, &local_181c, &local_18);
        if (iVar1 == 1) {
            local_c = local_18;
            snprintf(local_1818, 0x800, "i2c write path = %s, addr = %d\n",
                     (int)local_18 + 0xc, *(undefined4 *)((int)local_18 + 8));
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_i2c.c",
                 0xb9, "i2c_write", 9, 0xdb, 0x14, auStack_1018);
            iVar1 = ioctl(*(int *)((int)local_c + 4), 0x703,
                          *(uint *)((int)local_c + 8) >> 1);
            if (iVar1 < 0) {
                snprintf(local_1818, 0x800,
                         "write io ctrl for path = %s, addr = %d failed\n",
                         (int)local_c + 0xc, *(undefined4 *)((int)local_c + 8));
                V_LOCK();
                logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_i2c.c",
                     0xb9, "i2c_write", 9, 0xde, 100, auStack_1018);
                free(local_18);
                pthread_mutex_unlock((pthread_mutex_t *)&DAT_0016055c);
                param_3 = 0xfffffffd;
            } else {
                for (local_14 = 0; local_14 < param_3;
                     local_14 = local_14 + 1) {
                    sVar2 = write(*(int *)((int)local_c + 4),
                                  (void *)(param_2 + local_14), 1);
                    if (sVar2 != 1) {
                        snprintf(local_1818, 0x800, "fail to write %d:%d\n",
                                 local_14, param_3);
                        V_LOCK();
                        logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/device/"
                             "hal/platform/cv183x/cv183x_i2c.c",
                             0xb9, "i2c_write", 9, 0xe8, 100, auStack_1018);
                    }
                }
                free(local_18);
                usleep(10000);
                pthread_mutex_unlock((pthread_mutex_t *)&DAT_0016055c);
            }
        } else {
            snprintf(local_1818, 0x800, "ctx %d not inited\n", local_181c);
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_i2c.c",
                 0xb9, "i2c_write", 9, 0xef, 100, auStack_1018);
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_0016055c);
            param_3 = 0xfffffffc;
        }
    } else {
        builtin_strncpy(local_1818, "failed to i2c lock\n", 0x14);
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_i2c.c",
             0xb9, "i2c_write", 9, 0xd3, 100, auStack_1018);
        param_3 = 0xffffffff;
    }
    return param_3;
}

undefined4 i2c_ioctl(int param_1, short param_2, undefined4 param_3)

{
    int iVar1;
    undefined4 uVar2;
    char local_1818[2048];
    undefined1 auStack_1018[4096];
    void *local_18;
    int local_14;
    int local_10;
    undefined4 *local_c;

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0016055c);
    if (iVar1 == 0) {
        local_c = (undefined4 *)new_iterator_c_map(DAT_00160574);
        local_10 = (*(code *)*local_c)(local_c);
        while (local_10 != 0) {
            local_14 = local_c[5];
            if (*(int *)**(undefined4 **)(local_14 + 0x10) == param_1) {
                local_18 = (void *)(*(code *)local_c[2])(local_10);
                if (param_2 == 0x703) {
                    *(undefined4 *)((int)local_18 + 8) = param_3;
                    (*(code *)local_c[1])(local_c, local_18, 0x10c);
                    snprintf(local_1818, 0x800,
                             "update the slave address to %d\n", param_3);
                    V_LOCK();
                    logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/platform/cv183x/cv183x_i2c.c",
                         0xb9, "i2c_ioctl", 9, 0x115, 0x14, auStack_1018);
                    free(local_18);
                }
                break;
            }
            local_10 = (*(code *)*local_c)(local_c);
        }
        delete_iterator_c_map(local_c);
        pthread_mutex_unlock((pthread_mutex_t *)&DAT_0016055c);
        uVar2 = 0;
    } else {
        builtin_strncpy(local_1818, "failed to i2c lock\n", 0x14);
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, local_1818);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_i2c.c",
             0xb9, "i2c_ioctl", 9, 0x105, 100, auStack_1018);
        uVar2 = 0xfffffffc;
    }
    return uVar2;
}

undefined4 i2c_get_fd_from_ctx(undefined4 param_1)

{
    int iVar1;
    undefined4 local_1814;
    char local_1810[20];
    undefined2 local_17fc;
    undefined1 local_17fa;
    undefined1 auStack_1010[4096];
    void *local_10;
    undefined4 local_c;

    local_c = 0xffffffff;
    local_1814 = param_1;
    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_0016055c);
    if (iVar1 == 0) {
        iVar1 = find_c_map(DAT_00160574, &local_1814, &local_10);
        if (iVar1 == 0) {
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_0016055c);
            local_c = 0xfffffffe;
        } else {
            snprintf(local_1810, 0x800, "i2c dev = %s, addr = 0x%x, fd = %d",
                     (int)local_10 + 0xc, *(undefined4 *)((int)local_10 + 8),
                     *(undefined4 *)((int)local_10 + 4));
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_i2c.c",
                 0xb9, "i2c_get_fd_from_ctx", 0x13, 0x136, 0x14, auStack_1010);
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_0016055c);
            local_c = *(undefined4 *)((int)local_10 + 4);
            free(local_10);
        }
    } else {
        builtin_strncpy(local_1810, "failed to get i2c lo", 0x14);
        local_17fc = 0x6b63;
        local_17fa = 0;
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_i2c.c",
             0xb9, "i2c_get_fd_from_ctx", 0x13, 299, 100, auStack_1010);
        local_c = 0xfffffffc;
    }
    return local_c;
}

void cgsleep_ms(int param_1)

{
    usleep(param_1 * 1000);
    return;
}

void FUN_000bae88(void)

{
    cgsleep_ms(1);
    return;
}

void FUN_000baea0(void)

{
    char local_1810[20];
    undefined2 local_17fc;
    undefined1 auStack_1010[4099];
    undefined1 local_d;
    ssize_t local_c;

    local_d = 0x31;
    local_c = write(DAT_00150c24, &local_d, 1);
    if (local_c != 1) {
        builtin_strncpy(local_1810, "error! write SDA hig", 0x14);
        local_17fc = 0x68;
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_i2c_sim.c",
             0xbd, "sda_high", 8, 0x2d, 0x28, auStack_1010);
    }
    return;
}

void FUN_000baf9c(void)

{
    char local_1810[2048];
    undefined1 auStack_1010[4099];
    undefined1 local_d;
    ssize_t local_c;

    local_d = 0x30;
    local_c = write(DAT_00150c24, &local_d, 1);
    if (local_c != 1) {
        builtin_strncpy(local_1810, "error! write SDA low", 0x14);
        local_1810[0x14] = 0;
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_i2c_sim.c",
             0xbd, "sda_low", 7, 0x38, 0x28, auStack_1010);
    }
    return;
}

void FUN_000bb098(void)

{
    char local_1810[20];
    undefined2 local_17fc;
    undefined1 auStack_1010[4099];
    undefined1 local_d;
    ssize_t local_c;

    local_d = 0x31;
    local_c = write(DAT_00150c20, &local_d, 1);
    if (local_c != 1) {
        builtin_strncpy(local_1810, "error! write SCL hig", 0x14);
        local_17fc = 0x68;
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_i2c_sim.c",
             0xbd, "scl_high", 8, 0x42, 0x28, auStack_1010);
    }
    return;
}

void FUN_000bb194(void)

{
    char local_1810[2048];
    undefined1 auStack_1010[4099];
    undefined1 local_d;
    ssize_t local_c;

    local_d = 0x30;
    local_c = write(DAT_00150c20, &local_d, 1);
    if (local_c != 1) {
        builtin_strncpy(local_1810, "error! write SCL low", 0x14);
        local_1810[0x14] = 0;
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_i2c_sim.c",
             0xbd, "scl_low", 7, 0x4b, 0x28, auStack_1010);
    }
    return;
}

int FUN_000bb290(void)

{
    int iVar1;
    char acStack_1810[2048];
    undefined1 auStack_1010[4099];
    char local_d;
    ssize_t local_c;

    local_c = read(DAT_00150c24, &local_d, 1);
    if (local_c == 1) {
        iVar1 = (int)(local_d != '0');
    } else {
        snprintf(acStack_1810, 0x800, "error! read SDA return %d", local_c);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, acStack_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_i2c_sim.c",
             0xbd, "sda_status", 10, 0x55, 0x28, auStack_1010);
        iVar1 = -1;
    }
    return iVar1;
}

int i2c_sim_init(void)

{
    int iVar1;
    char local_180c[12];
    uint local_1800;
    uint local_17fc;
    char acStack_17f8[8];
    undefined2 local_17f0;
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    builtin_strncpy(local_180c, "i2c_sim_init", 0xc);
    local_1800._0_1_ = ' ';
    local_1800._1_1_ = 's';
    local_1800._2_1_ = 't';
    local_1800._3_1_ = 'a';
    local_17fc = CONCAT13(local_17fc._3_1_, 0x7472);
    V_LOCK();
    logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
        0xbd, "i2c_sim_init", 0xc, 0x62, 0x28, auStack_100c);
    iVar1 = access("/sys/class/gpio/gpio461/", 0);
    if (iVar1 == -1) {
        local_c = system("echo 461 > /sys/class/gpio/export");
        if (local_c != 0) {
            snprintf(local_180c, 0x800, "[i2c_sim] echo %s > %s failed",
                     &DAT_0013ae54, "/sys/class/gpio/export");
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_i2c_sim.c",
                 0xbd, "i2c_sim_init", 0xc, 0x68, 100, auStack_100c);
            return local_c;
        }
        builtin_strncpy(local_180c, "init gpio461", 0xc);
        local_1800 = local_1800 & 0xffffff00;
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_i2c_sim.c",
             0xbd, "i2c_sim_init", 0xc, 0x6c, 0x28, auStack_100c);
    }
    iVar1 = access("/sys/class/gpio/gpio459/", 0);
    if (iVar1 == -1) {
        local_c = system("echo 459 > /sys/class/gpio/export");
        if (local_c != 0) {
            snprintf(local_180c, 0x800, "[i2c_sim] echo %s > %s failed",
                     &DAT_0013aee0, "/sys/class/gpio/export");
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_i2c_sim.c",
                 0xbd, "i2c_sim_init", 0xc, 0x73, 100, auStack_100c);
            return local_c;
        }
        builtin_strncpy(local_180c, "init gpio459", 0xc);
        local_1800 = local_1800 & 0xffffff00;
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_i2c_sim.c",
             0xbd, "i2c_sim_init", 0xc, 0x77, 0x28, auStack_100c);
    }
    local_c = system("echo high > /sys/class/gpio/gpio461/direction");
    if (local_c == 0) {
        local_c = system("echo high > /sys/class/gpio/gpio459/direction");
        if (local_c == 0) {
            DAT_0016057c = 1;
            if (0 < DAT_00150c20) {
                close(DAT_00150c20);
            }
            DAT_00150c20 = open("/sys/class/gpio/gpio459/value", 1);
            if (DAT_00150c20 < 0) {
                builtin_strncpy(local_180c, "open gpio459", 0xc);
                local_1800._0_1_ = ' ';
                local_1800._1_1_ = 'f';
                local_1800._2_1_ = 'a';
                local_1800._3_1_ = 'i';
                local_17fc._0_1_ = 'l';
                local_17fc._1_1_ = 'e';
                local_17fc._2_1_ = 'd';
                local_17fc._3_1_ = '\0';
                V_LOCK();
                logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_i2c_sim.c",
                     0xbd, "i2c_sim_init", 0xc, 0x90, 100, auStack_100c);
                local_c = DAT_00150c20;
            } else {
                if (0 < DAT_00150c24) {
                    close(DAT_00150c24);
                }
                DAT_00150c24 = open("/sys/class/gpio/gpio461/value", 1);
                if (DAT_00150c24 < 0) {
                    builtin_strncpy(local_180c, "open gpio461", 0xc);
                    local_1800._0_1_ = ' ';
                    local_1800._1_1_ = 'f';
                    local_1800._2_1_ = 'a';
                    local_1800._3_1_ = 'i';
                    local_17fc._0_1_ = 'l';
                    local_17fc._1_1_ = 'e';
                    local_17fc._2_1_ = 'd';
                    local_17fc._3_1_ = '\0';
                    V_LOCK();
                    logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
                         0xbd, "i2c_sim_init", 0xc, 0x9b, 100, auStack_100c);
                    local_c = DAT_00150c24;
                } else {
                    if (0 < DAT_00150c28) {
                        close(DAT_00150c28);
                    }
                    DAT_00150c28 = open("/sys/class/gpio/gpio461/direction", 1);
                    if (DAT_00150c28 < 0) {
                        builtin_strncpy(local_180c, "open gpio461", 0xc);
                        local_1800._0_1_ = ' ';
                        local_1800._1_1_ = 'd';
                        local_1800._2_1_ = 'i';
                        local_1800._3_1_ = 'r';
                        local_17fc._0_1_ = 'e';
                        local_17fc._1_1_ = 'c';
                        local_17fc._2_1_ = 't';
                        local_17fc._3_1_ = 'i';
                        builtin_strncpy(acStack_17f8, "on faile", 8);
                        local_17f0 = 100;
                        V_LOCK();
                        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/device/"
                             "hal/platform/cv183x/cv183x_i2c_sim.c",
                             0xbd, "i2c_sim_init", 0xc, 0xa7, 0x28,
                             auStack_100c);
                        builtin_strncpy(local_180c, "open gpio461", 0xc);
                        local_1800._0_1_ = ' ';
                        local_1800._1_1_ = 'd';
                        local_1800._2_1_ = 'i';
                        local_1800._3_1_ = 'r';
                        local_17fc._0_1_ = 'e';
                        local_17fc._1_1_ = 'c';
                        local_17fc._2_1_ = 't';
                        local_17fc._3_1_ = 'i';
                        builtin_strncpy(acStack_17f8, "on faile", 8);
                        local_17f0 = 100;
                        V_LOCK();
                        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/device/"
                             "hal/platform/cv183x/cv183x_i2c_sim.c",
                             0xbd, "i2c_sim_init", 0xc, 0xa8, 100,
                             auStack_100c);
                        local_c = DAT_00150c28;
                    } else {
                        snprintf(local_180c, 0x800,
                                 "power i2c device:%s addr:0x%02x fd:%d",
                                 "sim_dev", 0x10, 0xff);
                        V_LOCK();
                        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/device/"
                             "hal/platform/cv183x/cv183x_i2c_sim.c",
                             0xbd, "i2c_sim_init", 0xc, 0xac, 0x28,
                             auStack_100c);
                        builtin_strncpy(local_180c, "i2c_sim_init", 0xc);
                        local_1800._0_1_ = ' ';
                        local_1800._1_1_ = 'e';
                        local_1800._2_1_ = 'n';
                        local_1800._3_1_ = 'd';
                        local_17fc = local_17fc & 0xffffff00;
                        V_LOCK();
                        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/backend/device/"
                             "hal/platform/cv183x/cv183x_i2c_sim.c",
                             0xbd, "i2c_sim_init", 0xc, 0xad, 0x28,
                             auStack_100c);
                        local_c = 0xff;
                    }
                }
            }
        } else {
            snprintf(local_180c, 0x800, "[i2c_sim] echo high > %s failed",
                     "/sys/class/gpio/gpio459/direction");
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_i2c_sim.c",
                 0xbd, "i2c_sim_init", 0xc, 0x84, 100, auStack_100c);
        }
    } else {
        snprintf(local_180c, 0x800, "[i2c_sim] echo high > %s failed",
                 "/sys/class/gpio/gpio461/direction");
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_i2c_sim.c",
             0xbd, "i2c_sim_init", 0xc, 0x7d, 100, auStack_100c);
    }
    return local_c;
}

void i2c_sim_uninit(void)

{
    if (0 < DAT_00150c20) {
        close(DAT_00150c20);
    }
    if (0 < DAT_00150c24) {
        close(DAT_00150c24);
    }
    if (0 < DAT_00150c28) {
        close(DAT_00150c28);
    }
    return;
}

void FUN_000bbebc(void)

{
    char local_1814[8];
    uint local_180c;
    char acStack_1808[2036];
    undefined1 auStack_1014[4096];
    undefined4 local_14;
    undefined1 local_10;
    ssize_t local_c;

    if (DAT_0016057c != 0) {
        local_14 = 0x6e69;
        local_10 = 0;
        local_c = write(DAT_00150c28, &local_14, 2);
        if (local_c != 2) {
            builtin_strncpy(local_1814, "write in", 8);
            local_180c = local_180c & 0xffffff00;
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_i2c_sim.c",
                 0xbd, "set_sda_in", 10, 0xcf, 0x28, auStack_1014);
        }
        close(DAT_00150c24);
        DAT_00150c24 = 0xffffffff;
        DAT_00150c24 = open("/sys/class/gpio/gpio461/value", 0);
        if (DAT_00150c24 < 0) {
            builtin_strncpy(local_1814, "open gpi", 8);
            local_180c._0_1_ = 'o';
            local_180c._1_1_ = '4';
            local_180c._2_1_ = '6';
            local_180c._3_1_ = '1';
            builtin_strncpy(acStack_1808, " failed", 8);
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_i2c_sim.c",
                 0xbd, "set_sda_in", 10, 0xd7, 0x28, auStack_1014);
        }
        DAT_0016057c = 0;
    }
    return;
}

void FUN_000bc0d4(void)

{
    char local_1814[8];
    undefined4 local_180c;
    char acStack_1808[2036];
    undefined1 auStack_1014[4096];
    undefined4 local_14;
    undefined1 local_10;
    ssize_t local_c;

    if (DAT_0016057c != 1) {
        local_14 = 0x74756f;
        local_10 = 0;
        local_c = write(DAT_00150c28, &local_14, 3);
        if (local_c != 3) {
            builtin_strncpy(local_1814, "write ou", 8);
            local_180c = CONCAT22(local_180c._2_2_, 0x74);
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_i2c_sim.c",
                 0xbd, "set_sda_out", 0xb, 0xe9, 0x28, auStack_1014);
        }
        close(DAT_00150c24);
        DAT_00150c24 = 0xffffffff;
        DAT_00150c24 = open("/sys/class/gpio/gpio461/value", 1);
        if (DAT_00150c24 < 0) {
            builtin_strncpy(local_1814, "open gpi", 8);
            local_180c._0_1_ = 'o';
            local_180c._1_1_ = '4';
            local_180c._2_1_ = '6';
            local_180c._3_1_ = '1';
            builtin_strncpy(acStack_1808, " failed", 8);
            V_LOCK();
            logfmt_raw(auStack_1014, 0x1000, 0, local_1814);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_i2c_sim.c",
                 0xbd, "set_sda_out", 0xb, 0xf1, 0x28, auStack_1014);
        }
        DAT_0016057c = 1;
    }
    return;
}

void FUN_000bc2f0(void)

{
    FUN_000bc0d4();
    FUN_000baea0();
    FUN_000bb098();
    FUN_000bae88();
    FUN_000baf9c();
    FUN_000bae88();
    return;
}

void FUN_000bc318(void)

{
    FUN_000bc0d4();
    FUN_000bb194();
    FUN_000bae88();
    FUN_000baf9c();
    FUN_000bb098();
    FUN_000bae88();
    FUN_000baea0();
    FUN_000bae88();
    return;
}

undefined4 FUN_000bc348(void)

{
    char acStack_180c[2048];
    undefined1 auStack_100c[4098];
    char local_a;
    char local_9;

    local_a = '\0';
    FUN_000bb194();
    FUN_000bae88();
    FUN_000bbebc();
    while (true) {
        local_9 = FUN_000bb290();
        if (local_9 == '\0') {
            FUN_000bb098();
            FUN_000bae88();
            return 1;
        }
        if (local_9 == -1)
            break;
        local_a = local_a + '\x01';
        FUN_000bb098();
        FUN_000bae88();
        FUN_000bb194();
        FUN_000bae88();
    }
    snprintf(acStack_180c, 0x800, "%s:%d ack error", "i2c_check_ack", 0x125);
    V_LOCK();
    logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
        0xbd, "i2c_check_ack", 0xd, 0x125, 0x28, auStack_100c);
    FUN_000bb098();
    FUN_000bae88();
    return 0;
}

void FUN_000bc480(char param_1)

{
    FUN_000bb194();
    FUN_000bae88();
    FUN_000bc0d4();
    if (param_1 == '\x01') {
        FUN_000baf9c();
    } else if (param_1 == '\0') {
        FUN_000baea0();
    }
    FUN_000bb098();
    FUN_000bae88();
    return;
}

void FUN_000bc4d8(byte param_1)

{
    int iVar1;
    char local_1810[52];
    undefined2 local_17dc;
    undefined1 local_17da;
    undefined1 auStack_1010[4099];
    byte local_d;
    int local_c;

    local_c = 0;
    FUN_000bc0d4();
    for (local_d = 0x80; local_d != 0; local_d = local_d >> 1) {
        FUN_000bb194();
        FUN_000bae88();
        if ((local_d & param_1) == 0) {
            FUN_000baf9c();
        } else {
            FUN_000baea0();
        }
        FUN_000bb098();
        FUN_000bae88();
    }
    do {
        iVar1 = FUN_000bc348();
        if (iVar1 != 0) {
            return;
        }
        local_c = local_c + 1;
    } while (local_c < 4);
    builtin_strncpy(local_1810,
                    "IIC_SendData checkack 3 times,send data checkack err",
                    0x34);
    local_17dc = 0x726f;
    local_17da = 0;
    V_LOCK();
    logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
        0xbd, "i2c_send_data", 0xd, 0x167, 100, auStack_1010);
    return;
}

byte FUN_000bc668(undefined1 param_1)

{
    char local_180c[16];
    undefined4 local_17fc;
    undefined1 auStack_100c[4097];
    char local_b;
    byte local_a;
    byte local_9;

    local_a = 0;
    FUN_000bbebc();
    local_9 = 0x80;
    while (true) {
        if (local_9 == 0) {
            FUN_000bc480(param_1);
            return local_a;
        }
        FUN_000bb194();
        FUN_000bae88();
        close(DAT_00150c24);
        DAT_00150c24 = open("/sys/class/gpio/gpio461/value", 0);
        if (DAT_00150c24 < 0)
            break;
        local_b = FUN_000bb290();
        if (local_b == '\x01') {
            local_a = local_a | local_9;
        } else if (local_b == -1) {
            FUN_000bb098();
            FUN_000bae88();
            builtin_strncpy(local_180c, "read GPIO461 err", 0x10);
            local_17fc = CONCAT13(local_17fc._3_1_, 0x726f);
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_i2c_sim.c",
                 0xbd, "i2c_recv_data", 0xd, 0x18b, 0x28, auStack_100c);
            return 0xff;
        }
        FUN_000bb098();
        FUN_000bae88();
        local_9 = local_9 >> 1;
    }
    builtin_strncpy(local_180c, "open gpio461 fai", 0x10);
    local_17fc._0_1_ = 'l';
    local_17fc._1_1_ = 'e';
    local_17fc._2_1_ = 'd';
    local_17fc._3_1_ = '\0';
    V_LOCK();
    logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
        0xbd, "i2c_recv_data", 0xd, 0x17c, 0x28, auStack_100c);
    FUN_000bb098();
    FUN_000bae88();
    return 0xff;
}

undefined1 i2c_sim_send_cmd(char param_1, char param_2, char param_3,
                            undefined1 param_4, undefined1 param_5)

{
    byte bVar1;
    undefined1 uVar2;

    bVar1 = param_1 << 1;
    if (param_3 != '\0') {
        FUN_000bc2f0();
        FUN_000bc4d8(bVar1);
        FUN_000bc4d8(param_4);
    }
    if (param_2 == '\0') {
        if (param_3 != '\x01') {
            FUN_000bc2f0();
            FUN_000bc4d8(bVar1);
        }
        FUN_000bc4d8(param_5);
        FUN_000bc318();
        uVar2 = 0;
    } else {
        FUN_000bc2f0();
        FUN_000bc4d8(bVar1 | 1);
        uVar2 = FUN_000bc668(0);
        FUN_000bc318();
    }
    return uVar2;
}

int lcd_init(char *param_1)

{
    int iVar1;
    char local_1808[8];
    undefined4 local_1800;
    char acStack_17fc[2036];
    undefined1 auStack_1008[4096];

    if (DAT_00160584 == 0) {
        if (param_1 == (char *)0x0) {
            builtin_strncpy(local_1808, "bad para", 8);
            local_1800 = CONCAT13(local_1800._3_1_, 0xa6d);
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_lcd.c",
                 0xb9, "lcd_init", 8, 0x1a, 100, auStack_1008);
            iVar1 = -3;
        } else {
            iVar1 = open(param_1, 0x802);
            DAT_00160580 = iVar1;
            if (iVar1 < 0) {
                builtin_strncpy(local_1808, "open lcd", 8);
                local_1800._0_1_ = ' ';
                local_1800._1_1_ = 'f';
                local_1800._2_1_ = 'a';
                local_1800._3_1_ = 'i';
                builtin_strncpy(acStack_17fc, "led!!!\n", 8);
                V_LOCK();
                logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_lcd.c",
                     0xb9, "lcd_init", 8, 0x20, 100, auStack_1008);
                iVar1 = -1;
            } else {
                DAT_00160584 = 1;
            }
        }
    } else {
        iVar1 = 0;
    }
    return iVar1;
}

undefined4 lcd_write(int param_1, byte param_2, int param_3, uint param_4)

{
    int iVar1;
    undefined4 uVar2;
    uint local_1820;
    byte local_1815;
    char local_1810[8];
    undefined4 local_1808;
    char acStack_1804[2036];
    undefined1 auStack_1010[4096];
    size_t local_10;
    int local_c;

    local_c = 0;
    if (DAT_00160584 == 0) {
        uVar2 = 0xfffffffe;
    } else if (((param_1 == DAT_00160580) && (param_2 < 4)) &&
               (param_4 < 0x41)) {
        iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_00160588);
        local_1820 = param_4;
        local_1815 = param_2;
        if (iVar1 == 0) {
            do {
                local_10 = local_1820;
                if (0xf < local_1820) {
                    local_10 = 0x10;
                }
                iVar1 = (int)(char)local_1815;
                local_1815 = local_1815 + 1;
                memcpy(&DAT_001605a0 + iVar1 * 0x10,
                       (void *)(param_3 + local_c), local_10);
                local_c = local_c + local_10;
                local_1820 = local_1820 - local_10;
            } while ((local_1820 != 0) && (local_1815 < 4));
            write(DAT_00160580, &DAT_001605a0, 0x40);
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160588);
            uVar2 = 0;
        } else {
            builtin_strncpy(local_1810, "failed t", 8);
            local_1808._0_1_ = 'o';
            local_1808._1_1_ = ' ';
            local_1808._2_1_ = 'l';
            local_1808._3_1_ = 'c';
            builtin_strncpy(acStack_1804, "d lock\n", 8);
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_lcd.c",
                 0xb9, "lcd_write", 9, 0x42, 100, auStack_1010);
            uVar2 = 0xfffffffc;
        }
    } else {
        builtin_strncpy(local_1810, "bad para", 8);
        local_1808 = CONCAT13(local_1808._3_1_, 0xa6d);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_lcd.c",
             0xb9, "lcd_write", 9, 0x3c, 0x50, auStack_1010);
        uVar2 = 0xfffffffd;
    }
    return uVar2;
}

undefined4 lcd_flush(void)

{
    return 0;
}

undefined4 lcd_clear(int param_1)

{
    int iVar1;
    undefined4 uVar2;
    char local_1808[8];
    undefined4 local_1800;
    char acStack_17fc[2036];
    undefined1 auStack_1008[4096];

    if (DAT_00160584 == 0) {
        uVar2 = 0xfffffffe;
    } else if (param_1 == DAT_00160580) {
        iVar1 = pthread_mutex_lock((pthread_mutex_t *)&DAT_00160588);
        if (iVar1 == 0) {
            memset(&DAT_001605a0, 0x20, 0x40);
            lseek(DAT_00160580, 0, 0);
            write(DAT_00160580, &DAT_001605a0, 0x40);
            pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160588);
            uVar2 = 0;
        } else {
            builtin_strncpy(local_1808, "failed t", 8);
            local_1800._0_1_ = 'o';
            local_1800._1_1_ = ' ';
            local_1800._2_1_ = 'l';
            local_1800._3_1_ = 'c';
            builtin_strncpy(acStack_17fc, "d lock\n", 8);
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_lcd.c",
                 0xb9, "lcd_clear", 9, 0x70, 100, auStack_1008);
            uVar2 = 0xfffffffc;
        }
    } else {
        builtin_strncpy(local_1808, "bad para", 8);
        local_1800 = CONCAT13(local_1800._3_1_, 0xa6d);
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_lcd.c",
             0xb9, "lcd_clear", 9, 0x6b, 0x50, auStack_1008);
        uVar2 = 0xfffffffd;
    }
    return uVar2;
}

undefined4 lcd_uninit(int param_1)

{
    int iVar1;
    char local_180c[2048];
    undefined1 auStack_100c[4096];
    undefined4 local_c;

    local_c = 0;
    if (DAT_00160584 != 0) {
        iVar1 = close(param_1);
        if (iVar1 != 0) {
            builtin_strncpy(local_180c, "lcd close failed!!!\n", 0x14);
            local_180c[0x14] = 0;
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, local_180c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_lcd.c",
                 0xb9, "lcd_uninit", 10, 0x87, 100, auStack_100c);
            local_c = 0xffffffff;
        }
        DAT_00160584 = 0;
    }
    return local_c;
}

undefined4 uart_init(void)

{
    undefined4 uVar1;
    char local_1808[28];
    undefined2 local_17ec;
    undefined1 auStack_1008[4096];

    if (platform_inited == 0) {
        builtin_strncpy(local_1808, "please init platform first!!", 0x1c);
        local_17ec = 10;
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0, local_1808);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_uart.c",
             0xba, "uart_init", 9, 0x28, 100, auStack_1008);
        uVar1 = 0xffffffff;
    } else {
        if (DAT_001608e0 == 0) {
            DAT_001608e0 = new_c_map(&LAB_000bd250, 0, 0);
        }
        uVar1 = 0;
    }
    return uVar1;
}

void uart_uninit(void)

{
    if (DAT_001608e0 != 0) {
        delete_c_map(DAT_001608e0);
        DAT_001608e0 = 0;
    }
    return;
}

void FUN_000bd3dc(undefined4 param_1, int param_2, uint param_3)

{
    uint __c;
    uint local_1c;
    uint local_10;
    int local_c;

    printf("Dumping %u %s bytes from %p:\n", param_3, param_1, param_2);
    local_1c = param_3;
    local_c = param_2;
    while (true) {
        if ((int)local_1c < 1) {
            return;
        }
        for (local_10 = 0; local_10 < 0x10; local_10 = local_10 + 1) {
            if (local_10 < local_1c) {
                printf("%02x ", (uint) * (byte *)(local_c + local_10));
            } else {
                printf("   ");
            }
        }
        for (local_10 = 0; local_10 < 0x10; local_10 = local_10 + 1) {
            if (local_10 < local_1c) {
                if ((*(byte *)(local_c + local_10) < 0x20) ||
                    (0x7e < *(byte *)(local_c + local_10))) {
                    __c = 0x2e;
                } else {
                    __c = (uint) * (byte *)(local_c + local_10);
                }
                putchar(__c);
            } else {
                putchar(0x20);
            }
        }
        putchar(10);
        local_c = local_c + 0x10;
        if ((int)local_1c < 0x11)
            break;
        local_1c = local_1c - 0x10;
    }
    return;
}

undefined4 FUN_000bd558(undefined4 param_1)

{
    undefined4 uVar1;

    uVar1 = hal_chain_uart_addr(param_1);
    return uVar1;
}

int FUN_000bd580(undefined4 param_1)

{
    int iVar1;
    undefined4 uVar2;
    undefined4 local_224[2];
    char acStack_21c[512];
    undefined4 local_1c;
    int local_18;
    void *local_14;
    void *local_10;
    int local_c;

    local_c = 0;
    local_224[0] = param_1;
    iVar1 = find_c_map(DAT_001608e0, local_224, &local_14);
    if (iVar1 == 1) {
        local_10 = local_14;
        local_c = *(int *)((int)local_14 + 4);
        free(local_14);
    } else {
        uVar2 = FUN_000bd558(local_224[0]);
        snprintf(acStack_21c, 0x200, "/dev/ttyS%d", uVar2);
        local_18 = open(acStack_21c, 0x902);
        local_1c = local_224[0];
        local_c = local_18;
        FUN_000bd674(local_18);
        insert_c_map(DAT_001608e0, local_224, 4, &local_1c, 8);
    }
    return local_c;
}

void FUN_000bd674(int param_1)

{
    termios local_48;
    speed_t local_c;

    local_c = 0x1002;
    tcgetattr(param_1, &local_48);
    cfsetispeed(&local_48, local_c);
    cfsetospeed(&local_48, local_c);
    local_48.c_cflag = local_48.c_cflag & 0xfffffecf | 0x8b0;
    local_48.c_iflag = local_48.c_iflag & 0xfffffa14;
    local_48.c_oflag = local_48.c_oflag & 0xfffffffe;
    local_48.c_lflag = local_48.c_lflag & 0xffff7fb4;
    local_48.c_cc[5] = '\0';
    local_48.c_cc[6] = '\t';
    tcsetattr(param_1, 0, &local_48);
    tcflush(param_1, 2);
    return;
}

uint uart_send(int param_1, int param_2, uint param_3)

{
    char acStack_1818[2048];
    undefined1 auStack_1018[4096];
    uint local_18;
    int local_14;
    uint local_10;
    int local_c;

    local_18 = 0;
    local_14 = 0;
    local_10 = 0;
    local_c = 0;
    pthread_mutex_lock((pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
    local_14 = FUN_000bd580(param_1);
    if (local_14 < 0) {
        snprintf(acStack_1818, 0x800,
                 "failed to get fd of chain %d, ret = %d\n", param_1, local_14);
        V_LOCK();
        logfmt_raw(auStack_1018, 0x1000, 0, acStack_1818);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_uart.c",
             0xba, "uart_send", 9, 0xaf, 100, auStack_1018);
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
        local_10 = 0xffffffff;
    } else {
        local_c = 0;
        flock(local_14, 2);
        for (; (local_10 < param_3 && (local_c < 0x1e));
             local_c = local_c + 1) {
            local_18 = write(local_14, (void *)(param_2 + local_10),
                             param_3 - local_10);
            if ((int)local_18 < 0) {
                snprintf(acStack_1818, 0x800,
                         "write %d bytes failed, ret = %d on chain %d\n",
                         param_3, local_18, param_1);
                V_LOCK();
                logfmt_raw(auStack_1018, 0x1000, 0, acStack_1818);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/backend/"
                     "device/hal/platform/cv183x/cv183x_uart.c",
                     0xba, "uart_send", 9, 0xc0, 100, auStack_1018);
                pthread_mutex_unlock(
                    (pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
                return local_18;
            }
            local_10 = local_10 + local_18;
            if (param_3 == local_10)
                break;
            usleep(100000);
        }
        flock(local_14, 8);
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
        if (param_3 != local_10) {
            snprintf(acStack_1818, 0x800,
                     "write %d bytes failed, ret = %d on chain %d\n", param_3,
                     local_10, param_1);
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, acStack_1818);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_uart.c",
                 0xba, "uart_send", 9, 0xd0, 100, auStack_1018);
        }
    }
    return local_10;
}

ssize_t uart_receive(int param_1, void *param_2, size_t param_3)

{
    char acStack_1810[2048];
    undefined1 auStack_1010[4096];
    ssize_t local_10;
    int local_c;

    local_10 = 0;
    local_c = 0;
    pthread_mutex_lock((pthread_mutex_t *)(param_1 * 0x18 + 0x160760));
    local_c = FUN_000bd580(param_1);
    if (local_c < 0) {
        snprintf(acStack_1810, 0x800,
                 "failed to get fd of chain %d, ret = %d\n", param_1, local_c);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, acStack_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_uart.c",
             0xba, "uart_receive", 0xc, 0xeb, 100, auStack_1010);
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 * 0x18 + 0x160760));
        local_10 = -1;
    } else {
        local_10 = read(local_c, param_2, param_3);
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 * 0x18 + 0x160760));
    }
    return local_10;
}

undefined4 FUN_000bdd70(int param_1, speed_t *param_2, uint *param_3)

{
    undefined4 uVar1;
    char local_184c[32];
    undefined4 local_182c;
    undefined2 local_1828;
    undefined1 local_1826;
    undefined1 auStack_104c[4096];
    termios tStack_4c;
    speed_t local_10;
    speed_t local_c;

    tcgetattr(param_1, &tStack_4c);
    local_10 = cfgetispeed(&tStack_4c);
    local_c = cfgetospeed(&tStack_4c);
    if (local_10 == local_c) {
        if (*param_3 < 4) {
            builtin_strncpy(local_184c, "bad param to get baud, size too ",
                            0x20);
            local_182c._0_1_ = 's';
            local_182c._1_1_ = 'm';
            local_182c._2_1_ = 'a';
            local_182c._3_1_ = 'l';
            local_1828 = 0xa6c;
            local_1826 = 0;
            V_LOCK();
            logfmt_raw(auStack_104c, 0x1000, 0, local_184c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_uart.c",
                 0xba, "get_baud", 8, 0x10a, 100, auStack_104c);
            uVar1 = 0xfffffffe;
        } else {
            *param_2 = local_10;
            *param_3 = 4;
            uVar1 = 0;
        }
    } else {
        builtin_strncpy(local_184c, "input and output speed not match", 0x20);
        local_182c = CONCAT22(local_182c._2_2_, 10);
        V_LOCK();
        logfmt_raw(auStack_104c, 0x1000, 0, local_184c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_uart.c",
             0xba, "get_baud", 8, 0x105, 100, auStack_104c);
        uVar1 = 0xffffffff;
    }
    return uVar1;
}

undefined4 FUN_000bdfbc(undefined4 param_1)

{
    undefined4 uVar1;

    switch (param_1) {
    case 0:
        uVar1 = 0x100d;
        break;
    case 1:
        uVar1 = 0x100a;
        break;
    case 2:
        uVar1 = 0x1007;
        break;
    default:
        uVar1 = 0x1002;
        break;
    case 6:
        uVar1 = 0x1004;
        break;
    case 7:
        uVar1 = 0x1003;
        break;
    case 8:
        uVar1 = 0x1001;
        break;
    case 9:
        uVar1 = 0xf;
        break;
    case 10:
        uVar1 = 0xe;
        break;
    case 0xb:
        uVar1 = 0xd;
        break;
    case 0x1a:
        uVar1 = 0x1002;
    }
    return uVar1;
}

int FUN_000be0ac(undefined4 param_1, int param_2, undefined4 *param_3)

{
    undefined4 uVar1;
    int iVar2;
    char acStack_2cc[512];
    char acStack_cc[188];
    int local_10;
    word *local_c;

    memset(acStack_cc, 0, 0x80);
    local_c = &WORD_0001c200;
    local_10 = FUN_000bdfbc(*param_3);
    if (local_10 == 0x1002) {
        local_c = &WORD_0001c200;
    } else if (local_10 == 0x1008) {
        local_c = (word *)&DAT_000f4240;
    } else if (local_10 == 0x100a) {
        local_c = (word *)0x16e360;
    } else if (local_10 == 0x100d) {
        local_c = (word *)0x2faf08;
    }
    close(param_2);
    uVar1 = FUN_000bd558(param_1);
    snprintf(acStack_2cc, 0x200, "/dev/ttyS%d", uVar1);
    sprintf(acStack_cc,
            "echo %d > /proc/tty/driver/serial && echo 5555555555 > %s",
            local_c, acStack_2cc);
    iVar2 = system(acStack_cc);
    if (iVar2 == 0) {
        iVar2 = open(acStack_2cc, 0x902, 0);
    } else {
        puts("UART_BAUD CMD ERROR");
        iVar2 = -2;
    }
    return iVar2;
}

undefined4 FUN_000be20c(int param_1, undefined4 *param_2, uint param_3)

{
    undefined4 uVar1;
    char local_1848[36];
    undefined2 local_1824;
    undefined1 local_1822;
    undefined1 auStack_1048[4096];
    termios tStack_48;
    speed_t local_c;

    tcgetattr(param_1, &tStack_48);
    if (param_3 < 4) {
        builtin_strncpy(local_1848, "bad param to set baud, size too smal",
                        0x24);
        local_1824 = 0xa6c;
        local_1822 = 0;
        V_LOCK();
        logfmt_raw(auStack_1048, 0x1000, 0, local_1848);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_uart.c",
             0xba, "set_baud", 8, 0x15c, 100, auStack_1048);
        uVar1 = 0xfffffffe;
    } else {
        local_c = FUN_000bdfbc(*param_2);
        cfsetispeed(&tStack_48, local_c);
        cfsetospeed(&tStack_48, local_c);
        tcsetattr(param_1, 1, &tStack_48);
        tcflush(param_1, 2);
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 FUN_000be3a8(int param_1, uint *param_2, uint *param_3)

{
    undefined4 uVar1;
    char local_1844[36];
    undefined2 local_1820;
    undefined1 local_181e;
    undefined1 auStack_1044[4096];
    termios tStack_44;

    tcgetattr(param_1, &tStack_44);
    if (*param_3 < 4) {
        builtin_strncpy(local_1844, "bad param to get vmin, size too smal",
                        0x24);
        local_1820 = 0xa6c;
        local_181e = 0;
        V_LOCK();
        logfmt_raw(auStack_1044, 0x1000, 0, local_1844);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_uart.c",
             0xba, "get_vmin", 8, 0x174, 100, auStack_1044);
        uVar1 = 0xfffffffe;
    } else {
        *param_2 = (uint)tStack_44.c_cc[6];
        *param_3 = 4;
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 FUN_000be514(int param_1, undefined4 *param_2, uint param_3)

{
    undefined4 uVar1;
    char local_1848[36];
    undefined2 local_1824;
    undefined1 local_1822;
    undefined1 auStack_1048[4096];
    termios tStack_48;
    undefined4 local_c;

    tcgetattr(param_1, &tStack_48);
    if (param_3 < 4) {
        builtin_strncpy(local_1848, "bad param to set baud, size too smal",
                        0x24);
        local_1824 = 0xa6c;
        local_1822 = 0;
        V_LOCK();
        logfmt_raw(auStack_1048, 0x1000, 0, local_1848);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_uart.c",
             0xba, "set_vmin", 8, 0x185, 100, auStack_1048);
        uVar1 = 0xfffffffe;
    } else {
        local_c = *param_2;
        tStack_48.c_cc[6] = (cc_t)local_c;
        tcsetattr(param_1, 0, &tStack_48);
        tcflush(param_1, 2);
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 uart_set_config(int param_1, int param_2, undefined4 param_3,
                           undefined4 param_4)

{
    char acStack_1810[2048];
    undefined1 auStack_1010[4096];
    undefined4 local_10;
    undefined4 local_c;

    local_c = 0;
    local_10 = 0xffffffff;
    pthread_mutex_lock((pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
    local_c = FUN_000bd580(param_1);
    if (param_2 == 0) {
        local_10 = FUN_000be20c(local_c, param_3, param_4);
    } else if (param_2 == 1) {
        local_10 = FUN_000be514(local_c, param_3, param_4);
    } else {
        snprintf(acStack_1810, 0x800, "unknown set config type = %d\n",
                 param_2);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, acStack_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_uart.c",
             0xba, "uart_set_config", 0xf, 0x1a9, 0x50, auStack_1010);
    }
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
    return local_10;
}

undefined4 uart_get_config(int param_1, int param_2, undefined4 param_3,
                           undefined4 param_4)

{
    char acStack_1810[2048];
    undefined1 auStack_1010[4096];
    undefined4 local_10;
    undefined4 local_c;

    local_c = 0;
    local_10 = 0xffffffff;
    pthread_mutex_lock((pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
    local_c = FUN_000bd580(param_1);
    snprintf(acStack_1810, 0x800, "get config of chain %d\n", param_1);
    V_LOCK();
    logfmt_raw(auStack_1010, 0x1000, 0, acStack_1810);
    V_UNLOCK();
    zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/"
        "rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/"
        "backend/device/hal/platform/cv183x/cv183x_uart.c",
        0xba, "uart_get_config", 0xf, 0x1bd, 0x14, auStack_1010);
    if (param_2 == 0) {
        local_10 = FUN_000bdd70(local_c, param_3, param_4);
    } else if (param_2 == 1) {
        local_10 = FUN_000be3a8(local_c, param_3, param_4);
    } else {
        snprintf(acStack_1810, 0x800, "unknown get config type = %d\n",
                 param_2);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, acStack_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_uart.c",
             0xba, "uart_get_config", 0xf, 0x1c7, 0x50, auStack_1010);
    }
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
    return local_10;
}

undefined4 high_speed_uart_set_config(void)

{
    return 0xfffffffb;
}

undefined4 high_speed_uart_get_config(void)

{
    return 0xfffffffb;
}

undefined4 uart_flush(int param_1)

{
    undefined4 uVar1;
    char acStack_180c[2048];
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    pthread_mutex_lock((pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
    local_c = FUN_000bd580(param_1);
    if (local_c < 0) {
        snprintf(acStack_180c, 0x800,
                 "failed to get fd of chain %d, ret = %d\n", param_1, local_c);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_uart.c",
             0xba, "uart_flush", 10, 0x1eb, 100, auStack_100c);
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
        uVar1 = 0xffffffff;
    } else {
        tcflush(local_c, 2);
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 uart_flush_tx(int param_1)

{
    undefined4 uVar1;
    char acStack_180c[2048];
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    pthread_mutex_lock((pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
    local_c = FUN_000bd580(param_1);
    if (local_c < 0) {
        snprintf(acStack_180c, 0x800,
                 "failed to get fd of chain %d, ret = %d\n", param_1, local_c);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_uart.c",
             0xba, "uart_flush_tx", 0xd, 0x1fc, 100, auStack_100c);
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
        uVar1 = 0xffffffff;
    } else {
        tcflush(local_c, 0);
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 uart_flush_rx(int param_1)

{
    undefined4 uVar1;
    char acStack_180c[2048];
    undefined1 auStack_100c[4096];
    int local_c;

    local_c = 0;
    pthread_mutex_lock((pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
    local_c = FUN_000bd580(param_1);
    if (local_c < 0) {
        snprintf(acStack_180c, 0x800,
                 "failed to get fd of chain %d, ret = %d\n", param_1, local_c);
        V_LOCK();
        logfmt_raw(auStack_100c, 0x1000, 0, acStack_180c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_uart.c",
             0xba, "uart_flush_rx", 0xd, 0x20d, 100, auStack_100c);
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
        uVar1 = 0xffffffff;
    } else {
        tcflush(local_c, 1);
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 * 0x18 + 0x1605e0));
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 uart_get_readable_byte_num(int param_1)

{
    int iVar1;
    char local_1810[24];
    undefined2 local_17f8;
    undefined1 auStack_1010[4096];
    undefined4 local_10;
    int local_c;

    local_c = 0;
    local_10 = 0;
    pthread_mutex_lock((pthread_mutex_t *)(param_1 * 0x18 + 0x160760));
    local_c = FUN_000bd580(param_1);
    if (local_c < 0) {
        snprintf(local_1810, 0x800, "failed to get fd of chain %d, ret = %d\n",
                 param_1, local_c);
        V_LOCK();
        logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/backend/device/hal/platform/"
             "cv183x/cv183x_uart.c",
             0xba, "uart_get_readable_byte_num", 0x1a, 0x21d, 100,
             auStack_1010);
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 * 0x18 + 0x160760));
        local_10 = 0xffffffff;
    } else {
        iVar1 = ioctl(local_c, 0x541b, &local_10);
        if (iVar1 != 0) {
            builtin_strncpy(local_1810, "ioctl to FIONREAD failed", 0x18);
            local_17f8 = 10;
            V_LOCK();
            logfmt_raw(auStack_1010, 0x1000, 0, local_1810);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/backend/"
                 "device/hal/platform/cv183x/cv183x_uart.c",
                 0xba, "uart_get_readable_byte_num", 0x1a, 0x223, 0x50,
                 auStack_1010);
            local_10 = 0;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 * 0x18 + 0x160760));
    }
    return local_10;
}

uint FUN_000bf258(uint param_1)

{
    return param_1 << 0x18 | (param_1 >> 8 & 0xff) << 0x10 |
           (param_1 >> 0x10 & 0xff) << 8 | param_1 >> 0x18;
}

undefined4 FUN_000bf280(undefined4 param_1)

{
    return param_1;
}

void FUN_000bf2a4(int param_1, int param_2, uint param_3)

{
    undefined4 uVar1;
    undefined4 local_14;

    for (local_14 = 0; local_14 < param_3; local_14 = local_14 + 1) {
        uVar1 = FUN_000bf258(*(undefined4 *)(param_2 + local_14 * 4));
        *(undefined4 *)(param_1 + local_14 * 4) = uVar1;
    }
    return;
}

void FUN_000bf324(void *param_1, void *param_2, int param_3)

{
    int iVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    uint uVar6;
    uint uVar7;
    uint uVar8;
    uint uVar9;
    uint local_134[8];
    uint local_114[66];
    int local_c;

    if (param_3 == 0) {
        memcpy(local_114, param_2, 0x40);
    } else {
        for (local_c = 0; local_c < 0x10; local_c = local_c + 1) {
            uVar2 = FUN_000bf258(*(undefined4 *)((int)param_2 + local_c * 4));
            local_114[local_c] = uVar2;
        }
    }
    for (local_c = 0x10; local_c < 0x40; local_c = local_c + 2) {
        local_114[local_c] = ((local_114[local_c + -2] >> 0x11 |
                               local_114[local_c + -2] << 0xf) ^
                              (local_114[local_c + -2] >> 0x13 |
                               local_114[local_c + -2] << 0xd) ^
                              local_114[local_c + -2] >> 10) +
                             local_114[local_c + -7] +
                             (local_114[local_c + -0xf] >> 3 ^
                              (local_114[local_c + -0xf] >> 7 |
                               local_114[local_c + -0xf] << 0x19) ^
                              (local_114[local_c + -0xf] >> 0x12 |
                               local_114[local_c + -0xf] << 0xe)) +
                             local_114[local_c + -0x10];
        local_114[local_c + 1] = ((local_114[local_c + -1] >> 0x11 |
                                   local_114[local_c + -1] << 0xf) ^
                                  (local_114[local_c + -1] >> 0x13 |
                                   local_114[local_c + -1] << 0xd) ^
                                  local_114[local_c + -1] >> 10) +
                                 local_114[local_c + -6] +
                                 (local_114[local_c + -0xe] >> 3 ^
                                  (local_114[local_c + -0xe] >> 7 |
                                   local_114[local_c + -0xe] << 0x19) ^
                                  (local_114[local_c + -0xe] >> 0x12 |
                                   local_114[local_c + -0xe] << 0xe)) +
                                 local_114[local_c + -0xf];
    }
    memcpy(local_134, param_1, 0x20);
    iVar1 = local_134[7] +
            ((local_134[4] >> 0x19 | local_134[4] << 7) ^
             (local_134[4] >> 6 | local_134[4] << 0x1a) ^
             (local_134[4] >> 0xb | local_134[4] << 0x15)) +
            (local_134[6] ^ local_134[4] & (local_134[6] ^ local_134[5])) +
            local_114[0] + 0x428a2f98;
    local_134[3] = local_134[3] + iVar1;
    uVar2 = iVar1 +
            ((local_134[0] >> 2 | local_134[0] << 0x1e) ^
             (local_134[0] >> 0xd | local_134[0] << 0x13) ^
             (local_134[0] >> 0x16 | local_134[0] << 10)) +
            (local_134[0] & (local_134[1] | local_134[2]) |
             local_134[2] & local_134[1]);
    iVar1 = local_134[6] +
            ((local_134[3] >> 0x19 | local_134[3] * 0x80) ^
             (local_134[3] >> 6 | local_134[3] * 0x4000000) ^
             (local_134[3] >> 0xb | local_134[3] * 0x200000)) +
            (local_134[5] ^ local_134[3] & (local_134[5] ^ local_134[4])) +
            local_114[1] + 0x71374491;
    local_134[2] = local_134[2] + iVar1;
    uVar3 =
        iVar1 +
        ((uVar2 >> 2 | uVar2 * 0x40000000) ^ (uVar2 >> 0xd | uVar2 * 0x80000) ^
         (uVar2 >> 0x16 | uVar2 * 0x400)) +
        (uVar2 & (local_134[0] | local_134[1]) | local_134[1] & local_134[0]);
    iVar1 = local_134[5] +
            ((local_134[2] >> 0x19 | local_134[2] * 0x80) ^
             (local_134[2] >> 6 | local_134[2] * 0x4000000) ^
             (local_134[2] >> 0xb | local_134[2] * 0x200000)) +
            (local_134[4] ^ local_134[2] & (local_134[4] ^ local_134[3])) +
            local_114[2] + -0x4a3f0431;
    local_134[1] = local_134[1] + iVar1;
    uVar4 =
        iVar1 +
        ((uVar3 >> 2 | uVar3 * 0x40000000) ^ (uVar3 >> 0xd | uVar3 * 0x80000) ^
         (uVar3 >> 0x16 | uVar3 * 0x400)) +
        (uVar3 & (uVar2 | local_134[0]) | local_134[0] & uVar2);
    iVar1 = local_134[4] +
            ((local_134[1] >> 0x19 | local_134[1] * 0x80) ^
             (local_134[1] >> 6 | local_134[1] * 0x4000000) ^
             (local_134[1] >> 0xb | local_134[1] * 0x200000)) +
            (local_134[3] ^ local_134[1] & (local_134[3] ^ local_134[2])) +
            local_114[3] + -0x164a245b;
    local_134[0] = local_134[0] + iVar1;
    uVar5 =
        iVar1 +
        ((uVar4 >> 2 | uVar4 * 0x40000000) ^ (uVar4 >> 0xd | uVar4 * 0x80000) ^
         (uVar4 >> 0x16 | uVar4 * 0x400)) +
        (uVar4 & (uVar3 | uVar2) | uVar2 & uVar3);
    iVar1 = local_134[3] +
            ((local_134[0] >> 0x19 | local_134[0] * 0x80) ^
             (local_134[0] >> 6 | local_134[0] * 0x4000000) ^
             (local_134[0] >> 0xb | local_134[0] * 0x200000)) +
            (local_134[2] ^ local_134[0] & (local_134[2] ^ local_134[1])) +
            local_114[4] + 0x3956c25b;
    uVar2 = uVar2 + iVar1;
    uVar6 =
        iVar1 +
        ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
         (uVar5 >> 0x16 | uVar5 * 0x400)) +
        (uVar5 & (uVar4 | uVar3) | uVar3 & uVar4);
    iVar1 = local_134[2] +
            ((uVar2 >> 0x19 | uVar2 * 0x80) ^ (uVar2 >> 6 | uVar2 * 0x4000000) ^
             (uVar2 >> 0xb | uVar2 * 0x200000)) +
            (local_134[1] ^ uVar2 & (local_134[1] ^ local_134[0])) +
            local_114[5] + 0x59f111f1;
    uVar3 = uVar3 + iVar1;
    uVar7 =
        iVar1 +
        ((uVar6 >> 2 | uVar6 * 0x40000000) ^ (uVar6 >> 0xd | uVar6 * 0x80000) ^
         (uVar6 >> 0x16 | uVar6 * 0x400)) +
        (uVar6 & (uVar5 | uVar4) | uVar4 & uVar5);
    iVar1 = local_134[1] +
            ((uVar3 >> 0x19 | uVar3 * 0x80) ^ (uVar3 >> 6 | uVar3 * 0x4000000) ^
             (uVar3 >> 0xb | uVar3 * 0x200000)) +
            (local_134[0] ^ uVar3 & (local_134[0] ^ uVar2)) + local_114[6] +
            -0x6dc07d5c;
    uVar4 = uVar4 + iVar1;
    uVar8 =
        iVar1 +
        ((uVar7 >> 2 | uVar7 * 0x40000000) ^ (uVar7 >> 0xd | uVar7 * 0x80000) ^
         (uVar7 >> 0x16 | uVar7 * 0x400)) +
        (uVar7 & (uVar6 | uVar5) | uVar5 & uVar6);
    iVar1 = local_134[0] +
            ((uVar4 >> 0x19 | uVar4 * 0x80) ^ (uVar4 >> 6 | uVar4 * 0x4000000) ^
             (uVar4 >> 0xb | uVar4 * 0x200000)) +
            (uVar2 ^ uVar4 & (uVar2 ^ uVar3)) + local_114[7] + -0x54e3a12b;
    uVar5 = uVar5 + iVar1;
    uVar9 =
        iVar1 +
        ((uVar8 >> 2 | uVar8 * 0x40000000) ^ (uVar8 >> 0xd | uVar8 * 0x80000) ^
         (uVar8 >> 0x16 | uVar8 * 0x400)) +
        (uVar8 & (uVar7 | uVar6) | uVar6 & uVar7);
    iVar1 = uVar2 +
            ((uVar5 >> 0x19 | uVar5 * 0x80) ^ (uVar5 >> 6 | uVar5 * 0x4000000) ^
             (uVar5 >> 0xb | uVar5 * 0x200000)) +
            (uVar3 ^ uVar5 & (uVar3 ^ uVar4)) + local_114[8] + -0x27f85568;
    uVar6 = uVar6 + iVar1;
    uVar2 =
        iVar1 +
        ((uVar9 >> 2 | uVar9 * 0x40000000) ^ (uVar9 >> 0xd | uVar9 * 0x80000) ^
         (uVar9 >> 0x16 | uVar9 * 0x400)) +
        (uVar9 & (uVar8 | uVar7) | uVar7 & uVar8);
    iVar1 = uVar3 +
            ((uVar6 >> 0x19 | uVar6 * 0x80) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^
             (uVar6 >> 0xb | uVar6 * 0x200000)) +
            (uVar4 ^ uVar6 & (uVar4 ^ uVar5)) + local_114[9] + 0x12835b01;
    uVar7 = uVar7 + iVar1;
    uVar3 =
        iVar1 +
        ((uVar2 >> 2 | uVar2 * 0x40000000) ^ (uVar2 >> 0xd | uVar2 * 0x80000) ^
         (uVar2 >> 0x16 | uVar2 * 0x400)) +
        (uVar2 & (uVar9 | uVar8) | uVar8 & uVar9);
    iVar1 = uVar4 +
            ((uVar7 >> 0x19 | uVar7 * 0x80) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^
             (uVar7 >> 0xb | uVar7 * 0x200000)) +
            (uVar5 ^ uVar7 & (uVar5 ^ uVar6)) + local_114[10] + 0x243185be;
    uVar8 = uVar8 + iVar1;
    uVar4 =
        iVar1 +
        ((uVar3 >> 2 | uVar3 * 0x40000000) ^ (uVar3 >> 0xd | uVar3 * 0x80000) ^
         (uVar3 >> 0x16 | uVar3 * 0x400)) +
        (uVar3 & (uVar2 | uVar9) | uVar9 & uVar2);
    iVar1 = uVar5 +
            ((uVar8 >> 0x19 | uVar8 * 0x80) ^ (uVar8 >> 6 | uVar8 * 0x4000000) ^
             (uVar8 >> 0xb | uVar8 * 0x200000)) +
            (uVar6 ^ uVar8 & (uVar6 ^ uVar7)) + local_114[0xb] + 0x550c7dc3;
    uVar9 = uVar9 + iVar1;
    uVar5 =
        iVar1 +
        ((uVar4 >> 2 | uVar4 * 0x40000000) ^ (uVar4 >> 0xd | uVar4 * 0x80000) ^
         (uVar4 >> 0x16 | uVar4 * 0x400)) +
        (uVar4 & (uVar3 | uVar2) | uVar2 & uVar3);
    iVar1 = uVar6 +
            ((uVar9 >> 0x19 | uVar9 * 0x80) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^
             (uVar9 >> 0xb | uVar9 * 0x200000)) +
            (uVar7 ^ uVar9 & (uVar7 ^ uVar8)) + local_114[0xc] + 0x72be5d74;
    uVar2 = uVar2 + iVar1;
    uVar6 =
        iVar1 +
        ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
         (uVar5 >> 0x16 | uVar5 * 0x400)) +
        (uVar5 & (uVar4 | uVar3) | uVar3 & uVar4);
    iVar1 = uVar7 +
            ((uVar2 >> 0x19 | uVar2 * 0x80) ^ (uVar2 >> 6 | uVar2 * 0x4000000) ^
             (uVar2 >> 0xb | uVar2 * 0x200000)) +
            (uVar8 ^ uVar2 & (uVar8 ^ uVar9)) + local_114[0xd] + -0x7f214e02;
    uVar3 = uVar3 + iVar1;
    uVar7 =
        iVar1 +
        ((uVar6 >> 2 | uVar6 * 0x40000000) ^ (uVar6 >> 0xd | uVar6 * 0x80000) ^
         (uVar6 >> 0x16 | uVar6 * 0x400)) +
        (uVar6 & (uVar5 | uVar4) | uVar4 & uVar5);
    iVar1 = uVar8 +
            ((uVar3 >> 0x19 | uVar3 * 0x80) ^ (uVar3 >> 6 | uVar3 * 0x4000000) ^
             (uVar3 >> 0xb | uVar3 * 0x200000)) +
            (uVar9 ^ uVar3 & (uVar9 ^ uVar2)) + local_114[0xe] + -0x6423f959;
    uVar4 = uVar4 + iVar1;
    uVar8 =
        iVar1 +
        ((uVar7 >> 2 | uVar7 * 0x40000000) ^ (uVar7 >> 0xd | uVar7 * 0x80000) ^
         (uVar7 >> 0x16 | uVar7 * 0x400)) +
        (uVar7 & (uVar6 | uVar5) | uVar5 & uVar6);
    iVar1 = uVar9 +
            ((uVar4 >> 0x19 | uVar4 * 0x80) ^ (uVar4 >> 6 | uVar4 * 0x4000000) ^
             (uVar4 >> 0xb | uVar4 * 0x200000)) +
            (uVar2 ^ uVar4 & (uVar2 ^ uVar3)) + local_114[0xf] + -0x3e640e8c;
    uVar5 = uVar5 + iVar1;
    uVar9 =
        iVar1 +
        ((uVar8 >> 2 | uVar8 * 0x40000000) ^ (uVar8 >> 0xd | uVar8 * 0x80000) ^
         (uVar8 >> 0x16 | uVar8 * 0x400)) +
        (uVar8 & (uVar7 | uVar6) | uVar6 & uVar7);
    iVar1 = uVar2 +
            ((uVar5 >> 0x19 | uVar5 * 0x80) ^ (uVar5 >> 6 | uVar5 * 0x4000000) ^
             (uVar5 >> 0xb | uVar5 * 0x200000)) +
            (uVar3 ^ uVar5 & (uVar3 ^ uVar4)) + local_114[0x10] + -0x1b64963f;
    uVar6 = uVar6 + iVar1;
    uVar2 =
        iVar1 +
        ((uVar9 >> 2 | uVar9 * 0x40000000) ^ (uVar9 >> 0xd | uVar9 * 0x80000) ^
         (uVar9 >> 0x16 | uVar9 * 0x400)) +
        (uVar9 & (uVar8 | uVar7) | uVar7 & uVar8);
    iVar1 = uVar3 +
            ((uVar6 >> 0x19 | uVar6 * 0x80) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^
             (uVar6 >> 0xb | uVar6 * 0x200000)) +
            (uVar4 ^ uVar6 & (uVar4 ^ uVar5)) + local_114[0x11] + -0x1041b87a;
    uVar7 = uVar7 + iVar1;
    uVar3 =
        iVar1 +
        ((uVar2 >> 2 | uVar2 * 0x40000000) ^ (uVar2 >> 0xd | uVar2 * 0x80000) ^
         (uVar2 >> 0x16 | uVar2 * 0x400)) +
        (uVar2 & (uVar9 | uVar8) | uVar8 & uVar9);
    iVar1 = uVar4 +
            ((uVar7 >> 0x19 | uVar7 * 0x80) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^
             (uVar7 >> 0xb | uVar7 * 0x200000)) +
            (uVar5 ^ uVar7 & (uVar5 ^ uVar6)) + local_114[0x12] + 0xfc19dc6;
    uVar8 = uVar8 + iVar1;
    uVar4 =
        iVar1 +
        ((uVar3 >> 2 | uVar3 * 0x40000000) ^ (uVar3 >> 0xd | uVar3 * 0x80000) ^
         (uVar3 >> 0x16 | uVar3 * 0x400)) +
        (uVar3 & (uVar2 | uVar9) | uVar9 & uVar2);
    iVar1 = uVar5 +
            ((uVar8 >> 0x19 | uVar8 * 0x80) ^ (uVar8 >> 6 | uVar8 * 0x4000000) ^
             (uVar8 >> 0xb | uVar8 * 0x200000)) +
            (uVar6 ^ uVar8 & (uVar6 ^ uVar7)) + local_114[0x13] + 0x240ca1cc;
    uVar9 = uVar9 + iVar1;
    uVar5 =
        iVar1 +
        ((uVar4 >> 2 | uVar4 * 0x40000000) ^ (uVar4 >> 0xd | uVar4 * 0x80000) ^
         (uVar4 >> 0x16 | uVar4 * 0x400)) +
        (uVar4 & (uVar3 | uVar2) | uVar2 & uVar3);
    iVar1 = uVar6 +
            ((uVar9 >> 0x19 | uVar9 * 0x80) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^
             (uVar9 >> 0xb | uVar9 * 0x200000)) +
            (uVar7 ^ uVar9 & (uVar7 ^ uVar8)) + local_114[0x14] + 0x2de92c6f;
    uVar2 = uVar2 + iVar1;
    uVar6 =
        iVar1 +
        ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
         (uVar5 >> 0x16 | uVar5 * 0x400)) +
        (uVar5 & (uVar4 | uVar3) | uVar3 & uVar4);
    iVar1 = uVar7 +
            ((uVar2 >> 0x19 | uVar2 * 0x80) ^ (uVar2 >> 6 | uVar2 * 0x4000000) ^
             (uVar2 >> 0xb | uVar2 * 0x200000)) +
            (uVar8 ^ uVar2 & (uVar8 ^ uVar9)) + local_114[0x15] + 0x4a7484aa;
    uVar3 = uVar3 + iVar1;
    uVar7 =
        iVar1 +
        ((uVar6 >> 2 | uVar6 * 0x40000000) ^ (uVar6 >> 0xd | uVar6 * 0x80000) ^
         (uVar6 >> 0x16 | uVar6 * 0x400)) +
        (uVar6 & (uVar5 | uVar4) | uVar4 & uVar5);
    iVar1 = uVar8 +
            ((uVar3 >> 0x19 | uVar3 * 0x80) ^ (uVar3 >> 6 | uVar3 * 0x4000000) ^
             (uVar3 >> 0xb | uVar3 * 0x200000)) +
            (uVar9 ^ uVar3 & (uVar9 ^ uVar2)) + local_114[0x16] + 0x5cb0a9dc;
    uVar4 = uVar4 + iVar1;
    uVar8 =
        iVar1 +
        ((uVar7 >> 2 | uVar7 * 0x40000000) ^ (uVar7 >> 0xd | uVar7 * 0x80000) ^
         (uVar7 >> 0x16 | uVar7 * 0x400)) +
        (uVar7 & (uVar6 | uVar5) | uVar5 & uVar6);
    iVar1 = uVar9 +
            ((uVar4 >> 0x19 | uVar4 * 0x80) ^ (uVar4 >> 6 | uVar4 * 0x4000000) ^
             (uVar4 >> 0xb | uVar4 * 0x200000)) +
            (uVar2 ^ uVar4 & (uVar2 ^ uVar3)) + local_114[0x17] + 0x76f988da;
    uVar5 = uVar5 + iVar1;
    uVar9 =
        iVar1 +
        ((uVar8 >> 2 | uVar8 * 0x40000000) ^ (uVar8 >> 0xd | uVar8 * 0x80000) ^
         (uVar8 >> 0x16 | uVar8 * 0x400)) +
        (uVar8 & (uVar7 | uVar6) | uVar6 & uVar7);
    iVar1 = uVar2 +
            ((uVar5 >> 0x19 | uVar5 * 0x80) ^ (uVar5 >> 6 | uVar5 * 0x4000000) ^
             (uVar5 >> 0xb | uVar5 * 0x200000)) +
            (uVar3 ^ uVar5 & (uVar3 ^ uVar4)) + local_114[0x18] + -0x67c1aeae;
    uVar6 = uVar6 + iVar1;
    uVar2 =
        iVar1 +
        ((uVar9 >> 2 | uVar9 * 0x40000000) ^ (uVar9 >> 0xd | uVar9 * 0x80000) ^
         (uVar9 >> 0x16 | uVar9 * 0x400)) +
        (uVar9 & (uVar8 | uVar7) | uVar7 & uVar8);
    iVar1 = uVar3 +
            ((uVar6 >> 0x19 | uVar6 * 0x80) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^
             (uVar6 >> 0xb | uVar6 * 0x200000)) +
            (uVar4 ^ uVar6 & (uVar4 ^ uVar5)) + local_114[0x19] + -0x57ce3993;
    uVar7 = uVar7 + iVar1;
    uVar3 =
        iVar1 +
        ((uVar2 >> 2 | uVar2 * 0x40000000) ^ (uVar2 >> 0xd | uVar2 * 0x80000) ^
         (uVar2 >> 0x16 | uVar2 * 0x400)) +
        (uVar2 & (uVar9 | uVar8) | uVar8 & uVar9);
    iVar1 = uVar4 +
            ((uVar7 >> 0x19 | uVar7 * 0x80) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^
             (uVar7 >> 0xb | uVar7 * 0x200000)) +
            (uVar5 ^ uVar7 & (uVar5 ^ uVar6)) + local_114[0x1a] + -0x4ffcd838;
    uVar8 = uVar8 + iVar1;
    uVar4 =
        iVar1 +
        ((uVar3 >> 2 | uVar3 * 0x40000000) ^ (uVar3 >> 0xd | uVar3 * 0x80000) ^
         (uVar3 >> 0x16 | uVar3 * 0x400)) +
        (uVar3 & (uVar2 | uVar9) | uVar9 & uVar2);
    iVar1 = uVar5 +
            ((uVar8 >> 0x19 | uVar8 * 0x80) ^ (uVar8 >> 6 | uVar8 * 0x4000000) ^
             (uVar8 >> 0xb | uVar8 * 0x200000)) +
            (uVar6 ^ uVar8 & (uVar6 ^ uVar7)) + local_114[0x1b] + -0x40a68039;
    uVar9 = uVar9 + iVar1;
    uVar5 =
        iVar1 +
        ((uVar4 >> 2 | uVar4 * 0x40000000) ^ (uVar4 >> 0xd | uVar4 * 0x80000) ^
         (uVar4 >> 0x16 | uVar4 * 0x400)) +
        (uVar4 & (uVar3 | uVar2) | uVar2 & uVar3);
    iVar1 = uVar6 +
            ((uVar9 >> 0x19 | uVar9 * 0x80) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^
             (uVar9 >> 0xb | uVar9 * 0x200000)) +
            (uVar7 ^ uVar9 & (uVar7 ^ uVar8)) + local_114[0x1c] + -0x391ff40d;
    uVar2 = uVar2 + iVar1;
    uVar6 =
        iVar1 +
        ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
         (uVar5 >> 0x16 | uVar5 * 0x400)) +
        (uVar5 & (uVar4 | uVar3) | uVar3 & uVar4);
    iVar1 = uVar7 +
            ((uVar2 >> 0x19 | uVar2 * 0x80) ^ (uVar2 >> 6 | uVar2 * 0x4000000) ^
             (uVar2 >> 0xb | uVar2 * 0x200000)) +
            (uVar8 ^ uVar2 & (uVar8 ^ uVar9)) + local_114[0x1d] + -0x2a586eb9;
    uVar3 = uVar3 + iVar1;
    uVar7 =
        iVar1 +
        ((uVar6 >> 2 | uVar6 * 0x40000000) ^ (uVar6 >> 0xd | uVar6 * 0x80000) ^
         (uVar6 >> 0x16 | uVar6 * 0x400)) +
        (uVar6 & (uVar5 | uVar4) | uVar4 & uVar5);
    iVar1 = uVar8 +
            ((uVar3 >> 0x19 | uVar3 * 0x80) ^ (uVar3 >> 6 | uVar3 * 0x4000000) ^
             (uVar3 >> 0xb | uVar3 * 0x200000)) +
            (uVar9 ^ uVar3 & (uVar9 ^ uVar2)) + local_114[0x1e] + 0x6ca6351;
    uVar4 = uVar4 + iVar1;
    uVar8 =
        iVar1 +
        ((uVar7 >> 2 | uVar7 * 0x40000000) ^ (uVar7 >> 0xd | uVar7 * 0x80000) ^
         (uVar7 >> 0x16 | uVar7 * 0x400)) +
        (uVar7 & (uVar6 | uVar5) | uVar5 & uVar6);
    iVar1 = uVar9 +
            ((uVar4 >> 0x19 | uVar4 * 0x80) ^ (uVar4 >> 6 | uVar4 * 0x4000000) ^
             (uVar4 >> 0xb | uVar4 * 0x200000)) +
            (uVar2 ^ uVar4 & (uVar2 ^ uVar3)) + local_114[0x1f] + 0x14292967;
    uVar5 = uVar5 + iVar1;
    uVar9 =
        iVar1 +
        ((uVar8 >> 2 | uVar8 * 0x40000000) ^ (uVar8 >> 0xd | uVar8 * 0x80000) ^
         (uVar8 >> 0x16 | uVar8 * 0x400)) +
        (uVar8 & (uVar7 | uVar6) | uVar6 & uVar7);
    iVar1 = uVar2 +
            ((uVar5 >> 0x19 | uVar5 * 0x80) ^ (uVar5 >> 6 | uVar5 * 0x4000000) ^
             (uVar5 >> 0xb | uVar5 * 0x200000)) +
            (uVar3 ^ uVar5 & (uVar3 ^ uVar4)) + local_114[0x20] + 0x27b70a85;
    uVar6 = uVar6 + iVar1;
    uVar2 =
        iVar1 +
        ((uVar9 >> 2 | uVar9 * 0x40000000) ^ (uVar9 >> 0xd | uVar9 * 0x80000) ^
         (uVar9 >> 0x16 | uVar9 * 0x400)) +
        (uVar9 & (uVar8 | uVar7) | uVar7 & uVar8);
    iVar1 = uVar3 +
            ((uVar6 >> 0x19 | uVar6 * 0x80) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^
             (uVar6 >> 0xb | uVar6 * 0x200000)) +
            (uVar4 ^ uVar6 & (uVar4 ^ uVar5)) + local_114[0x21] + 0x2e1b2138;
    uVar7 = uVar7 + iVar1;
    uVar3 =
        iVar1 +
        ((uVar2 >> 2 | uVar2 * 0x40000000) ^ (uVar2 >> 0xd | uVar2 * 0x80000) ^
         (uVar2 >> 0x16 | uVar2 * 0x400)) +
        (uVar2 & (uVar9 | uVar8) | uVar8 & uVar9);
    iVar1 = uVar4 +
            ((uVar7 >> 0x19 | uVar7 * 0x80) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^
             (uVar7 >> 0xb | uVar7 * 0x200000)) +
            (uVar5 ^ uVar7 & (uVar5 ^ uVar6)) + local_114[0x22] + 0x4d2c6dfc;
    uVar8 = uVar8 + iVar1;
    uVar4 =
        iVar1 +
        ((uVar3 >> 2 | uVar3 * 0x40000000) ^ (uVar3 >> 0xd | uVar3 * 0x80000) ^
         (uVar3 >> 0x16 | uVar3 * 0x400)) +
        (uVar3 & (uVar2 | uVar9) | uVar9 & uVar2);
    iVar1 = uVar5 +
            ((uVar8 >> 0x19 | uVar8 * 0x80) ^ (uVar8 >> 6 | uVar8 * 0x4000000) ^
             (uVar8 >> 0xb | uVar8 * 0x200000)) +
            (uVar6 ^ uVar8 & (uVar6 ^ uVar7)) + local_114[0x23] + 0x53380d13;
    uVar9 = uVar9 + iVar1;
    uVar5 =
        iVar1 +
        ((uVar4 >> 2 | uVar4 * 0x40000000) ^ (uVar4 >> 0xd | uVar4 * 0x80000) ^
         (uVar4 >> 0x16 | uVar4 * 0x400)) +
        (uVar4 & (uVar3 | uVar2) | uVar2 & uVar3);
    iVar1 = uVar6 +
            ((uVar9 >> 0x19 | uVar9 * 0x80) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^
             (uVar9 >> 0xb | uVar9 * 0x200000)) +
            (uVar7 ^ uVar9 & (uVar7 ^ uVar8)) + local_114[0x24] + 0x650a7354;
    uVar2 = uVar2 + iVar1;
    uVar6 =
        iVar1 +
        ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
         (uVar5 >> 0x16 | uVar5 * 0x400)) +
        (uVar5 & (uVar4 | uVar3) | uVar3 & uVar4);
    iVar1 = uVar7 +
            ((uVar2 >> 0x19 | uVar2 * 0x80) ^ (uVar2 >> 6 | uVar2 * 0x4000000) ^
             (uVar2 >> 0xb | uVar2 * 0x200000)) +
            (uVar8 ^ uVar2 & (uVar8 ^ uVar9)) + local_114[0x25] + 0x766a0abb;
    uVar3 = uVar3 + iVar1;
    uVar7 =
        iVar1 +
        ((uVar6 >> 2 | uVar6 * 0x40000000) ^ (uVar6 >> 0xd | uVar6 * 0x80000) ^
         (uVar6 >> 0x16 | uVar6 * 0x400)) +
        (uVar6 & (uVar5 | uVar4) | uVar4 & uVar5);
    iVar1 = uVar8 +
            ((uVar3 >> 0x19 | uVar3 * 0x80) ^ (uVar3 >> 6 | uVar3 * 0x4000000) ^
             (uVar3 >> 0xb | uVar3 * 0x200000)) +
            (uVar9 ^ uVar3 & (uVar9 ^ uVar2)) + local_114[0x26] + -0x7e3d36d2;
    uVar4 = uVar4 + iVar1;
    uVar8 =
        iVar1 +
        ((uVar7 >> 2 | uVar7 * 0x40000000) ^ (uVar7 >> 0xd | uVar7 * 0x80000) ^
         (uVar7 >> 0x16 | uVar7 * 0x400)) +
        (uVar7 & (uVar6 | uVar5) | uVar5 & uVar6);
    iVar1 = uVar9 +
            ((uVar4 >> 0x19 | uVar4 * 0x80) ^ (uVar4 >> 6 | uVar4 * 0x4000000) ^
             (uVar4 >> 0xb | uVar4 * 0x200000)) +
            (uVar2 ^ uVar4 & (uVar2 ^ uVar3)) + local_114[0x27] + -0x6d8dd37b;
    uVar5 = uVar5 + iVar1;
    uVar9 =
        iVar1 +
        ((uVar8 >> 2 | uVar8 * 0x40000000) ^ (uVar8 >> 0xd | uVar8 * 0x80000) ^
         (uVar8 >> 0x16 | uVar8 * 0x400)) +
        (uVar8 & (uVar7 | uVar6) | uVar6 & uVar7);
    iVar1 = uVar2 +
            ((uVar5 >> 0x19 | uVar5 * 0x80) ^ (uVar5 >> 6 | uVar5 * 0x4000000) ^
             (uVar5 >> 0xb | uVar5 * 0x200000)) +
            (uVar3 ^ uVar5 & (uVar3 ^ uVar4)) + local_114[0x28] + -0x5d40175f;
    uVar6 = uVar6 + iVar1;
    uVar2 =
        iVar1 +
        ((uVar9 >> 2 | uVar9 * 0x40000000) ^ (uVar9 >> 0xd | uVar9 * 0x80000) ^
         (uVar9 >> 0x16 | uVar9 * 0x400)) +
        (uVar9 & (uVar8 | uVar7) | uVar7 & uVar8);
    iVar1 = uVar3 +
            ((uVar6 >> 0x19 | uVar6 * 0x80) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^
             (uVar6 >> 0xb | uVar6 * 0x200000)) +
            (uVar4 ^ uVar6 & (uVar4 ^ uVar5)) + local_114[0x29] + -0x57e599b5;
    uVar7 = uVar7 + iVar1;
    uVar3 =
        iVar1 +
        ((uVar2 >> 2 | uVar2 * 0x40000000) ^ (uVar2 >> 0xd | uVar2 * 0x80000) ^
         (uVar2 >> 0x16 | uVar2 * 0x400)) +
        (uVar2 & (uVar9 | uVar8) | uVar8 & uVar9);
    iVar1 = uVar4 +
            ((uVar7 >> 0x19 | uVar7 * 0x80) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^
             (uVar7 >> 0xb | uVar7 * 0x200000)) +
            (uVar5 ^ uVar7 & (uVar5 ^ uVar6)) + local_114[0x2a] + -0x3db47490;
    uVar8 = uVar8 + iVar1;
    uVar4 =
        iVar1 +
        ((uVar3 >> 2 | uVar3 * 0x40000000) ^ (uVar3 >> 0xd | uVar3 * 0x80000) ^
         (uVar3 >> 0x16 | uVar3 * 0x400)) +
        (uVar3 & (uVar2 | uVar9) | uVar9 & uVar2);
    iVar1 = uVar5 +
            ((uVar8 >> 0x19 | uVar8 * 0x80) ^ (uVar8 >> 6 | uVar8 * 0x4000000) ^
             (uVar8 >> 0xb | uVar8 * 0x200000)) +
            (uVar6 ^ uVar8 & (uVar6 ^ uVar7)) + local_114[0x2b] + -0x3893ae5d;
    uVar9 = uVar9 + iVar1;
    uVar5 =
        iVar1 +
        ((uVar4 >> 2 | uVar4 * 0x40000000) ^ (uVar4 >> 0xd | uVar4 * 0x80000) ^
         (uVar4 >> 0x16 | uVar4 * 0x400)) +
        (uVar4 & (uVar3 | uVar2) | uVar2 & uVar3);
    iVar1 = uVar6 +
            ((uVar9 >> 0x19 | uVar9 * 0x80) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^
             (uVar9 >> 0xb | uVar9 * 0x200000)) +
            (uVar7 ^ uVar9 & (uVar7 ^ uVar8)) + local_114[0x2c] + -0x2e6d17e7;
    uVar2 = uVar2 + iVar1;
    uVar6 =
        iVar1 +
        ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
         (uVar5 >> 0x16 | uVar5 * 0x400)) +
        (uVar5 & (uVar4 | uVar3) | uVar3 & uVar4);
    iVar1 = uVar7 +
            ((uVar2 >> 0x19 | uVar2 * 0x80) ^ (uVar2 >> 6 | uVar2 * 0x4000000) ^
             (uVar2 >> 0xb | uVar2 * 0x200000)) +
            (uVar8 ^ uVar2 & (uVar8 ^ uVar9)) + local_114[0x2d] + -0x2966f9dc;
    uVar3 = uVar3 + iVar1;
    uVar7 =
        iVar1 +
        ((uVar6 >> 2 | uVar6 * 0x40000000) ^ (uVar6 >> 0xd | uVar6 * 0x80000) ^
         (uVar6 >> 0x16 | uVar6 * 0x400)) +
        (uVar6 & (uVar5 | uVar4) | uVar4 & uVar5);
    iVar1 = uVar8 +
            ((uVar3 >> 0x19 | uVar3 * 0x80) ^ (uVar3 >> 6 | uVar3 * 0x4000000) ^
             (uVar3 >> 0xb | uVar3 * 0x200000)) +
            (uVar9 ^ uVar3 & (uVar9 ^ uVar2)) + local_114[0x2e] + -0xbf1ca7b;
    uVar4 = uVar4 + iVar1;
    uVar8 =
        iVar1 +
        ((uVar7 >> 2 | uVar7 * 0x40000000) ^ (uVar7 >> 0xd | uVar7 * 0x80000) ^
         (uVar7 >> 0x16 | uVar7 * 0x400)) +
        (uVar7 & (uVar6 | uVar5) | uVar5 & uVar6);
    iVar1 = uVar9 +
            ((uVar4 >> 0x19 | uVar4 * 0x80) ^ (uVar4 >> 6 | uVar4 * 0x4000000) ^
             (uVar4 >> 0xb | uVar4 * 0x200000)) +
            (uVar2 ^ uVar4 & (uVar2 ^ uVar3)) + local_114[0x2f] + 0x106aa070;
    uVar5 = uVar5 + iVar1;
    uVar9 =
        iVar1 +
        ((uVar8 >> 2 | uVar8 * 0x40000000) ^ (uVar8 >> 0xd | uVar8 * 0x80000) ^
         (uVar8 >> 0x16 | uVar8 * 0x400)) +
        (uVar8 & (uVar7 | uVar6) | uVar6 & uVar7);
    iVar1 = uVar2 +
            ((uVar5 >> 0x19 | uVar5 * 0x80) ^ (uVar5 >> 6 | uVar5 * 0x4000000) ^
             (uVar5 >> 0xb | uVar5 * 0x200000)) +
            (uVar3 ^ uVar5 & (uVar3 ^ uVar4)) + local_114[0x30] + 0x19a4c116;
    uVar6 = uVar6 + iVar1;
    uVar2 =
        iVar1 +
        ((uVar9 >> 2 | uVar9 * 0x40000000) ^ (uVar9 >> 0xd | uVar9 * 0x80000) ^
         (uVar9 >> 0x16 | uVar9 * 0x400)) +
        (uVar9 & (uVar8 | uVar7) | uVar7 & uVar8);
    iVar1 = uVar3 +
            ((uVar6 >> 0x19 | uVar6 * 0x80) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^
             (uVar6 >> 0xb | uVar6 * 0x200000)) +
            (uVar4 ^ uVar6 & (uVar4 ^ uVar5)) + local_114[0x31] + 0x1e376c08;
    uVar7 = uVar7 + iVar1;
    uVar3 =
        iVar1 +
        ((uVar2 >> 2 | uVar2 * 0x40000000) ^ (uVar2 >> 0xd | uVar2 * 0x80000) ^
         (uVar2 >> 0x16 | uVar2 * 0x400)) +
        (uVar2 & (uVar9 | uVar8) | uVar8 & uVar9);
    iVar1 = uVar4 +
            ((uVar7 >> 0x19 | uVar7 * 0x80) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^
             (uVar7 >> 0xb | uVar7 * 0x200000)) +
            (uVar5 ^ uVar7 & (uVar5 ^ uVar6)) + local_114[0x32] + 0x2748774c;
    uVar8 = uVar8 + iVar1;
    uVar4 =
        iVar1 +
        ((uVar3 >> 2 | uVar3 * 0x40000000) ^ (uVar3 >> 0xd | uVar3 * 0x80000) ^
         (uVar3 >> 0x16 | uVar3 * 0x400)) +
        (uVar3 & (uVar2 | uVar9) | uVar9 & uVar2);
    iVar1 = uVar5 +
            ((uVar8 >> 0x19 | uVar8 * 0x80) ^ (uVar8 >> 6 | uVar8 * 0x4000000) ^
             (uVar8 >> 0xb | uVar8 * 0x200000)) +
            (uVar6 ^ uVar8 & (uVar6 ^ uVar7)) + local_114[0x33] + 0x34b0bcb5;
    uVar9 = uVar9 + iVar1;
    uVar5 =
        iVar1 +
        ((uVar4 >> 2 | uVar4 * 0x40000000) ^ (uVar4 >> 0xd | uVar4 * 0x80000) ^
         (uVar4 >> 0x16 | uVar4 * 0x400)) +
        (uVar4 & (uVar3 | uVar2) | uVar2 & uVar3);
    iVar1 = uVar6 +
            ((uVar9 >> 0x19 | uVar9 * 0x80) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^
             (uVar9 >> 0xb | uVar9 * 0x200000)) +
            (uVar7 ^ uVar9 & (uVar7 ^ uVar8)) + local_114[0x34] + 0x391c0cb3;
    uVar2 = uVar2 + iVar1;
    uVar6 =
        iVar1 +
        ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
         (uVar5 >> 0x16 | uVar5 * 0x400)) +
        (uVar5 & (uVar4 | uVar3) | uVar3 & uVar4);
    iVar1 = uVar7 +
            ((uVar2 >> 0x19 | uVar2 * 0x80) ^ (uVar2 >> 6 | uVar2 * 0x4000000) ^
             (uVar2 >> 0xb | uVar2 * 0x200000)) +
            (uVar8 ^ uVar2 & (uVar8 ^ uVar9)) + local_114[0x35] + 0x4ed8aa4a;
    uVar3 = uVar3 + iVar1;
    uVar7 =
        iVar1 +
        ((uVar6 >> 2 | uVar6 * 0x40000000) ^ (uVar6 >> 0xd | uVar6 * 0x80000) ^
         (uVar6 >> 0x16 | uVar6 * 0x400)) +
        (uVar6 & (uVar5 | uVar4) | uVar4 & uVar5);
    iVar1 = uVar8 +
            ((uVar3 >> 0x19 | uVar3 * 0x80) ^ (uVar3 >> 6 | uVar3 * 0x4000000) ^
             (uVar3 >> 0xb | uVar3 * 0x200000)) +
            (uVar9 ^ uVar3 & (uVar9 ^ uVar2)) + local_114[0x36] + 0x5b9cca4f;
    uVar4 = uVar4 + iVar1;
    uVar8 =
        iVar1 +
        ((uVar7 >> 2 | uVar7 * 0x40000000) ^ (uVar7 >> 0xd | uVar7 * 0x80000) ^
         (uVar7 >> 0x16 | uVar7 * 0x400)) +
        (uVar7 & (uVar6 | uVar5) | uVar5 & uVar6);
    iVar1 = uVar9 +
            ((uVar4 >> 0x19 | uVar4 * 0x80) ^ (uVar4 >> 6 | uVar4 * 0x4000000) ^
             (uVar4 >> 0xb | uVar4 * 0x200000)) +
            (uVar2 ^ uVar4 & (uVar2 ^ uVar3)) + local_114[0x37] + 0x682e6ff3;
    uVar5 = uVar5 + iVar1;
    uVar9 =
        iVar1 +
        ((uVar8 >> 2 | uVar8 * 0x40000000) ^ (uVar8 >> 0xd | uVar8 * 0x80000) ^
         (uVar8 >> 0x16 | uVar8 * 0x400)) +
        (uVar8 & (uVar7 | uVar6) | uVar6 & uVar7);
    iVar1 = uVar2 +
            ((uVar5 >> 0x19 | uVar5 * 0x80) ^ (uVar5 >> 6 | uVar5 * 0x4000000) ^
             (uVar5 >> 0xb | uVar5 * 0x200000)) +
            (uVar3 ^ uVar5 & (uVar3 ^ uVar4)) + local_114[0x38] + 0x748f82ee;
    uVar6 = uVar6 + iVar1;
    local_134[7] =
        iVar1 +
        ((uVar9 >> 2 | uVar9 * 0x40000000) ^ (uVar9 >> 0xd | uVar9 * 0x80000) ^
         (uVar9 >> 0x16 | uVar9 * 0x400)) +
        (uVar9 & (uVar8 | uVar7) | uVar7 & uVar8);
    iVar1 = uVar3 +
            ((uVar6 >> 0x19 | uVar6 * 0x80) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^
             (uVar6 >> 0xb | uVar6 * 0x200000)) +
            (uVar4 ^ uVar6 & (uVar4 ^ uVar5)) + local_114[0x39] + 0x78a5636f;
    uVar7 = uVar7 + iVar1;
    local_134[6] = iVar1 +
                   ((local_134[7] >> 2 | local_134[7] * 0x40000000) ^
                    (local_134[7] >> 0xd | local_134[7] * 0x80000) ^
                    (local_134[7] >> 0x16 | local_134[7] * 0x400)) +
                   (local_134[7] & (uVar9 | uVar8) | uVar8 & uVar9);
    iVar1 = uVar4 +
            ((uVar7 >> 0x19 | uVar7 * 0x80) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^
             (uVar7 >> 0xb | uVar7 * 0x200000)) +
            (uVar5 ^ uVar7 & (uVar5 ^ uVar6)) + local_114[0x3a] + -0x7b3787ec;
    uVar8 = uVar8 + iVar1;
    local_134[5] =
        iVar1 +
        ((local_134[6] >> 2 | local_134[6] * 0x40000000) ^
         (local_134[6] >> 0xd | local_134[6] * 0x80000) ^
         (local_134[6] >> 0x16 | local_134[6] * 0x400)) +
        (local_134[6] & (local_134[7] | uVar9) | uVar9 & local_134[7]);
    iVar1 = uVar5 +
            ((uVar8 >> 0x19 | uVar8 * 0x80) ^ (uVar8 >> 6 | uVar8 * 0x4000000) ^
             (uVar8 >> 0xb | uVar8 * 0x200000)) +
            (uVar6 ^ uVar8 & (uVar6 ^ uVar7)) + local_114[0x3b] + -0x7338fdf8;
    uVar9 = uVar9 + iVar1;
    uVar2 = iVar1 +
            ((local_134[5] >> 2 | local_134[5] * 0x40000000) ^
             (local_134[5] >> 0xd | local_134[5] * 0x80000) ^
             (local_134[5] >> 0x16 | local_134[5] * 0x400)) +
            (local_134[5] & (local_134[6] | local_134[7]) |
             local_134[7] & local_134[6]);
    iVar1 = uVar6 +
            ((uVar9 >> 0x19 | uVar9 * 0x80) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^
             (uVar9 >> 0xb | uVar9 * 0x200000)) +
            (uVar7 ^ uVar9 & (uVar7 ^ uVar8)) + local_114[0x3c] + -0x6f410006;
    local_134[7] = local_134[7] + iVar1;
    local_134[3] =
        iVar1 +
        ((uVar2 >> 2 | uVar2 * 0x40000000) ^ (uVar2 >> 0xd | uVar2 * 0x80000) ^
         (uVar2 >> 0x16 | uVar2 * 0x400)) +
        (uVar2 & (local_134[5] | local_134[6]) | local_134[6] & local_134[5]);
    iVar1 = uVar7 +
            ((local_134[7] >> 0x19 | local_134[7] * 0x80) ^
             (local_134[7] >> 6 | local_134[7] * 0x4000000) ^
             (local_134[7] >> 0xb | local_134[7] * 0x200000)) +
            (uVar8 ^ local_134[7] & (uVar8 ^ uVar9)) + local_114[0x3d] +
            -0x5baf9315;
    local_134[6] = local_134[6] + iVar1;
    local_134[2] =
        iVar1 +
        ((local_134[3] >> 2 | local_134[3] * 0x40000000) ^
         (local_134[3] >> 0xd | local_134[3] * 0x80000) ^
         (local_134[3] >> 0x16 | local_134[3] * 0x400)) +
        (local_134[3] & (uVar2 | local_134[5]) | local_134[5] & uVar2);
    iVar1 = uVar8 +
            ((local_134[6] >> 0x19 | local_134[6] * 0x80) ^
             (local_134[6] >> 6 | local_134[6] * 0x4000000) ^
             (local_134[6] >> 0xb | local_134[6] * 0x200000)) +
            (uVar9 ^ local_134[6] & (uVar9 ^ local_134[7])) + local_114[0x3e] +
            -0x41065c09;
    local_134[5] = local_134[5] + iVar1;
    local_134[1] =
        iVar1 +
        ((local_134[2] >> 2 | local_134[2] * 0x40000000) ^
         (local_134[2] >> 0xd | local_134[2] * 0x80000) ^
         (local_134[2] >> 0x16 | local_134[2] * 0x400)) +
        (local_134[2] & (local_134[3] | uVar2) | uVar2 & local_134[3]);
    iVar1 = uVar9 +
            ((local_134[5] >> 0x19 | local_134[5] * 0x80) ^
             (local_134[5] >> 6 | local_134[5] * 0x4000000) ^
             (local_134[5] >> 0xb | local_134[5] * 0x200000)) +
            (local_134[7] ^ local_134[5] & (local_134[7] ^ local_134[6])) +
            local_114[0x3f] + -0x398e870e;
    local_134[4] = uVar2 + iVar1;
    local_134[0] = iVar1 +
                   ((local_134[1] >> 2 | local_134[1] * 0x40000000) ^
                    (local_134[1] >> 0xd | local_134[1] * 0x80000) ^
                    (local_134[1] >> 0x16 | local_134[1] * 0x400)) +
                   (local_134[1] & (local_134[2] | local_134[3]) |
                    local_134[3] & local_134[2]);
    for (local_c = 0; local_c < 8; local_c = local_c + 1) {
        *(uint *)((int)param_1 + local_c * 4) =
            *(int *)((int)param_1 + local_c * 4) + local_134[local_c];
    }
    return;
}

void FUN_000c2974(undefined4 *param_1)

{
    *param_1 = 0x6a09e667;
    param_1[1] = 0xbb67ae85;
    param_1[2] = 0x3c6ef372;
    param_1[3] = 0xa54ff53a;
    param_1[4] = 0x510e527f;
    param_1[5] = 0x9b05688c;
    param_1[6] = 0x1f83d9ab;
    param_1[7] = 0x5be0cd19;
    return;
}

void FUN_000c2a30(int param_1, int param_2)

{
    undefined4 local_18c;
    undefined4 uStack_188;
    undefined4 uStack_184;
    undefined4 uStack_180;
    undefined4 local_17c;
    undefined4 uStack_178;
    undefined4 uStack_174;
    undefined4 uStack_170;
    undefined4 local_16c;
    undefined4 uStack_168;
    undefined4 uStack_164;
    undefined4 uStack_160;
    undefined4 local_15c;
    undefined4 uStack_158;
    undefined4 uStack_154;
    undefined4 uStack_150;
    uint auStack_14c[4];
    undefined1 auStack_13c[16];
    uint auStack_12c[8];
    uint local_10c[8];
    uint local_ec;
    undefined4 uStack_e8;
    undefined4 uStack_e4;
    undefined4 uStack_e0;
    undefined4 local_dc;
    undefined4 uStack_d8;
    undefined4 uStack_d4;
    undefined4 uStack_d0;
    undefined4 local_cc;
    undefined4 uStack_c8;
    undefined4 uStack_c4;
    undefined4 uStack_c0;
    undefined4 local_bc;
    undefined4 uStack_b8;
    undefined4 uStack_b4;
    undefined4 uStack_b0;
    undefined4 local_ac;
    undefined4 uStack_a8;
    undefined4 uStack_a4;
    undefined4 uStack_a0;
    undefined4 local_9c;
    undefined4 uStack_98;
    undefined4 uStack_94;
    undefined4 uStack_90;
    undefined1 auStack_8c[32];
    undefined4 local_6c;
    undefined4 uStack_68;
    undefined4 uStack_64;
    undefined4 uStack_60;
    undefined4 local_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 uStack_50;
    undefined1 auStack_4c[16];
    int local_3c;
    undefined1 auStack_38[44];
    uint local_c;

    FUN_000c2974(&local_ec);
    FUN_000bf324(&local_ec, param_1, 1);
    memcpy(auStack_14c, (void *)(param_1 + 0x40), 0x10);
    memcpy(auStack_13c, &DAT_0013b65c, 0x30);
    FUN_000bf324(&local_ec, auStack_14c, 1);
    local_10c[0] = local_ec;
    local_10c[1] = uStack_e8;
    local_10c[2] = uStack_e4;
    local_10c[3] = uStack_e0;
    local_10c[4] = local_dc;
    local_10c[5] = uStack_d8;
    local_10c[6] = uStack_d4;
    local_10c[7] = uStack_d0;
    FUN_000c2974(&local_6c);
    for (local_c = 0; local_c < 8; local_c = local_c + 1) {
        auStack_14c[local_c] = local_10c[local_c] ^ 0x36363636;
    }
    for (; local_c < 0x10; local_c = local_c + 1) {
        auStack_14c[local_c] = 0x36363636;
    }
    FUN_000bf324(&local_6c, auStack_14c, 0);
    FUN_000bf324(&local_6c, param_1, 1);
    FUN_000bf2a4(auStack_4c, param_1 + 0x40, 4);
    FUN_000bf2a4(auStack_38, &DAT_0013b6b0, 0xb);
    FUN_000c2974(&local_cc);
    for (local_c = 0; local_c < 8; local_c = local_c + 1) {
        auStack_14c[local_c] = local_10c[local_c] ^ 0x5c5c5c5c;
    }
    for (; local_c < 0x10; local_c = local_c + 1) {
        auStack_14c[local_c] = 0x5c5c5c5c;
    }
    FUN_000bf324(&local_cc, auStack_14c, 0);
    memcpy(auStack_8c, &DAT_0013b68c, 0x20);
    for (local_c = 0; local_c < 4; local_c = local_c + 1) {
        local_18c = local_6c;
        uStack_188 = uStack_68;
        uStack_184 = uStack_64;
        uStack_180 = uStack_60;
        local_17c = local_5c;
        uStack_178 = uStack_58;
        uStack_174 = uStack_54;
        uStack_170 = uStack_50;
        local_3c = local_c + 1;
        FUN_000bf324(&local_18c, auStack_4c, 0);
        local_ac = local_18c;
        uStack_a8 = uStack_188;
        uStack_a4 = uStack_184;
        uStack_a0 = uStack_180;
        local_9c = local_17c;
        uStack_98 = uStack_178;
        uStack_94 = uStack_174;
        uStack_90 = uStack_170;
        local_16c = local_cc;
        uStack_168 = uStack_c8;
        uStack_164 = uStack_c4;
        uStack_160 = uStack_c0;
        local_15c = local_bc;
        uStack_158 = uStack_b8;
        uStack_154 = uStack_b4;
        uStack_150 = uStack_b0;
        FUN_000bf324(&local_16c, &local_ac, 0);
        FUN_000bf2a4(param_2 + local_c * 0x20, &local_16c, 8);
    }
    return;
}

void FUN_000c2d68(int param_1, int param_2, undefined4 param_3)

{
    uint local_8c[8];
    uint auStack_6c[8];
    uint local_4c[8];
    uint local_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 local_1c;
    undefined4 uStack_18;
    undefined4 uStack_14;
    undefined4 uStack_10;
    uint local_c;

    FUN_000c2974(&local_2c);
    FUN_000bf324(&local_2c, param_1, 1);
    memcpy(local_8c, (void *)(param_1 + 0x40), 0x10);
    memcpy(local_8c + 4, &DAT_0013b65c, 0x30);
    FUN_000bf324(&local_2c, local_8c, 1);
    local_4c[0] = local_2c;
    local_4c[1] = uStack_28;
    local_4c[2] = uStack_24;
    local_4c[3] = uStack_20;
    local_4c[4] = local_1c;
    local_4c[5] = uStack_18;
    local_4c[6] = uStack_14;
    local_4c[7] = uStack_10;
    FUN_000c2974(param_3);
    for (local_c = 0; local_c < 8; local_c = local_c + 1) {
        local_8c[local_c] = local_4c[local_c] ^ 0x5c5c5c5c;
    }
    for (; local_c < 0x10; local_c = local_c + 1) {
        local_8c[local_c] = 0x5c5c5c5c;
    }
    FUN_000bf324(param_3, local_8c, 0);
    FUN_000c2974(&local_2c);
    for (local_c = 0; local_c < 8; local_c = local_c + 1) {
        local_8c[local_c] = local_4c[local_c] ^ 0x36363636;
    }
    for (; local_c < 0x10; local_c = local_c + 1) {
        local_8c[local_c] = 0x36363636;
    }
    FUN_000bf324(&local_2c, local_8c, 0);
    FUN_000bf324(&local_2c, param_2, 1);
    FUN_000bf324(&local_2c, param_2 + 0x40, 1);
    FUN_000bf324(&local_2c, &DAT_0013b6dc, 0);
    local_8c[0] = local_2c;
    local_8c[1] = uStack_28;
    local_8c[2] = uStack_24;
    local_8c[3] = uStack_20;
    local_8c[4] = local_1c;
    local_8c[5] = uStack_18;
    local_8c[6] = uStack_14;
    local_8c[7] = uStack_10;
    memcpy(auStack_6c, &DAT_0013b68c, 0x20);
    FUN_000bf324(param_3, local_8c, 0);
    return;
}

void FUN_000c2ff4(uint *param_1, uint *param_2)

{
    uint uVar1;
    uint local_4c;
    uint local_48;
    uint local_44;
    uint local_40;
    uint local_3c;
    uint local_38;
    uint local_34;
    uint local_30;
    uint local_2c;
    uint local_28;
    uint local_24;
    uint local_20;
    uint local_1c;
    uint local_18;
    uint local_14;
    uint local_10;
    uint local_c;

    *param_1 = *param_1 ^ *param_2;
    local_c = *param_1;
    param_1[1] = param_2[1] ^ param_1[1];
    local_10 = param_1[1];
    param_1[2] = param_2[2] ^ param_1[2];
    local_14 = param_1[2];
    param_1[3] = param_2[3] ^ param_1[3];
    local_18 = param_1[3];
    param_1[4] = param_2[4] ^ param_1[4];
    local_1c = param_1[4];
    param_1[5] = param_2[5] ^ param_1[5];
    local_20 = param_1[5];
    param_1[6] = param_2[6] ^ param_1[6];
    local_24 = param_1[6];
    param_1[7] = param_2[7] ^ param_1[7];
    local_28 = param_1[7];
    param_1[8] = param_2[8] ^ param_1[8];
    local_2c = param_1[8];
    param_1[9] = param_2[9] ^ param_1[9];
    local_30 = param_1[9];
    param_1[10] = param_2[10] ^ param_1[10];
    local_34 = param_1[10];
    param_1[0xb] = param_2[0xb] ^ param_1[0xb];
    local_38 = param_1[0xb];
    param_1[0xc] = param_2[0xc] ^ param_1[0xc];
    local_3c = param_1[0xc];
    param_1[0xd] = param_2[0xd] ^ param_1[0xd];
    local_40 = param_1[0xd];
    param_1[0xe] = param_2[0xe] ^ param_1[0xe];
    local_44 = param_1[0xe];
    param_1[0xf] = param_2[0xf] ^ param_1[0xf];
    local_48 = param_1[0xf];
    for (local_4c = 0; local_4c < 8; local_4c = local_4c + 2) {
        local_1c = (local_c + local_3c >> 0x19 | (local_c + local_3c) * 0x80) ^
                   local_1c;
        local_30 =
            (local_20 + local_10 >> 0x19 | (local_20 + local_10) * 0x80) ^
            local_30;
        local_44 =
            (local_34 + local_24 >> 0x19 | (local_34 + local_24) * 0x80) ^
            local_44;
        local_18 =
            (local_48 + local_38 >> 0x19 | (local_48 + local_38) * 0x80) ^
            local_18;
        local_2c = (local_1c + local_c >> 0x17 | (local_1c + local_c) * 0x200) ^
                   local_2c;
        local_40 =
            (local_30 + local_20 >> 0x17 | (local_30 + local_20) * 0x200) ^
            local_40;
        local_14 =
            (local_44 + local_34 >> 0x17 | (local_44 + local_34) * 0x200) ^
            local_14;
        local_28 =
            (local_18 + local_48 >> 0x17 | (local_18 + local_48) * 0x200) ^
            local_28;
        local_3c =
            (local_2c + local_1c >> 0x13 | (local_2c + local_1c) * 0x2000) ^
            local_3c;
        local_10 =
            (local_40 + local_30 >> 0x13 | (local_40 + local_30) * 0x2000) ^
            local_10;
        local_24 =
            (local_14 + local_44 >> 0x13 | (local_14 + local_44) * 0x2000) ^
            local_24;
        local_38 =
            (local_28 + local_18 >> 0x13 | (local_28 + local_18) * 0x2000) ^
            local_38;
        uVar1 = local_3c + local_2c;
        local_c = (uVar1 >> 0xe | uVar1 * 0x40000) ^ local_c;
        uVar1 = local_10 + local_40;
        local_20 = (uVar1 >> 0xe | uVar1 * 0x40000) ^ local_20;
        uVar1 = local_24 + local_14;
        local_34 = (uVar1 >> 0xe | uVar1 * 0x40000) ^ local_34;
        uVar1 = local_38 + local_28;
        local_48 = (uVar1 >> 0xe | uVar1 * 0x40000) ^ local_48;
        local_10 = (local_c + local_18 >> 0x19 | (local_c + local_18) * 0x80) ^
                   local_10;
        local_24 =
            (local_20 + local_1c >> 0x19 | (local_20 + local_1c) * 0x80) ^
            local_24;
        local_38 =
            (local_34 + local_30 >> 0x19 | (local_34 + local_30) * 0x80) ^
            local_38;
        local_3c =
            (local_48 + local_44 >> 0x19 | (local_48 + local_44) * 0x80) ^
            local_3c;
        local_14 = (local_10 + local_c >> 0x17 | (local_10 + local_c) * 0x200) ^
                   local_14;
        local_28 =
            (local_24 + local_20 >> 0x17 | (local_24 + local_20) * 0x200) ^
            local_28;
        local_2c =
            (local_38 + local_34 >> 0x17 | (local_38 + local_34) * 0x200) ^
            local_2c;
        local_40 =
            (local_3c + local_48 >> 0x17 | (local_3c + local_48) * 0x200) ^
            local_40;
        local_18 =
            (local_14 + local_10 >> 0x13 | (local_14 + local_10) * 0x2000) ^
            local_18;
        local_1c =
            (local_28 + local_24 >> 0x13 | (local_28 + local_24) * 0x2000) ^
            local_1c;
        local_30 =
            (local_2c + local_38 >> 0x13 | (local_2c + local_38) * 0x2000) ^
            local_30;
        local_44 =
            (local_40 + local_3c >> 0x13 | (local_40 + local_3c) * 0x2000) ^
            local_44;
        local_c =
            (local_18 + local_14 >> 0xe | (local_18 + local_14) * 0x40000) ^
            local_c;
        local_20 =
            (local_1c + local_28 >> 0xe | (local_1c + local_28) * 0x40000) ^
            local_20;
        local_34 =
            (local_30 + local_2c >> 0xe | (local_30 + local_2c) * 0x40000) ^
            local_34;
        local_48 =
            (local_44 + local_40 >> 0xe | (local_44 + local_40) * 0x40000) ^
            local_48;
    }
    *param_1 = *param_1 + local_c;
    param_1[1] = param_1[1] + local_10;
    param_1[2] = param_1[2] + local_14;
    param_1[3] = param_1[3] + local_18;
    param_1[4] = param_1[4] + local_1c;
    param_1[5] = param_1[5] + local_20;
    param_1[6] = param_1[6] + local_24;
    param_1[7] = param_1[7] + local_28;
    param_1[8] = param_1[8] + local_2c;
    param_1[9] = param_1[9] + local_30;
    param_1[10] = param_1[10] + local_34;
    param_1[0xb] = param_1[0xb] + local_38;
    param_1[0xc] = param_1[0xc] + local_3c;
    param_1[0xd] = param_1[0xd] + local_40;
    param_1[0xe] = param_1[0xe] + local_44;
    param_1[0xf] = param_1[0xf] + local_48;
    return;
}

void FUN_000c38ac(undefined4 param_1, int param_2, undefined4 param_3)

{
    uint uVar1;
    uint *puVar2;
    uint uVar3;
    undefined1 auStack_a8[64];
    uint local_68[16];
    int local_28;
    uint local_24;
    uint local_20;
    undefined1 *local_1c;
    uint local_18;
    uint local_14;

    local_1c = auStack_a8;
    local_20 = param_2 + 0x3fU & 0xffffffc0;
    FUN_000c2a30(param_1, auStack_a8);
    for (local_14 = 0; local_14 < 0x400; local_14 = local_14 + 2) {
        memcpy((void *)(local_20 + local_14 * 0x80), auStack_a8, 0x80);
        FUN_000c2ff4(auStack_a8, local_68);
        FUN_000c2ff4(local_68, auStack_a8);
        memcpy((void *)(local_20 + (local_14 + 1) * 0x80), auStack_a8, 0x80);
        FUN_000c2ff4(auStack_a8, local_68);
        FUN_000c2ff4(local_68, auStack_a8);
    }
    for (local_14 = 0; local_14 < 0x400; local_14 = local_14 + 2) {
        local_24 = local_68[0] & 0x3ff;
        local_28 = local_20 + local_24 * 0x80;
        for (local_18 = 0; local_18 < 0x10; local_18 = local_18 + 1) {
            uVar1 = *(uint *)((int)(local_1c + local_18 * 8) + 4);
            puVar2 = (uint *)(local_28 + local_18 * 8);
            uVar3 = puVar2[1];
            *(uint *)(local_1c + local_18 * 8) =
                *puVar2 ^ *(uint *)(local_1c + local_18 * 8);
            *(uint *)((int)(local_1c + local_18 * 8) + 4) = uVar3 ^ uVar1;
        }
        FUN_000c2ff4(auStack_a8, local_68);
        FUN_000c2ff4(local_68, auStack_a8);
        local_24 = local_68[0] & 0x3ff;
        local_28 = local_20 + local_24 * 0x80;
        for (local_18 = 0; local_18 < 0x10; local_18 = local_18 + 1) {
            uVar1 = *(uint *)((int)(local_1c + local_18 * 8) + 4);
            puVar2 = (uint *)(local_28 + local_18 * 8);
            uVar3 = puVar2[1];
            *(uint *)(local_1c + local_18 * 8) =
                *puVar2 ^ *(uint *)(local_1c + local_18 * 8);
            *(uint *)((int)(local_1c + local_18 * 8) + 4) = uVar3 ^ uVar1;
        }
        FUN_000c2ff4(auStack_a8, local_68);
        FUN_000c2ff4(local_68, auStack_a8);
    }
    FUN_000c2d68(param_1, auStack_a8, param_3);
    return;
}

void FUN_000c3b68(int param_1, int param_2)

{
    undefined4 local_c;

    for (local_c = 0; local_c < 8; local_c = local_c + 1) {
        *(uint *)(param_1 + local_c * 4) =
            *(int *)(param_2 + local_c * 4) << 0x18 |
            (*(uint *)(param_2 + local_c * 4) & 0xff00) << 8 |
            *(uint *)(param_2 + local_c * 4) >> 8 & 0xff00 |
            *(uint *)(param_2 + local_c * 4) >> 0x18;
    }
    return;
}

void scrypt_regenhash(undefined4 param_1, int param_2)

{
    undefined4 uStack_20260;
    undefined1 auStack_2025c[131580];
    undefined1 auStack_60[76];
    undefined4 local_14;
    undefined4 local_10;
    undefined4 *local_c;

    uStack_20260 = 0;
    memset(auStack_2025c, 0, 0x201fc);
    local_c = (undefined4 *)(param_2 + 0x4c);
    local_10 = param_1;
    FUN_000bf2a4(auStack_60, param_2, 0x13);
    local_14 = FUN_000bf258(*local_c);
    FUN_000c38ac(auStack_60, &uStack_20260, local_10);
    FUN_000c3b68(local_10, local_10);
    return;
}

undefined4 scrypt_test(undefined4 param_1, int param_2, undefined4 param_3)

{
    uint uVar1;
    undefined4 uVar2;
    undefined1 auStack_202a0[131612];
    undefined1 auStack_84[28];
    undefined4 local_68;
    undefined1 auStack_64[76];
    undefined4 local_18;
    undefined1 *local_10;
    uint local_c;

    local_c = FUN_000bf280(*(undefined4 *)(param_2 + 0x1c));
    FUN_000bf2a4(auStack_64, param_1, 0x13);
    local_18 = FUN_000bf258(param_3);
    local_10 = auStack_202a0;
    FUN_000c38ac(auStack_64, local_10, auStack_84);
    uVar1 = FUN_000bf258(local_68);
    if (uVar1 < 0x10000) {
        if (local_c < uVar1) {
            uVar2 = 0;
        } else {
            uVar2 = 1;
        }
    } else {
        uVar2 = 0xffffffff;
    }
    return uVar2;
}

void sha256_transf(int param_1, int param_2, int param_3)

{
    int iVar1;
    uint uVar2;
    uint uVar3;
    uint local_13c[8];
    uint local_11c[67];
    int local_10;
    int local_c;

    for (local_c = 0; local_c < param_3; local_c = local_c + 1) {
        iVar1 = param_2 + local_c * 0x40;
        for (local_10 = 0; local_10 < 0x10; local_10 = local_10 + 1) {
            local_11c[local_10] = CONCAT13(
                *(undefined1 *)(iVar1 + local_10 * 4),
                CONCAT12(*(undefined1 *)(iVar1 + local_10 * 4 + 1),
                         CONCAT11(*(undefined1 *)(iVar1 + local_10 * 4 + 2),
                                  *(undefined1 *)(iVar1 + local_10 * 4 + 3))));
        }
        for (local_10 = 0x10; local_10 < 0x40; local_10 = local_10 + 1) {
            local_11c[local_10] = ((local_11c[local_10 + -2] >> 0x11 |
                                    local_11c[local_10 + -2] << 0xf) ^
                                   (local_11c[local_10 + -2] >> 0x13 |
                                    local_11c[local_10 + -2] << 0xd) ^
                                   local_11c[local_10 + -2] >> 10) +
                                  local_11c[local_10 + -7] +
                                  (local_11c[local_10 + -0xf] >> 3 ^
                                   (local_11c[local_10 + -0xf] >> 7 |
                                    local_11c[local_10 + -0xf] << 0x19) ^
                                   (local_11c[local_10 + -0xf] >> 0x12 |
                                    local_11c[local_10 + -0xf] << 0xe)) +
                                  local_11c[local_10 + -0x10];
        }
        for (local_10 = 0; local_10 < 8; local_10 = local_10 + 1) {
            local_13c[local_10] = *(uint *)(param_1 + (local_10 + 0x22) * 4);
        }
        for (local_10 = 0; local_10 < 0x40; local_10 = local_10 + 1) {
            iVar1 =
                local_13c[7] +
                ((local_13c[4] >> 0x19 | local_13c[4] << 7) ^
                 (local_13c[4] >> 6 | local_13c[4] << 0x1a) ^
                 (local_13c[4] >> 0xb | local_13c[4] << 0x15)) +
                (local_13c[6] & ~local_13c[4] ^ local_13c[4] & local_13c[5]) +
                *(int *)(sha256_k + local_10 * 4) + local_11c[local_10];
            uVar2 = local_13c[2] ^ local_13c[1];
            uVar3 = local_13c[2] & local_13c[1];
            local_13c[7] = local_13c[6];
            local_13c[6] = local_13c[5];
            local_13c[5] = local_13c[4];
            local_13c[4] = local_13c[3] + iVar1;
            local_13c[3] = local_13c[2];
            local_13c[2] = local_13c[1];
            local_13c[1] = local_13c[0];
            local_13c[0] = iVar1 +
                           ((local_13c[0] >> 2 | local_13c[0] << 0x1e) ^
                            (local_13c[0] >> 0xd | local_13c[0] << 0x13) ^
                            (local_13c[0] >> 0x16 | local_13c[0] << 10)) +
                           (uVar3 ^ local_13c[0] & uVar2);
        }
        for (local_10 = 0; local_10 < 8; local_10 = local_10 + 1) {
            *(uint *)(param_1 + (local_10 + 0x22) * 4) =
                *(int *)(param_1 + (local_10 + 0x22) * 4) + local_13c[local_10];
        }
    }
    return;
}

void sha256(undefined4 param_1, undefined4 param_2, undefined4 param_3)

{
    undefined1 auStack_b0[168];

    sha256_init(auStack_b0);
    sha256_update(auStack_b0, param_1, param_2);
    sha256_final(auStack_b0, param_3);
    return;
}

void sha256_init(undefined4 *param_1)

{
    int local_c;

    for (local_c = 0; local_c < 8; local_c = local_c + 1) {
        param_1[local_c + 0x22] = *(undefined4 *)(sha256_h0 + local_c * 4);
    }
    param_1[1] = 0;
    *param_1 = 0;
    return;
}

void sha256_update(int *param_1, void *param_2, uint param_3)

{
    uint uVar1;
    size_t __n;
    uint __n_00;

    __n = 0x40 - param_1[1];
    if (param_3 <= __n) {
        __n = param_3;
    }
    memcpy((void *)((int)param_1 + param_1[1] + 8), param_2, __n);
    if (param_1[1] + param_3 < 0x40) {
        param_1[1] = param_1[1] + param_3;
    } else {
        uVar1 = param_3 - __n >> 6;
        sha256_transf(param_1, param_1 + 2, 1);
        sha256_transf(param_1, (int)param_2 + __n, uVar1);
        __n_00 = param_3 - __n & 0x3f;
        memcpy(param_1 + 2, (void *)((int)param_2 + __n + uVar1 * 0x40),
               __n_00);
        param_1[1] = __n_00;
        *param_1 = *param_1 + (uVar1 + 1) * 0x40;
    }
    return;
}

void sha256_final(int *param_1, int param_2)

{
    int iVar1;
    int iVar2;
    int iVar3;
    int local_c;

    if ((param_1[1] & 0x3fU) < 0x38) {
        iVar3 = 1;
    } else {
        iVar3 = 2;
    }
    iVar1 = (*param_1 + param_1[1]) * 8;
    iVar2 = iVar3 * 0x40;
    memset((void *)((int)param_1 + param_1[1] + 8), 0, iVar2 - param_1[1]);
    *(undefined1 *)((int)param_1 + param_1[1] + 8) = 0x80;
    *(char *)((int)param_1 + iVar2 + 7) = (char)iVar1;
    *(char *)((int)param_1 + iVar2 + 6) = (char)((uint)iVar1 >> 8);
    *(char *)((int)param_1 + iVar2 + 5) = (char)((uint)iVar1 >> 0x10);
    *(char *)(param_1 + iVar3 * 0x10 + 1) = (char)((uint)iVar1 >> 0x18);
    sha256_transf(param_1, param_1 + 2, iVar3);
    for (local_c = 0; local_c < 8; local_c = local_c + 1) {
        *(char *)(param_2 + local_c * 4 + 3) = (char)param_1[local_c + 0x22];
        *(char *)(param_2 + local_c * 4 + 2) =
            (char)((uint)param_1[local_c + 0x22] >> 8);
        *(char *)(param_2 + local_c * 4 + 1) =
            (char)((uint)param_1[local_c + 0x22] >> 0x10);
        *(char *)(param_2 + local_c * 4) =
            (char)((uint)param_1[local_c + 0x22] >> 0x18);
    }
    return;
}

ushort FUN_000c468c(ushort param_1, byte param_2)

{
    return *(ushort *)(crc_itu_t_table +
                       ((uint)param_2 ^ (uint)(param_1 >> 8)) * 2) ^
           param_1 << 8;
}

undefined2 BM_CRC16(undefined1 *param_1, int param_2)

{
    int local_18;
    undefined1 *local_14;
    undefined2 local_a;

    local_a = 0xffff;
    local_18 = param_2;
    local_14 = param_1;
    while (local_18 != 0) {
        local_a = FUN_000c468c(local_a, *local_14);
        local_18 = local_18 + -1;
        local_14 = local_14 + 1;
    }
    return local_a;
}

undefined2 BM_CRC16_WITH_KEY(undefined1 *param_1, int param_2,
                             undefined2 param_3)

{
    int local_18;
    undefined1 *local_14;
    undefined2 local_a;

    local_18 = param_2;
    local_14 = param_1;
    local_a = param_3;
    while (local_18 != 0) {
        local_a = FUN_000c468c(local_a, *local_14);
        local_18 = local_18 + -1;
        local_14 = local_14 + 1;
    }
    return local_a;
}

undefined4 BM_CRC8(void)

{
    return 0;
}

byte BM_CRC5(byte *param_1, uint param_2)

{
    byte bVar1;
    bool bVar2;
    byte *local_2c;
    undefined4 local_24;
    undefined4 local_1c;
    byte local_18;
    byte local_15;
    int local_14;
    uint local_10;
    uint local_c;

    local_1c = 0x1010101;
    local_18 = 1;
    local_10 = 0x80;
    local_14 = 0;
    local_c = 0;
    local_2c = param_1;
    while (true) {
        bVar1 = local_1c._3_1_;
        if (param_2 <= local_c)
            break;
        bVar2 = (local_10 & *local_2c) != 0;
        local_24 =
            CONCAT13(local_1c._2_1_,
                     CONCAT12(bVar2 ^ local_18 ^ local_1c._1_1_,
                              CONCAT11((char)local_1c, bVar2 ^ local_18)));
        local_10 = local_10 >> 1;
        local_14 = local_14 + 1;
        if (local_14 == 8) {
            local_10 = 0x80;
            local_14 = 0;
            local_2c = local_2c + 1;
        }
        local_1c = local_24;
        local_18 = bVar1;
        local_c = local_c + 1;
    }
    local_15 = 0;
    if (local_18 != 0) {
        local_15 = 0x10;
    }
    if (local_1c._3_1_ != 0) {
        local_15 = local_15 | 8;
    }
    if (local_1c._2_1_ != '\0') {
        local_15 = local_15 | 4;
    }
    if (local_1c._1_1_ != 0) {
        local_15 = local_15 | 2;
    }
    if ((char)local_1c != '\0') {
        local_15 = local_15 | 1;
    }
    return local_15;
}

undefined2 POWER_CRC16(byte *param_1, short param_2)

{
    short local_16;
    byte *local_14;
    undefined2 local_a;

    local_a = 0xffff;
    local_16 = param_2;
    local_14 = param_1;
    while (local_16 != 0) {
        local_a = CONCAT11(
            (&chCRCLTalbe)[(ushort)((byte)local_a ^ *local_14)],
            local_a._1_1_ ^ chCRCHTalbe[(ushort)((byte)local_a ^ *local_14)]);
        local_16 = local_16 + -1;
        local_14 = local_14 + 1;
    }
    return local_a;
}

uint FUN_000c4ad8(byte *param_1)

{
    byte *local_14;
    uint local_c;

    local_c = 0x1505;
    for (local_14 = param_1; *local_14 != 0; local_14 = local_14 + 1) {
        local_c = (uint)*local_14 ^ local_c * 0x21;
    }
    return local_c;
}

undefined4 *FUN_000c4b40(char *param_1, void *param_2, size_t param_3)

{
    size_t sVar1;
    undefined4 *puVar2;
    undefined4 uVar3;
    int iVar4;

    sVar1 = strlen(param_1);
    sVar1 = sVar1 + 1;
    iVar4 = (-sVar1 & 3) + sVar1;
    puVar2 = (undefined4 *)malloc(iVar4 + param_3 + 0xc);
    if (puVar2 == (undefined4 *)0x0) {
        puVar2 = (undefined4 *)0x0;
    } else {
        memcpy(puVar2 + 3, param_1, sVar1);
        uVar3 = FUN_000c4ad8(param_1);
        *puVar2 = uVar3;
        puVar2[1] = (int)puVar2 + iVar4 + 0xc;
        memcpy((void *)puVar2[1], param_2, param_3);
    }
    return puVar2;
}

uint FUN_000c4c24(int param_1, uint param_2)

{
    return param_2 & *(int *)(param_1 + 4) - 1U;
}

void FUN_000c4c5c(int *param_1, undefined4 *param_2)

{
    int iVar1;

    iVar1 = FUN_000c4c24(param_1, *param_2);
    param_2[2] = *(undefined4 *)(*param_1 + iVar1 * 4);
    *(undefined4 **)(*param_1 + iVar1 * 4) = param_2;
    return;
}

undefined4 FUN_000c4cd0(int *param_1, int param_2)

{
    void *pvVar1;
    int iVar2;
    int iVar3;
    undefined4 uVar4;
    int local_14;
    int local_10;
    int local_c;

    local_c = 0;
    local_14 = param_1[1];
    while (iVar2 = local_14 + -1, local_14 != 0) {
        local_10 = *(int *)(*param_1 + iVar2 * 4);
        while (local_14 = iVar2, local_10 != 0) {
            iVar3 = *(int *)(local_10 + 8);
            *(int *)(local_10 + 8) = local_c;
            local_c = local_10;
            local_10 = iVar3;
        }
    }
    pvVar1 = realloc((void *)*param_1, param_2 << 2);
    if (pvVar1 != (void *)0x0) {
        *param_1 = (int)pvVar1;
        param_1[1] = param_2;
    }
    if (*param_1 != 0) {
        memset((void *)*param_1, 0, param_1[1] << 2);
        local_10 = local_c;
        while (local_10 != 0) {
            iVar2 = *(int *)(local_10 + 8);
            FUN_000c4c5c(param_1, local_10);
            local_10 = iVar2;
        }
    }
    if (pvVar1 == (void *)0x0) {
        uVar4 = 0xffffffff;
    } else {
        uVar4 = 0;
    }
    return uVar4;
}

int *FUN_000c4e34(int *param_1, char *param_2)

{
    int iVar1;
    int iVar2;
    int iVar3;
    int *local_14;

    iVar1 = FUN_000c4ad8(param_2);
    if (param_1[1] != 0) {
        iVar3 = *param_1;
        iVar2 = FUN_000c4c24(param_1, iVar1);
        for (local_14 = (int *)(iVar3 + iVar2 * 4); *local_14 != 0;
             local_14 = (int *)(*local_14 + 8)) {
            if ((iVar1 == *(int *)*local_14) &&
                (iVar2 = strcmp((char *)(*local_14 + 0xc), param_2),
                 iVar2 == 0)) {
                return local_14;
            }
        }
    }
    return (int *)0x0;
}

void map_deinit_(int *param_1)

{
    int iVar1;
    void *pvVar2;
    int local_10;
    void *local_c;

    local_10 = param_1[1];
    while (iVar1 = local_10 + -1, local_10 != 0) {
        local_c = *(void **)(*param_1 + iVar1 * 4);
        while (local_10 = iVar1, local_c != (void *)0x0) {
            pvVar2 = *(void **)((int)local_c + 8);
            free(local_c);
            local_c = pvVar2;
        }
    }
    free((void *)*param_1);
    return;
}

undefined4 map_get_(undefined4 param_1, undefined4 param_2)

{
    int *piVar1;
    undefined4 uVar2;

    piVar1 = (int *)FUN_000c4e34(param_1, param_2);
    if (piVar1 == (int *)0x0) {
        uVar2 = 0;
    } else {
        uVar2 = *(undefined4 *)(*piVar1 + 4);
    }
    return uVar2;
}

undefined4 map_set_(int param_1, undefined4 param_2, void *param_3,
                    size_t param_4)

{
    int *piVar1;
    void *__ptr;
    int iVar2;
    undefined4 uVar3;

    piVar1 = (int *)FUN_000c4e34(param_1, param_2);
    if (piVar1 != (int *)0x0) {
        memcpy(*(void **)(*piVar1 + 4), param_3, param_4);
        return 0;
    }
    __ptr = (void *)FUN_000c4b40(param_2, param_3, param_4);
    if (__ptr == (void *)0x0) {
    LAB_000c50f4:
        if (__ptr != (void *)0x0) {
            free(__ptr);
        }
        uVar3 = 0xffffffff;
    } else {
        if (*(uint *)(param_1 + 4) <= *(uint *)(param_1 + 8)) {
            if (*(int *)(param_1 + 4) == 0) {
                iVar2 = 1;
            } else {
                iVar2 = *(int *)(param_1 + 4) << 1;
            }
            iVar2 = FUN_000c4cd0(param_1, iVar2);
            if (iVar2 != 0)
                goto LAB_000c50f4;
        }
        FUN_000c4c5c(param_1, __ptr);
        *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + 1;
        uVar3 = 0;
    }
    return uVar3;
}

void map_remove_(int param_1, undefined4 param_2)

{
    int *piVar1;
    void *__ptr;

    piVar1 = (int *)FUN_000c4e34(param_1, param_2);
    if (piVar1 != (int *)0x0) {
        __ptr = (void *)*piVar1;
        *piVar1 = *(int *)(*piVar1 + 8);
        free(__ptr);
        *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + -1;
    }
    return;
}

undefined4 *map_iter_(undefined4 *param_1)

{
    *param_1 = 0xffffffff;
    param_1[1] = 0;
    return param_1;
}

int map_next_(int *param_1, uint *param_2)

{
    uint uVar1;

    if (param_2[1] == 0)
        goto LAB_000c522c;
    param_2[1] = *(uint *)(param_2[1] + 8);
    uVar1 = param_2[1];
    while (true) {
        if (uVar1 != 0) {
            return param_2[1] + 0xc;
        }
    LAB_000c522c:
        *param_2 = *param_2 + 1;
        if ((uint)param_1[1] <= *param_2)
            break;
        param_2[1] = *(uint *)(*param_1 + *param_2 * 4);
        uVar1 = param_2[1];
    }
    return 0;
}

int statusServiceThread(int param_1)

{
    char *pcVar1;
    int iVar2;
    size_t sVar3;
    int *piVar4;
    undefined1 auStack_7054[4096];
    char local_6054[8];
    undefined2 local_604c;
    undefined1 local_604a;
    socklen_t local_6048;
    char acStack_6044[10240];
    char acStack_3844[4096];
    sockaddr sStack_2844;
    char local_2834[10240];
    undefined4 local_34;
    undefined4 local_30;
    int local_2c;
    int local_28;
    size_t local_24;
    uint local_20;
    char *local_1c;
    int local_18;
    ssize_t local_14;

    local_34 = 3;
    local_30 = 0;
    local_2c = param_1;
    memset(local_2834, 0, 0x2800);
    local_1c = local_2834;
    local_14 = -1;
    memset(acStack_3844, 0, 0x1000);
    local_24 = 0;
    local_28 = 0;
    local_18 = 0;
    local_6048 = 0;
    local_20 = 0;
    local_604a = 0;
    local_604c = 0xa0d;
    builtin_strncpy(local_6054, "\r\n\r\n", 5);
    memset(local_2834, 0, 0x2800);
    do {
        if (ExitServer == '\x01')
            goto LAB_000c567c;
        local_14 = recvfrom(local_2c, local_1c, 0x27ff - local_18, 0,
                            &sStack_2844, &local_6048);
        if (local_14 < 1) {
            close(local_2c);
            V_LOCK();
            logfmt_raw(auStack_7054, 0x1000, 0,
                       ":statusServiceThread recvfrom<=0");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/common/general/http.c",
                0x9f, "statusServiceThread", 0x13, 0x34, 0x14, auStack_7054);
            return 0;
        }
        local_18 = local_18 + local_14;
        if (0x27fe < local_18) {
            close(local_2c);
            V_LOCK();
            logfmt_raw(auStack_7054, 0x1000, 0, "BUFSIZE is too small!");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/common/general/http.c",
                0x9f, "statusServiceThread", 0x13, 0x3c, 0x14, auStack_7054);
            return 0;
        }
        local_1c = local_2834 + local_18;
        pcVar1 = strstr(local_2834, local_6054);
    } while (pcVar1 == (char *)0x0);
    V_LOCK();
    logfmt_raw(auStack_7054, 0x1000, 0, "find http request end flag!");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/common/general/http.c",
         0x9f, "statusServiceThread", 0x13, 0x43, 0x14, auStack_7054);
LAB_000c567c:
    V_LOCK();
    logfmt_raw(auStack_7054, 0x1000, 0, "get http=%s", local_2834);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/common/general/http.c",
         0x9f, "statusServiceThread", 0x13, 0x48, 0x14, auStack_7054);
    if ((((local_2834[0] == 'G') && (local_2834[1] == 'E')) &&
         (local_2834[2] == 'T')) &&
        (local_2834[3] == ' ')) {
        local_14 = setsockopt(local_2c, 1, 0x15, &local_34, 8);
        if (local_14 == 0) {
            local_14 = setsockopt(local_2c, 1, 0x14, &local_34, 8);
            if (local_14 == 0) {
                if (http_test_case == (code *)0x0) {
                    V_LOCK();
                    logfmt_raw(auStack_7054, 0x1000, 0,
                               "No 6060 test case found.");
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "common/general/http.c",
                         0x9f, "statusServiceThread", 0x13, 0x67, 0x14,
                         auStack_7054);
                } else {
                    iVar2 = (*http_test_case)(local_2834, acStack_3844, 0x1000);
                    if (iVar2 != 0) {
                        close(local_2c);
                        V_LOCK();
                        logfmt_raw(auStack_7054, 0x1000, 0,
                                   "statusServiceThread exit for Error cmd!");
                        V_UNLOCK();
                        zlog(g_zc,
                             "/workspace/jenkins/jenkins/workspace/"
                             "Antminer_L9_CVCtrl_release/build/rootfs/"
                             "buildroot/tmp/release/build/"
                             "godminer-origin_godminer-branch1/common/general/"
                             "http.c",
                             0x9f, "statusServiceThread", 0x13, 0x6c, 0x14,
                             auStack_7054);
                        return 0;
                    }
                }
                local_24 = strlen(acStack_3844);
                local_14 = 0;
                iVar2 =
                    sprintf(acStack_6044, "HTTP/1.0  200  OK%s", &local_604c);
                local_14 = local_14 + iVar2;
                iVar2 = sprintf(acStack_6044 + local_14,
                                "Server: SearchFreqServer%s", &local_604c);
                local_14 = local_14 + iVar2;
                iVar2 = sprintf(acStack_6044 + local_14,
                                "Cache-Control: no-cache%s", &local_604c);
                local_14 = local_14 + iVar2;
                iVar2 = sprintf(acStack_6044 + local_14, "Pragma: no-cache%s",
                                &local_604c);
                local_14 = local_14 + iVar2;
                iVar2 = sprintf(acStack_6044 + local_14,
                                "Content-Type: text/plain%s", &local_604c);
                local_14 = local_14 + iVar2;
                iVar2 = sprintf(acStack_6044 + local_14, "Content-Length: %d%s",
                                local_24, &local_604c);
                local_14 = local_14 + iVar2;
                iVar2 = sprintf(acStack_6044 + local_14,
                                "Connection: Keep-Alive%s", local_6054);
                local_14 = local_14 + iVar2;
                V_LOCK();
                logfmt_raw(auStack_7054, 0x1000, 0, "send http response...");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/common/"
                     "general/http.c",
                     0x9f, "statusServiceThread", 0x13, 0x7b, 0x14,
                     auStack_7054);
                while (ExitServer != '\x01') {
                    local_20 = 0;
                    do {
                        pcVar1 = acStack_6044 + local_20;
                        sVar3 = strlen(acStack_6044);
                        local_14 =
                            send(local_2c, pcVar1, sVar3 - local_20, 0x4000);
                        if ((local_14 == -1) &&
                            (piVar4 = __errno_location(), *piVar4 == 0xb)) {
                            V_LOCK();
                            logfmt_raw(auStack_7054, 0x1000, 0,
                                       "statusServiceThread send http timeout, "
                                       "try again...");
                            V_UNLOCK();
                            zlog(g_zc,
                                 "/workspace/jenkins/jenkins/workspace/"
                                 "Antminer_L9_CVCtrl_release/build/rootfs/"
                                 "buildroot/tmp/release/build/"
                                 "godminer-origin_godminer-branch1/common/"
                                 "general/http.c",
                                 0x9f, "statusServiceThread", 0x13, 0x84, 0x14,
                                 auStack_7054);
                            usleep(100000);
                        } else {
                            if (local_14 < 1) {
                                close(local_2c);
                                V_LOCK();
                                logfmt_raw(auStack_7054, 0x1000, 0,
                                           "statusServiceThread send http "
                                           "response error");
                                V_UNLOCK();
                                zlog(g_zc,
                                     "/workspace/jenkins/jenkins/workspace/"
                                     "Antminer_L9_CVCtrl_release/build/rootfs/"
                                     "buildroot/tmp/release/build/"
                                     "godminer-origin_godminer-branch1/common/"
                                     "general/http.c",
                                     0x9f, "statusServiceThread", 0x13, 0x8b,
                                     0x14, auStack_7054);
                                return 0;
                            }
                            local_20 = local_20 + local_14;
                        }
                        sVar3 = strlen(acStack_6044);
                    } while ((local_20 < sVar3) && (ExitServer != '\x01'));
                    sVar3 = strlen(acStack_6044);
                    if ((sVar3 <= local_20) || (ExitServer != '\0'))
                        break;
                }
                V_LOCK();
                logfmt_raw(auStack_7054, 0x1000, 0, "send http data...");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/common/"
                     "general/http.c",
                     0x9f, "statusServiceThread", 0x13, 0x99, 0x14,
                     auStack_7054);
                local_20 = 0;
                while (true) {
                    local_14 = send(local_2c, acStack_3844 + local_20,
                                    local_24 - local_20, 0);
                    V_LOCK();
                    logfmt_raw(auStack_7054, 0x1000, 0, "send http data ret=%d",
                               local_14);
                    V_UNLOCK();
                    zlog(g_zc,
                         "/workspace/jenkins/jenkins/workspace/"
                         "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/"
                         "tmp/release/build/godminer-origin_godminer-branch1/"
                         "common/general/http.c",
                         0x9f, "statusServiceThread", 0x13, 0x9f, 0x14,
                         auStack_7054);
                    if (local_14 < 1)
                        break;
                    local_20 = local_20 + local_14;
                    if ((((int)local_24 <= (int)local_20) || (local_28 != 0)) ||
                        (ExitServer == '\x01'))
                        goto LAB_000c610c;
                }
                local_28 = 1;
                V_LOCK();
                logfmt_raw(auStack_7054, 0x1000, 0,
                           "statusServiceThread send http data error");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/common/"
                     "general/http.c",
                     0x9f, "statusServiceThread", 0x13, 0xa3, 0x14,
                     auStack_7054);
            LAB_000c610c:
                V_LOCK();
                logfmt_raw(auStack_7054, 0x1000, 0, "one client disconnected!");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/common/"
                     "general/http.c",
                     0x9f, "statusServiceThread", 0x13, 0xad, 0x14,
                     auStack_7054);
                close(local_2c);
            } else {
                close(local_2c);
                V_LOCK();
                logfmt_raw(auStack_7054, 0x1000, 0,
                           "setsockopt SO_RCVTIMEO failed");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/common/"
                     "general/http.c",
                     0x9f, "statusServiceThread", 0x13, 0x5f, 0x14,
                     auStack_7054);
                local_20 = 0;
            }
        } else {
            close(local_2c);
            V_LOCK();
            logfmt_raw(auStack_7054, 0x1000, 0,
                       "setsockopt SO_SNDTIMEO failed");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/common/general/http.c",
                0x9f, "statusServiceThread", 0x13, 0x57, 0x14, auStack_7054);
            local_20 = 0;
        }
    } else {
        close(local_2c);
        V_LOCK();
        logfmt_raw(auStack_7054, 0x1000, 0,
                   "statusServiceThread not support http command");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/common/general/http.c",
             0x9f, "statusServiceThread", 0x13, 0x4f, 0x14, auStack_7054);
        local_20 = 0;
    }
    return local_20;
}

undefined4 httpListenThread(void)

{
    int iVar1;
    undefined1 auStack_1034[4096];
    socklen_t local_34;
    sockaddr sStack_30;
    sockaddr local_20;
    undefined4 local_10;
    int local_c;

    local_10 = 0;
    local_c = -1;
    do {
        listen_sockfd = socket(2, 1, 6);
        if (listen_sockfd < 0) {
            V_LOCK();
            logfmt_raw(auStack_1034, 0x1000, 0,
                       "socket creating failed, try again after 10s...");
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/common/general/http.c",
                0x9f, "httpListenThread", 0x10, 0xc6, 0x50, auStack_1034);
            sleep(10);
        } else {
            memset(&local_20, 0, 0x10);
            local_20.sa_family = 2;
            local_20.sa_data._2_4_ = htonl(0);
            local_20.sa_data._0_2_ = htons(0x17ac);
            iVar1 = bind(listen_sockfd, &local_20, 0x10);
            if (iVar1 < 0) {
                V_LOCK();
                logfmt_raw(auStack_1034, 0x1000, 0,
                           "http port bind failed! try again after 10s...");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/common/"
                     "general/http.c",
                     0x9f, "httpListenThread", 0x10, 0xd3, 0x50, auStack_1034);
                close(listen_sockfd);
                listen_sockfd = -1;
                sleep(10);
            } else {
                iVar1 = listen(listen_sockfd, 100);
                if (-1 < iVar1)
                    break;
                V_LOCK();
                logfmt_raw(auStack_1034, 0x1000, 0,
                           "http listen failed! try again after 10s...");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/common/"
                     "general/http.c",
                     0x9f, "httpListenThread", 0x10, 0xde, 0x50, auStack_1034);
                close(listen_sockfd);
                listen_sockfd = -1;
                sleep(10);
            }
        }
    } while (ExitServer != '\x01');
    V_LOCK();
    logfmt_raw(auStack_1034, 0x1000, 0, "start listen on 6060 ...");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/common/general/http.c",
         0x9f, "httpListenThread", 0x10, 0xeb, 0x3c, auStack_1034);
    do {
        if (ExitServer == '\x01') {
        LAB_000c6628:
            close(listen_sockfd);
            listen_sockfd = 0xffffffff;
            return local_10;
        }
        local_c = -1;
        while ((local_c == -1 && (ExitServer != '\x01'))) {
            usleep(10000);
            local_34 = 0x10;
            local_c = accept(listen_sockfd, &sStack_30, &local_34);
        }
        if (ExitServer != '\0') {
            if (local_c != -1) {
                close(local_c);
                local_c = -1;
            }
            goto LAB_000c6628;
        }
        V_LOCK();
        logfmt_raw(auStack_1034, 0x1000, 0, "one client connected sock=%d",
                   local_c);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/common/general/http.c",
             0x9f, "httpListenThread", 0x10, 0x101, 0x14, auStack_1034);
        statusServiceThread(local_c);
    } while (true);
}

void start_http_thread(void)

{
    undefined1 auStack_1038[4096];
    pthread_attr_t pStack_38;
    pthread_t local_14;
    int local_10;
    undefined4 local_c;

    V_LOCK();
    logfmt_raw(auStack_1038, 0x1000, 0, "start the http thread.");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/common/general/http.c",
         0x9f, "start_http_thread", 0x11, 0x111, 0x3c, auStack_1038);
    local_10 = pthread_attr_init(&pStack_38);
    local_c = 0x200000;
    local_10 = pthread_attr_setstacksize(&pStack_38, 0x200000);
    local_10 =
        pthread_create(&local_14, &pStack_38, httpListenThread, (void *)0x0);
    pthread_detach(local_14);
    V_LOCK();
    logfmt_raw(auStack_1038, 0x1000, 0, "httpListenThread start ret=%d",
               local_10);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/common/general/http.c",
         0x9f, "start_http_thread", 0x11, 0x118, 0x3c, auStack_1038);
    return;
}

undefined4 log_init(void)

{
    int iVar1;
    undefined4 uVar2;

    if (opt_zlog_conf_file == (char *)0x0) {
        opt_zlog_conf_file = strdup("/etc/zlog.conf");
    }
    iVar1 = zlog_init(opt_zlog_conf_file);
    if (iVar1 == 0) {
        g_zc = zlog_get_category("miner_zc");
        if (g_zc == 0) {
            puts("zlog get miner_zc category fail");
            zlog_fini();
            uVar2 = 0xfffffffe;
        } else {
            g_temp_zc = zlog_get_category("miner_temp_zc");
            if (g_temp_zc == 0) {
                puts("zlog get miner_temp_zc category fail");
                zlog_fini();
                uVar2 = 0xfffffffd;
            } else {
                g_fan_zc = zlog_get_category("miner_fan_zc");
                if (g_fan_zc == 0) {
                    puts("zlog get miner_fan_zc category fail");
                    zlog_fini();
                    uVar2 = 0xfffffffd;
                } else {
                    g_hash_zc = zlog_get_category("miner_hash_zc");
                    if (g_hash_zc == 0) {
                        puts("zlog get miner_hash_zc category fail");
                        zlog_fini();
                        uVar2 = 0xfffffffc;
                    } else {
                        g_droa_zc = zlog_get_category("miner_droa");
                        if (g_droa_zc == 0) {
                            puts("zlog get miner_droa category fail");
                            zlog_fini();
                            uVar2 = 0xfffffffb;
                        } else {
                            puts("zlog init OK!");
                            uVar2 = 0;
                        }
                    }
                }
            }
        }
    } else {
        puts("zlog init failed");
        uVar2 = 0xffffffff;
    }
    return uVar2;
}

undefined4 log_uninit(void)

{
    if ((((g_zc != 0) || (g_temp_zc != 0)) || (g_fan_zc != 0)) ||
        ((g_hash_zc != 0 || (g_droa_zc != 0)))) {
        zlog_fini();
        g_droa_zc = 0;
        g_hash_zc = 0;
        g_temp_zc = 0;
        g_zc = 0;
    }
    puts("zlog uninit!");
    return 0;
}

undefined4 log_reload(void)

{
    if ((((g_zc != 0) && (g_temp_zc != 0)) && (g_fan_zc != 0)) &&
        ((g_hash_zc != 0 && (g_droa_zc != 0)))) {
        zlog_reload(opt_zlog_conf_file);
        puts("zlog reload!");
    }
    return 0;
}

void log_droa(undefined4 param_1)

{
    if (DAT_0016096c == 0) {
        DAT_0016096c = zlog_get_category(PTR_s_miner_droa_0015104c);
    }
    zlog(DAT_0016096c,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/common/general/log/log.c",
         0xa2, "log_droa", 8, 0x6e, 0x28, &DAT_0013c3a0, param_1);
    return;
}

uint my_system(char *param_1)

{
    int *piVar1;
    char *pcVar2;
    undefined1 auStack_1410[4096];
    char acStack_410[1024];
    FILE *local_10;
    uint local_c;

    if (param_1 == (char *)0x0) {
        V_LOCK();
        logfmt_raw(auStack_1410, 0x1000, 0, "cmd is NULL!");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/common/general/log/log.c",
             0xa2, "my_system", 9, 0x99, 0x28, auStack_1410);
        local_c = 0xffffffff;
    } else {
        local_10 = popen(param_1, "r");
        if (local_10 == (FILE *)0x0) {
            V_LOCK();
            piVar1 = __errno_location();
            pcVar2 = strerror(*piVar1);
            logfmt_raw(auStack_1410, 0x1000, 0, "popen error: %s", pcVar2);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/common/"
                 "general/log/log.c",
                 0xa2, "my_system", 9, 0x9e, 0x28, auStack_1410);
            local_c = 0xffffffff;
        } else {
            do {
                pcVar2 = fgets(acStack_410, 0x400, local_10);
            } while (pcVar2 != (char *)0x0);
            local_c = pclose(local_10);
            if (local_c == 0xffffffff) {
                V_LOCK();
                logfmt_raw(auStack_1410, 0x1000, 0,
                           "close popen file pointer fp error!");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/common/"
                     "general/log/log.c",
                     0xa2, "my_system", 9, 0xa9, 0x28, auStack_1410);
            } else if (local_c != 0) {
                V_LOCK();
                logfmt_raw(auStack_1410, 0x1000, 0, "pclose res is :%d",
                           (local_c & 0x7f) == 0);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/common/"
                     "general/log/log.c",
                     0xa2, "my_system", 9, 0xb2, 0x28, auStack_1410);
                local_c = (int)local_c >> 8 & 0xff;
            }
        }
    }
    return local_c;
}

int FUN_000c6ec4(int param_1, undefined4 param_2, undefined4 param_3,
                 undefined4 param_4)

{
    undefined1 auStack_200c[4096];
    char acStack_100c[4096];
    uint local_c;

    local_c = snprintf(acStack_100c, 0x1000,
                       "/usr/bin/updatename.sh %s %s %s %s %s %s",
                       *(undefined4 *)(param_1 + 8), param_1 + 0x2a,
                       param_1 + 0x48, param_2, param_3, param_4);
    if ((local_c == 0xffffffff) || (0xfff < local_c)) {
        V_LOCK();
        logfmt_raw(auStack_200c, 0x1000, 0, "too large command LOGUPDATENAME");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/common/general/log/log.c",
             0xa2, "_log_update_name", 0x10, 0xc0, 0x28, auStack_200c);
        local_c = -1;
    } else {
        V_LOCK();
        logfmt_raw(auStack_200c, 0x1000, 0, "_log_update_name");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/common/general/log/log.c",
             0xa2, "_log_update_name", 0x10, 0xc3, 0x14, auStack_200c);
        local_c = my_system(acStack_100c);
        if (local_c != 0) {
            V_LOCK();
            logfmt_raw(auStack_200c, 0x1000, 0,
                       "my_system returned failed %d on LOGUPDATENAME",
                       local_c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/common/"
                 "general/log/log.c",
                 0xa2, "_log_update_name", 0x10, 199, 0x28, auStack_200c);
        }
    }
    return local_c;
}

int FUN_000c7148(undefined4 *param_1)

{
    undefined1 auStack_2018[4096];
    char acStack_1018[4096];
    undefined4 local_18;
    uint local_14;

    local_18 = 0;
    local_14 = snprintf(acStack_1018, 0x1000, "/usr/bin/checksize.sh %d %s", 0,
                        param_1[2]);
    if ((local_14 == 0xffffffff) || (0xfff < local_14)) {
        V_LOCK();
        logfmt_raw(auStack_2018, 0x1000, 0, "too large command LOGCHECKSIZE");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/common/general/log/log.c",
             0xa2, "log_rotate", 10, 0xd6, 0x28, auStack_2018);
        local_14 = -1;
    } else {
        local_14 = my_system(acStack_1018);
        if (local_14 != 0) {
            V_LOCK();
            logfmt_raw(auStack_2018, 0x1000, 0,
                       "my_system returned failed %d on LOGCHECKSIZE",
                       local_14);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/common/"
                 "general/log/log.c",
                 0xa2, "log_rotate", 10, 0xdc, 0x28, auStack_2018);
        }
        local_14 = snprintf(acStack_1018, 0x1000,
                            "/usr/bin/rotate.sh %d %d %s %s %s %s %s", local_18,
                            *param_1, param_1[2], param_1[1],
                            (int)param_1 + 0x2a, param_1 + 0x12, param_1[0x17]);
        if ((local_14 == 0xffffffff) || (0xfff < local_14)) {
            V_LOCK();
            logfmt_raw(auStack_2018, 0x1000, 0, "too large command LOGROTATE");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/common/"
                 "general/log/log.c",
                 0xa2, "log_rotate", 10, 0xe2, 0x28, auStack_2018);
            local_14 = -1;
        } else {
            local_14 = my_system(acStack_1018);
            if (local_14 != 0) {
                V_LOCK();
                logfmt_raw(auStack_2018, 0x1000, 0,
                           "my_system returned failed %d on LOGROTATE",
                           local_14);
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/common/"
                     "general/log/log.c",
                     0xa2, "log_rotate", 10, 0xe8, 0x28, auStack_2018);
            }
        }
    }
    return local_14;
}

int FUN_000c74b8(int param_1, undefined4 param_2, undefined4 param_3)

{
    undefined1 auStack_200c[4096];
    char acStack_100c[4096];
    uint local_c;

    local_c =
        snprintf(acStack_100c, 0x1000, "/usr/bin/symbollink.sh %s %s %s %s %s",
                 *(undefined4 *)(param_1 + 8), param_1 + 0x2a, param_1 + 0x48,
                 param_2, param_3);
    if ((local_c == 0xffffffff) || (0xfff < local_c)) {
        V_LOCK();
        logfmt_raw(auStack_200c, 0x1000, 0,
                   "too large command LOG_SYMBOL_LINK");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/common/general/log/log.c",
             0xa2, "_log_generate_symbol_link", 0x19, 0xf6, 0x28, auStack_200c);
        local_c = -1;
    } else {
        local_c = my_system(acStack_100c);
        if (local_c != 0) {
            V_LOCK();
            logfmt_raw(auStack_200c, 0x1000, 0,
                       "my_system returned failed %d on LOG_SYMBOL_LINK",
                       local_c);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/common/"
                 "general/log/log.c",
                 0xa2, "_log_generate_symbol_link", 0x19, 0xfd, 0x28,
                 auStack_200c);
        }
    }
    return local_c;
}

void FUN_000c76ac(undefined4 *param_1)

{
    int iVar1;
    uint uVar2;
    size_t __n;
    char *__s1;
    char local_2058[4096];
    undefined1 auStack_1058[4096];
    char acStack_58[20];
    char acStack_44[32];
    int local_24;
    uint local_20;
    tm *local_1c;
    undefined4 *local_18;
    uint local_14;

    local_14 = 0;
    local_18 = param_1;
    if (param_1 == (undefined4 *)0x0) {
        builtin_strncpy(local_2058, "input arg wrong\n", 0x10);
        local_2058[0x10] = 0;
        V_LOCK();
        logfmt_raw(auStack_1058, 0x1000, 0, local_2058, 0);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/common/general/log/log.c",
             0xa2, "log_thread_routine", 0x12, 0x110, 0x78, auStack_1058);
    }
    *local_18 = 0;
    local_18[0x17] = "cglog_sync";
    do {
        local_14 = local_14 + 1;
        if (local_14 % 0x1e == 0) {
            time(&local_24);
            local_1c = localtime(&local_24);
            strftime(acStack_44, 0xf, "%Y-%m/%d", local_1c);
            strftime(acStack_58, 10, "%H-%M-%S", local_1c);
            iVar1 = strncmp((char *)((int)local_18 + 0x2a), "1970", 4);
            if ((iVar1 == 0) && (0x1e13380 < local_24)) {
                local_20 = FUN_000c6ec4(local_18, "cglog_init", acStack_44,
                                        acStack_58);
                uVar2 = FUN_000c6ec4(local_18, "cglog_sync", acStack_44,
                                     acStack_58);
                local_20 = local_20 | uVar2;
                if (local_20 == 0) {
                    strncpy((char *)((int)local_18 + 0x2a), acStack_44, 0x1e);
                    strncpy((char *)(local_18 + 0x12), acStack_58, 0x14);
                    strcpy((char *)(local_18 + 3),
                           (char *)((int)local_18 + 0x2a));
                }
            }
            if (*(char *)(local_18 + 3) == '\0') {
                strcpy((char *)(local_18 + 3), (char *)((int)local_18 + 0x2a));
            } else {
                __s1 = (char *)(local_18 + 3);
                __n = strlen(acStack_44);
                iVar1 = strncmp(__s1, acStack_44, __n);
                if (iVar1 != 0) {
                    local_20 = FUN_000c74b8(local_18, "cglog_sync", acStack_44);
                    if (local_20 == 0) {
                        strncpy((char *)(local_18 + 3), acStack_44, 0x1e);
                    }
                }
            }
            FUN_000c7148(local_18);
        }
        sleep(1);
    } while (true);
}

void cal_log_init(void)

{
    int iVar1;
    char local_2018[4096];
    undefined1 auStack_1018[4096];
    pthread_t local_18;
    time_t tStack_14;
    tm *local_10;
    undefined4 *local_c;

    local_c = &DAT_0016090c;
    if (DAT_00160936 == '\0') {
        time(&tStack_14);
        local_10 = localtime(&tStack_14);
        strftime((char *)((int)local_c + 0x2a), 0xf, "%Y-%m/%d", local_10);
        strftime((char *)(local_c + 0x12), 10, "%H-%M-%S", local_10);
        *local_c = 1;
        local_c[1] = "/var/log";
        local_c[2] = "nvdata";
        local_c[0x17] = "cglog_init";
        FUN_000c7148(local_c);
        iVar1 = pthread_create(&local_18, (pthread_attr_t *)0x0, FUN_000c76ac,
                               local_c);
        if (iVar1 != 0) {
            builtin_strncpy(local_2018, "Failed to create log thread", 0x1c);
            V_LOCK();
            logfmt_raw(auStack_1018, 0x1000, 0, local_2018, 0);
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/common/"
                 "general/log/log.c",
                 0xa2, "cal_log_init", 0xc, 0x15f, 0x78, auStack_1018);
        }
        pthread_detach(local_18);
    }
    return;
}

void logfmt_raw(void *param_1, size_t param_2, undefined4 param_3,
                undefined4 param_4)

{
    uint uVar1;
    undefined4 uVar2;
    char *pcVar3;
    size_t sVar4;
    int iVar5;
    char *pcVar6;
    undefined4 uVar7;
    undefined4 *puVar8;
    char local_1030;
    undefined4 *local_1020;
    char acStack_101c[4096];
    char *local_1c;
    int local_18;
    int local_14;
    undefined4 local_4;

    local_14 = 0;
    local_4 = param_4;
    memset(param_1, 0, param_2);
    memset(acStack_101c, 0, 0x1000);
    local_1020 = &local_4;
    for (local_18 = 0; local_18 < DAT_00160988; local_18 = local_18 + 1) {
        puVar8 = (undefined4 *)((int)local_1020 + 7U & 0xfffffff8);
        local_1020 = puVar8 + 8;
        uVar2 = *puVar8;
        pcVar6 = (char *)puVar8[4];
        uVar7 = puVar8[5];
        switch (puVar8[2]) {
        case 0:
            pcVar3 = strchr(pcVar6, 0x20);
            if ((pcVar3 == (char *)0x0) &&
                ((iVar5 = strcmp(pcVar6, "true"),
                  iVar5 != 0 || (sVar4 = strlen(pcVar6), sVar4 != 4)))) {
                iVar5 = sprintf((char *)((int)param_1 + local_14), "%s=%s ",
                                uVar2, pcVar6);
                local_14 = local_14 + iVar5;
            } else {
                iVar5 = sprintf((char *)((int)param_1 + local_14), "%s=\"%s\" ",
                                uVar2, pcVar6);
                local_14 = local_14 + iVar5;
            }
            break;
        case 1:
            iVar5 = sprintf((char *)((int)param_1 + local_14), "%s=%lf ", uVar2,
                            uVar7, pcVar6, uVar7);
            local_14 = local_14 + iVar5;
            break;
        case 2:
            local_1030 = (char)pcVar6;
            if (local_1030 == '\0') {
                uVar1 = 0xc714;
            } else {
                uVar1 = 0xc6f0;
            }
            iVar5 = sprintf((char *)((int)param_1 + local_14), "%s=%s ", uVar2,
                            uVar1 | 0x130000);
            local_14 = local_14 + iVar5;
            break;
        case 3:
            iVar5 = sprintf((char *)((int)param_1 + local_14), "%s=%lld ",
                            uVar2, uVar7, pcVar6, uVar7);
            local_14 = local_14 + iVar5;
            break;
        default:
            goto switchD_000c7c58_default;
        }
    }
    local_1c = (char *)*local_1020;
    vsprintf(acStack_101c, local_1c, local_1020 + 1);
    pcVar6 = strchr(acStack_101c, 0x20);
    if (pcVar6 == (char *)0x0) {
        sprintf((char *)((int)param_1 + local_14), "msg=%s", acStack_101c);
    } else {
        sprintf((char *)((int)param_1 + local_14), "msg=\"%s\"", acStack_101c);
    }
    DAT_00160988 = 0;
switchD_000c7c58_default:
    return;
}

void V_LOCK(void)

{
    pthread_mutex_lock((pthread_mutex_t *)&DAT_00160970);
    return;
}

void V_UNLOCK(void)

{
    pthread_mutex_unlock((pthread_mutex_t *)&DAT_00160970);
    return;
}

undefined8 *V_STR(undefined8 *param_1, char *param_2, char *param_3)

{
    size_t sVar1;
    size_t sVar2;

    DAT_00160988 = DAT_00160988 + 1;
    sVar1 = strlen(param_2);
    sVar2 = strlen(param_3);
    *param_1 = 0;
    param_1[1] = 0;
    param_1[2] = 0;
    param_1[3] = 0;
    *(char **)param_1 = param_2;
    *(size_t *)((int)param_1 + 4) = sVar1;
    *(char **)(param_1 + 2) = param_3;
    *(size_t *)(param_1 + 3) = sVar2;
    return param_1;
}

undefined4 *V_FLOAT(undefined4 *param_1, char *param_2)

{
    size_t sVar1;
    undefined8 in_d0;
    undefined4 local_18;
    undefined4 uStack_14;

    DAT_00160988 = DAT_00160988 + 1;
    sVar1 = strlen(param_2);
    *param_1 = param_2;
    param_1[1] = sVar1;
    param_1[2] = 1;
    local_18 = (undefined4)in_d0;
    uStack_14 = (undefined4)((ulonglong)in_d0 >> 0x20);
    param_1[4] = local_18;
    param_1[5] = uStack_14;
    param_1[6] = 0;
    return param_1;
}

undefined8 *V_BOOL(undefined8 *param_1, char *param_2, undefined1 param_3)

{
    size_t sVar1;

    DAT_00160988 = DAT_00160988 + 1;
    sVar1 = strlen(param_2);
    *param_1 = 0;
    param_1[1] = 0;
    param_1[2] = 0;
    param_1[3] = 0;
    *(char **)param_1 = param_2;
    *(size_t *)((int)param_1 + 4) = sVar1;
    *(undefined4 *)(param_1 + 1) = 2;
    *(undefined1 *)(param_1 + 2) = param_3;
    return param_1;
}

undefined4 *V_INT(undefined4 *param_1, char *param_2, undefined4 param_3,
                  undefined4 param_4)

{
    size_t sVar1;

    DAT_00160988 = DAT_00160988 + 1;
    sVar1 = strlen(param_2);
    *param_1 = param_2;
    param_1[1] = sVar1;
    param_1[2] = 3;
    param_1[4] = param_3;
    param_1[5] = param_4;
    param_1[6] = 0;
    return param_1;
}

void *new_observable_subject(void)

{
    void *pvVar1;

    pvVar1 = calloc(1, 0x404);
    return pvVar1;
}

void destroy_observable_subject(void *param_1)

{
    free(param_1);
    return;
}

void subject_observe(int param_1, undefined4 param_2)

{
    *(undefined4 *)(param_1 + *(int *)(param_1 + 0x400) * 4) = param_2;
    *(int *)(param_1 + 0x400) = *(int *)(param_1 + 0x400) + 1;
    return;
}

void subject_notify_all(int param_1, undefined4 param_2)

{
    undefined4 local_c;

    for (local_c = 0; local_c < *(int *)(param_1 + 0x400);
         local_c = local_c + 1) {
        (**(code **)(param_1 + local_c * 4))(param_2);
    }
    return;
}

undefined4 FUN_000c82fc(void)

{
    int *piVar1;
    undefined4 uVar2;

    piVar1 = __errno_location();
    if ((*piVar1 == 0xb) || (piVar1 = __errno_location(), *piVar1 == 0xb)) {
        uVar2 = 1;
    } else {
        uVar2 = 0;
    }
    return uVar2;
}

undefined4 send_line(uint param_1, char *param_2)

{
    char cVar1;
    size_t sVar2;
    int iVar3;
    uint uVar4;
    undefined4 uVar5;
    uint uVar6;
    fd_set afStack_1024[32];
    timeval local_24;
    fd_set *local_1c;
    uint local_18;
    int local_14;
    size_t local_10;
    int local_c;

    local_c = 0;
    if (param_1 == 0xffffffff) {
        V_LOCK();
        logfmt_raw(afStack_1024, 0x1000, 0, "socket invalid!");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/common/general/socket.c",
             0xa1, "send_line", 9, 0xc, 0x14, afStack_1024);
        uVar5 = 0;
    } else {
        sVar2 = strlen(param_2);
        local_10 = sVar2;
        if (param_2[sVar2 - 1] != '\n') {
            local_10 = sVar2 + 1;
            param_2[sVar2] = '\n';
            param_2[local_10] = '\0';
        }
        for (; 0 < (int)local_10; local_10 = local_10 - local_14) {
            local_24.tv_sec = 0;
            local_24.tv_usec = 0;
            local_1c = afStack_1024;
            for (local_18 = 0; local_18 < 0x20; local_18 = local_18 + 1) {
                local_1c->fds_bits[local_18] = 0;
            }
            uVar4 = param_1 + 0x1f;
            if (-1 < (int)param_1) {
                uVar4 = param_1;
            }
            uVar6 = param_1 & 0x1f;
            if ((int)param_1 < 1) {
                uVar6 = -(-param_1 & 0x1f);
            }
            afStack_1024[0].fds_bits[(int)uVar4 >> 5] =
                afStack_1024[0].fds_bits[(int)uVar4 >> 5] | 1 << (uVar6 & 0xff);
            iVar3 = select(param_1 + 1, (fd_set *)0x0, afStack_1024,
                           (fd_set *)0x0, &local_24);
            if (iVar3 < 1) {
                return 0;
            }
            local_14 = send(param_1, param_2 + local_c, local_10, 0x4000);
            if (local_14 < 0) {
                cVar1 = FUN_000c82fc();
                if (cVar1 != '\x01') {
                    return 0;
                }
                local_14 = 0;
            }
            local_c = local_c + local_14;
        }
        uVar5 = 1;
    }
    return uVar5;
}

undefined4 socket_full(uint param_1, __time_t param_2)

{
    int iVar1;
    uint uVar2;
    undefined4 uVar3;
    uint uVar4;
    undefined1 auStack_1098[4096];
    fd_set fStack_98;
    timeval local_18;
    uint local_10;
    fd_set *local_c;

    if (param_1 == 0xffffffff) {
        V_LOCK();
        logfmt_raw(auStack_1098, 0x1000, 0, "socket invalid!");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/common/general/socket.c",
             0xa1, "socket_full", 0xb, 0x35, 0x14, auStack_1098, param_2);
        uVar3 = 0;
    } else {
        local_c = &fStack_98;
        for (local_10 = 0; local_10 < 0x20; local_10 = local_10 + 1) {
            fStack_98.fds_bits[local_10] = 0;
        }
        uVar2 = param_1 + 0x1f;
        if (-1 < (int)param_1) {
            uVar2 = param_1;
        }
        uVar4 = param_1 & 0x1f;
        if ((int)param_1 < 1) {
            uVar4 = -(-param_1 & 0x1f);
        }
        fStack_98.fds_bits[(int)uVar2 >> 5] =
            fStack_98.fds_bits[(int)uVar2 >> 5] | 1 << (uVar4 & 0xff);
        local_18.tv_usec = 0;
        local_18.tv_sec = param_2;
        V_LOCK();
        logfmt_raw(auStack_1098, 0x1000, 0, "socket_full before select");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/common/general/socket.c",
             0xa1, "socket_full", 0xb, 0x3d, 0x14, auStack_1098);
        iVar1 = select(param_1 + 1, &fStack_98, (fd_set *)0x0, (fd_set *)0x0,
                       &local_18);
        if (iVar1 < 1) {
            V_LOCK();
            logfmt_raw(auStack_1098, 0x1000, 0, "socket_full select false");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/common/"
                 "general/socket.c",
                 0xa1, "socket_full", 0xb, 0x42, 0x14, auStack_1098);
            uVar3 = 0;
        } else {
            V_LOCK();
            logfmt_raw(auStack_1098, 0x1000, 0, "socket_full select true");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/common/"
                 "general/socket.c",
                 0xa1, "socket_full", 0xb, 0x3f, 0x14, auStack_1098);
            uVar3 = 1;
        }
    }
    return uVar3;
}

void keep_sockalive(int param_1)

{
    undefined4 local_18;
    undefined4 local_14;
    undefined4 local_10;
    char local_9;

    local_10 = 1;
    local_14 = 0x2d;
    local_18 = 0x1e;
    local_9 = '\0';
    setsockopt(param_1, 1, 9, &local_10, 4);
    if (local_9 != '\x01') {
        fcntl(param_1, 2, 1);
    }
    setsockopt(param_1, 6, 1, &local_10, 4);
    setsockopt(param_1, 6, 6, &local_10, 4);
    setsockopt(param_1, 6, 4, &local_14, 4);
    setsockopt(param_1, 6, 5, &local_18, 4);
    return;
}

void *new_task_timer(void)

{
    void *pvVar1;

    pvVar1 = calloc(1, 0x180c);
    return pvVar1;
}

void add_new_task(int param_1, undefined4 param_2, undefined4 param_3)

{
    int iVar1;

    iVar1 = *(int *)(param_1 + 0x1800);
    *(undefined4 *)(param_1 + iVar1 * 4) = param_2;
    *(undefined4 *)(param_1 + (iVar1 + 0x100) * 4) = param_3;
    clock_gettime(1, (timespec *)(param_1 + (iVar1 + 0x80) * 0x10));
    *(int *)(param_1 + 0x1800) = *(int *)(param_1 + 0x1800) + 1;
    return;
}

byte task_timer_thread(int param_1)

{
    long lVar1;
    byte bVar2;
    int iVar3;
    int iVar4;
    uint uVar5;
    undefined8 uVar6;
    undefined1 auStack_1044[4096];
    int *local_44;
    timespec *local_40;
    int *local_3c;
    int local_38;
    uint local_34;
    int local_30;
    int local_2c;
    char *local_28;
    int local_24;
    int local_20;
    uint local_1c;

    local_28 = (char *)calloc(1, 0x40);
    snprintf(local_28, 0x40, "%.10s_%d", "task_timer_thread", 0);
    V_LOCK();
    lVar1 = syscall(0xe0);
    logfmt_raw(auStack_1044, 0x1000, 0, "%s on pid %ld", local_28, lVar1);
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/common/general/task_timer.c",
         0xa5, "task_timer_thread", 0x11, 0x2c, 0x28, auStack_1044);
    prctl(0xf, local_28);
    local_30 = 0;
    local_1c = 0;
    local_34 = 0;
    local_2c = param_1;
    while (true) {
        local_38 = *(int *)(local_2c + 0x1800);
        for (local_20 = 0; local_20 < local_38; local_20 = local_20 + 1) {
            local_3c = (int *)(local_2c + (local_20 + 0x80) * 0x10);
            clock_gettime(1, (timespec *)(local_3c + 2));
            iVar3 = local_3c[2] - *local_3c;
            uVar6 = VectorShiftLeft((longlong)iVar3, 5, 0x40, 0);
            uVar6 = VectorSub(uVar6, (longlong)iVar3, 8);
            uVar6 = VectorAdd(uVar6, uVar6, 8);
            uVar5 = (uint)uVar6;
            uVar6 = VectorAdd(CONCAT44((int)((ulonglong)uVar6 >> 0x20) * 2 +
                                           (uint)CARRY4(uVar5, uVar5),
                                       uVar5 * 2),
                              (longlong)iVar3, 8);
            uVar6 = VectorShiftLeft(uVar6, 3, 0x40, 0);
            local_30 = (local_3c[3] - local_3c[1]) / 1000000 + (int)uVar6;
            if (*(int *)(local_2c + (local_20 + 0x100) * 4) <= local_30) {
                local_40 = (timespec *)(local_2c + (local_20 + 0x80) * 0x10);
                clock_gettime(1, local_40);
                (**(code **)(local_2c + local_20 * 4))(local_30);
            }
        }
        local_1c = 0x7fffffff;
        for (local_24 = 0; local_24 < local_38; local_24 = local_24 + 1) {
            iVar3 = *(int *)(local_2c + (local_24 + 0x100) * 4);
            local_44 = (int *)(local_2c + (local_24 + 0x80) * 0x10);
            clock_gettime(1, (timespec *)(local_44 + 2));
            iVar4 = local_44[2] - *local_44;
            uVar6 = VectorShiftLeft((longlong)iVar4, 5, 0x40, 0);
            uVar6 = VectorSub(uVar6, (longlong)iVar4, 8);
            uVar6 = VectorAdd(uVar6, uVar6, 8);
            uVar5 = (uint)uVar6;
            uVar6 = VectorAdd(CONCAT44((int)((ulonglong)uVar6 >> 0x20) * 2 +
                                           (uint)CARRY4(uVar5, uVar5),
                                       uVar5 * 2),
                              (longlong)iVar4, 8);
            uVar6 = VectorShiftLeft(uVar6, 3, 0x40, 0);
            local_34 =
                iVar3 - ((local_44[3] - local_44[1]) / 1000000 + (int)uVar6);
            if ((int)local_34 < (int)local_1c) {
                local_1c = local_34;
            }
        }
        local_1c = local_1c & ~((int)local_1c >> 0x1f);
        bVar2 = *(byte *)(local_2c + 0x1804) ^ 1;
        if (bVar2 != 0)
            break;
        usleep(local_1c * 1000);
    }
    return bVar2;
}

void __exec_all_task(int param_1)

{
    int iVar1;
    int *piVar2;
    int iVar3;
    int iVar4;
    uint uVar5;
    undefined8 uVar6;
    int local_14;

    iVar1 = *(int *)(param_1 + 0x1800);
    for (local_14 = 0; local_14 < iVar1; local_14 = local_14 + 1) {
        piVar2 = (int *)(param_1 + (local_14 + 0x80) * 0x10);
        clock_gettime(1, (timespec *)(piVar2 + 2));
        iVar3 = piVar2[2] - *piVar2;
        uVar6 = VectorShiftLeft((longlong)iVar3, 5, 0x40, 0);
        uVar6 = VectorSub(uVar6, (longlong)iVar3, 8);
        uVar6 = VectorAdd(uVar6, uVar6, 8);
        uVar5 = (uint)uVar6;
        uVar6 = VectorAdd(CONCAT44((int)((ulonglong)uVar6 >> 0x20) * 2 +
                                       (uint)CARRY4(uVar5, uVar5),
                                   uVar5 * 2),
                          (longlong)iVar3, 8);
        uVar6 = VectorShiftLeft(uVar6, 3, 0x40, 0);
        iVar3 = piVar2[3];
        iVar4 = piVar2[1];
        clock_gettime(1, (timespec *)(param_1 + (local_14 + 0x80) * 0x10));
        (**(code **)(param_1 + local_14 * 4))((iVar3 - iVar4) / 1000000 +
                                              (int)uVar6);
    }
    return;
}

void start_task_timer(void *param_1)

{
    int iVar1;
    int local_c;

    *(undefined1 *)((int)param_1 + 0x1804) = 1;
    iVar1 = *(int *)((int)param_1 + 0x1800);
    for (local_c = 0; local_c < iVar1; local_c = local_c + 1) {
        clock_gettime(1, (timespec *)((int)param_1 + (local_c + 0x80) * 0x10));
    }
    pthread_create((pthread_t *)((int)param_1 + 0x1808), (pthread_attr_t *)0x0,
                   task_timer_thread, param_1);
    return;
}

void stop_task_timer(int param_1)

{
    void *pvStack_c;

    if (*(char *)(param_1 + 0x1804) != '\0') {
        *(undefined1 *)(param_1 + 0x1804) = 0;
        pthread_join(*(pthread_t *)(param_1 + 0x1808), &pvStack_c);
    }
    return;
}

void destroy_task_timer(void *param_1)

{
    if (*(char *)((int)param_1 + 0x1804) != '\0') {
        stop_task_timer(param_1);
    }
    free(param_1);
    return;
}

void force_exec_all_task(int param_1)

{
    if (*(char *)(param_1 + 0x1804) == '\0') {
        __exec_all_task(param_1);
    } else {
        stop_task_timer(param_1);
        __exec_all_task(param_1);
        start_task_timer(param_1);
    }
    return;
}

void __init_pipe_of_queue(undefined4 *param_1, undefined4 param_2,
                          undefined4 param_3)

{
    undefined4 uVar1;

    uVar1 = pipe_new(param_2, param_3);
    *param_1 = uVar1;
    uVar1 = pipe_consumer_new(*param_1);
    param_1[2] = uVar1;
    uVar1 = pipe_producer_new(*param_1);
    param_1[1] = uVar1;
    return;
}

void __deinit_pipe_of_queue(undefined4 *param_1)

{
    pipe_free(*param_1);
    pipe_consumer_free(param_1[2]);
    pipe_producer_free(param_1[1]);
    return;
}

void *queue_new(undefined4 param_1, undefined4 param_2)

{
    void *pvVar1;

    pvVar1 = calloc(1, 0x60);
    if (pvVar1 == (void *)0x0) {
        printf("calloc failed in queue_new");
        pvVar1 = (void *)0x0;
    } else {
        __init_pipe_of_queue(pvVar1, param_1, param_2);
        pthread_mutex_init((pthread_mutex_t *)((int)pvVar1 + 0x10),
                           (pthread_mutexattr_t *)0x0);
        pthread_condattr_init((pthread_condattr_t *)((int)pvVar1 + 0x58));
        pthread_condattr_setclock((pthread_condattr_t *)((int)pvVar1 + 0x58),
                                  1);
        pthread_cond_init((pthread_cond_t *)((int)pvVar1 + 0x28),
                          (pthread_condattr_t *)((int)pvVar1 + 0x58));
        *(undefined4 *)((int)pvVar1 + 0xc) = 0;
        *(undefined1 *)((int)pvVar1 + 0x5c) = 0;
    }
    return pvVar1;
}

void queue_free(void *param_1)

{
    pthread_cond_destroy((pthread_cond_t *)((int)param_1 + 0x28));
    pthread_mutex_destroy((pthread_mutex_t *)((int)param_1 + 0x10));
    __deinit_pipe_of_queue(param_1);
    free(param_1);
    return;
}

undefined1 queue_enqueue(int param_1, undefined4 param_2, int param_3)

{
    undefined1 local_9;

    local_9 = 1;
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x10));
    pipe_push(*(undefined4 *)(param_1 + 4), param_2, param_3, &local_9);
    *(int *)(param_1 + 0xc) = *(int *)(param_1 + 0xc) + param_3;
    pthread_cond_signal((pthread_cond_t *)(param_1 + 0x28));
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x10));
    return local_9;
}

void clean_up(pthread_mutex_t *param_1)

{
    pthread_mutex_unlock(param_1);
    return;
}

void queue_dequeue(int param_1, undefined4 param_2, uint param_3)

{
    uint uVar1;
    __pthread_unwind_buf_t a_Stack_1130[6];
    undefined1 auStack_1014[4096];
    int local_14;
    int local_10;
    code *local_c;

    local_c = clean_up;
    local_10 = param_1 + 0x10;
    local_14 = __sigsetjmp(a_Stack_1130, 0);
    if (local_14 != 0) {
        (*local_c)(local_10);
        __pthread_unwind_next(a_Stack_1130);
    }
    __pthread_register_cancel(a_Stack_1130);
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x10));
    do {
        if (param_3 <= *(uint *)(param_1 + 0xc)) {
            uVar1 = pipe_pop(*(undefined4 *)(param_1 + 8), param_2, param_3);
            if (param_3 != uVar1) {
                V_LOCK();
                logfmt_raw(auStack_1014, 0x1000, 0, "%s, unkown error",
                           "queue_dequeue");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/common/"
                     "general/thread_safe_queue.c",
                     0xac, "queue_dequeue", 0xd, 0x59, 100, auStack_1014);
                /* WARNING: Subroutine does not return */
                exit(-1);
            }
            *(uint *)(param_1 + 0xc) = *(int *)(param_1 + 0xc) - param_3;
        LAB_000c96f8:
            pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x10));
            __pthread_unregister_cancel(a_Stack_1130);
            return;
        }
        if (*(char *)(param_1 + 0x5c) != '\0') {
            *(undefined1 *)(param_1 + 0x5c) = 0;
            goto LAB_000c96f8;
        }
        pthread_cond_wait((pthread_cond_t *)(param_1 + 0x28),
                          (pthread_mutex_t *)(param_1 + 0x10));
    } while (true);
}

int queue_dequeue_for(int param_1, undefined4 param_2, uint param_3,
                      int *param_4)

{
    uint uVar1;
    undefined1 auStack_1018[4096];
    timespec local_18;
    int local_10;
    int local_c;

    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x10));
    clock_gettime(1, &local_18);
    local_10 = param_4[1] + local_18.tv_nsec;
    local_18.tv_sec = local_18.tv_sec + local_10 / 1000000000 + *param_4;
    local_18.tv_nsec = local_10 % 1000000000;
    local_c = 0;
    do {
        if (param_3 <= *(uint *)(param_1 + 0xc)) {
            uVar1 = pipe_pop(*(undefined4 *)(param_1 + 8), param_2, param_3);
            if (param_3 != uVar1) {
                V_LOCK();
                logfmt_raw(auStack_1018, 0x1000, 0, "%s, unkown error",
                           "queue_dequeue_for");
                V_UNLOCK();
                zlog(g_zc,
                     "/workspace/jenkins/jenkins/workspace/"
                     "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                     "release/build/godminer-origin_godminer-branch1/common/"
                     "general/thread_safe_queue.c",
                     0xac, "queue_dequeue_for", 0x11, 0x72, 100, auStack_1018);
                /* WARNING: Subroutine does not return */
                exit(-1);
            }
            *(uint *)(param_1 + 0xc) = *(int *)(param_1 + 0xc) - param_3;
            break;
        }
        local_c = pthread_cond_timedwait((pthread_cond_t *)(param_1 + 0x28),
                                         (pthread_mutex_t *)(param_1 + 0x10),
                                         &local_18);
    } while (local_c != 0x6e);
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x10));
    return local_c;
}

void queue_clear(undefined4 *param_1)

{
    size_t __size;
    int iVar1;
    undefined1 auStack_100c[4096];
    void *local_c;

    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 4));
    __size = pipe_elem_size(*param_1);
    local_c = calloc(1, __size);
    while (true) {
        if ((int)param_1[3] < 1) {
            free(local_c);
            pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 4));
            return;
        }
        iVar1 = pipe_pop(param_1[2], local_c, 1);
        if (iVar1 != 1)
            break;
        param_1[3] = param_1[3] + -1;
    }
    V_LOCK();
    logfmt_raw(auStack_100c, 0x1000, 0, "%s, unkown error", "queue_clear");
    V_UNLOCK();
    zlog(g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
         "build/rootfs/buildroot/tmp/release/build/"
         "godminer-origin_godminer-branch1/common/general/thread_safe_queue.c",
         0xac, "queue_clear", 0xb, 0x81, 100, auStack_100c);
    /* WARNING: Subroutine does not return */
    exit(-1);
}

undefined1 queue_try_dequeue(int param_1, undefined4 param_2, uint param_3)

{
    uint uVar1;
    undefined1 auStack_100c[4099];
    undefined1 local_9;

    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x10));
    local_9 = 0;
    if (*(uint *)(param_1 + 0xc) < param_3) {
        local_9 = 0;
    } else {
        uVar1 = pipe_pop(*(undefined4 *)(param_1 + 8), param_2, param_3);
        if (param_3 != uVar1) {
            V_LOCK();
            logfmt_raw(auStack_100c, 0x1000, 0, "%s, unkown error",
                       "queue_try_dequeue");
            V_UNLOCK();
            zlog(g_zc,
                 "/workspace/jenkins/jenkins/workspace/"
                 "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                 "release/build/godminer-origin_godminer-branch1/common/"
                 "general/thread_safe_queue.c",
                 0xac, "queue_try_dequeue", 0x11, 0x94, 100, auStack_100c);
            /* WARNING: Subroutine does not return */
            exit(-1);
        }
        *(uint *)(param_1 + 0xc) = *(int *)(param_1 + 0xc) - param_3;
        local_9 = 1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x10));
    return local_9;
}

undefined4 queue_element_num(int param_1)

{
    return *(undefined4 *)(param_1 + 0xc);
}

void queue_force_wakeup(int param_1)

{
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x10));
    *(undefined1 *)(param_1 + 0x5c) = 1;
    pthread_cond_signal((pthread_cond_t *)(param_1 + 0x28));
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x10));
    return;
}

void xxtea_encode(uint *param_1, uint param_2, int param_3)

{
    uint uVar1;
    uint uVar2;
    undefined1 auStack_1020[4104];
    uint local_18;
    uint local_14;
    uint local_10;
    int local_c;

    if (param_2 < 2) {
        V_LOCK();
        logfmt_raw(auStack_1020, 0x1000, 0,
                   " xxtea encode input data length <= 1");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/common/general/xxtea.c",
             0xa0, "xxtea_encode", 0xc, 0x18, 100, auStack_1020);
    } else {
        local_c = FUN_000cc2a0(0x34, param_2);
        local_c = local_c + 6;
        local_14 = 0;
        local_18 = param_1[param_2 + 0x3fffffff];
        do {
            local_14 = local_14 + 0x9e3779b9;
            uVar1 = local_14 >> 2 & 3;
            for (local_10 = 0; local_10 < param_2 - 1;
                 local_10 = local_10 + 1) {
                uVar2 = param_1[local_10 + 1];
                param_1[local_10] =
                    param_1[local_10] +
                    ((local_18 >> 5 ^ uVar2 << 2) +
                         (local_18 << 4 ^ uVar2 >> 3) ^
                     (local_14 ^ uVar2) +
                         (local_18 ^
                          *(uint *)(param_3 + (uVar1 ^ local_10 & 3) * 4)));
                local_18 = param_1[local_10];
            }
            uVar2 = *param_1;
            param_1[param_2 + 0x3fffffff] =
                param_1[param_2 + 0x3fffffff] +
                ((local_18 >> 5 ^ uVar2 << 2) + (local_18 << 4 ^ uVar2 >> 3) ^
                 (local_14 ^ uVar2) +
                     (local_18 ^
                      *(uint *)(param_3 + (uVar1 ^ local_10 & 3) * 4)));
            local_18 = param_1[param_2 + 0x3fffffff];
            local_c = local_c + -1;
        } while (local_c != 0);
    }
    return;
}

void xxtea_decode(uint *param_1, uint param_2, int param_3)

{
    uint uVar1;
    uint uVar2;
    undefined1 auStack_1020[4104];
    uint local_18;
    uint local_14;
    uint local_10;
    int local_c;

    if (param_2 < 2) {
        V_LOCK();
        logfmt_raw(auStack_1020, 0x1000, 0,
                   " xxtea decode input data length <= 1");
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/common/general/xxtea.c",
             0xa0, "xxtea_decode", 0xc, 0x35, 100, auStack_1020);
    } else {
        local_c = FUN_000cc2a0(0x34, param_2);
        local_c = local_c + 6;
        local_14 = local_c * -0x61c88647;
        local_18 = *param_1;
        do {
            uVar1 = local_14 >> 2 & 3;
            for (local_10 = param_2 - 1; local_10 != 0;
                 local_10 = local_10 - 1) {
                uVar2 = param_1[local_10 + 0x3fffffff];
                param_1[local_10] =
                    param_1[local_10] -
                    ((uVar2 >> 5 ^ local_18 << 2) +
                         (uVar2 << 4 ^ local_18 >> 3) ^
                     (local_14 ^ local_18) +
                         (uVar2 ^
                          *(uint *)(param_3 + (uVar1 ^ local_10 & 3) * 4)));
                local_18 = param_1[local_10];
            }
            uVar2 = param_1[param_2 + 0x3fffffff];
            *param_1 =
                *param_1 -
                ((local_14 ^ local_18) +
                     (uVar2 ^ *(uint *)(param_3 + uVar1 * 4)) ^
                 (uVar2 >> 5 ^ local_18 << 2) + (uVar2 << 4 ^ local_18 >> 3));
            local_18 = *param_1;
            local_14 = local_14 + 0x61c88647;
            local_c = local_c + -1;
        } while (local_c != 0);
    }
    return;
}

undefined4 data_enc(undefined4 param_1, uint param_2, char param_3,
                    byte param_4)

{
    undefined4 uVar1;
    undefined1 auStack_1008[4096];

    if (param_3 == '\x01') {
        if ((param_2 & 7) == 0) {
            xxtea_encode(param_1, param_2 >> 2,
                         &xxtea_key + (uint)param_4 * 0x10);
            uVar1 = 1;
        } else {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       " xxtea input data length %% 8 must be 0, but now is %d",
                       param_2 & 7);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/common/general/xxtea.c",
                0xa0, "data_enc", 8, 0x5d, 100, auStack_1008);
            uVar1 = 0;
        }
    } else {
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0,
                   "algorithm_type is %d, but not support it", param_3);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/common/general/xxtea.c",
             0xa0, "data_enc", 8, 100, 100, auStack_1008);
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 data_dec(undefined4 param_1, uint param_2, char param_3,
                    byte param_4)

{
    undefined4 uVar1;
    undefined1 auStack_1008[4096];

    if (param_3 == '\x01') {
        if ((param_2 & 7) == 0) {
            xxtea_decode(param_1, param_2 >> 2,
                         &xxtea_key + (uint)param_4 * 0x10);
            uVar1 = 1;
        } else {
            V_LOCK();
            logfmt_raw(auStack_1008, 0x1000, 0,
                       " xxtea input data length %% 8 must be 0, but now is %d",
                       param_2 & 7);
            V_UNLOCK();
            zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/"
                "Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/"
                "build/godminer-origin_godminer-branch1/common/general/xxtea.c",
                0xa0, "data_dec", 8, 0x70, 100, auStack_1008);
            uVar1 = 0;
        }
    } else {
        V_LOCK();
        logfmt_raw(auStack_1008, 0x1000, 0,
                   "algorithm_type is %d, but not support it", param_3);
        V_UNLOCK();
        zlog(g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/"
             "build/rootfs/buildroot/tmp/release/build/"
             "godminer-origin_godminer-branch1/common/general/xxtea.c",
             0xa0, "data_dec", 8, 0x77, 100, auStack_1008);
        uVar1 = 0;
    }
    return uVar1;
}

undefined4 FUN_000ca794(undefined4 *param_1)

{
    return *param_1;
}

undefined4 pipe_elem_size(undefined4 param_1)

{
    undefined4 uVar1;

    uVar1 = FUN_000ca794(param_1);
    return uVar1;
}

undefined4 *FUN_000ca7e4(undefined4 *param_1, int param_2)

{
    undefined4 uVar1;
    undefined4 uVar2;
    undefined4 uVar3;
    undefined4 uVar4;
    undefined4 uVar5;

    uVar5 = *(undefined4 *)(param_2 + 0xc);
    uVar4 = *(undefined4 *)(param_2 + 0x10);
    uVar3 = *(undefined4 *)(param_2 + 0x14);
    uVar2 = *(undefined4 *)(param_2 + 0x18);
    uVar1 = FUN_000ca794(param_2);
    *param_1 = uVar5;
    param_1[1] = uVar4;
    param_1[2] = uVar3;
    param_1[3] = uVar2;
    param_1[4] = uVar1;
    return param_1;
}

int FUN_000ca858(int param_1, int param_2, undefined4 param_3,
                 undefined4 param_4, int param_5)

{
    return (param_2 - param_1) - param_5;
}

bool FUN_000ca89c(undefined4 param_1, undefined4 param_2, uint param_3,
                  uint param_4)

{
    return param_4 <= param_3;
}

int FUN_000ca8ec(int param_1, int param_2, int param_3, int param_4,
                 int param_5)

{
    int iVar1;

    iVar1 = FUN_000ca89c(param_1, param_2, param_3, param_4, param_5);
    if (iVar1 == 0) {
        param_4 = param_4 - param_3;
    } else {
        param_4 = (param_4 - param_1) + (param_2 - param_3);
    }
    return param_4 - param_5;
}

uint FUN_000ca980(int param_1, uint param_2, uint param_3)

{
    if (param_3 <= param_2) {
        param_2 = param_1 + (param_2 - param_3);
    }
    return param_2;
}

uint FUN_000ca9dc(uint param_1, uint param_2, int param_3)

{
    if (param_2 < param_1) {
        param_2 = param_3 - (param_1 - param_2);
    }
    return param_2;
}

int FUN_000caa3c(void *param_1, void *param_2, size_t param_3)

{
    memcpy(param_1, param_2, param_3);
    return (int)param_1 + param_3;
}

uint FUN_000caa7c(uint param_1)

{
    uint local_14;
    uint local_c;

    if (param_1 < 0x80000000) {
        local_14 = param_1 - 1;
        for (local_c = 1; local_c < 0x20; local_c = local_c << 1) {
            local_14 = local_14 | local_14 >> (local_c & 0xff);
        }
        param_1 = local_14 + 1;
    }
    return param_1;
}

void FUN_000cab24(int param_1)

{
    undefined1 auStack_1c[20];

    if ((param_1 != 0) && (*(int *)(param_1 + 0xc) != 0)) {
        FUN_000ca7e4(auStack_1c, param_1);
    }
    return;
}

void FUN_000cab78(int param_1)

{
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x3c));
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x24));
    FUN_000cab24(param_1);
    return;
}

void FUN_000cabbc(int param_1)

{
    FUN_000cab24(param_1);
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x24));
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x3c));
    return;
}

int *pipe_new(int param_1, int param_2)

{
    size_t __size;
    void *__ptr;
    int iVar1;
    int *__s;
    size_t sVar2;

    if (param_1 == 0) {
        __s = (int *)0x0;
    } else {
        __s = (int *)malloc(0xb8);
        __size = param_1 * 0x20;
        __ptr = malloc(__size);
        sVar2 = (param_2 + 1) * param_1;
        if ((__s == (int *)0x0) || (__ptr == (void *)0x0)) {
            free(__s);
            free(__ptr);
            __s = (int *)0x0;
        } else {
            if (param_2 == 0) {
                iVar1 = -1;
            } else {
                if (sVar2 < __size) {
                    sVar2 = __size;
                }
                iVar1 = FUN_000caa7c(sVar2);
            }
            memset(__s, 0, 0xb8);
            *__s = param_1;
            __s[1] = __size;
            __s[2] = iVar1;
            __s[3] = (int)__ptr;
            __s[4] = (int)((int)__ptr + __size);
            __s[5] = (int)__ptr;
            __s[6] = (int)__ptr + param_1;
            __s[7] = 1;
            __s[8] = 1;
            pthread_mutex_init((pthread_mutex_t *)(__s + 9),
                               (pthread_mutexattr_t *)0x0);
            pthread_mutex_init((pthread_mutex_t *)(__s + 0xf),
                               (pthread_mutexattr_t *)0x0);
            pthread_cond_init((pthread_cond_t *)(__s + 0x16),
                              (pthread_condattr_t *)0x0);
            pthread_cond_init((pthread_cond_t *)(__s + 0x22),
                              (pthread_condattr_t *)0x0);
            FUN_000cab24(__s);
        }
    }
    return __s;
}

int pipe_producer_new(int param_1)

{
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x24));
    *(int *)(param_1 + 0x1c) = *(int *)(param_1 + 0x1c) + 1;
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x24));
    return param_1;
}

int pipe_consumer_new(int param_1)

{
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x3c));
    *(int *)(param_1 + 0x20) = *(int *)(param_1 + 0x20) + 1;
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x3c));
    return param_1;
}

void FUN_000cae8c(void *param_1)

{
    pthread_mutex_destroy((pthread_mutex_t *)((int)param_1 + 0x24));
    pthread_mutex_destroy((pthread_mutex_t *)((int)param_1 + 0x3c));
    pthread_cond_destroy((pthread_cond_t *)((int)param_1 + 0x58));
    pthread_cond_destroy((pthread_cond_t *)((int)param_1 + 0x88));
    free(*(void **)((int)param_1 + 0xc));
    free(param_1);
    return;
}

void pipe_free(int param_1)

{
    int iVar1;
    int iVar2;

    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x24));
    *(int *)(param_1 + 0x1c) = *(int *)(param_1 + 0x1c) + -1;
    iVar1 = *(int *)(param_1 + 0x1c);
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x24));
    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x3c));
    *(int *)(param_1 + 0x20) = *(int *)(param_1 + 0x20) + -1;
    iVar2 = *(int *)(param_1 + 0x20);
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x3c));
    if (iVar2 == 0) {
        free(*(void **)(param_1 + 0xc));
        *(undefined4 *)(param_1 + 0xc) = 0;
        if (iVar1 == 0) {
            FUN_000cae8c(param_1);
        } else {
            pthread_cond_broadcast((pthread_cond_t *)(param_1 + 0x88));
        }
    } else if (iVar1 == 0) {
        pthread_cond_broadcast((pthread_cond_t *)(param_1 + 0x58));
    }
    return;
}

void pipe_producer_free(int param_1)

{
    int iVar1;

    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x24));
    *(int *)(param_1 + 0x1c) = *(int *)(param_1 + 0x1c) + -1;
    iVar1 = *(int *)(param_1 + 0x1c);
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x24));
    if (iVar1 == 0) {
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x3c));
        iVar1 = *(int *)(param_1 + 0x20);
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x3c));
        if (iVar1 == 0) {
            FUN_000cae8c(param_1);
        } else {
            pthread_cond_broadcast((pthread_cond_t *)(param_1 + 0x58));
        }
    }
    return;
}

void pipe_consumer_free(int param_1)

{
    int iVar1;

    pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x3c));
    *(int *)(param_1 + 0x20) = *(int *)(param_1 + 0x20) + -1;
    iVar1 = *(int *)(param_1 + 0x20);
    pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x3c));
    if (iVar1 == 0) {
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x24));
        iVar1 = *(int *)(param_1 + 0x1c);
        pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 0x24));
        if (iVar1 == 0) {
            FUN_000cae8c(param_1);
        } else {
            pthread_cond_broadcast((pthread_cond_t *)(param_1 + 0x88));
        }
    }
    return;
}

undefined4 FUN_000cb204(int param_1, int param_2, int param_3, int param_4,
                        undefined4 param_5, undefined4 param_6)

{
    int iVar1;
    undefined4 uVar2;

    iVar1 = FUN_000ca89c(param_1, param_2, param_3, param_4, param_5);
    if (iVar1 == 0) {
        param_6 = FUN_000caa3c(param_6, param_3, param_4 - param_3);
    } else {
        uVar2 = FUN_000caa3c(param_6, param_3, param_2 - param_3);
        param_6 = FUN_000caa3c(uVar2, param_1, param_4 - param_1);
    }
    return param_6;
}

undefined4 FUN_000cb2c4(undefined4 param_1, int param_2, uint param_3,
                        undefined1 *param_4)

{
    undefined4 uVar1;
    uint local_3c;
    undefined4 local_2c;
    undefined4 uStack_28;
    undefined4 uStack_24;
    undefined4 uStack_20;
    undefined4 local_1c;
    void *local_18;
    int local_14;
    uint local_10;
    uint local_c;

    FUN_000cab24(param_2);
    local_c = *(uint *)(param_2 + 8);
    local_10 = *(uint *)(param_2 + 4);
    local_14 = FUN_000ca794(param_2);
    local_3c = param_3;
    if (local_c <= param_3) {
        local_3c = local_c;
    }
    if (local_10 < local_3c) {
        if ((undefined *)(local_3c + local_14) < &UNK_00100001) {
            local_18 = malloc(local_3c + local_14);
            if (local_18 == (void *)0x0) {
                *param_4 = 0;
                FUN_000ca7e4(param_1, param_2);
            } else {
                FUN_000ca7e4(&local_2c, param_2);
                uVar1 = FUN_000cb204(local_2c, uStack_28, uStack_24, uStack_20,
                                     local_1c, local_18);
                *(undefined4 *)(param_2 + 0x18) = uVar1;
                free(*(void **)(param_2 + 0xc));
                *(void **)(param_2 + 0xc) = local_18;
                *(undefined4 *)(param_2 + 0x14) =
                    *(undefined4 *)(param_2 + 0xc);
                *(uint *)(param_2 + 0x10) = (int)local_18 + local_3c + local_14;
                FUN_000cab24(param_2);
                FUN_000ca7e4(param_1, param_2);
            }
        } else {
            *param_4 = 0;
            FUN_000ca7e4(param_1, param_2);
        }
    } else {
        FUN_000ca7e4(param_1, param_2);
    }
    return param_1;
}

undefined4 *FUN_000cb478(undefined4 *param_1, int param_2, undefined4 param_3,
                         undefined4 param_4, undefined4 param_5,
                         undefined4 param_6, undefined4 param_7, int param_8,
                         undefined4 param_9)

{
    int iVar1;
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    int local_28;
    undefined4 *local_24;
    int local_20;
    uint local_1c;
    uint local_18;
    int local_14;
    undefined4 local_8;
    undefined4 uStack_4;

    local_28 = param_2;
    local_24 = param_1;
    local_8 = param_3;
    uStack_4 = param_4;
    local_14 = FUN_000ca794(param_2);
    local_18 = FUN_000ca858(local_8, uStack_4, param_5, param_6, param_7);
    iVar1 = FUN_000ca8ec(local_8, uStack_4, param_5, param_6, param_7);
    local_1c = param_8 + iVar1;
    if (local_18 < local_1c) {
        pthread_mutex_lock((pthread_mutex_t *)(local_28 + 0x24));
        FUN_000ca7e4(&local_8, local_28);
        iVar1 = FUN_000ca8ec(local_8, uStack_4, param_5, param_6, param_7);
        local_1c = param_8 + iVar1;
        local_20 = FUN_000cc2a0(local_1c, local_14);
        if (local_18 < local_1c) {
            iVar1 = FUN_000caa7c(local_20 + 1);
            FUN_000cb2c4(&local_40, local_28, local_14 * iVar1, param_9);
            local_8 = local_40;
            uStack_4 = uStack_3c;
            param_5 = uStack_38;
            param_6 = uStack_34;
            param_7 = local_30;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(local_28 + 0x24));
    }
    *local_24 = local_8;
    local_24[1] = uStack_4;
    local_24[2] = param_5;
    local_24[3] = param_6;
    local_24[4] = param_7;
    return local_24;
}

undefined4 FUN_000cb5fc(undefined4 param_1, int param_2, undefined4 param_3,
                        int param_4, undefined4 param_5, int param_6,
                        uint param_7)

{
    char cVar1;
    undefined4 uVar2;
    uint uVar3;
    int local_4;

    cVar1 = FUN_000ca89c(param_1, param_2, param_3, param_4, param_5);
    local_4 = param_4;
    if (cVar1 != '\x01') {
        uVar3 = param_7;
        if ((uint)(param_2 - param_4) <= param_7) {
            uVar3 = param_2 - param_4;
        }
        local_4 = FUN_000caa3c(param_4, param_6, uVar3);
        param_6 = param_6 + uVar3;
        param_7 = param_7 - uVar3;
    }
    if (param_7 != 0) {
        uVar2 = FUN_000ca980(param_1, local_4, param_2);
        local_4 = FUN_000caa3c(uVar2, param_6, param_7);
    }
    uVar2 = FUN_000ca980(param_1, local_4, param_2);
    return uVar2;
}

undefined4 *FUN_000cb718(undefined4 *param_1, int param_2, int *param_3)

{
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    int *local_34;
    int local_30;
    undefined4 *local_2c;
    undefined4 local_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    undefined4 uStack_18;
    undefined4 local_14;
    int local_10;
    int local_c;

    local_34 = param_3;
    local_30 = param_2;
    local_2c = param_1;
    FUN_000ca7e4(&local_24, param_2);
    local_c = FUN_000ca8ec(local_24, uStack_20, uStack_1c, uStack_18, local_14);
    local_10 = *(int *)(local_30 + 0x20);
    *local_34 = *(int *)(local_30 + 8);
    while ((local_c == *local_34 && (local_10 != 0))) {
        pthread_cond_wait((pthread_cond_t *)(local_30 + 0x88),
                          (pthread_mutex_t *)(local_30 + 0x3c));
        FUN_000ca7e4(&local_50, local_30);
        local_24 = local_50;
        uStack_20 = uStack_4c;
        uStack_1c = uStack_48;
        uStack_18 = uStack_44;
        local_14 = local_40;
        local_c =
            FUN_000ca8ec(local_50, uStack_4c, uStack_48, uStack_44, local_40);
        local_10 = *(int *)(local_30 + 0x20);
        *local_34 = *(int *)(local_30 + 8);
    }
    *local_2c = local_24;
    local_2c[1] = uStack_20;
    local_2c[2] = uStack_1c;
    local_2c[3] = uStack_18;
    local_2c[4] = local_14;
    return local_2c;
}

void __pipe_push(int param_1, int param_2, uint param_3, char *param_4)

{
    int iVar1;
    int iVar2;
    undefined4 uVar3;
    uint uVar4;
    undefined4 local_60;
    undefined4 uStack_5c;
    undefined4 uStack_58;
    undefined4 uStack_54;
    undefined4 local_50;
    char *local_48;
    uint local_44;
    int local_40;
    int local_3c;
    undefined4 local_34;
    undefined4 uStack_30;
    undefined4 local_2c;
    undefined4 uStack_28;
    undefined4 local_24;
    int local_20;
    int local_1c;
    uint local_18;
    uint local_14;

    local_48 = param_4;
    local_44 = param_3;
    local_40 = param_2;
    local_3c = param_1;
    local_14 = FUN_000ca794(param_1);
    if (local_44 != 0) {
        local_18 = 0;
        pthread_mutex_lock((pthread_mutex_t *)(local_3c + 0x3c));
        FUN_000cb718(&local_34, local_3c, &local_20);
        if (*(int *)(local_3c + 0x20) == 0) {
            pthread_mutex_unlock((pthread_mutex_t *)(local_3c + 0x3c));
        } else {
            FUN_000cb478(&local_60, local_3c, local_34, uStack_30, local_2c,
                         uStack_28, local_24, local_44, local_48);
            iVar2 = local_20;
            local_34 = local_60;
            uStack_30 = uStack_5c;
            local_2c = uStack_58;
            uStack_28 = uStack_54;
            local_24 = local_50;
            if (*local_48 == '\0') {
                pthread_mutex_unlock((pthread_mutex_t *)(local_3c + 0x3c));
            } else {
                iVar1 = FUN_000ca8ec(local_60, uStack_5c, uStack_58, uStack_54,
                                     local_50);
                uVar4 = local_44;
                if ((uint)(iVar2 - iVar1) < local_44) {
                    iVar2 = FUN_000ca8ec(local_34, uStack_30, local_2c,
                                         uStack_28, local_24);
                    uVar4 = local_20 - iVar2;
                }
                local_18 = uVar4;
                uVar3 = FUN_000cb5fc(local_34, uStack_30, local_2c, uStack_28,
                                     local_24, local_40, uVar4);
                *(undefined4 *)(local_3c + 0x18) = uVar3;
                pthread_mutex_unlock((pthread_mutex_t *)(local_3c + 0x3c));
                if (local_18 == local_14) {
                    pthread_cond_signal((pthread_cond_t *)(local_3c + 0x58));
                } else {
                    pthread_cond_broadcast((pthread_cond_t *)(local_3c + 0x58));
                }
                local_1c = local_44 - local_18;
                if (local_1c != 0) {
                    __pipe_push(local_3c, local_40 + local_18, local_1c,
                                local_48);
                }
            }
        }
    }
    return;
}

void pipe_push(undefined4 param_1, undefined4 param_2, int param_3,
               undefined4 param_4)

{
    int iVar1;

    iVar1 = FUN_000ca794(param_1);
    __pipe_push(param_1, param_2, iVar1 * param_3, param_4);
    return;
}

undefined4 *FUN_000cbaf8(undefined4 *param_1, int param_2)

{
    undefined4 local_40;
    undefined4 uStack_3c;
    undefined4 uStack_38;
    undefined4 uStack_34;
    undefined4 local_30;
    int local_28;
    undefined4 *local_24;
    undefined4 local_20;
    undefined4 uStack_1c;
    undefined4 uStack_18;
    undefined4 uStack_14;
    undefined4 local_10;
    int local_c;

    local_28 = param_2;
    local_24 = param_1;
    FUN_000ca7e4(&local_20, param_2);
    local_c = FUN_000ca8ec(local_20, uStack_1c, uStack_18, uStack_14, local_10);
    while ((local_c == 0 && (*(int *)(local_28 + 0x1c) != 0))) {
        pthread_cond_wait((pthread_cond_t *)(local_28 + 0x58),
                          (pthread_mutex_t *)(local_28 + 0x24));
        FUN_000ca7e4(&local_40, local_28);
        local_20 = local_40;
        uStack_1c = uStack_3c;
        uStack_18 = uStack_38;
        uStack_14 = uStack_34;
        local_10 = local_30;
        local_c =
            FUN_000ca8ec(local_40, uStack_3c, uStack_38, uStack_34, local_30);
    }
    *local_24 = local_20;
    local_24[1] = uStack_1c;
    local_24[2] = uStack_18;
    local_24[3] = uStack_14;
    local_24[4] = local_10;
    return local_24;
}

undefined4 *FUN_000cbbf8(undefined4 *param_1, undefined4 param_2, int param_3,
                         int param_4, undefined4 param_5, int param_6,
                         undefined4 param_7, uint param_8, int *param_9)

{
    uint uVar1;
    void *__dest;
    void *__src;
    int iVar2;
    uint uVar3;
    size_t __n;
    int local_4;

    uVar3 = (param_3 - param_4) - param_6;
    uVar1 = param_8;
    if (uVar3 <= param_8) {
        uVar1 = uVar3;
    }
    __dest = (void *)FUN_000caa3c(param_7, param_4 + param_6, uVar1);
    __n = param_8 - uVar1;
    local_4 = FUN_000ca980(param_2, param_4 + uVar1, param_3);
    if (__n != 0) {
        __src = (void *)FUN_000ca980(param_2, local_4 + param_6, param_3);
        memcpy(__dest, __src, __n);
        iVar2 = FUN_000ca980(param_2, (int)__src + __n, param_3);
        local_4 = FUN_000ca9dc(param_2, iVar2 - param_6, param_3);
    }
    *param_9 = local_4;
    *param_1 = param_2;
    param_1[1] = param_3;
    param_1[2] = local_4;
    param_1[3] = param_5;
    param_1[4] = param_6;
    return param_1;
}

void FUN_000cbd9c(int param_1, undefined4 param_2, undefined4 param_3,
                  undefined4 param_4, undefined4 param_5, undefined4 param_6)

{
    uint uVar1;
    undefined1 auStack_40[28];
    int local_24;
    undefined1 local_1d;
    uint local_1c;
    undefined4 local_c;
    undefined4 uStack_8;
    undefined4 uStack_4;

    local_24 = param_1;
    local_c = param_2;
    uStack_8 = param_3;
    uStack_4 = param_4;
    local_1c = FUN_000ca858(param_2, param_3, param_4, param_5, param_6);
    local_1d = 1;
    uVar1 = FUN_000ca8ec(local_c, uStack_8, uStack_4, param_5, param_6);
    if (local_1c >> 2 < uVar1) {
        pthread_mutex_unlock((pthread_mutex_t *)(local_24 + 0x24));
    } else {
        pthread_mutex_unlock((pthread_mutex_t *)(local_24 + 0x24));
        pthread_mutex_lock((pthread_mutex_t *)(local_24 + 0x3c));
        pthread_mutex_lock((pthread_mutex_t *)(local_24 + 0x24));
        FUN_000ca7e4(&local_c, local_24);
        local_1c = FUN_000ca858(local_c, uStack_8, uStack_4, param_5, param_6);
        uVar1 = FUN_000ca8ec(local_c, uStack_8, uStack_4, param_5, param_6);
        if (uVar1 <= local_1c >> 2) {
            FUN_000cb2c4(auStack_40, local_24, local_1c >> 1, &local_1d);
        }
        pthread_mutex_unlock((pthread_mutex_t *)(local_24 + 0x24));
        pthread_mutex_unlock((pthread_mutex_t *)(local_24 + 0x3c));
    }
    return;
}

uint FUN_000cbefc(int param_1, undefined4 param_2, uint param_3)

{
    uint uVar1;
    undefined4 local_50;
    undefined4 uStack_4c;
    undefined4 uStack_48;
    undefined4 uStack_44;
    undefined4 local_40;
    uint local_34;
    undefined4 local_30;
    int local_2c;
    undefined4 local_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    undefined4 local_18;
    undefined4 local_14;
    uint local_10;
    uint local_c;

    if (param_3 == 0) {
        local_c = 0;
    } else {
        local_c = 0;
        local_34 = param_3;
        local_30 = param_2;
        local_2c = param_1;
        pthread_mutex_lock((pthread_mutex_t *)(param_1 + 0x24));
        FUN_000cbaf8(&local_24, local_2c);
        local_10 =
            FUN_000ca8ec(local_24, uStack_20, uStack_1c, local_18, local_14);
        if (local_10 == 0) {
            pthread_mutex_unlock((pthread_mutex_t *)(local_2c + 0x24));
            local_c = 0;
        } else {
            FUN_000cab24(local_2c);
            local_c = local_34;
            if (local_10 <= local_34) {
                local_c = local_10;
            }
            FUN_000cbbf8(&local_50, local_24, uStack_20, uStack_1c, local_18,
                         local_14, local_30, local_c, local_2c + 0x14);
            local_24 = local_50;
            uStack_20 = uStack_4c;
            uStack_1c = uStack_48;
            local_18 = uStack_44;
            local_14 = local_40;
            FUN_000cab24(local_2c);
            FUN_000cbd9c(local_2c, local_24, uStack_20, uStack_1c, local_18,
                         local_14);
            uVar1 = FUN_000ca794(local_2c);
            if (local_c == uVar1) {
                pthread_cond_signal((pthread_cond_t *)(local_2c + 0x88));
            } else {
                pthread_cond_broadcast((pthread_cond_t *)(local_2c + 0x88));
            }
        }
    }
    return local_c;
}

undefined4 pipe_pop(undefined4 param_1, int param_2, int param_3)

{
    int iVar1;
    int iVar2;
    undefined4 uVar3;
    undefined4 local_20;
    undefined4 local_10;
    undefined4 local_c;

    iVar1 = FUN_000ca794(param_1);
    local_c = iVar1 * param_3;
    local_10 = 0;
    local_20 = param_2;
    do {
        iVar2 = FUN_000cbefc(param_1, local_20, local_c);
        local_20 = local_20 + iVar2;
        local_10 = local_10 + iVar2;
        local_c = local_c - iVar2;
        if (iVar2 == 0)
            break;
    } while (local_c != 0);
    uVar3 = FUN_000cc2a0(local_10, iVar1);
    return uVar3;
}

undefined4 pipe_pop_eager(undefined4 param_1, undefined4 param_2, int param_3)

{
    int iVar1;
    undefined4 uVar2;

    iVar1 = FUN_000ca794(param_1);
    uVar2 = FUN_000cbefc(param_1, param_2, iVar1 * param_3);
    uVar2 = FUN_000cc2a0(uVar2, iVar1);
    return uVar2;
}

void pipe_reserve(int param_1, int param_2)

{
    int iVar1;
    uint uVar2;
    undefined1 auStack_48[24];
    uint local_30;
    int local_2c;
    undefined1 local_25;
    undefined4 local_24;
    undefined4 uStack_20;
    undefined4 uStack_1c;
    undefined4 uStack_18;
    undefined4 local_14;
    undefined4 local_10;
    int local_c;

    local_25 = 1;
    local_30 = param_2;
    local_2c = param_1;
    local_c = param_1;
    iVar1 = FUN_000ca794(param_1);
    local_30 = iVar1 * local_30;
    if (local_30 == 0) {
        local_30 = 0x20;
    }
    local_10 = *(undefined4 *)(local_c + 8);
    FUN_000cab78(local_c);
    FUN_000ca7e4(&local_24, local_c);
    uVar2 = FUN_000ca8ec(local_24, uStack_20, uStack_1c, uStack_18, local_14);
    if (uVar2 < local_30) {
        FUN_000cb2c4(auStack_48, local_c, local_30, &local_25);
    }
    FUN_000cabbc(local_c);
    return;
}

ulonglong FUN_000cc2a0(uint param_1, uint param_2)

{
    uint uVar1;
    ulonglong uVar2;

    if (param_2 - 1 == 0) {
        return CONCAT44(param_2, param_1);
    }
    if (param_2 == 0) {
        uVar1 = raise(8);
        return (ulonglong)uVar1;
    }
    if (param_1 <= param_2) {
        return CONCAT44(param_2, (uint)(param_1 == param_2));
    }
    if ((param_2 & param_2 - 1) == 0) {
        return CONCAT44(param_2, param_1 >> (0x1fU - LZCOUNT(param_2) & 0xff));
    }
    /* WARNING: Could not recover jumptable at 0x000cc2d0. Too many branches */
    /* WARNING: Treating indirect jump as call */
    uVar2 = (*(code *)(&UNK_000cc2d8 +
                       (0x1f - (LZCOUNT(param_2) - LZCOUNT(param_1))) * 0x10))(
        param_1, param_2, 0);
    return uVar2;
}

void FUN_000cc4fc(undefined4 param_1, int param_2)

{
    if (param_2 != 0) {
        FUN_000cc2a0();
        return;
    }
    raise(8);
    return;
}

ulonglong FUN_000cc518(uint param_1, uint param_2)

{
    uint uVar1;
    uint uVar2;
    uint uVar3;
    ulonglong uVar4;

    if (param_2 == 0) {
        uVar2 = raise(8);
        return (ulonglong)uVar2;
    }
    uVar3 = param_1 ^ param_2;
    uVar2 = param_2;
    if ((int)param_2 < 0) {
        uVar2 = -param_2;
    }
    if (uVar2 - 1 == 0) {
        if ((int)param_2 < 0) {
            param_1 = -param_1;
        }
        return CONCAT44(uVar2, param_1);
    }
    uVar1 = param_1;
    if ((int)param_1 < 0) {
        uVar1 = -param_1;
    }
    if (uVar1 <= uVar2) {
        if (uVar1 < uVar2) {
            param_1 = 0;
        }
        if (uVar1 == uVar2) {
            param_1 = (int)uVar3 >> 0x1f | 1;
        }
        return CONCAT44(uVar2, param_1);
    }
    if ((uVar2 & uVar2 - 1) == 0) {
        uVar1 = uVar1 >> (0x1fU - LZCOUNT(uVar2) & 0xff);
        if ((int)uVar3 < 0) {
            uVar1 = -uVar1;
        }
        return CONCAT44(uVar2, uVar1);
    }
    /* WARNING: Could not recover jumptable at 0x000cc558. Too many branches */
    /* WARNING: Treating indirect jump as call */
    uVar4 = (*(code *)(&UNK_000cc560 +
                       (0x1f - (LZCOUNT(uVar2) - LZCOUNT(uVar1))) * 0x10))(0);
    return uVar4;
}

uint FUN_000cc51e(uint param_1, uint param_2)

{
    uint uVar1;
    uint uVar2;
    uint uVar3;
    char in_NG;

    uVar3 = param_1 ^ param_2;
    uVar1 = param_2;
    if (in_NG != '\0') {
        uVar1 = -param_2;
    }
    if (uVar1 - 1 == 0) {
        if ((int)param_2 < 0) {
            param_1 = -param_1;
        }
        return param_1;
    }
    uVar2 = param_1;
    if ((int)param_1 < 0) {
        uVar2 = -param_1;
    }
    if (uVar2 <= uVar1) {
        if (uVar2 < uVar1) {
            param_1 = 0;
        }
        if (uVar2 == uVar1) {
            param_1 = (int)uVar3 >> 0x1f | 1;
        }
        return param_1;
    }
    if ((uVar1 & uVar1 - 1) == 0) {
        uVar2 = uVar2 >> (0x1fU - LZCOUNT(uVar1) & 0xff);
        if ((int)uVar3 < 0) {
            uVar2 = -uVar2;
        }
        return uVar2;
    }
    /* WARNING: Could not recover jumptable at 0x000cc558. Too many branches */
    /* WARNING: Treating indirect jump as call */
    uVar1 = (*(code *)(&UNK_000cc560 +
                       (0x1f - (LZCOUNT(uVar1) - LZCOUNT(uVar2))) * 0x10))(0);
    return uVar1;
}

void FUN_000cc7ac(undefined4 param_1, int param_2)

{
    if (param_2 != 0) {
        FUN_000cc51e();
        return;
    }
    raise(8);
    return;
}

ulonglong FUN_000ccad4(uint param_1, uint param_2)

{
    byte bVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    int iVar5;
    uint uVar6;
    int iVar7;
    uint uVar8;
    bool bVar9;
    bool bVar10;
    bool bVar11;

    if (param_1 == 0 && param_2 == 0) {
        return CONCAT44(param_2, param_1);
    }
    iVar7 = 0x432;
    uVar8 = param_2 >> 0x16;
    if (uVar8 != 0) {
        iVar7 = 3;
        if (param_2 >> 0x19 != 0) {
            iVar7 = 6;
        }
        if (param_2 >> 0x1c != 0) {
            iVar7 = iVar7 + 3;
        }
        uVar4 = iVar7 - ((int)param_2 >> 0x1f);
        uVar8 = param_1 << (0x20 - uVar4 & 0xff);
        param_1 = param_1 >> (uVar4 & 0xff) | param_2 << (0x20 - uVar4 & 0xff);
        param_2 = param_2 >> (uVar4 & 0xff);
        iVar7 = uVar4 + 0x432;
    }
    if (0xfffff < param_2) {
        if (0x1fffff < param_2) {
            uVar4 = param_2 & 1;
            param_2 = param_2 >> 1;
            bVar1 = (byte)param_1;
            param_1 = (uint)(uVar4 != 0) << 0x1f | param_1 >> 1;
            uVar8 = (uint)(bVar1 & 1) << 0x1f | uVar8 >> 1;
            iVar7 = iVar7 + 1;
            if (0xffbfffff < (uint)(iVar7 * 0x200000)) {
                return 0x7ff0000000000000;
            }
        }
    LAB_000cc8e0:
        bVar10 = 0x7fffffff < uVar8;
        if (uVar8 == 0x80000000) {
            bVar10 = (param_1 & 1) != 0;
        }
        return CONCAT44(param_2 + iVar7 * 0x100000 +
                            (uint)CARRY4(param_1, (uint)bVar10),
                        param_1 + bVar10);
    }
    bVar9 = (uVar8 & 0x80000000) != 0;
    uVar8 = uVar8 << 1;
    uVar4 = param_1 * 2;
    bVar10 = CARRY4(param_1, param_1);
    param_1 = param_1 * 2 + (uint)bVar9;
    param_2 = param_2 * 2 + (uint)(bVar10 || CARRY4(uVar4, (uint)bVar9));
    iVar7 = iVar7 + -1;
    if ((param_2 & 0x100000) != 0)
        goto LAB_000cc8e0;
    uVar2 = param_1;
    uVar4 = param_2;
    if (param_2 == 0) {
        uVar2 = 0;
        uVar4 = param_1;
    }
    iVar5 = LZCOUNT(uVar4);
    if (param_2 == 0) {
        iVar5 = iVar5 + 0x20;
    }
    uVar6 = iVar5 - 0xb;
    bVar11 = SBORROW4(uVar6, 0x20);
    uVar3 = iVar5 - 0x2b;
    bVar10 = (int)uVar3 < 0;
    bVar9 = uVar3 == 0;
    if ((int)uVar6 < 0x20) {
        bVar11 = SCARRY4(uVar3, 0xc);
        iVar5 = iVar5 + -0x1f;
        bVar10 = iVar5 < 0;
        bVar9 = iVar5 == 0;
        uVar3 = uVar6;
        if (!bVar9 && bVar10 == bVar11) {
            uVar2 = uVar4 << (uVar6 & 0xff);
            uVar4 = uVar4 >> (0xcU - iVar5 & 0xff);
            goto LAB_000cc958;
        }
    }
    if (bVar9 || bVar10 != bVar11) {
        uVar8 = 0x20 - uVar3;
    }
    uVar4 = uVar4 << (uVar3 & 0xff);
    if (bVar9 || bVar10 != bVar11) {
        uVar4 = uVar4 | uVar2 >> (uVar8 & 0xff);
        uVar2 = uVar2 << (uVar3 & 0xff);
    }
LAB_000cc958:
    if ((int)uVar6 <= iVar7) {
        return CONCAT44(uVar4 + (iVar7 - uVar6) * 0x100000, uVar2);
    }
    uVar8 = ~(iVar7 - uVar6);
    if (0x1e < (int)uVar8) {
        return (ulonglong)(uVar4 >> (uVar8 - 0x1f & 0xff));
    }
    iVar7 = uVar8 - 0x13;
    if (iVar7 == 0 || iVar7 < 0 != SCARRY4(uVar8 - 0x1f, 0xc)) {
        uVar8 = uVar8 + 1;
        return CONCAT44(uVar4 >> (uVar8 & 0xff),
                        uVar2 >> (uVar8 & 0xff) | uVar4
                                                      << (0x20 - uVar8 & 0xff));
    }
    return (ulonglong)(uVar2 >> (0x20 - (0xcU - iVar7) & 0xff) |
                       uVar4 << (0xcU - iVar7 & 0xff));
}

ulonglong FUN_000ccae4(uint param_1, uint param_2)

{
    byte bVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    int iVar5;
    uint uVar6;
    int iVar7;
    uint uVar8;
    uint uVar9;
    bool bVar10;
    bool bVar11;
    bool bVar12;

    if (param_1 == 0 && param_2 == 0) {
        return CONCAT44(param_2, param_1);
    }
    uVar8 = param_2 & 0x80000000;
    uVar3 = param_2;
    if ((int)uVar8 < 0) {
        bVar11 = param_1 != 0;
        param_1 = -param_1;
        uVar3 = -param_2 - (uint)bVar11;
    }
    iVar7 = 0x432;
    uVar9 = uVar3 >> 0x16;
    if (uVar9 != 0) {
        iVar7 = 3;
        if (uVar3 >> 0x19 != 0) {
            iVar7 = 6;
        }
        if (uVar3 >> 0x1c != 0) {
            iVar7 = iVar7 + 3;
        }
        uVar4 = iVar7 - ((int)uVar3 >> 0x1f);
        uVar9 = param_1 << (0x20 - uVar4 & 0xff);
        param_1 = param_1 >> (uVar4 & 0xff) | uVar3 << (0x20 - uVar4 & 0xff);
        uVar3 = uVar3 >> (uVar4 & 0xff);
        iVar7 = uVar4 + 0x432;
    }
    if (0xfffff < uVar3) {
        if (0x1fffff < uVar3) {
            uVar4 = uVar3 & 1;
            uVar3 = uVar3 >> 1;
            bVar1 = (byte)param_1;
            param_1 = (uint)(uVar4 != 0) << 0x1f | param_1 >> 1;
            uVar9 = (uint)(bVar1 & 1) << 0x1f | uVar9 >> 1;
            iVar7 = iVar7 + 1;
            if (0xffbfffff < (uint)(iVar7 * 0x200000)) {
                return (ulonglong)(uVar8 | 0x7ff00000) << 0x20;
            }
        }
    LAB_000cc8e0:
        bVar11 = 0x7fffffff < uVar9;
        if (uVar9 == 0x80000000) {
            bVar11 = (param_1 & 1) != 0;
        }
        return CONCAT44(uVar3 + iVar7 * 0x100000 +
                                (uint)CARRY4(param_1, (uint)bVar11) |
                            uVar8,
                        param_1 + bVar11);
    }
    bVar10 = (uVar9 & 0x80000000) != 0;
    uVar9 = uVar9 << 1;
    uVar4 = param_1 * 2;
    bVar11 = CARRY4(param_1, param_1);
    param_1 = param_1 * 2 + (uint)bVar10;
    uVar3 = uVar3 * 2 + (uint)(bVar11 || CARRY4(uVar4, (uint)bVar10));
    iVar7 = iVar7 + -1;
    if ((uVar3 & 0x100000) != 0)
        goto LAB_000cc8e0;
    uVar2 = param_1;
    uVar4 = uVar3;
    if (uVar3 == 0) {
        uVar2 = 0;
        uVar4 = param_1;
    }
    iVar5 = LZCOUNT(uVar4);
    if (uVar3 == 0) {
        iVar5 = iVar5 + 0x20;
    }
    uVar6 = iVar5 - 0xb;
    bVar12 = SBORROW4(uVar6, 0x20);
    uVar3 = iVar5 - 0x2b;
    bVar11 = (int)uVar3 < 0;
    bVar10 = uVar3 == 0;
    if ((int)uVar6 < 0x20) {
        bVar12 = SCARRY4(uVar3, 0xc);
        iVar5 = iVar5 + -0x1f;
        bVar11 = iVar5 < 0;
        bVar10 = iVar5 == 0;
        uVar3 = uVar6;
        if (!bVar10 && bVar11 == bVar12) {
            uVar2 = uVar4 << (uVar6 & 0xff);
            uVar4 = uVar4 >> (0xcU - iVar5 & 0xff);
            goto LAB_000cc958;
        }
    }
    if (bVar10 || bVar11 != bVar12) {
        uVar9 = 0x20 - uVar3;
    }
    uVar4 = uVar4 << (uVar3 & 0xff);
    if (bVar10 || bVar11 != bVar12) {
        uVar4 = uVar4 | uVar2 >> (uVar9 & 0xff);
        uVar2 = uVar2 << (uVar3 & 0xff);
    }
LAB_000cc958:
    if ((int)uVar6 <= iVar7) {
        return CONCAT44(uVar4 + (iVar7 - uVar6) * 0x100000 | uVar8, uVar2);
    }
    uVar3 = ~(iVar7 - uVar6);
    if (0x1e < (int)uVar3) {
        return CONCAT44(param_2, uVar4 >> (uVar3 - 0x1f & 0xff)) &
               0x80000000ffffffff;
    }
    iVar7 = uVar3 - 0x13;
    if (iVar7 == 0 || iVar7 < 0 != SCARRY4(uVar3 - 0x1f, 0xc)) {
        uVar3 = uVar3 + 1;
        return CONCAT44(uVar8 | uVar4 >> (uVar3 & 0xff),
                        uVar2 >> (uVar3 & 0xff) | uVar4
                                                      << (0x20 - uVar3 & 0xff));
    }
    return CONCAT44(param_2, uVar2 >> (0x20 - (0xcU - iVar7) & 0xff) |
                                 uVar4 << (0xcU - iVar7 & 0xff)) &
           0x80000000ffffffff;
}

uint FUN_000cccd0(uint param_1, uint param_2)

{
    uint uVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    int iVar5;

    if (param_1 == 0 && param_2 == 0) {
        return param_1;
    }
    uVar1 = param_1;
    uVar2 = param_2;
    if (param_2 == 0) {
        uVar1 = 0;
        uVar2 = param_1;
    }
    iVar5 = 0x5b000000;
    if (param_2 == 0) {
        iVar5 = 0x4b000000;
    }
    uVar3 = LZCOUNT(uVar2);
    uVar4 = uVar3 - 8;
    iVar5 = iVar5 + -0x800000 + uVar4 * -0x800000;
    if (uVar3 < 8) {
        uVar4 = uVar2 << uVar3 + 0x18;
        uVar2 = iVar5 + ((uVar2 >> (0x20 - (uVar3 + 0x18) & 0xff)) -
                         ((int)uVar4 >> 0x1f));
        if (uVar1 == 0 && (uVar4 & 0x7fffffff) == 0) {
            uVar2 = uVar2 & ~(uVar4 >> 0x1f);
        }
        return uVar2;
    }
    uVar3 = uVar1 << (uVar4 & 0xff);
    uVar2 = iVar5 + (uVar2 << (uVar4 & 0xff)) +
            (uVar1 >> (0x20 - uVar4 & 0xff)) + (uint)(0x7fffffff < uVar3);
    if (uVar3 == 0x80000000) {
        uVar2 = uVar2 & 0xfffffffe;
    }
    return uVar2;
}

uint FUN_000ccce0(uint param_1, uint param_2)

{
    uint uVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    int iVar6;
    bool bVar7;

    if (param_1 == 0 && param_2 == 0) {
        return param_1;
    }
    uVar5 = param_2 & 0x80000000;
    if ((int)uVar5 < 0) {
        bVar7 = param_1 != 0;
        param_1 = -param_1;
        param_2 = -param_2 - (uint)bVar7;
    }
    uVar2 = param_1;
    uVar1 = param_2;
    if (param_2 == 0) {
        uVar2 = 0;
        uVar1 = param_1;
    }
    uVar5 = uVar5 | 0x5b000000;
    if (param_2 == 0) {
        uVar5 = uVar5 + 0xf0000000;
    }
    uVar3 = LZCOUNT(uVar1);
    uVar4 = uVar3 - 8;
    iVar6 = (uVar5 - 0x800000) + uVar4 * -0x800000;
    if (uVar3 < 8) {
        uVar4 = uVar1 << uVar3 + 0x18;
        uVar5 = iVar6 + ((uVar1 >> (0x20 - (uVar3 + 0x18) & 0xff)) -
                         ((int)uVar4 >> 0x1f));
        if (uVar2 == 0 && (uVar4 & 0x7fffffff) == 0) {
            uVar5 = uVar5 & ~(uVar4 >> 0x1f);
        }
        return uVar5;
    }
    uVar3 = uVar2 << (uVar4 & 0xff);
    uVar5 = iVar6 + (uVar1 << (uVar4 & 0xff)) +
            (uVar2 >> (0x20 - uVar4 & 0xff)) + (uint)(0x7fffffff < uVar3);
    if (uVar3 == 0x80000000) {
        uVar5 = uVar5 & 0xfffffffe;
    }
    return uVar5;
}

undefined8 FUN_000ccd5c(int param_1, int param_2, int param_3, int param_4)

{
    int iVar1;
    undefined8 uVar2;
    int local_8;

    if ((param_4 == 0) && (param_3 == 0)) {
        if (param_2 < 0) {
            param_2 = -0x80000000;
        } else if (param_2 != 0 || param_1 != 0) {
            param_2 = 0x7fffffff;
        }
        local_8 = param_2;
        iVar1 = raise(8);
        return CONCAT44(local_8, iVar1);
    }
    if (param_2 < 0) {
        iVar1 = -param_2 - (uint)(param_1 != 0);
        if (param_4 < 0) {
            uVar2 = FUN_000ccea0(-param_1, iVar1, -param_3,
                                 -param_4 - (uint)(param_3 != 0), &local_8);
            return uVar2;
        }
        uVar2 = FUN_000ccea0(-param_1, iVar1, param_3, param_4, &local_8);
        return CONCAT44(-(int)((ulonglong)uVar2 >> 0x20) -
                            (uint)((int)uVar2 != 0),
                        -(int)uVar2);
    }
    if (param_4 < 0) {
        uVar2 = FUN_000ccea0(param_1, param_2, -param_3,
                             -param_4 - (uint)(param_3 != 0), &local_8);
        return CONCAT44(-(int)((ulonglong)uVar2 >> 0x20) -
                            (uint)((int)uVar2 != 0),
                        -(int)uVar2);
    }
    uVar2 = FUN_000ccea0();
    return uVar2;
}

void FUN_000ccdfc(undefined4 param_1, undefined4 param_2, int param_3,
                  int param_4)

{
    if ((param_4 == 0) && (param_3 == 0)) {
        raise(8);
        return;
    }
    FUN_000ccea0();
    return;
}

int FUN_000cce38(undefined4 param_1, uint param_2, undefined4 param_3,
                 undefined4 param_4)

{
    int iVar1;

    if (-1 < (int)((uint)((double)CONCAT44(param_2, param_1) < 0.0) << 0x1f)) {
        iVar1 = FUN_000cce60();
        return iVar1;
    }
    iVar1 =
        FUN_000cce60(param_1, param_2 ^ 0x80000000, param_3, param_4, param_4);
    return -iVar1;
}

undefined8 FUN_000cce60(undefined4 param_1, undefined4 param_2)

{
    uint uVar1;
    double dVar2;

    dVar2 = (double)CONCAT44(param_2, param_1) * 2.3283064365386963e-10;
    uVar1 = (uint)(0.0 < dVar2) * (int)(longlong)dVar2;
    dVar2 = (double)CONCAT44(param_2, param_1) - (double)uVar1 * 4294967296.0;
    return CONCAT44(uVar1, (uint)(0.0 < dVar2) * (int)(longlong)dVar2);
}

undefined8 FUN_000ccea0(uint param_1, uint param_2, uint param_3, uint param_4,
                        uint *param_5)

{
    uint uVar1;
    uint uVar2;
    int iVar3;
    uint uVar4;
    uint uVar5;
    uint uVar6;
    uint uVar7;
    uint uVar8;
    uint uVar9;
    int iVar10;
    uint uVar11;
    bool bVar12;

    bVar12 = param_4 <= param_2;
    if (param_2 == param_4) {
        bVar12 = param_3 <= param_1;
    }
    if (bVar12) {
        iVar10 = LZCOUNT(param_4);
        if (param_4 == 0) {
            iVar10 = LZCOUNT(param_3) + 0x20;
        }
        iVar3 = LZCOUNT(param_2);
        if (param_2 == 0) {
            iVar3 = LZCOUNT(param_1) + 0x20;
        }
        uVar11 = iVar10 - iVar3;
        uVar8 = uVar11 - 0x20;
        uVar9 = 0x20 - uVar11;
        uVar5 = param_3 << (uVar11 & 0xff);
        uVar6 = param_4 << (uVar11 & 0xff) | param_3 << (uVar8 & 0xff) |
                param_3 >> (uVar9 & 0xff);
        bVar12 = uVar6 <= param_2;
        if (param_2 == uVar6) {
            bVar12 = uVar5 <= param_1;
        }
        if (bVar12) {
            bVar12 = param_1 < uVar5;
            param_1 = param_1 - uVar5;
            uVar1 = 1 << (uVar11 & 0xff);
            param_2 = (param_2 - uVar6) - (uint)bVar12;
            uVar2 = 1 << (uVar8 & 0xff) | 1U >> (uVar9 & 0xff);
        } else {
            uVar1 = 0;
            uVar2 = uVar1;
        }
        if (uVar11 != 0) {
            uVar7 = uVar6 >> 1;
            uVar6 = (uint)((uVar6 & 1) != 0) << 0x1f | uVar5 >> 1;
            uVar5 = uVar11;
            do {
                while (true) {
                    bVar12 = uVar7 <= param_2;
                    if (param_2 == uVar7) {
                        bVar12 = uVar6 <= param_1;
                    }
                    if (bVar12)
                        break;
                    bVar12 = CARRY4(param_1, param_1);
                    param_1 = param_1 * 2;
                    param_2 = param_2 * 2 + (uint)bVar12;
                    uVar5 = uVar5 - 1;
                    uVar4 = param_2;
                    if (uVar5 == 0)
                        goto LAB_000ccf4a;
                }
                bVar12 = param_1 < uVar6;
                uVar4 = param_1 - uVar6;
                param_1 = uVar4 * 2 + 1;
                param_2 = ((param_2 - uVar7) - (uint)bVar12) * 2 +
                          (uint)CARRY4(uVar4, uVar4) +
                          (uint)(0xfffffffe < uVar4 * 2);
                uVar5 = uVar5 - 1;
                uVar4 = param_2;
            } while (uVar5 != 0);
        LAB_000ccf4a:
            param_2 = uVar4 >> (uVar11 & 0xff);
            bVar12 = CARRY4(uVar1, param_1);
            uVar5 = uVar1 + param_1;
            param_1 = param_1 >> (uVar11 & 0xff) | uVar4 << (uVar9 & 0xff) |
                      uVar4 >> (uVar8 & 0xff);
            uVar6 = param_1 << (uVar11 & 0xff);
            uVar1 = uVar5 - uVar6;
            uVar2 = ((uVar4 + uVar2 + bVar12) -
                     (param_2 << (uVar11 & 0xff) |
                      param_1 << (uVar11 - 0x20 & 0xff) |
                      param_1 >> (0x20 - uVar11 & 0xff))) -
                    (uint)(uVar5 < uVar6);
        }
    } else {
        uVar1 = 0;
        uVar2 = uVar1;
    }
    if (param_5 != (uint *)0x0) {
        *param_5 = param_1;
        param_5[1] = param_2;
    }
    return CONCAT44(uVar2, uVar1);
}

void __libc_csu_init(EVP_PKEY_CTX *param_1, undefined4 param_2,
                     undefined4 param_3, undefined4 param_4)

{
    int iVar1;
    undefined **ppuVar2;

    _init(param_1);
    iVar1 = 0;
    ppuVar2 = &__DT_INIT_ARRAY;
    do {
        iVar1 = iVar1 + 1;
        (*(code *)*ppuVar2)(param_1, param_2, param_3, *ppuVar2, param_4);
        ppuVar2 = ppuVar2 + 1;
    } while (iVar1 != 1);
    return;
}

void __libc_csu_fini(void)

{
    return;
}

void FUN_000ccff8(char *param_1, stat *param_2)

{
    __xstat(3, param_1, param_2);
    return;
}

void _fini(void)

{
    return;
}
